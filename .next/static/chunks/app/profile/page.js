/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/profile/page"],{

/***/ "(app-pages-browser)/./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/NDk4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/./node_modules/ieee754/index.js\")\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz82ZmU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgQnVmZmVyLmZyb20oYnVmKS5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz84OTBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js":
/*!****************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/Icon.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Icon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nconst Icon = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({\n    color = \"currentColor\",\n    size = 24,\n    strokeWidth = 2,\n    absoluteStrokeWidth,\n    className = \"\",\n    children,\n    iconNode,\n    ...rest\n  }, ref) => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\n      \"svg\",\n      {\n        ref,\n        ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        width: size,\n        height: size,\n        stroke: color,\n        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n        className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide\", className),\n        ...rest\n      },\n      [\n        ...iconNode.map(([tag, attrs]) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs)),\n        ...Array.isArray(children) ? children : [children]\n      ]\n    );\n  }\n);\n\n\n//# sourceMappingURL=Icon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Q7QUFDSztBQUNGOztBQUVyRCxhQUFhLGlEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXLG9EQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFZO0FBQy9CO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMENBQTBDLG9EQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcz83MGNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ0Ni4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlZmF1bHRBdHRyaWJ1dGVzIGZyb20gJy4vZGVmYXVsdEF0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzIH0gZnJvbSAnLi9zaGFyZWQvc3JjL3V0aWxzLmpzJztcblxuY29uc3QgSWNvbiA9IGZvcndhcmRSZWYoXG4gICh7XG4gICAgY29sb3IgPSBcImN1cnJlbnRDb2xvclwiLFxuICAgIHNpemUgPSAyNCxcbiAgICBzdHJva2VXaWR0aCA9IDIsXG4gICAgYWJzb2x1dGVTdHJva2VXaWR0aCxcbiAgICBjbGFzc05hbWUgPSBcIlwiLFxuICAgIGNoaWxkcmVuLFxuICAgIGljb25Ob2RlLFxuICAgIC4uLnJlc3RcbiAgfSwgcmVmKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInN2Z1wiLFxuICAgICAge1xuICAgICAgICByZWYsXG4gICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgICB3aWR0aDogc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogYWJzb2x1dGVTdHJva2VXaWR0aCA/IE51bWJlcihzdHJva2VXaWR0aCkgKiAyNCAvIE51bWJlcihzaXplKSA6IHN0cm9rZVdpZHRoLFxuICAgICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhcImx1Y2lkZVwiLCBjbGFzc05hbWUpLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICAuLi5pY29uTm9kZS5tYXAoKFt0YWcsIGF0dHJzXSkgPT4gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJzKSksXG4gICAgICAgIC4uLkFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dXG4gICAgICBdXG4gICAgKTtcbiAgfVxuKTtcblxuZXhwb3J0IHsgSWNvbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JY29uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createLucideIcon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/* harmony import */ var _Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Icon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nconst createLucideIcon = (iconName, iconNode) => {\n  const Component = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n    ({ className, ...props }, ref) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_Icon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n      ref,\n      iconNode,\n      className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(`lucide-${(0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toKebabCase)(iconName)}`, className),\n      ...props\n    })\n  );\n  Component.displayName = `${iconName}`;\n  return Component;\n};\n\n\n//# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Q7QUFDZ0I7QUFDckM7O0FBRTdCO0FBQ0Esb0JBQW9CLGlEQUFVO0FBQzlCLE9BQU8scUJBQXFCLFVBQVUsb0RBQWEsQ0FBQyxnREFBSTtBQUN4RDtBQUNBO0FBQ0EsaUJBQWlCLGtFQUFZLFdBQVcsaUVBQVcsV0FBVztBQUM5RDtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcz82YjExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ0Ni4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzLCB0b0tlYmFiQ2FzZSB9IGZyb20gJy4vc2hhcmVkL3NyYy91dGlscy5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uanMnO1xuXG5jb25zdCBjcmVhdGVMdWNpZGVJY29uID0gKGljb25OYW1lLCBpY29uTm9kZSkgPT4ge1xuICBjb25zdCBDb21wb25lbnQgPSBmb3J3YXJkUmVmKFxuICAgICh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiBjcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAgIHJlZixcbiAgICAgIGljb25Ob2RlLFxuICAgICAgY2xhc3NOYW1lOiBtZXJnZUNsYXNzZXMoYGx1Y2lkZS0ke3RvS2ViYWJDYXNlKGljb25OYW1lKX1gLCBjbGFzc05hbWUpLFxuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICApO1xuICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBgJHtpY29uTmFtZX1gO1xuICByZXR1cm4gQ29tcG9uZW50O1xufTtcblxuZXhwb3J0IHsgY3JlYXRlTHVjaWRlSWNvbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVMdWNpZGVJY29uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ defaultAttributes; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nvar defaultAttributes = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: 24,\n  height: 24,\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 2,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\"\n};\n\n\n//# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2RlZmF1bHRBdHRyaWJ1dGVzLmpzPzVlNGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDQ2LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBkZWZhdWx0QXR0cmlidXRlcyA9IHtcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG59O1xuXG5leHBvcnQgeyBkZWZhdWx0QXR0cmlidXRlcyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0QXR0cmlidXRlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/briefcase.js":
/*!***************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/briefcase.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Briefcase; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst Briefcase = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Briefcase\", [\n  [\"path\", { d: \"M16 20V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16\", key: \"jecpp\" }],\n  [\"rect\", { width: \"20\", height: \"14\", x: \"2\", y: \"6\", rx: \"2\", key: \"i6l2r4\" }]\n]);\n\n\n//# sourceMappingURL=briefcase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvYnJpZWZjYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDs7QUFFdEQsa0JBQWtCLGdFQUFnQjtBQUNsQyxhQUFhLCtEQUErRDtBQUM1RSxhQUFhLG1FQUFtRTtBQUNoRjs7QUFFZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9icmllZmNhc2UuanM/NDRjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NDYuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IEJyaWVmY2FzZSA9IGNyZWF0ZUx1Y2lkZUljb24oXCJCcmllZmNhc2VcIiwgW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNMTYgMjBWNGEyIDIgMCAwIDAtMi0yaC00YTIgMiAwIDAgMC0yIDJ2MTZcIiwga2V5OiBcImplY3BwXCIgfV0sXG4gIFtcInJlY3RcIiwgeyB3aWR0aDogXCIyMFwiLCBoZWlnaHQ6IFwiMTRcIiwgeDogXCIyXCIsIHk6IFwiNlwiLCByeDogXCIyXCIsIGtleTogXCJpNmwycjRcIiB9XVxuXSk7XG5cbmV4cG9ydCB7IEJyaWVmY2FzZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmllZmNhc2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/briefcase.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/camera.js":
/*!************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/camera.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Camera; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst Camera = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Camera\", [\n  [\n    \"path\",\n    {\n      d: \"M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z\",\n      key: \"1tc9qg\"\n    }\n  ],\n  [\"circle\", { cx: \"12\", cy: \"13\", r: \"3\", key: \"1vg3eu\" }]\n]);\n\n\n//# sourceMappingURL=camera.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2FtZXJhLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDs7QUFFdEQsZUFBZSxnRUFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJDQUEyQztBQUMxRDs7QUFFNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9jYW1lcmEuanM/ZmE1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NDYuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IENhbWVyYSA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDYW1lcmFcIiwgW1xuICBbXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZDogXCJNMTQuNSA0aC01TDcgN0g0YTIgMiAwIDAgMC0yIDJ2OWEyIDIgMCAwIDAgMiAyaDE2YTIgMiAwIDAgMCAyLTJWOWEyIDIgMCAwIDAtMi0yaC0zbC0yLjUtM3pcIixcbiAgICAgIGtleTogXCIxdGM5cWdcIlxuICAgIH1cbiAgXSxcbiAgW1wiY2lyY2xlXCIsIHsgY3g6IFwiMTJcIiwgY3k6IFwiMTNcIiwgcjogXCIzXCIsIGtleTogXCIxdmczZXVcIiB9XVxuXSk7XG5cbmV4cG9ydCB7IENhbWVyYSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW1lcmEuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/camera.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/contact.js":
/*!*************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/contact.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Contact; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst Contact = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Contact\", [\n  [\"path\", { d: \"M16 2v2\", key: \"scm5qe\" }],\n  [\"path\", { d: \"M7 22v-2a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2\", key: \"1waht3\" }],\n  [\"path\", { d: \"M8 2v2\", key: \"pbkmx\" }],\n  [\"circle\", { cx: \"12\", cy: \"11\", r: \"3\", key: \"itu57m\" }],\n  [\"rect\", { x: \"3\", y: \"4\", width: \"18\", height: \"18\", rx: \"2\", key: \"12vinp\" }]\n]);\n\n\n//# sourceMappingURL=contact.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY29udGFjdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0Q7O0FBRXRELGdCQUFnQixnRUFBZ0I7QUFDaEMsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYSw4REFBOEQ7QUFDM0UsYUFBYSwyQkFBMkI7QUFDeEMsZUFBZSwyQ0FBMkM7QUFDMUQsYUFBYSxtRUFBbUU7QUFDaEY7O0FBRThCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY29udGFjdC5qcz84MzY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ0Ni4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgQ29udGFjdCA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDb250YWN0XCIsIFtcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE2IDJ2MlwiLCBrZXk6IFwic2NtNXFlXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk03IDIydi0yYTIgMiAwIDAgMSAyLTJoNmEyIDIgMCAwIDEgMiAydjJcIiwga2V5OiBcIjF3YWh0M1wiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNOCAydjJcIiwga2V5OiBcInBia214XCIgfV0sXG4gIFtcImNpcmNsZVwiLCB7IGN4OiBcIjEyXCIsIGN5OiBcIjExXCIsIHI6IFwiM1wiLCBrZXk6IFwiaXR1NTdtXCIgfV0sXG4gIFtcInJlY3RcIiwgeyB4OiBcIjNcIiwgeTogXCI0XCIsIHdpZHRoOiBcIjE4XCIsIGhlaWdodDogXCIxOFwiLCByeDogXCIyXCIsIGtleTogXCIxMnZpbnBcIiB9XVxuXSk7XG5cbmV4cG9ydCB7IENvbnRhY3QgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFjdC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/contact.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/file-text.js":
/*!***************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/file-text.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ FileText; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst FileText = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"FileText\", [\n  [\"path\", { d: \"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z\", key: \"1rqfz7\" }],\n  [\"path\", { d: \"M14 2v4a2 2 0 0 0 2 2h4\", key: \"tnqrlb\" }],\n  [\"path\", { d: \"M10 9H8\", key: \"b1mrlr\" }],\n  [\"path\", { d: \"M16 13H8\", key: \"t4e002\" }],\n  [\"path\", { d: \"M16 17H8\", key: \"z1uh3a\" }]\n]);\n\n\n//# sourceMappingURL=file-text.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvZmlsZS10ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDs7QUFFdEQsaUJBQWlCLGdFQUFnQjtBQUNqQyxhQUFhLGdGQUFnRjtBQUM3RixhQUFhLDZDQUE2QztBQUMxRCxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLDhCQUE4QjtBQUMzQyxhQUFhLDhCQUE4QjtBQUMzQzs7QUFFK0I7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9maWxlLXRleHQuanM/OTYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NDYuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IEZpbGVUZXh0ID0gY3JlYXRlTHVjaWRlSWNvbihcIkZpbGVUZXh0XCIsIFtcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE1IDJINmEyIDIgMCAwIDAtMiAydjE2YTIgMiAwIDAgMCAyIDJoMTJhMiAyIDAgMCAwIDItMlY3WlwiLCBrZXk6IFwiMXJxZno3XCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xNCAydjRhMiAyIDAgMCAwIDIgMmg0XCIsIGtleTogXCJ0bnFybGJcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTEwIDlIOFwiLCBrZXk6IFwiYjFtcmxyXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xNiAxM0g4XCIsIGtleTogXCJ0NGUwMDJcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE2IDE3SDhcIiwga2V5OiBcInoxdWgzYVwiIH1dXG5dKTtcblxuZXhwb3J0IHsgRmlsZVRleHQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS10ZXh0LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/file-text.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/house.js":
/*!***********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/house.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ House; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst House = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"House\", [\n  [\"path\", { d: \"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8\", key: \"5wwlr5\" }],\n  [\n    \"path\",\n    {\n      d: \"M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\",\n      key: \"1d0kgt\"\n    }\n  ]\n]);\n\n\n//# sourceMappingURL=house.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvaG91c2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNEOztBQUV0RCxjQUFjLGdFQUFnQjtBQUM5QixhQUFhLGdFQUFnRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2hvdXNlLmpzP2I3ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDQ2LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBIb3VzZSA9IGNyZWF0ZUx1Y2lkZUljb24oXCJIb3VzZVwiLCBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xNSAyMXYtOGExIDEgMCAwIDAtMS0xaC00YTEgMSAwIDAgMC0xIDF2OFwiLCBrZXk6IFwiNXd3bHI1XCIgfV0sXG4gIFtcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk0zIDEwYTIgMiAwIDAgMSAuNzA5LTEuNTI4bDctNS45OTlhMiAyIDAgMCAxIDIuNTgyIDBsNyA1Ljk5OUEyIDIgMCAwIDEgMjEgMTB2OWEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnpcIixcbiAgICAgIGtleTogXCIxZDBrZ3RcIlxuICAgIH1cbiAgXVxuXSk7XG5cbmV4cG9ydCB7IEhvdXNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvdXNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/house.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/log-out.js":
/*!*************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/log-out.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ LogOut; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst LogOut = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"LogOut\", [\n  [\"path\", { d: \"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4\", key: \"1uf3rs\" }],\n  [\"polyline\", { points: \"16 17 21 12 16 7\", key: \"1gabdz\" }],\n  [\"line\", { x1: \"21\", x2: \"9\", y1: \"12\", y2: \"12\", key: \"1uyos4\" }]\n]);\n\n\n//# sourceMappingURL=log-out.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbG9nLW91dC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0Q7O0FBRXRELGVBQWUsZ0VBQWdCO0FBQy9CLGFBQWEsNkRBQTZEO0FBQzFFLGlCQUFpQiwyQ0FBMkM7QUFDNUQsYUFBYSxzREFBc0Q7QUFDbkU7O0FBRTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbG9nLW91dC5qcz9iY2Y4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ0Ni4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgTG9nT3V0ID0gY3JlYXRlTHVjaWRlSWNvbihcIkxvZ091dFwiLCBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIk05IDIxSDVhMiAyIDAgMCAxLTItMlY1YTIgMiAwIDAgMSAyLTJoNFwiLCBrZXk6IFwiMXVmM3JzXCIgfV0sXG4gIFtcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjE2IDE3IDIxIDEyIDE2IDdcIiwga2V5OiBcIjFnYWJkelwiIH1dLFxuICBbXCJsaW5lXCIsIHsgeDE6IFwiMjFcIiwgeDI6IFwiOVwiLCB5MTogXCIxMlwiLCB5MjogXCIxMlwiLCBrZXk6IFwiMXV5b3M0XCIgfV1cbl0pO1xuXG5leHBvcnQgeyBMb2dPdXQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nLW91dC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/log-out.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/map-pin.js":
/*!*************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/map-pin.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MapPin; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst MapPin = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"MapPin\", [\n  [\n    \"path\",\n    {\n      d: \"M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0\",\n      key: \"1r0f0z\"\n    }\n  ],\n  [\"circle\", { cx: \"12\", cy: \"10\", r: \"3\", key: \"ilqhr7\" }]\n]);\n\n\n//# sourceMappingURL=map-pin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbWFwLXBpbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0Q7O0FBRXRELGVBQWUsZ0VBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBMkM7QUFDMUQ7O0FBRTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbWFwLXBpbi5qcz9iYTg3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ0Ni4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgTWFwUGluID0gY3JlYXRlTHVjaWRlSWNvbihcIk1hcFBpblwiLCBbXG4gIFtcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk0yMCAxMGMwIDQuOTkzLTUuNTM5IDEwLjE5My03LjM5OSAxMS43OTlhMSAxIDAgMCAxLTEuMjAyIDBDOS41MzkgMjAuMTkzIDQgMTQuOTkzIDQgMTBhOCA4IDAgMCAxIDE2IDBcIixcbiAgICAgIGtleTogXCIxcjBmMHpcIlxuICAgIH1cbiAgXSxcbiAgW1wiY2lyY2xlXCIsIHsgY3g6IFwiMTJcIiwgY3k6IFwiMTBcIiwgcjogXCIzXCIsIGtleTogXCJpbHFocjdcIiB9XVxuXSk7XG5cbmV4cG9ydCB7IE1hcFBpbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAtcGluLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/map-pin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/menu.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/menu.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Menu; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst Menu = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Menu\", [\n  [\"line\", { x1: \"4\", x2: \"20\", y1: \"12\", y2: \"12\", key: \"1e0a9i\" }],\n  [\"line\", { x1: \"4\", x2: \"20\", y1: \"6\", y2: \"6\", key: \"1owob3\" }],\n  [\"line\", { x1: \"4\", x2: \"20\", y1: \"18\", y2: \"18\", key: \"yk5zj1\" }]\n]);\n\n\n//# sourceMappingURL=menu.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbWVudS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0Q7O0FBRXRELGFBQWEsZ0VBQWdCO0FBQzdCLGFBQWEsc0RBQXNEO0FBQ25FLGFBQWEsb0RBQW9EO0FBQ2pFLGFBQWEsc0RBQXNEO0FBQ25FOztBQUUyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL21lbnUuanM/YTkyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NDYuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IE1lbnUgPSBjcmVhdGVMdWNpZGVJY29uKFwiTWVudVwiLCBbXG4gIFtcImxpbmVcIiwgeyB4MTogXCI0XCIsIHgyOiBcIjIwXCIsIHkxOiBcIjEyXCIsIHkyOiBcIjEyXCIsIGtleTogXCIxZTBhOWlcIiB9XSxcbiAgW1wibGluZVwiLCB7IHgxOiBcIjRcIiwgeDI6IFwiMjBcIiwgeTE6IFwiNlwiLCB5MjogXCI2XCIsIGtleTogXCIxb3dvYjNcIiB9XSxcbiAgW1wibGluZVwiLCB7IHgxOiBcIjRcIiwgeDI6IFwiMjBcIiwgeTE6IFwiMThcIiwgeTI6IFwiMThcIiwga2V5OiBcInlrNXpqMVwiIH1dXG5dKTtcblxuZXhwb3J0IHsgTWVudSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW51LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/menu.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/pen.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/pen.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Pen; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst Pen = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Pen\", [\n  [\n    \"path\",\n    {\n      d: \"M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z\",\n      key: \"1a8usu\"\n    }\n  ]\n]);\n\n\n//# sourceMappingURL=pen.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvcGVuLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDs7QUFFdEQsWUFBWSxnRUFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9wZW4uanM/ZDdiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NDYuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IFBlbiA9IGNyZWF0ZUx1Y2lkZUljb24oXCJQZW5cIiwgW1xuICBbXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZDogXCJNMjEuMTc0IDYuODEyYTEgMSAwIDAgMC0zLjk4Ni0zLjk4N0wzLjg0MiAxNi4xNzRhMiAyIDAgMCAwLS41LjgzbC0xLjMyMSA0LjM1MmEuNS41IDAgMCAwIC42MjMuNjIybDQuMzUzLTEuMzJhMiAyIDAgMCAwIC44My0uNDk3elwiLFxuICAgICAga2V5OiBcIjFhOHVzdVwiXG4gICAgfVxuICBdXG5dKTtcblxuZXhwb3J0IHsgUGVuIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/pen.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/upload.js":
/*!************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/upload.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Upload; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst Upload = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Upload\", [\n  [\"path\", { d: \"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\", key: \"ih7n3h\" }],\n  [\"polyline\", { points: \"17 8 12 3 7 8\", key: \"t8dd8p\" }],\n  [\"line\", { x1: \"12\", x2: \"12\", y1: \"3\", y2: \"15\", key: \"widbto\" }]\n]);\n\n\n//# sourceMappingURL=upload.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdXBsb2FkLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDs7QUFFdEQsZUFBZSxnRUFBZ0I7QUFDL0IsYUFBYSwrREFBK0Q7QUFDNUUsaUJBQWlCLHdDQUF3QztBQUN6RCxhQUFhLHNEQUFzRDtBQUNuRTs7QUFFNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy91cGxvYWQuanM/M2Y4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NDYuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IFVwbG9hZCA9IGNyZWF0ZUx1Y2lkZUljb24oXCJVcGxvYWRcIiwgW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNMjEgMTV2NGEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnYtNFwiLCBrZXk6IFwiaWg3bjNoXCIgfV0sXG4gIFtcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjE3IDggMTIgMyA3IDhcIiwga2V5OiBcInQ4ZGQ4cFwiIH1dLFxuICBbXCJsaW5lXCIsIHsgeDE6IFwiMTJcIiwgeDI6IFwiMTJcIiwgeTE6IFwiM1wiLCB5MjogXCIxNVwiLCBrZXk6IFwid2lkYnRvXCIgfV1cbl0pO1xuXG5leHBvcnQgeyBVcGxvYWQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBsb2FkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/upload.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/user.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/user.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ User; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst User = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"User\", [\n  [\"path\", { d: \"M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2\", key: \"975kel\" }],\n  [\"circle\", { cx: \"12\", cy: \"7\", r: \"4\", key: \"17ys0d\" }]\n]);\n\n\n//# sourceMappingURL=user.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdXNlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0Q7O0FBRXRELGFBQWEsZ0VBQWdCO0FBQzdCLGFBQWEsK0RBQStEO0FBQzVFLGVBQWUsMENBQTBDO0FBQ3pEOztBQUUyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL3VzZXIuanM/ODgyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NDYuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IFVzZXIgPSBjcmVhdGVMdWNpZGVJY29uKFwiVXNlclwiLCBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xOSAyMXYtMmE0IDQgMCAwIDAtNC00SDlhNCA0IDAgMCAwLTQgNHYyXCIsIGtleTogXCI5NzVrZWxcIiB9XSxcbiAgW1wiY2lyY2xlXCIsIHsgY3g6IFwiMTJcIiwgY3k6IFwiN1wiLCByOiBcIjRcIiwga2V5OiBcIjE3eXMwZFwiIH1dXG5dKTtcblxuZXhwb3J0IHsgVXNlciBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/user.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js":
/*!*******************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/x.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ X; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst X = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"X\", [\n  [\"path\", { d: \"M18 6 6 18\", key: \"1bl5f8\" }],\n  [\"path\", { d: \"m6 6 12 12\", key: \"d8bk6v\" }]\n]);\n\n\n//# sourceMappingURL=x.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMveC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0Q7O0FBRXRELFVBQVUsZ0VBQWdCO0FBQzFCLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsZ0NBQWdDO0FBQzdDOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL3guanM/NzAyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NDYuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IFggPSBjcmVhdGVMdWNpZGVJY29uKFwiWFwiLCBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xOCA2IDYgMThcIiwga2V5OiBcIjFibDVmOFwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtNiA2IDEyIDEyXCIsIGtleTogXCJkOGJrNnZcIiB9XVxuXSk7XG5cbmV4cG9ydCB7IFggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeClasses: function() { return /* binding */ mergeClasses; },\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.446.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nconst toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\nconst mergeClasses = (...classes) => classes.filter((className, index, array) => {\n  return Boolean(className) && array.indexOf(className) === index;\n}).join(\" \");\n\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVvQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL3NoYXJlZC9zcmMvdXRpbHMuanM/YmZkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NDYuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3QgdG9LZWJhYkNhc2UgPSAoc3RyaW5nKSA9PiBzdHJpbmcucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xuY29uc3QgbWVyZ2VDbGFzc2VzID0gKC4uLmNsYXNzZXMpID0+IGNsYXNzZXMuZmlsdGVyKChjbGFzc05hbWUsIGluZGV4LCBhcnJheSkgPT4ge1xuICByZXR1cm4gQm9vbGVhbihjbGFzc05hbWUpICYmIGFycmF5LmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gaW5kZXg7XG59KS5qb2luKFwiIFwiKTtcblxuZXhwb3J0IHsgbWVyZ2VDbGFzc2VzLCB0b0tlYmFiQ2FzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/M2NhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Csebik%5CDesktop%5CH1B%5CH1BMatch_FrontEnd%5Csrc%5Capp%5Cprofile%5Cpage.tsx&server=false!":
/*!*********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Csebik%5CDesktop%5CH1B%5CH1BMatch_FrontEnd%5Csrc%5Capp%5Cprofile%5Cpage.tsx&server=false! ***!
  \*********************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/profile/page.tsx */ \"(app-pages-browser)/./src/app/profile/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNzZWJpayU1Q0Rlc2t0b3AlNUNIMUIlNUNIMUJNYXRjaF9Gcm9udEVuZCU1Q3NyYyU1Q2FwcCU1Q3Byb2ZpbGUlNUNwYWdlLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/MDkzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXHNlYmlrXFxcXERlc2t0b3BcXFxcSDFCXFxcXEgxQk1hdGNoX0Zyb250RW5kXFxcXHNyY1xcXFxhcHBcXFxccHJvZmlsZVxcXFxwYWdlLnRzeFwiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Csebik%5CDesktop%5CH1B%5CH1BMatch_FrontEnd%5Csrc%5Capp%5Cprofile%5Cpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDZDQUE0QztJQUN4Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDBCQUEwQkMsbUJBQU9BLENBQUMsbUhBQTRCO0FBQ3BFLE1BQU1GLFlBQVksU0FBU0csSUFBSTtJQUMzQixJQUFJLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQU87UUFDdEdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztJQUNwQztJQUNBLElBQUlDLEtBQStCLEVBQUUsRUFFcEM7SUFDRCxPQUFPUDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9QLFFBQVFrQixPQUFPLEtBQUssY0FBZSxPQUFPbEIsUUFBUWtCLE9BQU8sS0FBSyxZQUFZbEIsUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xCLFFBQVFrQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0IsT0FBTyxFQUFFLGNBQWM7UUFBRWpCLE9BQU87SUFBSztJQUNuRUgsT0FBT3NCLE1BQU0sQ0FBQ3BCLFFBQVFrQixPQUFPLEVBQUVsQjtJQUMvQnFCLE9BQU9yQixPQUFPLEdBQUdBLFFBQVFrQixPQUFPO0FBQ2xDLEVBRUEsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanM/ZTJkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZExvY2FsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkTG9jYWxlO1xuICAgIH1cbn0pO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBhZGRMb2NhbGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtbG9jYWxlXCIpLmFkZExvY2FsZShwYXRoLCAuLi5hcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYWRkTG9jYWxlIiwiX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2giLCJyZXF1aXJlIiwicGF0aCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywwQkFBMEJDLG1CQUFPQSxDQUFDLG1IQUE0QjtBQUNwRSxNQUFNQyxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNKLGdCQUFnQk8sSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsYUFBYTtJQUN6RCxJQUFJTixLQUErQixFQUFFLEVBV3BDLE1BQU07UUFDSCxPQUFPO0lBQ1g7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPUixRQUFRMkIsT0FBTyxLQUFLLGNBQWUsT0FBTzNCLFFBQVEyQixPQUFPLEtBQUssWUFBWTNCLFFBQVEyQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8zQixRQUFRMkIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzlCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTJCLE9BQU8sRUFBRSxjQUFjO1FBQUUxQixPQUFPO0lBQUs7SUFDbkVILE9BQU8rQixNQUFNLENBQUM3QixRQUFRMkIsT0FBTyxFQUFFM0I7SUFDL0I4QixPQUFPOUIsT0FBTyxHQUFHQSxRQUFRMkIsT0FBTztBQUNsQyxFQUVBLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcz81YzI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RG9tYWluTG9jYWxlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREb21haW5Mb2NhbGU7XG4gICAgfVxufSk7XG5jb25zdCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIikubm9ybWFsaXplTG9jYWxlUGF0aDtcbiAgICAgICAgY29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4vZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIikuZGV0ZWN0RG9tYWluTG9jYWxlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhbGUgfHwgbm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgY29uc3QgZG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBcImh0dHBcIiArIChkb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiO1xuICAgICAgICAgICAgY29uc3QgZmluYWxMb2NhbGUgPSB0YXJnZXQgPT09IGRvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgdGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBwcm90byArIGRvbWFpbi5kb21haW4gKyAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKFwiXCIgKyBiYXNlUGF0aCArIGZpbmFsTG9jYWxlICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kb21haW4tbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJnZXREb21haW5Mb2NhbGUiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJ0YXJnZXQiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsInVuZGVmaW5lZCIsInByb3RvIiwiaHR0cCIsImZpbmFsTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (false) {}\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(prefetchPromise).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                forceOptimisticNavigation: !prefetchEnabled,\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ _react.default.createElement(\"a\", null, children);\n    }\n    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ _react.default.createElement(\"a\", {\n        ...restProps,\n        ...childProps\n    }, children);\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6InFEQUVhOztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQywyRkFBZ0I7QUFDN0MsTUFBTUksY0FBY0osbUJBQU9BLENBQUMscUlBQXlDO0FBQ3JFLE1BQU1LLGFBQWFMLG1CQUFPQSxDQUFDLGlJQUF1QztBQUNsRSxNQUFNTSxTQUFTTixtQkFBT0EsQ0FBQyw2RkFBcUI7QUFDNUMsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsdUZBQWM7QUFDekMsTUFBTVEsOEJBQThCUixtQkFBT0EsQ0FBQyw2SUFBNkM7QUFDekYsTUFBTVMsaUNBQWlDVCxtQkFBT0EsQ0FBQyxxSkFBaUQ7QUFDaEcsTUFBTVUsbUJBQW1CVixtQkFBT0EsQ0FBQyxtR0FBb0I7QUFDckQsTUFBTVcsbUJBQW1CWCxtQkFBT0EsQ0FBQyxxR0FBcUI7QUFDdEQsTUFBTVksZUFBZVosbUJBQU9BLENBQUMsNkZBQWlCO0FBQzlDLE1BQU1hLHNCQUFzQmIsbUJBQU9BLENBQUMsK0pBQWtEO0FBQ3RGLE1BQU1jLGFBQWEsSUFBSUM7QUFDdkIsU0FBU0MsU0FBU0MsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLFdBQVc7SUFDaEUsSUFBSSxLQUE2QixFQUFFLEVBRWxDO0lBQ0QsZ0pBQWdKO0lBQ2hKLElBQUksQ0FBQ0EsZUFBZSxDQUFDLENBQUMsR0FBR2xCLFlBQVltQixVQUFVLEVBQUVMLE9BQU87UUFDcEQ7SUFDSjtJQUNBLDRFQUE0RTtJQUM1RSxZQUFZO0lBQ1osSUFBSSxDQUFDRSxRQUFRSSxxQkFBcUIsRUFBRTtRQUNoQyxNQUFNQyxTQUNOLE9BQU9MLFFBQVFLLE1BQU0sS0FBSyxjQUFjTCxRQUFRSyxNQUFNLEdBQUcsWUFBWVIsU0FBU0EsT0FBT1EsTUFBTSxHQUFHQztRQUM5RixNQUFNQyxnQkFBZ0JULE9BQU8sTUFBTUMsS0FBSyxNQUFNTTtRQUM5QyxrRUFBa0U7UUFDbEUsSUFBSVgsV0FBV2MsR0FBRyxDQUFDRCxnQkFBZ0I7WUFDL0I7UUFDSjtRQUNBLCtCQUErQjtRQUMvQmIsV0FBV2UsR0FBRyxDQUFDRjtJQUNuQjtJQUNBLE1BQU1HLGtCQUFrQlIsY0FBY0wsT0FBT0QsUUFBUSxDQUFDRSxNQUFNRyxjQUFjSixPQUFPRCxRQUFRLENBQUNFLE1BQU1DLElBQUlDO0lBQ3BHLHVEQUF1RDtJQUN2RCwwREFBMEQ7SUFDMUQsc0RBQXNEO0lBQ3RELHlEQUF5RDtJQUN6RFcsUUFBUUMsT0FBTyxDQUFDRixpQkFBaUJHLEtBQUssQ0FBQyxDQUFDQztRQUNwQyxJQUFJQyxJQUFxQyxFQUFFO1lBQ3ZDLHFDQUFxQztZQUNyQyxNQUFNRDtRQUNWO0lBQ0o7QUFDSjtBQUNBLFNBQVNFLGdCQUFnQkMsS0FBSztJQUMxQixNQUFNQyxjQUFjRCxNQUFNRSxhQUFhO0lBQ3ZDLE1BQU1DLFNBQVNGLFlBQVlHLFlBQVksQ0FBQztJQUN4QyxPQUFPRCxVQUFVQSxXQUFXLFdBQVdILE1BQU1LLE9BQU8sSUFBSUwsTUFBTU0sT0FBTyxJQUFJTixNQUFNTyxRQUFRLElBQUlQLE1BQU1RLE1BQU0sSUFBSSw2QkFBNkI7SUFDeElSLE1BQU1TLFdBQVcsSUFBSVQsTUFBTVMsV0FBVyxDQUFDQyxLQUFLLEtBQUs7QUFDckQ7QUFDQSxTQUFTQyxZQUFZQyxDQUFDLEVBQUVoQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFFK0IsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRTNCLE1BQU0sRUFBRUgsV0FBVyxFQUFFK0IsZUFBZTtJQUNwRyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHTCxFQUFFVixhQUFhO0lBQ3BDLGtEQUFrRDtJQUNsRCxNQUFNZ0IsbUJBQW1CRCxTQUFTRSxXQUFXLE9BQU87SUFDcEQsSUFBSUQsb0JBQXFCbkIsQ0FBQUEsZ0JBQWdCYSxNQUFNLGdKQUFnSjtJQUMvTCxDQUFDM0IsZUFBZSxDQUFDLENBQUMsR0FBR2xCLFlBQVltQixVQUFVLEVBQUVMLEtBQUksR0FBSTtRQUNqRCw4Q0FBOEM7UUFDOUM7SUFDSjtJQUNBK0IsRUFBRVEsY0FBYztJQUNoQixNQUFNQyxXQUFXO1FBQ2Isd0VBQXdFO1FBQ3hFLE1BQU1DLGVBQWVQLFVBQVUsT0FBT0EsU0FBUztRQUMvQyxJQUFJLG9CQUFvQm5DLFFBQVE7WUFDNUJBLE1BQU0sQ0FBQ2lDLFVBQVUsWUFBWSxPQUFPLENBQUNoQyxNQUFNQyxJQUFJO2dCQUMzQ2dDO2dCQUNBMUI7Z0JBQ0EyQixRQUFRTztZQUNaO1FBQ0osT0FBTztZQUNIMUMsTUFBTSxDQUFDaUMsVUFBVSxZQUFZLE9BQU8sQ0FBQy9CLE1BQU1ELE1BQU07Z0JBQzdDMEMsMkJBQTJCLENBQUNQO2dCQUM1QkQsUUFBUU87WUFDWjtRQUNKO0lBQ0o7SUFDQSxJQUFJckMsYUFBYTtRQUNickIsT0FBTzRELE9BQU8sQ0FBQ0MsZUFBZSxDQUFDSjtJQUNuQyxPQUFPO1FBQ0hBO0lBQ0o7QUFDSjtBQUNBLFNBQVNLLGtCQUFrQkMsY0FBYztJQUNyQyxJQUFJLE9BQU9BLG1CQUFtQixVQUFVO1FBQ3BDLE9BQU9BO0lBQ1g7SUFDQSxPQUFPLENBQUMsR0FBRzNELFdBQVc0RCxTQUFTLEVBQUVEO0FBQ3JDO0FBQ0E7O0NBRUMsR0FBRyxNQUFNRSxPQUFPLFdBQVcsR0FBR2pFLEdBQUFBLE9BQU80RCxPQUFPLENBQUNNLFVBQVUsU0FBQyxTQUFTQyxjQUFjQyxLQUFLLEVBQUVDLFlBQVk7O0lBQy9GLElBQUlDO0lBQ0osTUFBTSxFQUFFckQsTUFBTXNELFFBQVEsRUFBRXJELElBQUlzRCxNQUFNLEVBQUVGLFVBQVVHLFlBQVksRUFBRTFELFVBQVUyRCxlQUFlLElBQUksRUFBRUMsUUFBUSxFQUFFMUIsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRTNCLE1BQU0sRUFBRW9ELE9BQU8sRUFBRUMsY0FBY0MsZ0JBQWdCLEVBQUVDLGNBQWNDLGdCQUFnQixFQUFFQyxpQkFBaUIsS0FBSyxFQUFFLEdBQUdDLFdBQVcsR0FBR2Q7SUFDelBFLFdBQVdHO0lBQ1gsSUFBSVEsa0JBQW1CLFFBQU9YLGFBQWEsWUFBWSxPQUFPQSxhQUFhLFFBQU8sR0FBSTtRQUNsRkEsV0FBVyxXQUFXLEdBQUd0RSxPQUFPNEQsT0FBTyxDQUFDdUIsYUFBYSxDQUFDLEtBQUssTUFBTWI7SUFDckU7SUFDQSxNQUFNYyxjQUFjcEYsT0FBTzRELE9BQU8sQ0FBQ3lCLFVBQVUsQ0FBQzlFLDRCQUE0QitFLGFBQWE7SUFDdkYsTUFBTUMsWUFBWXZGLE9BQU80RCxPQUFPLENBQUN5QixVQUFVLENBQUM3RSwrQkFBK0JnRixnQkFBZ0I7SUFDM0YsTUFBTXhFLFNBQVNvRSxlQUFlLE9BQU9BLGNBQWNHO0lBQ25ELDBEQUEwRDtJQUMxRCxNQUFNbEUsY0FBYyxDQUFDK0Q7SUFDckIsTUFBTWhDLGtCQUFrQnNCLGlCQUFpQjtJQUN6Qzs7Ozs7S0FLQyxHQUFHLE1BQU1lLGtCQUFrQmYsaUJBQWlCLE9BQU85RCxvQkFBb0I4RSxZQUFZLENBQUNDLElBQUksR0FBRy9FLG9CQUFvQjhFLFlBQVksQ0FBQ0UsSUFBSTtJQUNqSSxJQUFJMUQsSUFBcUMsRUFBRTtRQUN2QyxTQUFTMkQsZ0JBQWdCQyxJQUFJO1lBQ3pCLE9BQU8sSUFBSUMsTUFBTSxpQ0FBaUNELEtBQUtFLEdBQUcsR0FBRyxpQkFBaUJGLEtBQUtHLFFBQVEsR0FBRyw0QkFBNEJILEtBQUtJLE1BQU0sR0FBRyxlQUFnQixNQUE2QixHQUFHLHFFQUFxRSxDQUFDO1FBQ2xRO1FBQ0Esc0NBQXNDO1FBQ3RDLE1BQU1DLHFCQUFxQjtZQUN2QmxGLE1BQU07UUFDVjtRQUNBLE1BQU1tRixnQkFBZ0I3RyxPQUFPOEcsSUFBSSxDQUFDRjtRQUNsQ0MsY0FBY0UsT0FBTyxDQUFDLENBQUNOO1lBQ25CLElBQUlBLFFBQVEsUUFBUTtnQkFDaEIsSUFBSTVCLEtBQUssQ0FBQzRCLElBQUksSUFBSSxRQUFRLE9BQU81QixLQUFLLENBQUM0QixJQUFJLEtBQUssWUFBWSxPQUFPNUIsS0FBSyxDQUFDNEIsSUFBSSxLQUFLLFVBQVU7b0JBQ3hGLE1BQU1ILGdCQUFnQjt3QkFDbEJHO3dCQUNBQyxVQUFVO3dCQUNWQyxRQUFROUIsS0FBSyxDQUFDNEIsSUFBSSxLQUFLLE9BQU8sU0FBUyxPQUFPNUIsS0FBSyxDQUFDNEIsSUFBSTtvQkFDNUQ7Z0JBQ0o7WUFDSixPQUFPO2dCQUNILHNDQUFzQztnQkFDdEMsNkRBQTZEO2dCQUM3RCxNQUFNL0YsSUFBSStGO1lBQ2Q7UUFDSjtRQUNBLHNDQUFzQztRQUN0QyxNQUFNTyxxQkFBcUI7WUFDdkJyRixJQUFJO1lBQ0orQixTQUFTO1lBQ1RFLFFBQVE7WUFDUkQsU0FBUztZQUNUeUIsVUFBVTtZQUNWNUQsVUFBVTtZQUNWUyxRQUFRO1lBQ1JvRCxTQUFTO1lBQ1RDLGNBQWM7WUFDZEUsY0FBYztZQUNkRSxnQkFBZ0I7UUFDcEI7UUFDQSxNQUFNdUIsZ0JBQWdCakgsT0FBTzhHLElBQUksQ0FBQ0U7UUFDbENDLGNBQWNGLE9BQU8sQ0FBQyxDQUFDTjtZQUNuQixNQUFNUyxVQUFVLE9BQU9yQyxLQUFLLENBQUM0QixJQUFJO1lBQ2pDLElBQUlBLFFBQVEsTUFBTTtnQkFDZCxJQUFJNUIsS0FBSyxDQUFDNEIsSUFBSSxJQUFJUyxZQUFZLFlBQVlBLFlBQVksVUFBVTtvQkFDNUQsTUFBTVosZ0JBQWdCO3dCQUNsQkc7d0JBQ0FDLFVBQVU7d0JBQ1ZDLFFBQVFPO29CQUNaO2dCQUNKO1lBQ0osT0FBTyxJQUFJVCxRQUFRLFVBQVU7Z0JBQ3pCLElBQUk1QixLQUFLLENBQUM0QixJQUFJLElBQUlTLFlBQVksVUFBVTtvQkFDcEMsTUFBTVosZ0JBQWdCO3dCQUNsQkc7d0JBQ0FDLFVBQVU7d0JBQ1ZDLFFBQVFPO29CQUNaO2dCQUNKO1lBQ0osT0FBTyxJQUFJVCxRQUFRLGFBQWFBLFFBQVEsa0JBQWtCQSxRQUFRLGdCQUFnQjtnQkFDOUUsSUFBSTVCLEtBQUssQ0FBQzRCLElBQUksSUFBSVMsWUFBWSxZQUFZO29CQUN0QyxNQUFNWixnQkFBZ0I7d0JBQ2xCRzt3QkFDQUMsVUFBVTt3QkFDVkMsUUFBUU87b0JBQ1o7Z0JBQ0o7WUFDSixPQUFPLElBQUlULFFBQVEsYUFBYUEsUUFBUSxZQUFZQSxRQUFRLGFBQWFBLFFBQVEsY0FBY0EsUUFBUSxjQUFjQSxRQUFRLGtCQUFrQjtnQkFDM0ksSUFBSTVCLEtBQUssQ0FBQzRCLElBQUksSUFBSSxRQUFRUyxZQUFZLFdBQVc7b0JBQzdDLE1BQU1aLGdCQUFnQjt3QkFDbEJHO3dCQUNBQyxVQUFVO3dCQUNWQyxRQUFRTztvQkFDWjtnQkFDSjtZQUNKLE9BQU87Z0JBQ0gsc0NBQXNDO2dCQUN0Qyw2REFBNkQ7Z0JBQzdELE1BQU14RyxJQUFJK0Y7WUFDZDtRQUNKO1FBQ0EsNEZBQTRGO1FBQzVGLHNEQUFzRDtRQUN0RCxNQUFNVSxZQUFZMUcsT0FBTzRELE9BQU8sQ0FBQytDLE1BQU0sQ0FBQztRQUN4QyxJQUFJdkMsTUFBTXJELFFBQVEsSUFBSSxDQUFDMkYsVUFBVUUsT0FBTyxJQUFJLENBQUN2RixhQUFhO1lBQ3REcUYsVUFBVUUsT0FBTyxHQUFHO1lBQ3BCQyxRQUFRQyxJQUFJLENBQUM7UUFDakI7SUFDSjtJQUNBLElBQUk1RSxJQUFxQyxFQUFFO1FBQ3ZDLElBQUliLGVBQWUsQ0FBQ21ELFFBQVE7WUFDeEIsSUFBSXZEO1lBQ0osSUFBSSxPQUFPc0QsYUFBYSxVQUFVO2dCQUM5QnRELE9BQU9zRDtZQUNYLE9BQU8sSUFBSSxPQUFPQSxhQUFhLFlBQVksT0FBT0EsU0FBU3dDLFFBQVEsS0FBSyxVQUFVO2dCQUM5RTlGLE9BQU9zRCxTQUFTd0MsUUFBUTtZQUM1QjtZQUNBLElBQUk5RixNQUFNO2dCQUNOLE1BQU0rRixvQkFBb0IvRixLQUFLZ0csS0FBSyxDQUFDLEtBQUtDLElBQUksQ0FBQyxDQUFDQyxVQUFVQSxRQUFRQyxVQUFVLENBQUMsUUFBUUQsUUFBUUUsUUFBUSxDQUFDO2dCQUN0RyxJQUFJTCxtQkFBbUI7b0JBQ25CLE1BQU0sSUFBSWpCLE1BQU0sbUJBQW1COUUsT0FBTztnQkFDOUM7WUFDSjtRQUNKO0lBQ0o7SUFDQSxNQUFNLEVBQUVBLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUdsQixPQUFPNEQsT0FBTyxDQUFDMEQsT0FBTyxDQUFDO1FBQ3hDLElBQUksQ0FBQ2xDLGFBQWE7WUFDZCxNQUFNbUMsZUFBZXpELGtCQUFrQlM7WUFDdkMsT0FBTztnQkFDSHRELE1BQU1zRztnQkFDTnJHLElBQUlzRCxTQUFTVixrQkFBa0JVLFVBQVUrQztZQUM3QztRQUNKO1FBQ0EsTUFBTSxDQUFDQSxjQUFjQyxXQUFXLEdBQUcsQ0FBQyxHQUFHdEgsYUFBYXVILFdBQVcsRUFBRXJDLGFBQWFiLFVBQVU7UUFDeEYsT0FBTztZQUNIdEQsTUFBTXNHO1lBQ05yRyxJQUFJc0QsU0FBUyxDQUFDLEdBQUd0RSxhQUFhdUgsV0FBVyxFQUFFckMsYUFBYVosVUFBVWdELGNBQWNEO1FBQ3BGO0lBQ0osR0FBRztRQUNDbkM7UUFDQWI7UUFDQUM7S0FDSDtJQUNELE1BQU1rRCxlQUFlMUgsT0FBTzRELE9BQU8sQ0FBQytDLE1BQU0sQ0FBQzFGO0lBQzNDLE1BQU0wRyxhQUFhM0gsT0FBTzRELE9BQU8sQ0FBQytDLE1BQU0sQ0FBQ3pGO0lBQ3pDLG9GQUFvRjtJQUNwRixJQUFJMEc7SUFDSixJQUFJM0MsZ0JBQWdCO1FBQ2hCLElBQUkvQyxJQUFzQyxFQUFFO1lBQ3hDLElBQUkwQyxTQUFTO2dCQUNUaUMsUUFBUUMsSUFBSSxDQUFDLG9EQUFvRHZDLFdBQVc7WUFDaEY7WUFDQSxJQUFJTyxrQkFBa0I7Z0JBQ2xCK0IsUUFBUUMsSUFBSSxDQUFDLHlEQUF5RHZDLFdBQVc7WUFDckY7WUFDQSxJQUFJO2dCQUNBcUQsUUFBUTVILE9BQU80RCxPQUFPLENBQUNpRSxRQUFRLENBQUNDLElBQUksQ0FBQ3hEO1lBQ3pDLEVBQUUsT0FBT3JDLEtBQUs7Z0JBQ1YsSUFBSSxDQUFDcUMsVUFBVTtvQkFDWCxNQUFNLElBQUl5QixNQUFNLHVEQUF1RHhCLFdBQVc7Z0JBQ3RGO2dCQUNBLE1BQU0sSUFBSXdCLE1BQU0sNkRBQTZEeEIsV0FBVyw4RkFBK0YsTUFBNkIsR0FBRyxzRUFBc0UsQ0FBQztZQUNsUztRQUNKLE9BQU8sRUFFTjtJQUNMLE9BQU87UUFDSCxJQUFJckMsSUFBc0MsRUFBRTtZQUN4QyxJQUFJLENBQUNvQyxZQUFZLE9BQU8sS0FBSyxJQUFJQSxTQUFTeUQsSUFBSSxNQUFNLEtBQUs7Z0JBQ3JELE1BQU0sSUFBSWhDLE1BQU07WUFDcEI7UUFDSjtJQUNKO0lBQ0EsTUFBTWlDLFdBQVcvQyxpQkFBaUIyQyxTQUFTLE9BQU9BLFVBQVUsWUFBWUEsTUFBTUssR0FBRyxHQUFHNUQ7SUFDcEYsTUFBTSxDQUFDNkQsb0JBQW9CQyxXQUFXQyxhQUFhLEdBQUcsQ0FBQyxHQUFHM0gsaUJBQWlCNEgsZUFBZSxFQUFFO1FBQ3hGQyxZQUFZO0lBQ2hCO0lBQ0EsTUFBTUMsU0FBU3ZJLE9BQU80RCxPQUFPLENBQUM0RSxXQUFXLENBQUMsQ0FBQ0M7UUFDdkMsNEVBQTRFO1FBQzVFLElBQUlkLFdBQVdmLE9BQU8sS0FBSzFGLE1BQU13RyxhQUFhZCxPQUFPLEtBQUszRixNQUFNO1lBQzVEbUg7WUFDQVQsV0FBV2YsT0FBTyxHQUFHMUY7WUFDckJ3RyxhQUFhZCxPQUFPLEdBQUczRjtRQUMzQjtRQUNBaUgsbUJBQW1CTztRQUNuQixJQUFJVCxVQUFVO1lBQ1YsSUFBSSxPQUFPQSxhQUFhLFlBQVlBLFNBQVNTO2lCQUN4QyxJQUFJLE9BQU9ULGFBQWEsVUFBVTtnQkFDbkNBLFNBQVNwQixPQUFPLEdBQUc2QjtZQUN2QjtRQUNKO0lBQ0osR0FBRztRQUNDdkg7UUFDQThHO1FBQ0EvRztRQUNBbUg7UUFDQUY7S0FDSDtJQUNELDJEQUEyRDtJQUMzRGxJLE9BQU80RCxPQUFPLENBQUM4RSxTQUFTLENBQUM7UUFDckIsZ0hBQWdIO1FBQ2hILElBQUl4RyxJQUFxQyxFQUFFO1lBQ3ZDO1FBQ0o7UUFDQSxJQUFJLENBQUNsQixRQUFRO1lBQ1Q7UUFDSjtRQUNBLDJEQUEyRDtRQUMzRCxJQUFJLENBQUNtSCxhQUFhLENBQUMvRSxpQkFBaUI7WUFDaEM7UUFDSjtRQUNBLG9CQUFvQjtRQUNwQnJDLFNBQVNDLFFBQVFDLE1BQU1DLElBQUk7WUFDdkJNO1FBQ0osR0FBRztZQUNDbUgsTUFBTWxEO1FBQ1YsR0FBR3BFO0lBQ1AsR0FBRztRQUNDSDtRQUNBRDtRQUNBa0g7UUFDQTNHO1FBQ0E0QjtRQUNBZ0MsZUFBZSxPQUFPLEtBQUssSUFBSUEsWUFBWTVELE1BQU07UUFDakRSO1FBQ0FLO1FBQ0FvRTtLQUNIO0lBQ0QsTUFBTW1ELGFBQWE7UUFDZlgsS0FBS007UUFDTDNELFNBQVM1QixDQUFDO1lBQ04sSUFBSWQsSUFBcUMsRUFBRTtnQkFDdkMsSUFBSSxDQUFDYyxHQUFHO29CQUNKLE1BQU0sSUFBSStDLE1BQU07Z0JBQ3BCO1lBQ0o7WUFDQSxJQUFJLENBQUNkLGtCQUFrQixPQUFPTCxZQUFZLFlBQVk7Z0JBQ2xEQSxRQUFRNUI7WUFDWjtZQUNBLElBQUlpQyxrQkFBa0IyQyxNQUFNeEQsS0FBSyxJQUFJLE9BQU93RCxNQUFNeEQsS0FBSyxDQUFDUSxPQUFPLEtBQUssWUFBWTtnQkFDNUVnRCxNQUFNeEQsS0FBSyxDQUFDUSxPQUFPLENBQUM1QjtZQUN4QjtZQUNBLElBQUksQ0FBQ2hDLFFBQVE7Z0JBQ1Q7WUFDSjtZQUNBLElBQUlnQyxFQUFFNkYsZ0JBQWdCLEVBQUU7Z0JBQ3BCO1lBQ0o7WUFDQTlGLFlBQVlDLEdBQUdoQyxRQUFRQyxNQUFNQyxJQUFJK0IsU0FBU0MsU0FBU0MsUUFBUTNCLFFBQVFILGFBQWErQjtRQUNwRjtRQUNBeUIsY0FBYzdCLENBQUM7WUFDWCxJQUFJLENBQUNpQyxrQkFBa0IsT0FBT0gscUJBQXFCLFlBQVk7Z0JBQzNEQSxpQkFBaUI5QjtZQUNyQjtZQUNBLElBQUlpQyxrQkFBa0IyQyxNQUFNeEQsS0FBSyxJQUFJLE9BQU93RCxNQUFNeEQsS0FBSyxDQUFDUyxZQUFZLEtBQUssWUFBWTtnQkFDakYrQyxNQUFNeEQsS0FBSyxDQUFDUyxZQUFZLENBQUM3QjtZQUM3QjtZQUNBLElBQUksQ0FBQ2hDLFFBQVE7Z0JBQ1Q7WUFDSjtZQUNBLElBQUksQ0FBQyxDQUFDb0MsbUJBQW1CbEIsa0JBQXlCLGFBQVksS0FBTWIsYUFBYTtnQkFDN0U7WUFDSjtZQUNBTixTQUFTQyxRQUFRQyxNQUFNQyxJQUFJO2dCQUN2Qk07Z0JBQ0FzSCxVQUFVO2dCQUNWLGdHQUFnRztnQkFDaEd2SCx1QkFBdUI7WUFDM0IsR0FBRztnQkFDQ29ILE1BQU1sRDtZQUNWLEdBQUdwRTtRQUNQO1FBQ0EwRCxjQUFjL0IsQ0FBQztZQUNYLElBQUksQ0FBQ2lDLGtCQUFrQixPQUFPRCxxQkFBcUIsWUFBWTtnQkFDM0RBLGlCQUFpQmhDO1lBQ3JCO1lBQ0EsSUFBSWlDLGtCQUFrQjJDLE1BQU14RCxLQUFLLElBQUksT0FBT3dELE1BQU14RCxLQUFLLENBQUNXLFlBQVksS0FBSyxZQUFZO2dCQUNqRjZDLE1BQU14RCxLQUFLLENBQUNXLFlBQVksQ0FBQy9CO1lBQzdCO1lBQ0EsSUFBSSxDQUFDaEMsUUFBUTtnQkFDVDtZQUNKO1lBQ0EsSUFBSSxDQUFDb0MsbUJBQW1CL0IsYUFBYTtnQkFDakM7WUFDSjtZQUNBTixTQUFTQyxRQUFRQyxNQUFNQyxJQUFJO2dCQUN2Qk07Z0JBQ0FzSCxVQUFVO2dCQUNWLGdHQUFnRztnQkFDaEd2SCx1QkFBdUI7WUFDM0IsR0FBRztnQkFDQ29ILE1BQU1sRDtZQUNWLEdBQUdwRTtRQUNQO0lBQ0o7SUFDQSw2RkFBNkY7SUFDN0Ysd0ZBQXdGO0lBQ3hGLG9GQUFvRjtJQUNwRixJQUFJLENBQUMsR0FBR2hCLE9BQU8wSSxhQUFhLEVBQUU3SCxLQUFLO1FBQy9CMEgsV0FBVzNILElBQUksR0FBR0M7SUFDdEIsT0FBTyxJQUFJLENBQUMrRCxrQkFBa0JOLFlBQVlpRCxNQUFNRyxJQUFJLEtBQUssT0FBTyxDQUFFLFdBQVVILE1BQU14RCxLQUFLLEdBQUc7UUFDdEYsTUFBTTRFLFlBQVksT0FBT3hILFdBQVcsY0FBY0EsU0FBUzRELGVBQWUsT0FBTyxLQUFLLElBQUlBLFlBQVk1RCxNQUFNO1FBQzVHLHVFQUF1RTtRQUN2RSx1RUFBdUU7UUFDdkUsTUFBTXlILGVBQWUsQ0FBQzdELGVBQWUsT0FBTyxLQUFLLElBQUlBLFlBQVk4RCxjQUFjLEtBQUssQ0FBQyxHQUFHeEksaUJBQWlCeUksZUFBZSxFQUFFakksSUFBSThILFdBQVc1RCxlQUFlLE9BQU8sS0FBSyxJQUFJQSxZQUFZZ0UsT0FBTyxFQUFFaEUsZUFBZSxPQUFPLEtBQUssSUFBSUEsWUFBWWlFLGFBQWE7UUFDclBULFdBQVczSCxJQUFJLEdBQUdnSSxnQkFBZ0IsQ0FBQyxHQUFHdEksYUFBYTJJLFdBQVcsRUFBRSxDQUFDLEdBQUdoSixXQUFXaUosU0FBUyxFQUFFckksSUFBSThILFdBQVc1RCxlQUFlLE9BQU8sS0FBSyxJQUFJQSxZQUFZb0UsYUFBYTtJQUNySztJQUNBLE9BQU92RSxpQkFBaUIsV0FBVyxHQUFHakYsT0FBTzRELE9BQU8sQ0FBQzZGLFlBQVksQ0FBQzdCLE9BQU9nQixjQUFjLFdBQVcsR0FBRzVJLE9BQU80RCxPQUFPLENBQUN1QixhQUFhLENBQUMsS0FBSztRQUNuSSxHQUFHRCxTQUFTO1FBQ1osR0FBRzBELFVBQVU7SUFDakIsR0FBR3RFO0FBQ1A7O0FBQ0EsTUFBTXpFLFdBQVdvRTtBQUVqQixJQUFJLENBQUMsT0FBT3hFLFFBQVFtRSxPQUFPLEtBQUssY0FBZSxPQUFPbkUsUUFBUW1FLE9BQU8sS0FBSyxZQUFZbkUsUUFBUW1FLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT25FLFFBQVFtRSxPQUFPLENBQUM4RixVQUFVLEtBQUssYUFBYTtJQUNyS25LLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW1FLE9BQU8sRUFBRSxjQUFjO1FBQUVsRSxPQUFPO0lBQUs7SUFDbkVILE9BQU9vSyxNQUFNLENBQUNsSyxRQUFRbUUsT0FBTyxFQUFFbkU7SUFDL0JtSyxPQUFPbkssT0FBTyxHQUFHQSxRQUFRbUUsT0FBTztBQUNsQyxFQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzP2U0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3Jlc29sdmVocmVmID0gcmVxdWlyZShcIi4vcmVzb2x2ZS1ocmVmXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsXCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvdXRpbHNcIik7XG5jb25zdCBfYWRkbG9jYWxlID0gcmVxdWlyZShcIi4vYWRkLWxvY2FsZVwiKTtcbmNvbnN0IF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX3VzZWludGVyc2VjdGlvbiA9IHJlcXVpcmUoXCIuL3VzZS1pbnRlcnNlY3Rpb25cIik7XG5jb25zdCBfZ2V0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4vZ2V0LWRvbWFpbi1sb2NhbGVcIik7XG5jb25zdCBfYWRkYmFzZXBhdGggPSByZXF1aXJlKFwiLi9hZGQtYmFzZS1wYXRoXCIpO1xuY29uc3QgX3JvdXRlcnJlZHVjZXJ0eXBlcyA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXNcIik7XG5jb25zdCBwcmVmZXRjaGVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgb3B0aW9ucywgYXBwT3B0aW9ucywgaXNBcHBSb3V0ZXIpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFwcC1yb3V0ZXIgc3VwcG9ydHMgZXh0ZXJuYWwgdXJscyBvdXQgb2YgdGhlIGJveCBzbyBpdCBzaG91bGRuJ3Qgc2hvcnQtY2lyY3VpdCBoZXJlIGFzIHN1cHBvcnQgZm9yIGUuZy4gYHJlcGxhY2VgIGlzIGFkZGVkIGluIHRoZSBhcHAtcm91dGVyLlxuICAgIGlmICghaXNBcHBSb3V0ZXIgJiYgISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShocmVmKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIHNob3VsZCBvbmx5IGRlZHVwZSByZXF1ZXN0cyB3aGVuIGV4cGVyaW1lbnRhbC5vcHRpbWlzdGljQ2xpZW50Q2FjaGUgaXNcbiAgICAvLyBkaXNhYmxlZC5cbiAgICBpZiAoIW9wdGlvbnMuYnlwYXNzUHJlZmV0Y2hlZENoZWNrKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IC8vIExldCB0aGUgbGluaydzIGxvY2FsZSBwcm9wIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHJvdXRlciBsb2NhbGUuXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubG9jYWxlIDogXCJsb2NhbGVcIiBpbiByb3V0ZXIgPyByb3V0ZXIubG9jYWxlIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwcmVmZXRjaGVkS2V5ID0gaHJlZiArIFwiJVwiICsgYXMgKyBcIiVcIiArIGxvY2FsZTtcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBmZXRjaGVkIHRoZSBrZXksIHRoZW4gZG9uJ3QgcHJlZmV0Y2ggaXQgYWdhaW4hXG4gICAgICAgIGlmIChwcmVmZXRjaGVkLmhhcyhwcmVmZXRjaGVkS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgdGhpcyBVUkwgYXMgcHJlZmV0Y2hlZC5cbiAgICAgICAgcHJlZmV0Y2hlZC5hZGQocHJlZmV0Y2hlZEtleSk7XG4gICAgfVxuICAgIGNvbnN0IHByZWZldGNoUHJvbWlzZSA9IGlzQXBwUm91dGVyID8gcm91dGVyLnByZWZldGNoKGhyZWYsIGFwcE9wdGlvbnMpIDogcm91dGVyLnByZWZldGNoKGhyZWYsIGFzLCBvcHRpb25zKTtcbiAgICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAgIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICAgIFByb21pc2UucmVzb2x2ZShwcmVmZXRjaFByb21pc2UpLmNhdGNoKChlcnIpPT57XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcbiAgICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldCAhPT0gXCJfc2VsZlwiIHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgLy8gdHJpZ2dlcnMgcmVzb3VyY2UgZG93bmxvYWRcbiAgICBldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMjtcbn1cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBpc0FwcFJvdXRlciwgcHJlZmV0Y2hFbmFibGVkKSB7XG4gICAgY29uc3QgeyBub2RlTmFtZSB9ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgIC8vIGFuY2hvcnMgaW5zaWRlIGFuIHN2ZyBoYXZlIGEgbG93ZXJjYXNlIG5vZGVOYW1lXG4gICAgY29uc3QgaXNBbmNob3JOb2RlTmFtZSA9IG5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiQVwiO1xuICAgIGlmIChpc0FuY2hvck5vZGVOYW1lICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgLy8gYXBwLXJvdXRlciBzdXBwb3J0cyBleHRlcm5hbCB1cmxzIG91dCBvZiB0aGUgYm94IHNvIGl0IHNob3VsZG4ndCBzaG9ydC1jaXJjdWl0IGhlcmUgYXMgc3VwcG9ydCBmb3IgZS5nLiBgcmVwbGFjZWAgaXMgYWRkZWQgaW4gdGhlIGFwcC1yb3V0ZXIuXG4gICAgIWlzQXBwUm91dGVyICYmICEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoaHJlZikpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBuYXZpZ2F0ZSA9ICgpPT57XG4gICAgICAgIC8vIElmIHRoZSByb3V0ZXIgaXMgYW4gTmV4dFJvdXRlciBpbnN0YW5jZSBpdCB3aWxsIGhhdmUgYGJlZm9yZVBvcFN0YXRlYFxuICAgICAgICBjb25zdCByb3V0ZXJTY3JvbGwgPSBzY3JvbGwgIT0gbnVsbCA/IHNjcm9sbCA6IHRydWU7XG4gICAgICAgIGlmIChcImJlZm9yZVBvcFN0YXRlXCIgaW4gcm91dGVyKSB7XG4gICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJwdXNoXCJdKGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm91dGVyW3JlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiXShhcyB8fCBocmVmLCB7XG4gICAgICAgICAgICAgICAgZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbjogIXByZWZldGNoRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBzY3JvbGw6IHJvdXRlclNjcm9sbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0FwcFJvdXRlcikge1xuICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24obmF2aWdhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5hdmlnYXRlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0U3RyaW5nT3JVcmwodXJsT2JqT3JTdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHVybE9iak9yU3RyaW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB1cmxPYmpPclN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfZm9ybWF0dXJsLmZvcm1hdFVybCkodXJsT2JqT3JTdHJpbmcpO1xufVxuLyoqXG4gKiBSZWFjdCBDb21wb25lbnQgdGhhdCBlbmFibGVzIGNsaWVudC1zaWRlIHRyYW5zaXRpb25zIGJldHdlZW4gcm91dGVzLlxuICovIGNvbnN0IExpbmsgPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlua0NvbXBvbmVudChwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIGNvbnN0IHsgaHJlZjogaHJlZlByb3AsIGFzOiBhc1Byb3AsIGNoaWxkcmVuOiBjaGlsZHJlblByb3AsIHByZWZldGNoOiBwcmVmZXRjaFByb3AgPSBudWxsLCBwYXNzSHJlZiwgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIG9uQ2xpY2ssIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyUHJvcCwgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnRQcm9wLCBsZWdhY3lCZWhhdmlvciA9IGZhbHNlLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICAgIGNoaWxkcmVuID0gY2hpbGRyZW5Qcm9wO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgcGFnZXNSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5Sb3V0ZXJDb250ZXh0KTtcbiAgICBjb25zdCBhcHBSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5BcHBSb3V0ZXJDb250ZXh0KTtcbiAgICBjb25zdCByb3V0ZXIgPSBwYWdlc1JvdXRlciAhPSBudWxsID8gcGFnZXNSb3V0ZXIgOiBhcHBSb3V0ZXI7XG4gICAgLy8gV2UncmUgaW4gdGhlIGFwcCBkaXJlY3RvcnkgaWYgdGhlcmUgaXMgbm8gcGFnZXMgcm91dGVyLlxuICAgIGNvbnN0IGlzQXBwUm91dGVyID0gIXBhZ2VzUm91dGVyO1xuICAgIGNvbnN0IHByZWZldGNoRW5hYmxlZCA9IHByZWZldGNoUHJvcCAhPT0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIHBvc3NpYmxlIHN0YXRlcyBmb3IgcHJlZmV0Y2ggYXJlOlxuICAgICAqIC0gbnVsbDogdGhpcyBpcyB0aGUgZGVmYXVsdCBcImF1dG9cIiBtb2RlLCB3aGVyZSB3ZSB3aWxsIHByZWZldGNoIHBhcnRpYWxseSBpZiB0aGUgbGluayBpcyBpbiB0aGUgdmlld3BvcnRcbiAgICAgKiAtIHRydWU6IHdlIHdpbGwgcHJlZmV0Y2ggaWYgdGhlIGxpbmsgaXMgdmlzaWJsZSBhbmQgcHJlZmV0Y2ggdGhlIGZ1bGwgcGFnZSwgbm90IGp1c3QgcGFydGlhbGx5XG4gICAgICogLSBmYWxzZTogd2Ugd2lsbCBub3QgcHJlZmV0Y2ggaWYgaW4gdGhlIHZpZXdwb3J0IGF0IGFsbFxuICAgICAqLyBjb25zdCBhcHBQcmVmZXRjaEtpbmQgPSBwcmVmZXRjaFByb3AgPT09IG51bGwgPyBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5BVVRPIDogX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuRlVMTDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgYFwiICsgYXJncy5rZXkgKyBcImAgZXhwZWN0cyBhIFwiICsgYXJncy5leHBlY3RlZCArIFwiIGluIGA8TGluaz5gLCBidXQgZ290IGBcIiArIGFyZ3MuYWN0dWFsICsgXCJgIGluc3RlYWQuXCIgKyAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IFwiXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6IFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBocmVmOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHMgPSBPYmplY3Qua2V5cyhyZXF1aXJlZFByb3BzR3VhcmQpO1xuICAgICAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiaHJlZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHNba2V5XSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYHN0cmluZ2Agb3IgYG9iamVjdGBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHByb3BzW2tleV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBjb25zdCBfID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxQcm9wc0d1YXJkID0ge1xuICAgICAgICAgICAgYXM6IHRydWUsXG4gICAgICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICAgICAgc2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgc2hhbGxvdzogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3NIcmVmOiB0cnVlLFxuICAgICAgICAgICAgcHJlZmV0Y2g6IHRydWUsXG4gICAgICAgICAgICBsb2NhbGU6IHRydWUsXG4gICAgICAgICAgICBvbkNsaWNrOiB0cnVlLFxuICAgICAgICAgICAgb25Nb3VzZUVudGVyOiB0cnVlLFxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0cnVlLFxuICAgICAgICAgICAgbGVnYWN5QmVoYXZpb3I6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IE9iamVjdC5rZXlzKG9wdGlvbmFsUHJvcHNHdWFyZCk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgY29uc3QgdmFsVHlwZSA9IHR5cGVvZiBwcm9wc1trZXldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJhc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gXCJzdHJpbmdcIiAmJiB2YWxUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgc3RyaW5nYCBvciBgb2JqZWN0YFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImxvY2FsZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYHN0cmluZ2BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJvbkNsaWNrXCIgfHwga2V5ID09PSBcIm9uTW91c2VFbnRlclwiIHx8IGtleSA9PT0gXCJvblRvdWNoU3RhcnRcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYGZ1bmN0aW9uYFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInJlcGxhY2VcIiB8fCBrZXkgPT09IFwic2Nyb2xsXCIgfHwga2V5ID09PSBcInNoYWxsb3dcIiB8fCBrZXkgPT09IFwicGFzc0hyZWZcIiB8fCBrZXkgPT09IFwicHJlZmV0Y2hcIiB8fCBrZXkgPT09IFwibGVnYWN5QmVoYXZpb3JcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICE9IG51bGwgJiYgdmFsVHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBib29sZWFuYFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBjb25zdCBoYXNXYXJuZWQgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuICAgICAgICBpZiAocHJvcHMucHJlZmV0Y2ggJiYgIWhhc1dhcm5lZC5jdXJyZW50ICYmICFpc0FwcFJvdXRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTmV4dC5qcyBhdXRvLXByZWZldGNoZXMgYXV0b21hdGljYWxseSBiYXNlZCBvbiB2aWV3cG9ydC4gVGhlIHByZWZldGNoIGF0dHJpYnV0ZSBpcyBubyBsb25nZXIgbmVlZGVkLiBNb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wcmVmZXRjaC10cnVlLWRlcHJlY2F0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoaXNBcHBSb3V0ZXIgJiYgIWFzUHJvcCkge1xuICAgICAgICAgICAgbGV0IGhyZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhyZWZQcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IGhyZWZQcm9wO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaHJlZlByb3AgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGhyZWZQcm9wLnBhdGhuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IGhyZWZQcm9wLnBhdGhuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNEeW5hbWljU2VnbWVudCA9IGhyZWYuc3BsaXQoXCIvXCIpLnNvbWUoKHNlZ21lbnQpPT5zZWdtZW50LnN0YXJ0c1dpdGgoXCJbXCIpICYmIHNlZ21lbnQuZW5kc1dpdGgoXCJdXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1NlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHluYW1pYyBocmVmIGBcIiArIGhyZWYgKyBcImAgZm91bmQgaW4gPExpbms+IHdoaWxlIHVzaW5nIHRoZSBgL2FwcGAgcm91dGVyLCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvYXBwLWRpci1keW5hbWljLWhyZWZcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgaHJlZiwgYXMgfSA9IF9yZWFjdC5kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgaWYgKCFwYWdlc1JvdXRlcikge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZm9ybWF0U3RyaW5nT3JVcmwoaHJlZlByb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICAgICAgYXM6IGFzUHJvcCA/IGZvcm1hdFN0cmluZ09yVXJsKGFzUHJvcCkgOiByZXNvbHZlZEhyZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShwYWdlc1JvdXRlciwgaHJlZlByb3AsIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgYXM6IGFzUHJvcCA/ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHBhZ2VzUm91dGVyLCBhc1Byb3ApIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHBhZ2VzUm91dGVyLFxuICAgICAgICBocmVmUHJvcCxcbiAgICAgICAgYXNQcm9wXG4gICAgXSk7XG4gICAgY29uc3QgcHJldmlvdXNIcmVmID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGhyZWYpO1xuICAgIGNvbnN0IHByZXZpb3VzQXMgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoYXMpO1xuICAgIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgIGxldCBjaGlsZDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgJyArIGhyZWZQcm9wICsgJ2AgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlRW50ZXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcIm9uTW91c2VFbnRlclwiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGAnICsgaHJlZlByb3AgKyAnYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25Nb3VzZUVudGVyIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgXCIgKyBocmVmUHJvcCArIFwiYCBidXQgb25lIGNoaWxkIGlzIHJlcXVpcmVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbm8tY2hpbGRyZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgXCIgKyBocmVmUHJvcCArIFwiYCBidXQgb25seSBvbmUgY2hpbGQgaXMgc3VwcG9ydGVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbXVsdGlwbGUtY2hpbGRyZW5cIiArICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgaWYgKChjaGlsZHJlbiA9PSBudWxsID8gdm9pZCAwIDogY2hpbGRyZW4udHlwZSkgPT09IFwiYVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCA8TGluaz4gd2l0aCA8YT4gY2hpbGQuIFBsZWFzZSByZW1vdmUgPGE+IG9yIHVzZSA8TGluayBsZWdhY3lCZWhhdmlvcj4uXFxuTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1uZXctbGluay13aXRoLWV4dHJhLWFuY2hvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGlsZFJlZiA9IGxlZ2FjeUJlaGF2aW9yID8gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiICYmIGNoaWxkLnJlZiA6IGZvcndhcmRlZFJlZjtcbiAgICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uUmVmLCBpc1Zpc2libGUsIHJlc2V0VmlzaWJsZV0gPSAoMCwgX3VzZWludGVyc2VjdGlvbi51c2VJbnRlcnNlY3Rpb24pKHtcbiAgICAgICAgcm9vdE1hcmdpbjogXCIyMDBweFwiXG4gICAgfSk7XG4gICAgY29uc3Qgc2V0UmVmID0gX3JlYWN0LmRlZmF1bHQudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICAvLyBCZWZvcmUgdGhlIGxpbmsgZ2V0dGluZyBvYnNlcnZlZCwgY2hlY2sgaWYgdmlzaWJsZSBzdGF0ZSBuZWVkIHRvIGJlIHJlc2V0XG4gICAgICAgIGlmIChwcmV2aW91c0FzLmN1cnJlbnQgIT09IGFzIHx8IHByZXZpb3VzSHJlZi5jdXJyZW50ICE9PSBocmVmKSB7XG4gICAgICAgICAgICByZXNldFZpc2libGUoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQXMuY3VycmVudCA9IGFzO1xuICAgICAgICAgICAgcHJldmlvdXNIcmVmLmN1cnJlbnQgPSBocmVmO1xuICAgICAgICB9XG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZihlbCk7XG4gICAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gXCJmdW5jdGlvblwiKSBjaGlsZFJlZihlbCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFJlZi5jdXJyZW50ID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBjaGlsZFJlZixcbiAgICAgICAgaHJlZixcbiAgICAgICAgcmVzZXRWaXNpYmxlLFxuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWZcbiAgICBdKTtcbiAgICAvLyBQcmVmZXRjaCB0aGUgVVJMIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBhbmQgaXQncyB2aXNpYmxlLlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBpbiBkZXYsIHdlIG9ubHkgcHJlZmV0Y2ggb24gaG92ZXIgdG8gYXZvaWQgd2FzdGluZyByZXNvdXJjZXMgYXMgdGhlIHByZWZldGNoIHdpbGwgdHJpZ2dlciBjb21waWxpbmcgdGhlIHBhZ2UuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgdG8gcHJlZmV0Y2ggdGhlIFVSTCwgZG9uJ3QgZG8gcHJlZmV0Y2guXG4gICAgICAgIGlmICghaXNWaXNpYmxlIHx8ICFwcmVmZXRjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVmZXRjaCB0aGUgVVJMLlxuICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2luZDogYXBwUHJlZmV0Y2hLaW5kXG4gICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBocmVmLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgcHJlZmV0Y2hFbmFibGVkLFxuICAgICAgICBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlLFxuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGlzQXBwUm91dGVyLFxuICAgICAgICBhcHBQcmVmZXRjaEtpbmRcbiAgICBdKTtcbiAgICBjb25zdCBjaGlsZFByb3BzID0ge1xuICAgICAgICByZWY6IHNldFJlZixcbiAgICAgICAgb25DbGljayAoZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCByZW5kZXJlZCBpbnNpZGUgbmV4dC9saW5rIGhhcyB0byBwYXNzIGNsaWNrIGV2ZW50IHRvIFwib25DbGlja1wiIHByb3AuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBpc0FwcFJvdXRlciwgcHJlZmV0Y2hFbmFibGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUVudGVyIChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXJQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXJQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghcHJlZmV0Y2hFbmFibGVkIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpICYmIGlzQXBwUm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvZGlzY3Vzc2lvbnMvNDAyNjg/c29ydD10b3AjZGlzY3Vzc2lvbmNvbW1lbnQtMzU3MjY0Mn1cbiAgICAgICAgICAgICAgICBieXBhc3NQcmVmZXRjaGVkQ2hlY2s6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcbiAgICAgICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0IChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvblRvdWNoU3RhcnRQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvblRvdWNoU3RhcnRQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vblRvdWNoU3RhcnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQgJiYgaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEBzZWUge2h0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9kaXNjdXNzaW9ucy80MDI2OD9zb3J0PXRvcCNkaXNjdXNzaW9uY29tbWVudC0zNTcyNjQyfVxuICAgICAgICAgICAgICAgIGJ5cGFzc1ByZWZldGNoZWRDaGVjazogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGFwcFByZWZldGNoS2luZFxuICAgICAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXIuXG4gICAgLy8gSWYgdGhlIHVybCBpcyBhYnNvbHV0ZSwgd2UgY2FuIGJ5cGFzcyB0aGUgbG9naWMgdG8gcHJlcGVuZCB0aGUgZG9tYWluIGFuZCBsb2NhbGUuXG4gICAgaWYgKCgwLCBfdXRpbHMuaXNBYnNvbHV0ZVVybCkoYXMpKSB7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFzO1xuICAgIH0gZWxzZSBpZiAoIWxlZ2FjeUJlaGF2aW9yIHx8IHBhc3NIcmVmIHx8IGNoaWxkLnR5cGUgPT09IFwiYVwiICYmICEoXCJocmVmXCIgaW4gY2hpbGQucHJvcHMpKSB7XG4gICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBsb2NhbGUgOiBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlO1xuICAgICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSAocGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmlzTG9jYWxlRG9tYWluKSAmJiAoMCwgX2dldGRvbWFpbmxvY2FsZS5nZXREb21haW5Mb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGVzLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuZG9tYWluTG9jYWxlcyk7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGxvY2FsZURvbWFpbiB8fCAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5kZWZhdWx0TG9jYWxlKSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgICAgICAuLi5yZXN0UHJvcHMsXG4gICAgICAgIC4uLmNoaWxkUHJvcHNcbiAgICB9LCBjaGlsZHJlbik7XG59KTtcbmNvbnN0IF9kZWZhdWx0ID0gTGluaztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsIl9yZXNvbHZlaHJlZiIsIl9pc2xvY2FsdXJsIiwiX2Zvcm1hdHVybCIsIl91dGlscyIsIl9hZGRsb2NhbGUiLCJfcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfdXNlaW50ZXJzZWN0aW9uIiwiX2dldGRvbWFpbmxvY2FsZSIsIl9hZGRiYXNlcGF0aCIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJwcmVmZXRjaGVkIiwiU2V0IiwicHJlZmV0Y2giLCJyb3V0ZXIiLCJocmVmIiwiYXMiLCJvcHRpb25zIiwiYXBwT3B0aW9ucyIsImlzQXBwUm91dGVyIiwiaXNMb2NhbFVSTCIsImJ5cGFzc1ByZWZldGNoZWRDaGVjayIsImxvY2FsZSIsInVuZGVmaW5lZCIsInByZWZldGNoZWRLZXkiLCJoYXMiLCJhZGQiLCJwcmVmZXRjaFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwiZXJyIiwicHJvY2VzcyIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiZXZlbnRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm5hdGl2ZUV2ZW50Iiwid2hpY2giLCJsaW5rQ2xpY2tlZCIsImUiLCJyZXBsYWNlIiwic2hhbGxvdyIsInNjcm9sbCIsInByZWZldGNoRW5hYmxlZCIsIm5vZGVOYW1lIiwiaXNBbmNob3JOb2RlTmFtZSIsInRvVXBwZXJDYXNlIiwicHJldmVudERlZmF1bHQiLCJuYXZpZ2F0ZSIsInJvdXRlclNjcm9sbCIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJkZWZhdWx0Iiwic3RhcnRUcmFuc2l0aW9uIiwiZm9ybWF0U3RyaW5nT3JVcmwiLCJ1cmxPYmpPclN0cmluZyIsImZvcm1hdFVybCIsIkxpbmsiLCJmb3J3YXJkUmVmIiwiTGlua0NvbXBvbmVudCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiY2hpbGRyZW4iLCJocmVmUHJvcCIsImFzUHJvcCIsImNoaWxkcmVuUHJvcCIsInByZWZldGNoUHJvcCIsInBhc3NIcmVmIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VFbnRlclByb3AiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoU3RhcnRQcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJyZXN0UHJvcHMiLCJjcmVhdGVFbGVtZW50IiwicGFnZXNSb3V0ZXIiLCJ1c2VDb250ZXh0IiwiUm91dGVyQ29udGV4dCIsImFwcFJvdXRlciIsIkFwcFJvdXRlckNvbnRleHQiLCJhcHBQcmVmZXRjaEtpbmQiLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiRlVMTCIsImNyZWF0ZVByb3BFcnJvciIsImFyZ3MiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsImtleXMiLCJmb3JFYWNoIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJwYXRobmFtZSIsImhhc0R5bmFtaWNTZWdtZW50Iiwic3BsaXQiLCJzb21lIiwic2VnbWVudCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInVzZU1lbW8iLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlZEFzIiwicmVzb2x2ZUhyZWYiLCJwcmV2aW91c0hyZWYiLCJwcmV2aW91c0FzIiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJ0eXBlIiwiY2hpbGRSZWYiLCJyZWYiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJyZXNldFZpc2libGUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290TWFyZ2luIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInVzZUVmZmVjdCIsImtpbmQiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInByaW9yaXR5IiwiaXNBYnNvbHV0ZVVybCIsImN1ckxvY2FsZSIsImxvY2FsZURvbWFpbiIsImlzTG9jYWxlRG9tYWluIiwiZ2V0RG9tYWluTG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJjbG9uZUVsZW1lbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    },\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1ELHNCQUFzQixPQUFPUSxTQUFTLGVBQWVBLEtBQUtSLG1CQUFtQixJQUFJUSxLQUFLUixtQkFBbUIsQ0FBQ1MsSUFBSSxDQUFDQyxXQUFXLFNBQVNDLEVBQUU7SUFDdkksSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDbkJKLEdBQUc7WUFDQ0ssWUFBWTtZQUNaQyxlQUFlO2dCQUNYLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBSTtZQUM5QztRQUNKO0lBQ0osR0FBRztBQUNQO0FBQ0EsTUFBTVgscUJBQXFCLE9BQU9PLFNBQVMsZUFBZUEsS0FBS1Asa0JBQWtCLElBQUlPLEtBQUtQLGtCQUFrQixDQUFDUSxJQUFJLENBQUNDLFdBQVcsU0FBU1UsRUFBRTtJQUNwSSxPQUFPQyxhQUFhRDtBQUN4QjtBQUVBLElBQUksQ0FBQyxPQUFPdkIsUUFBUXlCLE9BQU8sS0FBSyxjQUFlLE9BQU96QixRQUFReUIsT0FBTyxLQUFLLFlBQVl6QixRQUFReUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPekIsUUFBUXlCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks1QixPQUFPQyxjQUFjLENBQUNDLFFBQVF5QixPQUFPLEVBQUUsY0FBYztRQUFFeEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPNkIsTUFBTSxDQUFDM0IsUUFBUXlCLE9BQU8sRUFBRXpCO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVF5QixPQUFPO0FBQ2xDLEVBRUEsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcz8xZTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogbnVsbCxcbiAgICBjYW5jZWxJZGxlQ2FsbGJhY2s6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICAgIH0sXG4gICAgY2FuY2VsSWRsZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbmNlbElkbGVDYWxsYmFjaztcbiAgICB9XG59KTtcbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihjYikge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNlbGYuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioe1xuICAgICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIDEpO1xufTtcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1pZGxlLWNhbGxiYWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/resolve-href.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n}));\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\");\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsZUFBZUMsbUJBQU9BLENBQUMsbUlBQXdDO0FBQ3JFLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGlJQUF1QztBQUNsRSxNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQyxxSEFBaUM7QUFDdkQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsNkZBQXFCO0FBQzVDLE1BQU1JLDBCQUEwQkosbUJBQU9BLENBQUMsbUhBQTRCO0FBQ3BFLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLHFJQUF5QztBQUNyRSxNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQyxpSEFBNEI7QUFDcEQsTUFBTU8saUJBQWlCUCxtQkFBT0EsQ0FBQyx5SUFBMkM7QUFDMUUsU0FBU0YsWUFBWVUsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFNBQVM7SUFDeEMsNENBQTRDO0lBQzVDLElBQUlDO0lBQ0osSUFBSUMsY0FBYyxPQUFPSCxTQUFTLFdBQVdBLE9BQU8sQ0FBQyxHQUFHUixXQUFXWSxvQkFBb0IsRUFBRUo7SUFDekYsNkRBQTZEO0lBQzdELG1EQUFtRDtJQUNuRCxNQUFNSyxnQkFBZ0JGLFlBQVlHLEtBQUssQ0FBQztJQUN4QyxNQUFNQyxxQkFBcUJGLGdCQUFnQkYsWUFBWUssS0FBSyxDQUFDSCxhQUFhLENBQUMsRUFBRSxDQUFDSSxNQUFNLElBQUlOO0lBQ3hGLE1BQU1PLFdBQVdILG1CQUFtQkksS0FBSyxDQUFDO0lBQzFDLElBQUksQ0FBQ0QsUUFBUSxDQUFDLEVBQUUsSUFBSSxFQUFDLEVBQUdKLEtBQUssQ0FBQyxjQUFjO1FBQ3hDTSxRQUFRQyxLQUFLLENBQUMsbUJBQW1CVixjQUFjLHVDQUF1Q0osT0FBT2UsUUFBUSxHQUFHO1FBQ3hHLE1BQU1DLGdCQUFnQixDQUFDLEdBQUdyQixPQUFPc0Isd0JBQXdCLEVBQUVUO1FBQzNESixjQUFjLENBQUNFLGdCQUFnQkEsYUFBYSxDQUFDLEVBQUUsR0FBRyxFQUFDLElBQUtVO0lBQzVEO0lBQ0EsMkRBQTJEO0lBQzNELElBQUksQ0FBQyxDQUFDLEdBQUduQixZQUFZcUIsVUFBVSxFQUFFZCxjQUFjO1FBQzNDLE9BQU9GLFlBQVk7WUFDZkU7U0FDSCxHQUFHQTtJQUNSO0lBQ0EsSUFBSTtRQUNBRCxPQUFPLElBQUlnQixJQUFJZixZQUFZZ0IsVUFBVSxDQUFDLE9BQU9wQixPQUFPcUIsTUFBTSxHQUFHckIsT0FBT2UsUUFBUSxFQUFFO0lBQ2xGLEVBQUUsT0FBT08sR0FBRztRQUNSLGtEQUFrRDtRQUNsRG5CLE9BQU8sSUFBSWdCLElBQUksS0FBSztJQUN4QjtJQUNBLElBQUk7UUFDQSxNQUFNSSxXQUFXLElBQUlKLElBQUlmLGFBQWFEO1FBQ3RDb0IsU0FBU1IsUUFBUSxHQUFHLENBQUMsR0FBR25CLHdCQUF3QjRCLDBCQUEwQixFQUFFRCxTQUFTUixRQUFRO1FBQzdGLElBQUlVLGlCQUFpQjtRQUNyQixJQUFJLENBQUMsR0FBRzNCLFFBQVE0QixjQUFjLEVBQUVILFNBQVNSLFFBQVEsS0FBS1EsU0FBU0ksWUFBWSxJQUFJekIsV0FBVztZQUN0RixNQUFNMEIsUUFBUSxDQUFDLEdBQUdyQyxhQUFhc0Msc0JBQXNCLEVBQUVOLFNBQVNJLFlBQVk7WUFDNUUsTUFBTSxFQUFFRyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBR2hDLGVBQWVpQyxhQUFhLEVBQUVULFNBQVNSLFFBQVEsRUFBRVEsU0FBU1IsUUFBUSxFQUFFYTtZQUNuRyxJQUFJRSxRQUFRO2dCQUNSTCxpQkFBaUIsQ0FBQyxHQUFHaEMsV0FBV1ksb0JBQW9CLEVBQUU7b0JBQ2xEVSxVQUFVZTtvQkFDVkcsTUFBTVYsU0FBU1UsSUFBSTtvQkFDbkJMLE9BQU8sQ0FBQyxHQUFHbEMsTUFBTXdDLElBQUksRUFBRU4sT0FBT0c7Z0JBQ2xDO1lBQ0o7UUFDSjtRQUNBLG9FQUFvRTtRQUNwRSxNQUFNSSxlQUFlWixTQUFTYSxNQUFNLEtBQUtqQyxLQUFLaUMsTUFBTSxHQUFHYixTQUFTdEIsSUFBSSxDQUFDUSxLQUFLLENBQUNjLFNBQVNhLE1BQU0sQ0FBQzFCLE1BQU0sSUFBSWEsU0FBU3RCLElBQUk7UUFDbEgsT0FBT0MsWUFBWTtZQUNmaUM7WUFDQVYsa0JBQWtCVTtTQUNyQixHQUFHQTtJQUNSLEVBQUUsT0FBT2IsR0FBRztRQUNSLE9BQU9wQixZQUFZO1lBQ2ZFO1NBQ0gsR0FBR0E7SUFDUjtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9sQixRQUFRbUQsT0FBTyxLQUFLLGNBQWUsT0FBT25ELFFBQVFtRCxPQUFPLEtBQUssWUFBWW5ELFFBQVFtRCxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9uRCxRQUFRbUQsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3RELE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW1ELE9BQU8sRUFBRSxjQUFjO1FBQUVsRCxPQUFPO0lBQUs7SUFDbkVILE9BQU91RCxNQUFNLENBQUNyRCxRQUFRbUQsT0FBTyxFQUFFbkQ7SUFDL0JzRCxPQUFPdEQsT0FBTyxHQUFHQSxRQUFRbUQsT0FBTztBQUNsQyxFQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXNvbHZlLWhyZWYuanM/MmY5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVIcmVmXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlSHJlZjtcbiAgICB9XG59KTtcbmNvbnN0IF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZ1wiKTtcbmNvbnN0IF9mb3JtYXR1cmwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybFwiKTtcbmNvbnN0IF9vbWl0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL29taXRcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbmNvbnN0IF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsXCIpO1xuY29uc3QgX3V0aWxzMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlsc1wiKTtcbmNvbnN0IF9pbnRlcnBvbGF0ZWFzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVycG9sYXRlLWFzXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZUhyZWYocm91dGVyLCBocmVmLCByZXNvbHZlQXMpIHtcbiAgICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICAgIGxldCBiYXNlO1xuICAgIGxldCB1cmxBc1N0cmluZyA9IHR5cGVvZiBocmVmID09PSBcInN0cmluZ1wiID8gaHJlZiA6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShocmVmKTtcbiAgICAvLyByZXBlYXRlZCBzbGFzaGVzIGFuZCBiYWNrc2xhc2hlcyBpbiB0aGUgVVJMIGFyZSBjb25zaWRlcmVkXG4gICAgLy8gaW52YWxpZCBhbmQgd2lsbCBuZXZlciBtYXRjaCBhIE5leHQuanMgcGFnZS9maWxlXG4gICAgY29uc3QgdXJsUHJvdG9NYXRjaCA9IHVybEFzU3RyaW5nLm1hdGNoKC9eW2EtekEtWl17MSx9OlxcL1xcLy8pO1xuICAgIGNvbnN0IHVybEFzU3RyaW5nTm9Qcm90byA9IHVybFByb3RvTWF0Y2ggPyB1cmxBc1N0cmluZy5zbGljZSh1cmxQcm90b01hdGNoWzBdLmxlbmd0aCkgOiB1cmxBc1N0cmluZztcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybEFzU3RyaW5nTm9Qcm90by5zcGxpdChcIj9cIik7XG4gICAgaWYgKCh1cmxQYXJ0c1swXSB8fCBcIlwiKS5tYXRjaCgvKFxcL1xcL3xcXFxcKS8pKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGhyZWYgJ1wiICsgdXJsQXNTdHJpbmcgKyBcIicgcGFzc2VkIHRvIG5leHQvcm91dGVyIGluIHBhZ2U6ICdcIiArIHJvdXRlci5wYXRobmFtZSArIFwiJy4gUmVwZWF0ZWQgZm9yd2FyZC1zbGFzaGVzICgvLykgb3IgYmFja3NsYXNoZXMgXFxcXCBhcmUgbm90IHZhbGlkIGluIHRoZSBocmVmLlwiKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFVybCA9ICgwLCBfdXRpbHMubm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKSh1cmxBc1N0cmluZ05vUHJvdG8pO1xuICAgICAgICB1cmxBc1N0cmluZyA9ICh1cmxQcm90b01hdGNoID8gdXJsUHJvdG9NYXRjaFswXSA6IFwiXCIpICsgbm9ybWFsaXplZFVybDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGJlY2F1c2UgaXQgY2Fubm90IGJlIHJvdXRlZCBieSB0aGUgTmV4dC5qcyByb3V0ZXJcbiAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKSh1cmxBc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHVybEFzU3RyaW5nXG4gICAgICAgIF0gOiB1cmxBc1N0cmluZztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYmFzZSA9IG5ldyBVUkwodXJsQXNTdHJpbmcuc3RhcnRzV2l0aChcIiNcIikgPyByb3V0ZXIuYXNQYXRoIDogcm91dGVyLnBhdGhuYW1lLCBcImh0dHA6Ly9uXCIpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gLyBmb3IgaW52YWxpZCBhc1BhdGggdmFsdWVzIGUuZy4gLy9cbiAgICAgICAgYmFzZSA9IG5ldyBVUkwoXCIvXCIsIFwiaHR0cDovL25cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSk7XG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKShmaW5hbFVybC5wYXRobmFtZSk7XG4gICAgICAgIGxldCBpbnRlcnBvbGF0ZWRBcyA9IFwiXCI7XG4gICAgICAgIGlmICgoMCwgX3V0aWxzMS5pc0R5bmFtaWNSb3V0ZSkoZmluYWxVcmwucGF0aG5hbWUpICYmIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJiByZXNvbHZlQXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gKDAsIF9xdWVyeXN0cmluZy5zZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KShmaW5hbFVybC5zZWFyY2hQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQsIHBhcmFtcyB9ID0gKDAsIF9pbnRlcnBvbGF0ZWFzLmludGVycG9sYXRlQXMpKGZpbmFsVXJsLnBhdGhuYW1lLCBmaW5hbFVybC5wYXRobmFtZSwgcXVlcnkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZEFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6ICgwLCBfb21pdC5vbWl0KShxdWVyeSwgcGFyYW1zKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXG4gICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW4gPyBmaW5hbFVybC5ocmVmLnNsaWNlKGZpbmFsVXJsLm9yaWdpbi5sZW5ndGgpIDogZmluYWxVcmwuaHJlZjtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgIGludGVycG9sYXRlZEFzIHx8IHJlc29sdmVkSHJlZlxuICAgICAgICBdIDogcmVzb2x2ZWRIcmVmO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHVybEFzU3RyaW5nXG4gICAgICAgIF0gOiB1cmxBc1N0cmluZztcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUtaHJlZi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwicmVzb2x2ZUhyZWYiLCJfcXVlcnlzdHJpbmciLCJyZXF1aXJlIiwiX2Zvcm1hdHVybCIsIl9vbWl0IiwiX3V0aWxzIiwiX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2giLCJfaXNsb2NhbHVybCIsIl91dGlsczEiLCJfaW50ZXJwb2xhdGVhcyIsInJvdXRlciIsImhyZWYiLCJyZXNvbHZlQXMiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybFByb3RvTWF0Y2giLCJtYXRjaCIsInVybEFzU3RyaW5nTm9Qcm90byIsInNsaWNlIiwibGVuZ3RoIiwidXJsUGFydHMiLCJzcGxpdCIsImNvbnNvbGUiLCJlcnJvciIsInBhdGhuYW1lIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImlzTG9jYWxVUkwiLCJVUkwiLCJzdGFydHNXaXRoIiwiYXNQYXRoIiwiXyIsImZpbmFsVXJsIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJpbnRlcnBvbGF0ZWRBcyIsImlzRHluYW1pY1JvdXRlIiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwicmVzdWx0IiwicGFyYW1zIiwiaW50ZXJwb2xhdGVBcyIsImhhc2giLCJvbWl0IiwicmVzb2x2ZWRIcmVmIiwib3JpZ2luIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQzlCLE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsNkdBQXlCO0FBQzlELE1BQU1FLDBCQUEwQixPQUFPQyx5QkFBeUI7QUFDaEUsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixNQUFNQyxTQUFTLEVBQUU7QUFDakIsU0FBU0MsZUFBZUMsT0FBTztJQUMzQixNQUFNQyxLQUFLO1FBQ1BDLE1BQU1GLFFBQVFFLElBQUksSUFBSTtRQUN0QkMsUUFBUUgsUUFBUUksVUFBVSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsV0FBV1AsT0FBT1EsSUFBSSxDQUFDLENBQUNDLE1BQU1BLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07SUFDcEYsSUFBSUs7SUFDSixJQUFJSCxVQUFVO1FBQ1ZHLFdBQVdaLFVBQVVQLEdBQUcsQ0FBQ2dCO1FBQ3pCLElBQUlHLFVBQVU7WUFDVixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxNQUFNQyxXQUFXLElBQUlaO0lBQ3JCLE1BQU1hLFdBQVcsSUFBSWYscUJBQXFCLENBQUNnQjtRQUN2Q0EsUUFBUUMsT0FBTyxDQUFDLENBQUNDO1lBQ2IsTUFBTUMsV0FBV0wsU0FBU3BCLEdBQUcsQ0FBQ3dCLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN2QkYsU0FBU0U7WUFDYjtRQUNKO0lBQ0osR0FBR2hCO0lBQ0hRLFdBQVc7UUFDUFA7UUFDQVM7UUFDQUQ7SUFDSjtJQUNBWCxPQUFPcUIsSUFBSSxDQUFDbEI7SUFDWkwsVUFBVXdCLEdBQUcsQ0FBQ25CLElBQUlPO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTYSxRQUFRQyxPQUFPLEVBQUVSLFFBQVEsRUFBRWQsT0FBTztJQUN2QyxNQUFNLEVBQUVDLEVBQUUsRUFBRVMsUUFBUSxFQUFFRCxRQUFRLEVBQUUsR0FBR1YsZUFBZUM7SUFDbERTLFNBQVNXLEdBQUcsQ0FBQ0UsU0FBU1I7SUFDdEJKLFNBQVNXLE9BQU8sQ0FBQ0M7SUFDakIsT0FBTyxTQUFTQztRQUNaZCxTQUFTZSxNQUFNLENBQUNGO1FBQ2hCWixTQUFTYSxTQUFTLENBQUNEO1FBQ25CLHVEQUF1RDtRQUN2RCxJQUFJYixTQUFTZ0IsSUFBSSxLQUFLLEdBQUc7WUFDckJmLFNBQVNnQixVQUFVO1lBQ25COUIsVUFBVTRCLE1BQU0sQ0FBQ3ZCO1lBQ2pCLE1BQU0wQixRQUFRN0IsT0FBTzhCLFNBQVMsQ0FBQyxDQUFDckIsTUFBTUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtZQUN0RixJQUFJd0IsUUFBUSxDQUFDLEdBQUc7Z0JBQ1o3QixPQUFPK0IsTUFBTSxDQUFDRixPQUFPO1lBQ3pCO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBU3JDLGdCQUFnQndDLEtBQUs7SUFDMUIsSUFBSSxFQUFFQyxPQUFPLEVBQUUzQixVQUFVLEVBQUU0QixRQUFRLEVBQUUsR0FBR0Y7SUFDeEMsTUFBTUcsYUFBYUQsWUFBWSxDQUFDdEM7SUFDaEMsTUFBTSxDQUFDd0MsU0FBU0MsV0FBVyxHQUFHLENBQUMsR0FBRzVDLE9BQU82QyxRQUFRLEVBQUU7SUFDbkQsTUFBTUMsYUFBYSxDQUFDLEdBQUc5QyxPQUFPK0MsTUFBTSxFQUFFO0lBQ3RDLE1BQU1DLGFBQWEsQ0FBQyxHQUFHaEQsT0FBT2lELFdBQVcsRUFBRSxDQUFDbEI7UUFDeENlLFdBQVdJLE9BQU8sR0FBR25CO0lBQ3pCLEdBQUcsRUFBRTtJQUNKLElBQUcvQixPQUFPbUQsU0FBUyxFQUFFO1FBQ2xCLElBQUloRCx5QkFBeUI7WUFDekIsSUFBSXVDLGNBQWNDLFNBQVM7WUFDM0IsTUFBTVosVUFBVWUsV0FBV0ksT0FBTztZQUNsQyxJQUFJbkIsV0FBV0EsUUFBUXFCLE9BQU8sRUFBRTtnQkFDNUIsTUFBTXBCLFlBQVlGLFFBQVFDLFNBQVMsQ0FBQ04sWUFBWUEsYUFBYW1CLFdBQVduQixZQUFZO29CQUNoRmQsTUFBTTZCLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFVLE9BQU87b0JBQ2hEckM7Z0JBQ0o7Z0JBQ0EsT0FBT21CO1lBQ1g7UUFDSixPQUFPO1lBQ0gsSUFBSSxDQUFDVyxTQUFTO2dCQUNWLE1BQU1VLGVBQWUsQ0FBQyxHQUFHbkQscUJBQXFCb0QsbUJBQW1CLEVBQUUsSUFBSVYsV0FBVztnQkFDbEYsT0FBTyxJQUFJLENBQUMsR0FBRzFDLHFCQUFxQnFELGtCQUFrQixFQUFFRjtZQUM1RDtRQUNKO0lBQ0osdURBQXVEO0lBQ3ZELEdBQUc7UUFDQ1g7UUFDQTdCO1FBQ0EyQjtRQUNBRztRQUNBRyxXQUFXSSxPQUFPO0tBQ3JCO0lBQ0QsTUFBTU0sZUFBZSxDQUFDLEdBQUd4RCxPQUFPaUQsV0FBVyxFQUFFO1FBQ3pDTCxXQUFXO0lBQ2YsR0FBRyxFQUFFO0lBQ0wsT0FBTztRQUNISTtRQUNBTDtRQUNBYTtLQUNIO0FBQ0w7QUFFQSxJQUFJLENBQUMsT0FBTzdELFFBQVE4RCxPQUFPLEtBQUssY0FBZSxPQUFPOUQsUUFBUThELE9BQU8sS0FBSyxZQUFZOUQsUUFBUThELE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzlELFFBQVE4RCxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakUsT0FBT0MsY0FBYyxDQUFDQyxRQUFROEQsT0FBTyxFQUFFLGNBQWM7UUFBRTdELE9BQU87SUFBSztJQUNuRUgsT0FBT2tFLE1BQU0sQ0FBQ2hFLFFBQVE4RCxPQUFPLEVBQUU5RDtJQUMvQmlFLE9BQU9qRSxPQUFPLEdBQUdBLFFBQVE4RCxPQUFPO0FBQ2xDLEVBRUEsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZUludGVyc2VjdGlvblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlSW50ZXJzZWN0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgX3JlcXVlc3RpZGxlY2FsbGJhY2sgPSByZXF1aXJlKFwiLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2tcIik7XG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuY29uc3QgaWRMaXN0ID0gW107XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB7XG4gICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuICAgICAgICBtYXJnaW46IG9wdGlvbnMucm9vdE1hcmdpbiB8fCBcIlwiXG4gICAgfTtcbiAgICBjb25zdCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpPT57XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGluc3RhbmNlID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgICBpZExpc3QucHVzaChpZCk7XG4gICAgb2JzZXJ2ZXJzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkLCBvYnNlcnZlciwgZWxlbWVudHMgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGlkTGlzdC5maW5kSW5kZXgoKG9iaik9Pm9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpbik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbihwYXJhbSkge1xuICAgIGxldCB7IHJvb3RSZWYsIHJvb3RNYXJnaW4sIGRpc2FibGVkIH0gPSBwYXJhbTtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBlbGVtZW50UmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG51bGwpO1xuICAgIGNvbnN0IHNldEVsZW1lbnQgPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKSgoZWxlbWVudCk9PntcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICB9LCBbXSk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVub2JzZXJ2ZSA9IG9ic2VydmUoZWxlbWVudCwgKGlzVmlzaWJsZSk9PmlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdFJlZiA9PSBudWxsID8gdm9pZCAwIDogcm9vdFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVub2JzZXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdGlkbGVjYWxsYmFjay5yZXF1ZXN0SWRsZUNhbGxiYWNrKSgoKT0+c2V0VmlzaWJsZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2suY2FuY2VsSWRsZUNhbGxiYWNrKShpZGxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgcm9vdFJlZixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50XG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldEVsZW1lbnQsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIHJlc2V0VmlzaWJsZVxuICAgIF07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pbnRlcnNlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInVzZUludGVyc2VjdGlvbiIsIl9yZWFjdCIsInJlcXVpcmUiLCJfcmVxdWVzdGlkbGVjYWxsYmFjayIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJNYXAiLCJpZExpc3QiLCJjcmVhdGVPYnNlcnZlciIsIm9wdGlvbnMiLCJpZCIsInJvb3QiLCJtYXJnaW4iLCJyb290TWFyZ2luIiwiZXhpc3RpbmciLCJmaW5kIiwib2JqIiwiaW5zdGFuY2UiLCJlbGVtZW50cyIsIm9ic2VydmVyIiwiZW50cmllcyIsImZvckVhY2giLCJlbnRyeSIsImNhbGxiYWNrIiwidGFyZ2V0IiwiaXNWaXNpYmxlIiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsInB1c2giLCJzZXQiLCJvYnNlcnZlIiwiZWxlbWVudCIsInVub2JzZXJ2ZSIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0IiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwYXJhbSIsInJvb3RSZWYiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwiZWxlbWVudFJlZiIsInVzZVJlZiIsInNldEVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJ0YWdOYW1lIiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function() {\n        return escapeStringRegexp;\n    }\n}));\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTtBQUM3RDtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxrQkFBa0I7QUFDeEIsU0FBU0YsbUJBQW1CRyxHQUFHO0lBQzNCLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDdkIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDeEM7SUFDQSxPQUFPQztBQUNYLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzP2RiZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVnZXhwIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZXNjYXBlLXN0cmluZy1yZWdleHBcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlU3RyaW5nUmVnZXhwXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVTdHJpbmdSZWdleHA7XG4gICAgfVxufSk7XG5jb25zdCByZUhhc1JlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dLztcbmNvbnN0IHJlUmVwbGFjZVJlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2c7XG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyKSB7XG4gICAgLy8gc2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvMmRhMDI0YzNiNGY5OTQ3YTQ4NTE3NjM5ZGU3NTYwNDU3Y2Q0ZWM2Yy9lc2NhcGVSZWdFeHAuanMjTDIzXG4gICAgaWYgKHJlSGFzUmVnRXhwLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVSZXBsYWNlUmVnRXhwLCBcIlxcXFwkJlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLXJlZ2V4cC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZXNjYXBlU3RyaW5nUmVnZXhwIiwicmVIYXNSZWdFeHAiLCJyZVJlcGxhY2VSZWdFeHAiLCJzdHIiLCJ0ZXN0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzVDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixnQkFBZ0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDO0FBQ25ELElBQUlDLElBQXFDLEVBQUU7SUFDdkNQLGNBQWNRLFdBQVcsR0FBRztBQUNoQyxFQUVBLHlEQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanM/OGZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvdXRlckNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlckNvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgUm91dGVyQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVyQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUm91dGVyQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfIiwiZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUM1QjtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLDRCQUE0QkMsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1DLGVBQWUsV0FBVyxHQUFHRiwwQkFBMEJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsMEdBQWU7QUFDdEYsTUFBTUcsbUJBQW1CO0FBQ3pCLFNBQVNiLFVBQVVjLE1BQU07SUFDckIsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBTztJQUNYTixPQUFPQSxPQUFPTyxtQkFBbUJQLE1BQU1RLE9BQU8sQ0FBQyxRQUFRLE9BQU8sTUFBTTtJQUNwRSxJQUFJVCxPQUFPTyxJQUFJLEVBQUU7UUFDYkEsT0FBT04sT0FBT0QsT0FBT08sSUFBSTtJQUM3QixPQUFPLElBQUlMLFVBQVU7UUFDakJLLE9BQU9OLE9BQVEsRUFBQ0MsU0FBU1EsT0FBTyxDQUFDLE9BQU8sTUFBTVIsV0FBVyxNQUFNQSxRQUFPO1FBQ3RFLElBQUlGLE9BQU9XLElBQUksRUFBRTtZQUNiSixRQUFRLE1BQU1QLE9BQU9XLElBQUk7UUFDN0I7SUFDSjtJQUNBLElBQUlMLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3BDQSxRQUFRTSxPQUFPZixhQUFhZ0Isc0JBQXNCLENBQUNQO0lBQ3ZEO0lBQ0EsSUFBSVEsU0FBU2QsT0FBT2MsTUFBTSxJQUFJUixTQUFTLE1BQU1BLFNBQVM7SUFDdEQsSUFBSUgsWUFBWSxDQUFDQSxTQUFTWSxRQUFRLENBQUMsTUFBTVosWUFBWTtJQUNyRCxJQUFJSCxPQUFPZ0IsT0FBTyxJQUFJLENBQUMsQ0FBQ2IsWUFBWUosaUJBQWlCa0IsSUFBSSxDQUFDZCxTQUFRLEtBQU1JLFNBQVMsT0FBTztRQUNwRkEsT0FBTyxPQUFRQSxDQUFBQSxRQUFRLEVBQUM7UUFDeEIsSUFBSUgsWUFBWUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxXQUFXLE1BQU1BO0lBQzFELE9BQU8sSUFBSSxDQUFDRyxNQUFNO1FBQ2RBLE9BQU87SUFDWDtJQUNBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJUyxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFDaERWLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ00sU0FBU0EsT0FBT0wsT0FBTyxDQUFDLEtBQUs7SUFDN0IsT0FBTyxLQUFLTixXQUFXSSxPQUFPSCxXQUFXVSxTQUFTVDtBQUN0RDtBQUNBLE1BQU1sQixnQkFBZ0I7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxTQUFTQyxxQkFBcUI4QixHQUFHO0lBQzdCLElBQUlDLElBQXNDLEVBQUU7UUFDeEMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUN6Q3JDLE9BQU91QyxJQUFJLENBQUNGLEtBQUtHLE9BQU8sQ0FBQyxDQUFDQztnQkFDdEIsSUFBSSxDQUFDbkMsY0FBY29DLFFBQVEsQ0FBQ0QsTUFBTTtvQkFDOUJFLFFBQVFDLElBQUksQ0FBQyx1REFBdURIO2dCQUN4RTtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU9wQyxVQUFVZ0M7QUFDckIsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLmpzPzdiNTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0VXJsOiBudWxsLFxuICAgIHVybE9iamVjdEtleXM6IG51bGwsXG4gICAgZm9ybWF0V2l0aFZhbGlkYXRpb246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZm9ybWF0VXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFVybDtcbiAgICB9LFxuICAgIHVybE9iamVjdEtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXJsT2JqZWN0S2V5cztcbiAgICB9LFxuICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFdpdGhWYWxpZGF0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4vcXVlcnlzdHJpbmdcIikpO1xuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztcbmZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmopIHtcbiAgICBsZXQgeyBhdXRoLCBob3N0bmFtZSB9ID0gdXJsT2JqO1xuICAgIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCBcIlwiO1xuICAgIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCBcIlwiO1xuICAgIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgXCJcIjtcbiAgICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgXCJcIjtcbiAgICBsZXQgaG9zdCA9IGZhbHNlO1xuICAgIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCBcIjpcIikgKyBcIkBcIiA6IFwiXCI7XG4gICAgaWYgKHVybE9iai5ob3N0KSB7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3Q7XG4gICAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgICAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPyBcIltcIiArIGhvc3RuYW1lICsgXCJdXCIgOiBob3N0bmFtZSk7XG4gICAgICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgICAgICAgaG9zdCArPSBcIjpcIiArIHVybE9iai5wb3J0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcXVlcnkgPSBTdHJpbmcoX3F1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkpKTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgcXVlcnkgJiYgXCI/XCIgKyBxdWVyeSB8fCBcIlwiO1xuICAgIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpKSBwcm90b2NvbCArPSBcIjpcIjtcbiAgICBpZiAodXJsT2JqLnNsYXNoZXMgfHwgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgICAgICBob3N0ID0gXCIvL1wiICsgKGhvc3QgfHwgXCJcIik7XG4gICAgICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gXCIvXCIpIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgIGhvc3QgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSBcIiNcIikgaGFzaCA9IFwiI1wiICsgaGFzaDtcbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gXCI/XCIpIHNlYXJjaCA9IFwiP1wiICsgc2VhcmNoO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBlbmNvZGVVUklDb21wb25lbnQpO1xuICAgIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKFwiI1wiLCBcIiUyM1wiKTtcbiAgICByZXR1cm4gXCJcIiArIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn1cbmNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICAgXCJhdXRoXCIsXG4gICAgXCJoYXNoXCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJob3N0bmFtZVwiLFxuICAgIFwiaHJlZlwiLFxuICAgIFwicGF0aFwiLFxuICAgIFwicGF0aG5hbWVcIixcbiAgICBcInBvcnRcIixcbiAgICBcInByb3RvY29sXCIsXG4gICAgXCJxdWVyeVwiLFxuICAgIFwic2VhcmNoXCIsXG4gICAgXCJzbGFzaGVzXCJcbl07XG5mdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGlmICghdXJsT2JqZWN0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRVcmwodXJsKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJmb3JtYXRVcmwiLCJ1cmxPYmplY3RLZXlzIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9xdWVyeXN0cmluZyIsIl8iLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJxdWVyeSIsImhvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiaW5kZXhPZiIsInBvcnQiLCJTdHJpbmciLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiZW5kc1dpdGgiLCJzbGFzaGVzIiwidGVzdCIsInVybCIsInByb2Nlc3MiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nconst _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nconst _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGlCQUFpQjtRQUNiLE9BQU9RLGNBQWNSLGVBQWU7SUFDeEM7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT1EsV0FBV1IsY0FBYztJQUNwQztBQUNKO0FBQ0EsTUFBTU8sZ0JBQWdCRSxtQkFBT0EsQ0FBQyw4R0FBaUI7QUFDL0MsTUFBTUQsYUFBYUMsbUJBQU9BLENBQUMsd0dBQWMsR0FFekMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanM/ZjUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFNvcnRlZFJvdXRlczogbnVsbCxcbiAgICBpc0R5bmFtaWNSb3V0ZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRTb3J0ZWRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NvcnRlZHJvdXRlcy5nZXRTb3J0ZWRSb3V0ZXM7XG4gICAgfSxcbiAgICBpc0R5bmFtaWNSb3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlO1xuICAgIH1cbn0pO1xuY29uc3QgX3NvcnRlZHJvdXRlcyA9IHJlcXVpcmUoXCIuL3NvcnRlZC1yb3V0ZXNcIik7XG5jb25zdCBfaXNkeW5hbWljID0gcmVxdWlyZShcIi4vaXMtZHluYW1pY1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0U29ydGVkUm91dGVzIiwiaXNEeW5hbWljUm91dGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfc29ydGVkcm91dGVzIiwiX2lzZHluYW1pYyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n}));\nconst _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM1Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsOEdBQWlCO0FBQy9DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDBHQUFlO0FBQzNDLFNBQVNGLGNBQWNJLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxLQUFLO0lBQzNDLElBQUlDLG9CQUFvQjtJQUN4QixNQUFNQyxlQUFlLENBQUMsR0FBR0wsWUFBWU0sYUFBYSxFQUFFTDtJQUNwRCxNQUFNTSxnQkFBZ0JGLGFBQWFHLE1BQU07SUFDekMsTUFBTUMsaUJBQ04sQ0FBQ1AsZUFBZUQsUUFBUSxDQUFDLEdBQUdILGNBQWNZLGVBQWUsRUFBRUwsY0FBY0gsY0FBYyxFQUFDLEtBQU0sZ0RBQWdEO0lBQzlJLHNFQUFzRTtJQUN0RUM7SUFDQUMsb0JBQW9CSDtJQUNwQixNQUFNVSxTQUFTcEIsT0FBT3FCLElBQUksQ0FBQ0w7SUFDM0IsSUFBSSxDQUFDSSxPQUFPRSxLQUFLLENBQUMsQ0FBQ0M7UUFDZixJQUFJcEIsUUFBUWUsY0FBYyxDQUFDSyxNQUFNLElBQUk7UUFDckMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHVCxhQUFhLENBQUNPLE1BQU07UUFDakQsaUNBQWlDO1FBQ2pDLDBEQUEwRDtRQUMxRCxJQUFJRyxXQUFXLE1BQU9GLENBQUFBLFNBQVMsUUFBUSxFQUFDLElBQUtELFFBQVE7UUFDckQsSUFBSUUsVUFBVTtZQUNWQyxXQUFXLENBQUMsQ0FBQ3ZCLFFBQVEsTUFBTSxFQUFDLElBQUssTUFBTXVCLFdBQVc7UUFDdEQ7UUFDQSxJQUFJRixVQUFVLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ3pCLFFBQVFBLFFBQVE7WUFDekNBO1NBQ0g7UUFDRCxPQUFPLENBQUNzQixZQUFZRixTQUFTTCxjQUFhLEtBQU0sNkNBQTZDO1FBQzVGTCxDQUFBQSxvQkFBb0JBLGtCQUFrQmdCLE9BQU8sQ0FBQ0gsVUFBVUYsU0FBU3JCLE1BQU0yQixHQUFHLENBQzNFLHVEQUF1RDtRQUN2RCxrREFBa0Q7UUFDbEQsb0NBQW9DO1FBQ3BDLENBQUNDLFVBQVVDLG1CQUFtQkQsVUFBVUUsSUFBSSxDQUFDLE9BQU9ELG1CQUFtQjdCLFdBQVcsR0FBRTtJQUN4RixJQUFJO1FBQ0FVLG9CQUFvQixHQUFHLG1DQUFtQzs7SUFFOUQsdUVBQXVFO0lBQ3ZFLGtEQUFrRDtJQUNsRDtJQUNBLE9BQU87UUFDSE87UUFDQWMsUUFBUXJCO0lBQ1o7QUFDSixFQUVBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVycG9sYXRlLWFzLmpzP2QwZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlcnBvbGF0ZUFzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUFzO1xuICAgIH1cbn0pO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3JvdXRlLXJlZ2V4XCIpO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIHtcbiAgICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiO1xuICAgIGNvbnN0IGR5bmFtaWNSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHM7XG4gICAgY29uc3QgZHluYW1pY01hdGNoZXMgPSAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogXCJcIikgfHwgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5O1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gcm91dGU7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3Vwcyk7XG4gICAgaWYgKCFwYXJhbXMuZXZlcnkoKHBhcmFtKT0+e1xuICAgICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgXCJcIjtcbiAgICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXTtcbiAgICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gXCJbXCIgKyAocmVwZWF0ID8gXCIuLi5cIiA6IFwiXCIpICsgcGFyYW0gKyBcIl1cIjtcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXBsYWNlZCA9ICghdmFsdWUgPyBcIi9cIiA6IFwiXCIpICsgXCJbXCIgKyByZXBsYWNlZCArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPSBpbnRlcnBvbGF0ZWRSb3V0ZS5yZXBsYWNlKHJlcGxhY2VkLCByZXBlYXQgPyB2YWx1ZS5tYXAoLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAoc2VnbWVudCk9PmVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KSkuam9pbihcIi9cIikgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSB8fCBcIi9cIik7XG4gICAgfSkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4gICAgICAgIDtcbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVycG9sYXRlLWFzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpbnRlcnBvbGF0ZUFzIiwiX3JvdXRlbWF0Y2hlciIsInJlcXVpcmUiLCJfcm91dGVyZWdleCIsInJvdXRlIiwiYXNQYXRobmFtZSIsInF1ZXJ5IiwiaW50ZXJwb2xhdGVkUm91dGUiLCJkeW5hbWljUmVnZXgiLCJnZXRSb3V0ZVJlZ2V4IiwiZHluYW1pY0dyb3VwcyIsImdyb3VwcyIsImR5bmFtaWNNYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwicGFyYW1zIiwia2V5cyIsImV2ZXJ5IiwicGFyYW0iLCJyZXBlYXQiLCJvcHRpb25hbCIsInJlcGxhY2VkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVwbGFjZSIsIm1hcCIsInNlZ21lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwicmVzdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Identify /[param]/ in route string\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return isDynamicRoute;\n    }\n}));\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQ0FBcUM7QUFDeEI7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGtEQUFpRDtJQUM3Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGFBQWE7QUFDbkIsU0FBU0QsZUFBZUUsS0FBSztJQUN6QixPQUFPRCxXQUFXRSxJQUFJLENBQUNEO0FBQzNCLEVBRUEsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcz80NmY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIElkZW50aWZ5IC9bcGFyYW1dLyBpbiByb3V0ZSBzdHJpbmdcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNEeW5hbWljUm91dGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzRHluYW1pY1JvdXRlO1xuICAgIH1cbn0pO1xuY29uc3QgVEVTVF9ST1VURSA9IC9cXC9cXFtbXi9dKz9cXF0oPz1cXC98JCkvO1xuZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGUpIHtcbiAgICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZHluYW1pYy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaXNEeW5hbWljUm91dGUiLCJURVNUX1JPVVRFIiwicm91dGUiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCw4Q0FBNkM7SUFDekNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxxRkFBYTtBQUNwQyxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyw4R0FBa0M7QUFDL0QsU0FBU0YsV0FBV0ksR0FBRztJQUNuQixnRUFBZ0U7SUFDaEUsSUFBSSxDQUFDLENBQUMsR0FBR0gsT0FBT0ksYUFBYSxFQUFFRCxNQUFNLE9BQU87SUFDNUMsSUFBSTtRQUNBLDREQUE0RDtRQUM1RCxNQUFNRSxpQkFBaUIsQ0FBQyxHQUFHTCxPQUFPTSxpQkFBaUI7UUFDbkQsTUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQixDQUFDLEdBQUdILGFBQWFRLFdBQVcsRUFBRUgsU0FBU0ksUUFBUTtJQUNoRyxFQUFFLE9BQU9DLEdBQUc7UUFDUixPQUFPO0lBQ1g7QUFDSixFQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybC5qcz81ZDI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMb2NhbFVSTFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNMb2NhbFVSTDtcbiAgICB9XG59KTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsKSB7XG4gICAgLy8gcHJldmVudCBhIGh5ZHJhdGlvbiBtaXNtYXRjaCBvbiBocmVmIGZvciB1cmwgd2l0aCBhbmNob3IgcmVmc1xuICAgIGlmICghKDAsIF91dGlscy5pc0Fic29sdXRlVXJsKSh1cmwpKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICAgICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbik7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJlc29sdmVkLnBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWxvY2FsLXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaXNMb2NhbFVSTCIsIl91dGlscyIsInJlcXVpcmUiLCJfaGFzYmFzZXBhdGgiLCJ1cmwiLCJpc0Fic29sdXRlVXJsIiwibG9jYXRpb25PcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiVVJMIiwib3JpZ2luIiwiaGFzQmFzZVBhdGgiLCJwYXRobmFtZSIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsd0NBQXVDO0lBQ25DSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsS0FBS0MsTUFBTSxFQUFFQyxJQUFJO0lBQ3RCLE1BQU1DLFVBQVUsQ0FBQztJQUNqQlQsT0FBT1EsSUFBSSxDQUFDRCxRQUFRRyxPQUFPLENBQUMsQ0FBQ0M7UUFDekIsSUFBSSxDQUFDSCxLQUFLSSxRQUFRLENBQUNELE1BQU07WUFDckJGLE9BQU8sQ0FBQ0UsSUFBSSxHQUFHSixNQUFNLENBQUNJLElBQUk7UUFDOUI7SUFDSjtJQUNBLE9BQU9GO0FBQ1gsRUFFQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LmpzP2ZiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvbWl0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvbWl0O1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gb21pdChvYmplY3QsIGtleXMpIHtcbiAgICBjb25zdCBvbWl0dGVkID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBvbWl0dGVkW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvbWl0dGVkO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbWl0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJvbWl0Iiwib2JqZWN0Iiwia2V5cyIsIm9taXR0ZWQiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    },\n    assign: function() {\n        return assign;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxTQUFTRix1QkFBdUJTLFlBQVk7SUFDeEMsTUFBTUMsUUFBUSxDQUFDO0lBQ2ZELGFBQWFFLE9BQU8sQ0FBQyxDQUFDYixPQUFPYztRQUN6QixJQUFJLE9BQU9GLEtBQUssQ0FBQ0UsSUFBSSxLQUFLLGFBQWE7WUFDbkNGLEtBQUssQ0FBQ0UsSUFBSSxHQUFHZDtRQUNqQixPQUFPLElBQUllLE1BQU1DLE9BQU8sQ0FBQ0osS0FBSyxDQUFDRSxJQUFJLEdBQUc7WUFDbENGLEtBQUssQ0FBQ0UsSUFBSSxDQUFDRyxJQUFJLENBQUNqQjtRQUNwQixPQUFPO1lBQ0hZLEtBQUssQ0FBQ0UsSUFBSSxHQUFHO2dCQUNURixLQUFLLENBQUNFLElBQUk7Z0JBQ1ZkO2FBQ0g7UUFDTDtJQUNKO0lBQ0EsT0FBT1k7QUFDWDtBQUNBLFNBQVNNLHVCQUF1QkMsS0FBSztJQUNqQyxJQUFJLE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFBVSxPQUFPQSxVQUFVLFdBQVc7UUFDdkcsT0FBT0UsT0FBT0Y7SUFDbEIsT0FBTztRQUNILE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU2hCLHVCQUF1Qm1CLFFBQVE7SUFDcEMsTUFBTUMsU0FBUyxJQUFJQztJQUNuQjNCLE9BQU80QixPQUFPLENBQUNILFVBQVVULE9BQU8sQ0FBQyxDQUFDTTtRQUM5QixJQUFJLENBQUNMLEtBQUtkLE1BQU0sR0FBR21CO1FBQ25CLElBQUlKLE1BQU1DLE9BQU8sQ0FBQ2hCLFFBQVE7WUFDdEJBLE1BQU1hLE9BQU8sQ0FBQyxDQUFDYSxPQUFPSCxPQUFPSSxNQUFNLENBQUNiLEtBQUtJLHVCQUF1QlE7UUFDcEUsT0FBTztZQUNISCxPQUFPSyxHQUFHLENBQUNkLEtBQUtJLHVCQUF1QmxCO1FBQzNDO0lBQ0o7SUFDQSxPQUFPdUI7QUFDWDtBQUNBLFNBQVNuQixPQUFPRSxNQUFNO0lBQ2xCLElBQUksSUFBSXVCLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsbUJBQW1CLElBQUlqQixNQUFNYyxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSSxPQUFPLEdBQUdBLE9BQU9KLE1BQU1JLE9BQU87UUFDbEhELGdCQUFnQixDQUFDQyxPQUFPLEVBQUUsR0FBR0gsU0FBUyxDQUFDRyxLQUFLO0lBQ2hEO0lBQ0FELGlCQUFpQm5CLE9BQU8sQ0FBQyxDQUFDRjtRQUN0QkksTUFBTW1CLElBQUksQ0FBQ3ZCLGFBQWF3QixJQUFJLElBQUl0QixPQUFPLENBQUMsQ0FBQ0MsTUFBTVIsT0FBTzhCLE1BQU0sQ0FBQ3RCO1FBQzdESCxhQUFhRSxPQUFPLENBQUMsQ0FBQ2IsT0FBT2MsTUFBTVIsT0FBT3FCLE1BQU0sQ0FBQ2IsS0FBS2Q7SUFDMUQ7SUFDQSxPQUFPTTtBQUNYLEVBRUEsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanM/MDE0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnk6IG51bGwsXG4gICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogbnVsbCxcbiAgICBhc3NpZ246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5O1xuICAgIH0sXG4gICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zO1xuICAgIH0sXG4gICAgYXNzaWduOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFzc2lnbjtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3QgcXVlcnkgPSB7fTtcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeVtrZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgICAgICAgcXVlcnlba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSBbXG4gICAgICAgICAgICAgICAgcXVlcnlba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBxdWVyeTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW0pIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4ocGFyYW0pIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyh1cmxRdWVyeSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBPYmplY3QuZW50cmllcyh1cmxRdWVyeSkuZm9yRWFjaCgocGFyYW0pPT57XG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBwYXJhbTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKT0+cmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlYXJjaFBhcmFtc0xpc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIHNlYXJjaFBhcmFtc0xpc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBzZWFyY2hQYXJhbXNMaXN0LmZvckVhY2goKHNlYXJjaFBhcmFtcyk9PntcbiAgICAgICAgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKS5mb3JFYWNoKChrZXkpPT50YXJnZXQuZGVsZXRlKGtleSkpO1xuICAgICAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PnRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiYXNzaWduIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJmb3JFYWNoIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwidXJsUXVlcnkiLCJyZXN1bHQiLCJVUkxTZWFyY2hQYXJhbXMiLCJlbnRyaWVzIiwiaXRlbSIsImFwcGVuZCIsInNldCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZWFyY2hQYXJhbXNMaXN0IiwiX2tleSIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function() {\n        return getRouteMatcher;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re, groups } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMscUZBQWE7QUFDcEMsU0FBU0YsZ0JBQWdCRyxLQUFLO0lBQzFCLElBQUksRUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Y7SUFDckIsT0FBTyxDQUFDRztRQUNKLE1BQU1DLGFBQWFILEdBQUdJLElBQUksQ0FBQ0Y7UUFDM0IsSUFBSSxDQUFDQyxZQUFZO1lBQ2IsT0FBTztRQUNYO1FBQ0EsTUFBTUUsU0FBUyxDQUFDTjtZQUNaLElBQUk7Z0JBQ0EsT0FBT08sbUJBQW1CUDtZQUM5QixFQUFFLE9BQU9RLEdBQUc7Z0JBQ1IsTUFBTSxJQUFJVixPQUFPVyxXQUFXLENBQUM7WUFDakM7UUFDSjtRQUNBLE1BQU1DLFNBQVMsQ0FBQztRQUNoQm5CLE9BQU9vQixJQUFJLENBQUNULFFBQVFVLE9BQU8sQ0FBQyxDQUFDQztZQUN6QixNQUFNQyxJQUFJWixNQUFNLENBQUNXLFNBQVM7WUFDMUIsTUFBTUUsSUFBSVgsVUFBVSxDQUFDVSxFQUFFRSxHQUFHLENBQUM7WUFDM0IsSUFBSUQsTUFBTUUsV0FBVztnQkFDakJQLE1BQU0sQ0FBQ0csU0FBUyxHQUFHLENBQUNFLEVBQUVHLE9BQU8sQ0FBQyxPQUFPSCxFQUFFSSxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLENBQUNDLFFBQVFmLE9BQU9lLFVBQVVQLEVBQUVRLE1BQU0sR0FBRztvQkFDdkZoQixPQUFPUztpQkFDVixHQUFHVCxPQUFPUztZQUNmO1FBQ0o7UUFDQSxPQUFPTDtJQUNYO0FBQ0osRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLmpzP2M4NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRSb3V0ZU1hdGNoZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlTWF0Y2hlcjtcbiAgICB9XG59KTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihwYXJhbSkge1xuICAgIGxldCB7IHJlLCBncm91cHMgfSA9IHBhcmFtO1xuICAgIHJldHVybiAocGF0aG5hbWUpPT57XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlID0gKHBhcmFtKT0+e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgX3V0aWxzLkRlY29kZUVycm9yKFwiZmFpbGVkIHRvIGRlY29kZSBwYXJhbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWUpPT57XG4gICAgICAgICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXTtcbiAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZihcIi9cIikgPyBtLnNwbGl0KFwiL1wiKS5tYXAoKGVudHJ5KT0+ZGVjb2RlKGVudHJ5KSkgOiBnLnJlcGVhdCA/IFtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlKG0pXG4gICAgICAgICAgICAgICAgXSA6IGRlY29kZShtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtbWF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0Um91dGVNYXRjaGVyIiwiX3V0aWxzIiwicmVxdWlyZSIsInBhcmFtIiwicmUiLCJncm91cHMiLCJwYXRobmFtZSIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsIkRlY29kZUVycm9yIiwicGFyYW1zIiwia2V5cyIsImZvckVhY2giLCJzbHVnTmFtZSIsImciLCJtIiwicG9zIiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsInNwbGl0IiwibWFwIiwiZW50cnkiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = \"\" + key;\n    }\n    return repeat ? optional ? \"(?:/(?<\" + cleanedKey + \">.+?))?\" : \"/(?<\" + cleanedKey + \">.+?)\" : \"/(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0lBQ0FDLHlCQUF5QjtRQUNyQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyxzQkFBc0JDLG1CQUFPQSxDQUFDLHdKQUF1RDtBQUMzRixNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDLHFHQUFxQjtBQUNuRCxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLDhIQUF5QjtBQUM5RCxNQUFNRywwQkFBMEI7QUFDaEMsTUFBTUMsa0NBQWtDO0FBQ3hDOzs7Ozs7O0NBT0MsR0FBRyxTQUFTQyxlQUFlQyxLQUFLO0lBQzdCLE1BQU1DLFdBQVdELE1BQU1FLFVBQVUsQ0FBQyxRQUFRRixNQUFNRyxRQUFRLENBQUM7SUFDekQsSUFBSUYsVUFBVTtRQUNWRCxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzVCO0lBQ0EsTUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDUkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3hCO0lBQ0EsT0FBTztRQUNIRSxLQUFLTjtRQUNMSztRQUNBSjtJQUNKO0FBQ0o7QUFDQSxTQUFTTSxxQkFBcUJDLEtBQUs7SUFDL0IsTUFBTUMsV0FBVyxDQUFDLEdBQUdiLHFCQUFxQmMsbUJBQW1CLEVBQUVGLE9BQU9KLEtBQUssQ0FBQyxHQUFHTyxLQUFLLENBQUM7SUFDckYsTUFBTUMsU0FBUyxDQUFDO0lBQ2hCLElBQUlDLGFBQWE7SUFDakIsT0FBTztRQUNIQyxvQkFBb0JMLFNBQVNNLEdBQUcsQ0FBQyxDQUFDQztZQUM5QixNQUFNQyxjQUFjeEIsb0JBQW9CeUIsMEJBQTBCLENBQUNDLElBQUksQ0FBQyxDQUFDQyxJQUFJSixRQUFRZCxVQUFVLENBQUNrQjtZQUNoRyxNQUFNQyxlQUFlTCxRQUFRTSxLQUFLLENBQUMsdUJBQXVCLHVCQUF1Qjs7WUFFakYsSUFBSUwsZUFBZUksY0FBYztnQkFDN0IsTUFBTSxFQUFFZixHQUFHLEVBQUVMLFFBQVEsRUFBRUksTUFBTSxFQUFFLEdBQUdOLGVBQWVzQixZQUFZLENBQUMsRUFBRTtnQkFDaEVULE1BQU0sQ0FBQ04sSUFBSSxHQUFHO29CQUNWaUIsS0FBS1Y7b0JBQ0xSO29CQUNBSjtnQkFDSjtnQkFDQSxPQUFPLE1BQU0sQ0FBQyxHQUFHTixjQUFjNkIsa0JBQWtCLEVBQUVQLGVBQWU7WUFDdEUsT0FBTyxJQUFJSSxjQUFjO2dCQUNyQixNQUFNLEVBQUVmLEdBQUcsRUFBRUQsTUFBTSxFQUFFSixRQUFRLEVBQUUsR0FBR0YsZUFBZXNCLFlBQVksQ0FBQyxFQUFFO2dCQUNoRVQsTUFBTSxDQUFDTixJQUFJLEdBQUc7b0JBQ1ZpQixLQUFLVjtvQkFDTFI7b0JBQ0FKO2dCQUNKO2dCQUNBLE9BQU9JLFNBQVNKLFdBQVcsZ0JBQWdCLFdBQVc7WUFDMUQsT0FBTztnQkFDSCxPQUFPLE1BQU0sQ0FBQyxHQUFHTixjQUFjNkIsa0JBQWtCLEVBQUVSO1lBQ3ZEO1FBQ0osR0FBR1MsSUFBSSxDQUFDO1FBQ1JiO0lBQ0o7QUFDSjtBQUNBLFNBQVM1QixjQUFjMEMsZUFBZTtJQUNsQyxNQUFNLEVBQUVaLGtCQUFrQixFQUFFRixNQUFNLEVBQUUsR0FBR0wscUJBQXFCbUI7SUFDNUQsT0FBTztRQUNIQyxJQUFJLElBQUlDLE9BQU8sTUFBTWQscUJBQXFCO1FBQzFDRixRQUFRQTtJQUNaO0FBQ0o7QUFDQTs7O0NBR0MsR0FBRyxTQUFTaUI7SUFDVCxJQUFJQyxJQUFJO0lBQ1IsT0FBTztRQUNILElBQUlDLFdBQVc7UUFDZixJQUFJQyxJQUFJLEVBQUVGO1FBQ1YsTUFBTUUsSUFBSSxFQUFFO1lBQ1JELFlBQVlFLE9BQU9DLFlBQVksQ0FBQyxLQUFLLENBQUNGLElBQUksS0FBSztZQUMvQ0EsSUFBSUcsS0FBS0MsS0FBSyxDQUFDLENBQUNKLElBQUksS0FBSztRQUM3QjtRQUNBLE9BQU9EO0lBQ1g7QUFDSjtBQUNBLFNBQVNNLHNCQUFzQnJDLEtBQUs7SUFDaEMsSUFBSSxFQUFFc0MsZUFBZSxFQUFFdEIsT0FBTyxFQUFFdUIsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBR3hDO0lBQ3pELE1BQU0sRUFBRU0sR0FBRyxFQUFFTCxRQUFRLEVBQUVJLE1BQU0sRUFBRSxHQUFHTixlQUFlaUI7SUFDakQsdURBQXVEO0lBQ3ZELGtCQUFrQjtJQUNsQixJQUFJeUIsYUFBYW5DLElBQUlvQyxPQUFPLENBQUMsT0FBTztJQUNwQyxJQUFJRixXQUFXO1FBQ1hDLGFBQWEsS0FBS0QsWUFBWUM7SUFDbEM7SUFDQSxJQUFJRSxhQUFhO0lBQ2pCLGtFQUFrRTtJQUNsRSxXQUFXO0lBQ1gsSUFBSUYsV0FBV0csTUFBTSxLQUFLLEtBQUtILFdBQVdHLE1BQU0sR0FBRyxJQUFJO1FBQ25ERCxhQUFhO0lBQ2pCO0lBQ0EsSUFBSSxDQUFDRSxNQUFNQyxTQUFTTCxXQUFXckMsS0FBSyxDQUFDLEdBQUcsTUFBTTtRQUMxQ3VDLGFBQWE7SUFDakI7SUFDQSxJQUFJQSxZQUFZO1FBQ1pGLGFBQWFIO0lBQ2pCO0lBQ0EsSUFBSUUsV0FBVztRQUNYRCxTQUFTLENBQUNFLFdBQVcsR0FBRyxLQUFLRCxZQUFZbEM7SUFDN0MsT0FBTztRQUNIaUMsU0FBUyxDQUFDRSxXQUFXLEdBQUcsS0FBS25DO0lBQ2pDO0lBQ0EsT0FBT0QsU0FBU0osV0FBVyxZQUFZd0MsYUFBYSxZQUFZLFNBQVNBLGFBQWEsVUFBVSxTQUFTQSxhQUFhO0FBQzFIO0FBQ0EsU0FBU00sMEJBQTBCdkMsS0FBSyxFQUFFd0MsZUFBZTtJQUNyRCxNQUFNdkMsV0FBVyxDQUFDLEdBQUdiLHFCQUFxQmMsbUJBQW1CLEVBQUVGLE9BQU9KLEtBQUssQ0FBQyxHQUFHTyxLQUFLLENBQUM7SUFDckYsTUFBTTJCLGtCQUFrQlQ7SUFDeEIsTUFBTVUsWUFBWSxDQUFDO0lBQ25CLE9BQU87UUFDSFUseUJBQXlCeEMsU0FBU00sR0FBRyxDQUFDLENBQUNDO1lBQ25DLE1BQU1rQyx3QkFBd0J6RCxvQkFBb0J5QiwwQkFBMEIsQ0FBQ2lDLElBQUksQ0FBQyxDQUFDL0IsSUFBSUosUUFBUWQsVUFBVSxDQUFDa0I7WUFDMUcsTUFBTUMsZUFBZUwsUUFBUU0sS0FBSyxDQUFDLHVCQUF1Qix1QkFBdUI7O1lBRWpGLElBQUk0Qix5QkFBeUI3QixjQUFjO2dCQUN2QyxPQUFPZ0Isc0JBQXNCO29CQUN6QkM7b0JBQ0F0QixTQUFTSyxZQUFZLENBQUMsRUFBRTtvQkFDeEJrQjtvQkFDQUMsV0FBV1Esa0JBQWtCbEQsa0NBQWtDc0Q7Z0JBQ25FO1lBQ0osT0FBTyxJQUFJL0IsY0FBYztnQkFDckIsT0FBT2dCLHNCQUFzQjtvQkFDekJDO29CQUNBdEIsU0FBU0ssWUFBWSxDQUFDLEVBQUU7b0JBQ3hCa0I7b0JBQ0FDLFdBQVdRLGtCQUFrQm5ELDBCQUEwQnVEO2dCQUMzRDtZQUNKLE9BQU87Z0JBQ0gsT0FBTyxNQUFNLENBQUMsR0FBR3pELGNBQWM2QixrQkFBa0IsRUFBRVI7WUFDdkQ7UUFDSixHQUFHUyxJQUFJLENBQUM7UUFDUmM7SUFDSjtBQUNKO0FBQ0EsU0FBU3RELG1CQUFtQnlDLGVBQWUsRUFBRTJCLGNBQWM7SUFDdkQsTUFBTUMsU0FBU1AsMEJBQTBCckIsaUJBQWlCMkI7SUFDMUQsT0FBTztRQUNILEdBQUdyRSxjQUFjMEMsZ0JBQWdCO1FBQ2pDNkIsWUFBWSxNQUFNRCxPQUFPTCx1QkFBdUIsR0FBRztRQUNuRFYsV0FBV2UsT0FBT2YsU0FBUztJQUMvQjtBQUNKO0FBQ0EsU0FBU3JELHdCQUF3QndDLGVBQWUsRUFBRThCLE9BQU87SUFDckQsTUFBTSxFQUFFMUMsa0JBQWtCLEVBQUUsR0FBR1AscUJBQXFCbUI7SUFDcEQsTUFBTSxFQUFFK0IsV0FBVyxJQUFJLEVBQUUsR0FBR0Q7SUFDNUIsSUFBSTFDLHVCQUF1QixLQUFLO1FBQzVCLElBQUk0QyxnQkFBZ0JELFdBQVcsT0FBTztRQUN0QyxPQUFPO1lBQ0hGLFlBQVksT0FBT0csZ0JBQWdCO1FBQ3ZDO0lBQ0o7SUFDQSxNQUFNLEVBQUVULHVCQUF1QixFQUFFLEdBQUdGLDBCQUEwQnJCLGlCQUFpQjtJQUMvRSxJQUFJaUMsdUJBQXVCRixXQUFXLGVBQWU7SUFDckQsT0FBTztRQUNIRixZQUFZLE1BQU1OLDBCQUEwQlUsdUJBQXVCO0lBQ3ZFO0FBQ0osRUFFQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC5qcz9lYWMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ2V0Um91dGVSZWdleDogbnVsbCxcbiAgICBnZXROYW1lZFJvdXRlUmVnZXg6IG51bGwsXG4gICAgZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZ2V0Um91dGVSZWdleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRSb3V0ZVJlZ2V4O1xuICAgIH0sXG4gICAgZ2V0TmFtZWRSb3V0ZVJlZ2V4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldE5hbWVkUm91dGVSZWdleDtcbiAgICB9LFxuICAgIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyY2VwdGlvbnJvdXRlcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9zZXJ2ZXIvZnV0dXJlL2hlbHBlcnMvaW50ZXJjZXB0aW9uLXJvdXRlc1wiKTtcbmNvbnN0IF9lc2NhcGVyZWdleHAgPSByZXF1aXJlKFwiLi4vLi4vZXNjYXBlLXJlZ2V4cFwiKTtcbmNvbnN0IF9yZW1vdmV0cmFpbGluZ3NsYXNoID0gcmVxdWlyZShcIi4vcmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCIpO1xuY29uc3QgTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVggPSBcIm54dFBcIjtcbmNvbnN0IE5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVggPSBcIm54dElcIjtcbi8qKlxuICogUGFyc2VzIGEgZ2l2ZW4gcGFyYW1ldGVyIGZyb20gYSByb3V0ZSB0byBhIGRhdGEgc3RydWN0dXJlIHRoYXQgY2FuIGJlIHVzZWRcbiAqIHRvIGdlbmVyYXRlIHRoZSBwYXJhbWV0cml6ZWQgcm91dGUuIEV4YW1wbGVzOlxuICogICAtIGBbLi4uc2x1Z11gIC0+IGB7IGtleTogJ3NsdWcnLCByZXBlYXQ6IHRydWUsIG9wdGlvbmFsOiB0cnVlIH1gXG4gKiAgIC0gYC4uLnNsdWdgIC0+IGB7IGtleTogJ3NsdWcnLCByZXBlYXQ6IHRydWUsIG9wdGlvbmFsOiBmYWxzZSB9YFxuICogICAtIGBbZm9vXWAgLT4gYHsga2V5OiAnZm9vJywgcmVwZWF0OiBmYWxzZSwgb3B0aW9uYWw6IHRydWUgfWBcbiAqICAgLSBgYmFyYCAtPiBgeyBrZXk6ICdiYXInLCByZXBlYXQ6IGZhbHNlLCBvcHRpb25hbDogZmFsc2UgfWBcbiAqLyBmdW5jdGlvbiBwYXJzZVBhcmFtZXRlcihwYXJhbSkge1xuICAgIGNvbnN0IG9wdGlvbmFsID0gcGFyYW0uc3RhcnRzV2l0aChcIltcIikgJiYgcGFyYW0uZW5kc1dpdGgoXCJdXCIpO1xuICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgY29uc3QgcmVwZWF0ID0gcGFyYW0uc3RhcnRzV2l0aChcIi4uLlwiKTtcbiAgICBpZiAocmVwZWF0KSB7XG4gICAgICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGtleTogcGFyYW0sXG4gICAgICAgIHJlcGVhdCxcbiAgICAgICAgb3B0aW9uYWxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFyYW1ldHJpemVkUm91dGUocm91dGUpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShyb3V0ZSkuc2xpY2UoMSkuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuICAgIGxldCBncm91cEluZGV4ID0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbWV0ZXJpemVkUm91dGU6IHNlZ21lbnRzLm1hcCgoc2VnbWVudCk9PntcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlck1hdGNoID0gX2ludGVyY2VwdGlvbnJvdXRlcy5JTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5maW5kKChtKT0+c2VnbWVudC5zdGFydHNXaXRoKG0pKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTWF0Y2hlcyA9IHNlZ21lbnQubWF0Y2goL1xcWygoPzpcXFsuKlxcXSl8LispXFxdLykgLy8gQ2hlY2sgZm9yIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChtYXJrZXJNYXRjaCAmJiBwYXJhbU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleSwgb3B0aW9uYWwsIHJlcGVhdCB9ID0gcGFyc2VQYXJhbWV0ZXIocGFyYW1NYXRjaGVzWzFdKTtcbiAgICAgICAgICAgICAgICBncm91cHNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBncm91cEluZGV4KyssXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIiArICgwLCBfZXNjYXBlcmVnZXhwLmVzY2FwZVN0cmluZ1JlZ2V4cCkobWFya2VyTWF0Y2gpICsgXCIoW14vXSs/KVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleSwgcmVwZWF0LCBvcHRpb25hbCB9ID0gcGFyc2VQYXJhbWV0ZXIocGFyYW1NYXRjaGVzWzFdKTtcbiAgICAgICAgICAgICAgICBncm91cHNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBncm91cEluZGV4KyssXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBlYXQgPyBvcHRpb25hbCA/IFwiKD86LyguKz8pKT9cIiA6IFwiLyguKz8pXCIgOiBcIi8oW14vXSs/KVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCIgKyAoMCwgX2VzY2FwZXJlZ2V4cC5lc2NhcGVTdHJpbmdSZWdleHApKHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICBncm91cHNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Um91dGVSZWdleChub3JtYWxpemVkUm91dGUpIHtcbiAgICBjb25zdCB7IHBhcmFtZXRlcml6ZWRSb3V0ZSwgZ3JvdXBzIH0gPSBnZXRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlOiBuZXcgUmVnRXhwKFwiXlwiICsgcGFyYW1ldGVyaXplZFJvdXRlICsgXCIoPzovKT8kXCIpLFxuICAgICAgICBncm91cHM6IGdyb3Vwc1xuICAgIH07XG59XG4vKipcbiAqIEJ1aWxkcyBhIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbWluaW1hbCByb3V0ZUtleSB1c2luZyBvbmx5IGEteiBhbmQgbWluaW1hbFxuICogbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gKi8gZnVuY3Rpb24gYnVpbGRHZXRTYWZlUm91dGVLZXkoKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBsZXQgcm91dGVLZXkgPSBcIlwiO1xuICAgICAgICBsZXQgaiA9ICsraTtcbiAgICAgICAgd2hpbGUoaiA+IDApe1xuICAgICAgICAgICAgcm91dGVLZXkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIChqIC0gMSkgJSAyNik7XG4gICAgICAgICAgICBqID0gTWF0aC5mbG9vcigoaiAtIDEpIC8gMjYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZUtleTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2FmZUtleUZyb21TZWdtZW50KHBhcmFtKSB7XG4gICAgbGV0IHsgZ2V0U2FmZVJvdXRlS2V5LCBzZWdtZW50LCByb3V0ZUtleXMsIGtleVByZWZpeCB9ID0gcGFyYW07XG4gICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQpO1xuICAgIC8vIHJlcGxhY2UgYW55IG5vbi13b3JkIGNoYXJhY3RlcnMgc2luY2UgdGhleSBjYW4gYnJlYWtcbiAgICAvLyB0aGUgbmFtZWQgcmVnZXhcbiAgICBsZXQgY2xlYW5lZEtleSA9IGtleS5yZXBsYWNlKC9cXFcvZywgXCJcIik7XG4gICAgaWYgKGtleVByZWZpeCkge1xuICAgICAgICBjbGVhbmVkS2V5ID0gXCJcIiArIGtleVByZWZpeCArIGNsZWFuZWRLZXk7XG4gICAgfVxuICAgIGxldCBpbnZhbGlkS2V5ID0gZmFsc2U7XG4gICAgLy8gY2hlY2sgaWYgdGhlIGtleSBpcyBzdGlsbCBpbnZhbGlkIGFuZCBmYWxsYmFjayB0byB1c2luZyBhIGtub3duXG4gICAgLy8gc2FmZSBrZXlcbiAgICBpZiAoY2xlYW5lZEtleS5sZW5ndGggPT09IDAgfHwgY2xlYW5lZEtleS5sZW5ndGggPiAzMCkge1xuICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihwYXJzZUludChjbGVhbmVkS2V5LnNsaWNlKDAsIDEpKSkpIHtcbiAgICAgICAgaW52YWxpZEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbnZhbGlkS2V5KSB7XG4gICAgICAgIGNsZWFuZWRLZXkgPSBnZXRTYWZlUm91dGVLZXkoKTtcbiAgICB9XG4gICAgaWYgKGtleVByZWZpeCkge1xuICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBcIlwiICsga2V5UHJlZml4ICsga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlS2V5c1tjbGVhbmVkS2V5XSA9IFwiXCIgKyBrZXk7XG4gICAgfVxuICAgIHJldHVybiByZXBlYXQgPyBvcHRpb25hbCA/IFwiKD86Lyg/PFwiICsgY2xlYW5lZEtleSArIFwiPi4rPykpP1wiIDogXCIvKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+Lis/KVwiIDogXCIvKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+W14vXSs/KVwiO1xufVxuZnVuY3Rpb24gZ2V0TmFtZWRQYXJhbWV0cml6ZWRSb3V0ZShyb3V0ZSwgcHJlZml4Um91dGVLZXlzKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocm91dGUpLnNsaWNlKDEpLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBnZXRTYWZlUm91dGVLZXkgPSBidWlsZEdldFNhZmVSb3V0ZUtleSgpO1xuICAgIGNvbnN0IHJvdXRlS2V5cyA9IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlOiBzZWdtZW50cy5tYXAoKHNlZ21lbnQpPT57XG4gICAgICAgICAgICBjb25zdCBoYXNJbnRlcmNlcHRpb25NYXJrZXIgPSBfaW50ZXJjZXB0aW9ucm91dGVzLklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLnNvbWUoKG0pPT5zZWdtZW50LnN0YXJ0c1dpdGgobSkpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1NYXRjaGVzID0gc2VnbWVudC5tYXRjaCgvXFxbKCg/OlxcWy4qXFxdKXwuKylcXF0vKSAvLyBDaGVjayBmb3IgcGFyYW1ldGVyc1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKGhhc0ludGVyY2VwdGlvbk1hcmtlciAmJiBwYXJhbU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2FmZUtleUZyb21TZWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2FmZVJvdXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50OiBwYXJhbU1hdGNoZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgICAga2V5UHJlZml4OiBwcmVmaXhSb3V0ZUtleXMgPyBORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTYWZlS2V5RnJvbVNlZ21lbnQoe1xuICAgICAgICAgICAgICAgICAgICBnZXRTYWZlUm91dGVLZXksXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHBhcmFtTWF0Y2hlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVLZXlzLFxuICAgICAgICAgICAgICAgICAgICBrZXlQcmVmaXg6IHByZWZpeFJvdXRlS2V5cyA/IE5FWFRfUVVFUllfUEFSQU1fUFJFRklYIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIiArICgwLCBfZXNjYXBlcmVnZXhwLmVzY2FwZVN0cmluZ1JlZ2V4cCkoc2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmpvaW4oXCJcIiksXG4gICAgICAgIHJvdXRlS2V5c1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXROYW1lZFJvdXRlUmVnZXgobm9ybWFsaXplZFJvdXRlLCBwcmVmaXhSb3V0ZUtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlLCBwcmVmaXhSb3V0ZUtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZ2V0Um91dGVSZWdleChub3JtYWxpemVkUm91dGUpLFxuICAgICAgICBuYW1lZFJlZ2V4OiBcIl5cIiArIHJlc3VsdC5uYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSArIFwiKD86Lyk/JFwiLFxuICAgICAgICByb3V0ZUtleXM6IHJlc3VsdC5yb3V0ZUtleXNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXgobm9ybWFsaXplZFJvdXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwYXJhbWV0ZXJpemVkUm91dGUgfSA9IGdldFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSk7XG4gICAgY29uc3QgeyBjYXRjaEFsbCA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHBhcmFtZXRlcml6ZWRSb3V0ZSA9PT0gXCIvXCIpIHtcbiAgICAgICAgbGV0IGNhdGNoQWxsUmVnZXggPSBjYXRjaEFsbCA/IFwiLipcIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lZFJlZ2V4OiBcIl4vXCIgKyBjYXRjaEFsbFJlZ2V4ICsgXCIkXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSB9ID0gZ2V0TmFtZWRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUsIGZhbHNlKTtcbiAgICBsZXQgY2F0Y2hBbGxHcm91cGVkUmVnZXggPSBjYXRjaEFsbCA/IFwiKD86KC8uKik/KVwiIDogXCJcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lZFJlZ2V4OiBcIl5cIiArIG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlICsgY2F0Y2hBbGxHcm91cGVkUmVnZXggKyBcIiRcIlxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlLXJlZ2V4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImdldFJvdXRlUmVnZXgiLCJnZXROYW1lZFJvdXRlUmVnZXgiLCJnZXROYW1lZE1pZGRsZXdhcmVSZWdleCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9pbnRlcmNlcHRpb25yb3V0ZXMiLCJyZXF1aXJlIiwiX2VzY2FwZXJlZ2V4cCIsIl9yZW1vdmV0cmFpbGluZ3NsYXNoIiwiTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVgiLCJORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYIiwicGFyc2VQYXJhbWV0ZXIiLCJwYXJhbSIsIm9wdGlvbmFsIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic2xpY2UiLCJyZXBlYXQiLCJrZXkiLCJnZXRQYXJhbWV0cml6ZWRSb3V0ZSIsInJvdXRlIiwic2VnbWVudHMiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwic3BsaXQiLCJncm91cHMiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwibWFwIiwic2VnbWVudCIsIm1hcmtlck1hdGNoIiwiSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMiLCJmaW5kIiwibSIsInBhcmFtTWF0Y2hlcyIsIm1hdGNoIiwicG9zIiwiZXNjYXBlU3RyaW5nUmVnZXhwIiwiam9pbiIsIm5vcm1hbGl6ZWRSb3V0ZSIsInJlIiwiUmVnRXhwIiwiYnVpbGRHZXRTYWZlUm91dGVLZXkiLCJpIiwicm91dGVLZXkiLCJqIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiTWF0aCIsImZsb29yIiwiZ2V0U2FmZUtleUZyb21TZWdtZW50IiwiZ2V0U2FmZVJvdXRlS2V5Iiwicm91dGVLZXlzIiwia2V5UHJlZml4IiwiY2xlYW5lZEtleSIsInJlcGxhY2UiLCJpbnZhbGlkS2V5IiwibGVuZ3RoIiwiaXNOYU4iLCJwYXJzZUludCIsImdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUiLCJwcmVmaXhSb3V0ZUtleXMiLCJuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSIsImhhc0ludGVyY2VwdGlvbk1hcmtlciIsInNvbWUiLCJ1bmRlZmluZWQiLCJwcmVmaXhSb3V0ZUtleSIsInJlc3VsdCIsIm5hbWVkUmVnZXgiLCJvcHRpb25zIiwiY2F0Y2hBbGwiLCJjYXRjaEFsbFJlZ2V4IiwiY2F0Y2hBbGxHcm91cGVkUmVnZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return getSortedRoutes;\n    }\n}));\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix) {\n        if (prefix === void 0) prefix = \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUM7SUFDRkMsT0FBT0MsT0FBTyxFQUFFO1FBQ1osSUFBSSxDQUFDQyxPQUFPLENBQUNELFFBQVFFLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLFVBQVUsRUFBRSxFQUFFO0lBQ3pEO0lBQ0FDLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUN2QjtJQUNBQSxRQUFRQyxNQUFNLEVBQUU7UUFDWixJQUFJQSxXQUFXLEtBQUssR0FBR0EsU0FBUztRQUNoQyxNQUFNQyxnQkFBZ0I7ZUFDZixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSTtTQUN4QixDQUFDQyxJQUFJO1FBQ04sSUFBSSxJQUFJLENBQUNDLFFBQVEsS0FBSyxNQUFNO1lBQ3hCSixjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxPQUFPO1FBQ3REO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFlBQVksS0FBSyxNQUFNO1lBQzVCUCxjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxVQUFVO1FBQ3pEO1FBQ0EsSUFBSSxJQUFJLENBQUNFLG9CQUFvQixLQUFLLE1BQU07WUFDcENSLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFlBQVk7UUFDM0Q7UUFDQSxNQUFNRyxTQUFTVCxjQUFjVSxHQUFHLENBQUMsQ0FBQ0MsSUFBSSxJQUFJLENBQUNWLFFBQVEsQ0FBQ2IsR0FBRyxDQUFDdUIsR0FBR2IsT0FBTyxDQUFDLEtBQUtDLFNBQVNZLElBQUksTUFBTUMsTUFBTSxDQUFDLENBQUNDLE1BQU1DLE9BQU87bUJBQ3JHRDttQkFDQUM7YUFDTixFQUFFLEVBQUU7UUFDVCxJQUFJLElBQUksQ0FBQ1YsUUFBUSxLQUFLLE1BQU07WUFDeEJLLE9BQU9NLElBQUksSUFBSSxJQUFJLENBQUNkLFFBQVEsQ0FBQ2IsR0FBRyxDQUFDLE1BQU1VLE9BQU8sQ0FBQ0MsU0FBUyxNQUFNLElBQUksQ0FBQ0ssUUFBUSxHQUFHO1FBQ2xGO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ1ksV0FBVyxFQUFFO1lBQ25CLE1BQU1DLElBQUlsQixXQUFXLE1BQU0sTUFBTUEsT0FBT21CLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDbEQsSUFBSSxJQUFJLENBQUNWLG9CQUFvQixJQUFJLE1BQU07Z0JBQ25DLE1BQU0sSUFBSVcsTUFBTSx5RkFBeUZGLElBQUksWUFBWUEsSUFBSSxVQUFVLElBQUksQ0FBQ1Qsb0JBQW9CLEdBQUc7WUFDdks7WUFDQUMsT0FBT1csT0FBTyxDQUFDSDtRQUNuQjtRQUNBLElBQUksSUFBSSxDQUFDVixZQUFZLEtBQUssTUFBTTtZQUM1QkUsT0FBT00sSUFBSSxJQUFJLElBQUksQ0FBQ2QsUUFBUSxDQUFDYixHQUFHLENBQUMsU0FBU1UsT0FBTyxDQUFDQyxTQUFTLFNBQVMsSUFBSSxDQUFDUSxZQUFZLEdBQUc7UUFDNUY7UUFDQSxJQUFJLElBQUksQ0FBQ0Msb0JBQW9CLEtBQUssTUFBTTtZQUNwQ0MsT0FBT00sSUFBSSxJQUFJLElBQUksQ0FBQ2QsUUFBUSxDQUFDYixHQUFHLENBQUMsV0FBV1UsT0FBTyxDQUFDQyxTQUFTLFVBQVUsSUFBSSxDQUFDUyxvQkFBb0IsR0FBRztRQUN2RztRQUNBLE9BQU9DO0lBQ1g7SUFDQWhCLFFBQVE0QixRQUFRLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFO1FBQ3JDLElBQUlGLFNBQVNHLE1BQU0sS0FBSyxHQUFHO1lBQ3ZCLElBQUksQ0FBQ1IsV0FBVyxHQUFHO1lBQ25CO1FBQ0o7UUFDQSxJQUFJTyxZQUFZO1lBQ1osTUFBTSxJQUFJSixNQUFNO1FBQ3BCO1FBQ0Esd0NBQXdDO1FBQ3hDLElBQUlNLGNBQWNKLFFBQVEsQ0FBQyxFQUFFO1FBQzdCLDZDQUE2QztRQUM3QyxJQUFJSSxZQUFZQyxVQUFVLENBQUMsUUFBUUQsWUFBWUUsUUFBUSxDQUFDLE1BQU07WUFDMUQsOENBQThDO1lBQzlDLElBQUlDLGNBQWNILFlBQVlQLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDeEMsSUFBSVcsYUFBYTtZQUNqQixJQUFJRCxZQUFZRixVQUFVLENBQUMsUUFBUUUsWUFBWUQsUUFBUSxDQUFDLE1BQU07Z0JBQzFELHVEQUF1RDtnQkFDdkRDLGNBQWNBLFlBQVlWLEtBQUssQ0FBQyxHQUFHLENBQUM7Z0JBQ3BDVyxhQUFhO1lBQ2pCO1lBQ0EsSUFBSUQsWUFBWUYsVUFBVSxDQUFDLFFBQVE7Z0JBQy9CLHdDQUF3QztnQkFDeENFLGNBQWNBLFlBQVlFLFNBQVMsQ0FBQztnQkFDcENQLGFBQWE7WUFDakI7WUFDQSxJQUFJSyxZQUFZRixVQUFVLENBQUMsUUFBUUUsWUFBWUQsUUFBUSxDQUFDLE1BQU07Z0JBQzFELE1BQU0sSUFBSVIsTUFBTSw4REFBOERTLGNBQWM7WUFDaEc7WUFDQSxJQUFJQSxZQUFZRixVQUFVLENBQUMsTUFBTTtnQkFDN0IsTUFBTSxJQUFJUCxNQUFNLDBEQUEwRFMsY0FBYztZQUM1RjtZQUNBLFNBQVNHLFdBQVdDLFlBQVksRUFBRUMsUUFBUTtnQkFDdEMsSUFBSUQsaUJBQWlCLE1BQU07b0JBQ3ZCLDZFQUE2RTtvQkFDN0UsaUNBQWlDO29CQUNqQyx3QkFBd0I7b0JBQ3hCLHNCQUFzQjtvQkFDdEIsd0ZBQXdGO29CQUN4RixJQUFJQSxpQkFBaUJDLFVBQVU7d0JBQzNCLHdIQUF3SDt3QkFDeEgsTUFBTSxJQUFJZCxNQUFNLHFFQUFxRWEsZUFBZSxZQUFZQyxXQUFXO29CQUMvSDtnQkFDSjtnQkFDQVgsVUFBVVksT0FBTyxDQUFDLENBQUNDO29CQUNmLElBQUlBLFNBQVNGLFVBQVU7d0JBQ25CLE1BQU0sSUFBSWQsTUFBTSx5Q0FBeUNjLFdBQVc7b0JBQ3hFO29CQUNBLElBQUlFLEtBQUtDLE9BQU8sQ0FBQyxPQUFPLFFBQVFYLFlBQVlXLE9BQU8sQ0FBQyxPQUFPLEtBQUs7d0JBQzVELE1BQU0sSUFBSWpCLE1BQU0scUNBQXFDZ0IsT0FBTyxZQUFZRixXQUFXO29CQUN2RjtnQkFDSjtnQkFDQVgsVUFBVVAsSUFBSSxDQUFDa0I7WUFDbkI7WUFDQSxJQUFJVixZQUFZO2dCQUNaLElBQUlNLFlBQVk7b0JBQ1osSUFBSSxJQUFJLENBQUN0QixZQUFZLElBQUksTUFBTTt3QkFDM0IsTUFBTSxJQUFJWSxNQUFNLDBGQUEwRixJQUFJLENBQUNaLFlBQVksR0FBRyxhQUFhYyxRQUFRLENBQUMsRUFBRSxHQUFHO29CQUM3SjtvQkFDQVUsV0FBVyxJQUFJLENBQUN2QixvQkFBb0IsRUFBRW9CO29CQUN0Qyw2REFBNkQ7b0JBQzdELElBQUksQ0FBQ3BCLG9CQUFvQixHQUFHb0I7b0JBQzVCLG9GQUFvRjtvQkFDcEZILGNBQWM7Z0JBQ2xCLE9BQU87b0JBQ0gsSUFBSSxJQUFJLENBQUNqQixvQkFBb0IsSUFBSSxNQUFNO3dCQUNuQyxNQUFNLElBQUlXLE1BQU0sMkZBQTJGLElBQUksQ0FBQ1gsb0JBQW9CLEdBQUcsY0FBY2EsUUFBUSxDQUFDLEVBQUUsR0FBRztvQkFDdks7b0JBQ0FVLFdBQVcsSUFBSSxDQUFDeEIsWUFBWSxFQUFFcUI7b0JBQzlCLDZEQUE2RDtvQkFDN0QsSUFBSSxDQUFDckIsWUFBWSxHQUFHcUI7b0JBQ3BCLGtGQUFrRjtvQkFDbEZILGNBQWM7Z0JBQ2xCO1lBQ0osT0FBTztnQkFDSCxJQUFJSSxZQUFZO29CQUNaLE1BQU0sSUFBSVYsTUFBTSx1REFBdURFLFFBQVEsQ0FBQyxFQUFFLEdBQUc7Z0JBQ3pGO2dCQUNBVSxXQUFXLElBQUksQ0FBQzNCLFFBQVEsRUFBRXdCO2dCQUMxQiw2REFBNkQ7Z0JBQzdELElBQUksQ0FBQ3hCLFFBQVEsR0FBR3dCO2dCQUNoQiwrRUFBK0U7Z0JBQy9FSCxjQUFjO1lBQ2xCO1FBQ0o7UUFDQSxpRkFBaUY7UUFDakYsSUFBSSxDQUFDLElBQUksQ0FBQ3hCLFFBQVEsQ0FBQ29DLEdBQUcsQ0FBQ1osY0FBYztZQUNqQyxJQUFJLENBQUN4QixRQUFRLENBQUNxQyxHQUFHLENBQUNiLGFBQWEsSUFBSW5DO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDVyxRQUFRLENBQUNiLEdBQUcsQ0FBQ3FDLGFBQWFoQyxPQUFPLENBQUM0QixTQUFTSCxLQUFLLENBQUMsSUFBSUksV0FBV0M7SUFDekU7SUFDQWdCLGFBQWE7UUFDVCxJQUFJLENBQUN2QixXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDZixRQUFRLEdBQUcsSUFBSXVDO1FBQ3BCLElBQUksQ0FBQ3BDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNHLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLG9CQUFvQixHQUFHO0lBQ2hDO0FBQ0o7QUFDQSxTQUFTbkIsZ0JBQWdCb0QsZUFBZTtJQUNwQyxrRkFBa0Y7SUFDbEYsNEVBQTRFO0lBQzVFLDJDQUEyQztJQUMzQyx5RUFBeUU7SUFDekUsMkJBQTJCO0lBQzNCLG9DQUFvQztJQUNwQyw4RUFBOEU7SUFDOUUsd0VBQXdFO0lBQ3hFLGdIQUFnSDtJQUNoSCw0RUFBNEU7SUFDNUUsTUFBTUMsT0FBTyxJQUFJcEQ7SUFDakIsNkZBQTZGO0lBQzdGbUQsZ0JBQWdCUCxPQUFPLENBQUMsQ0FBQ1MsV0FBV0QsS0FBS25ELE1BQU0sQ0FBQ29EO0lBQ2hELDRHQUE0RztJQUM1RyxPQUFPRCxLQUFLN0MsTUFBTTtBQUN0QixFQUVBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3NvcnRlZC1yb3V0ZXMuanM/MmY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFNvcnRlZFJvdXRlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0U29ydGVkUm91dGVzO1xuICAgIH1cbn0pO1xuY2xhc3MgVXJsTm9kZSB7XG4gICAgaW5zZXJ0KHVybFBhdGgpIHtcbiAgICAgICAgdGhpcy5faW5zZXJ0KHVybFBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKSwgW10sIGZhbHNlKTtcbiAgICB9XG4gICAgc21vb3NoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc21vb3NoKCk7XG4gICAgfVxuICAgIF9zbW9vc2gocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgcHJlZml4ID0gXCIvXCI7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUGF0aHMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmNoaWxkcmVuLmtleXMoKVxuICAgICAgICBdLnNvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuc2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIltdXCIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIlsuLi5dXCIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW5QYXRocy5zcGxpY2UoY2hpbGRyZW5QYXRocy5pbmRleE9mKFwiW1suLi5dXVwiKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGVzID0gY2hpbGRyZW5QYXRocy5tYXAoKGMpPT50aGlzLmNoaWxkcmVuLmdldChjKS5fc21vb3NoKFwiXCIgKyBwcmVmaXggKyBjICsgXCIvXCIpKS5yZWR1Y2UoKHByZXYsIGN1cnIpPT5bXG4gICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICAuLi5jdXJyXG4gICAgICAgICAgICBdLCBbXSk7XG4gICAgICAgIGlmICh0aGlzLnNsdWdOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb3V0ZXMucHVzaCguLi50aGlzLmNoaWxkcmVuLmdldChcIltdXCIpLl9zbW9vc2gocHJlZml4ICsgXCJbXCIgKyB0aGlzLnNsdWdOYW1lICsgXCJdL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBjb25zdCByID0gcHJlZml4ID09PSBcIi9cIiA/IFwiL1wiIDogcHJlZml4LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgZGVmaW5lIGEgcm91dGUgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2l0eSBhcyBhIG9wdGlvbmFsIGNhdGNoLWFsbCByb3V0ZSAoXCInICsgciArICdcIiBhbmQgXCInICsgciArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyAnXV1cIikuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZXMudW5zaGlmdChyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KFwiWy4uLl1cIikuX3Ntb29zaChwcmVmaXggKyBcIlsuLi5cIiArIHRoaXMucmVzdFNsdWdOYW1lICsgXCJdL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KFwiW1suLi5dXVwiKS5fc21vb3NoKHByZWZpeCArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyBcIl1dL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlcztcbiAgICB9XG4gICAgX2luc2VydCh1cmxQYXRocywgc2x1Z05hbWVzLCBpc0NhdGNoQWxsKSB7XG4gICAgICAgIGlmICh1cmxQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYXRjaEFsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2F0Y2gtYWxsIG11c3QgYmUgdGhlIGxhc3QgcGFydCBvZiB0aGUgVVJMLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbmV4dCBzZWdtZW50IGluIHRoZSB1cmxQYXRocyBsaXN0XG4gICAgICAgIGxldCBuZXh0U2VnbWVudCA9IHVybFBhdGhzWzBdO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2VnbWVudCBtYXRjaGVzIGBbc29tZXRoaW5nXWBcbiAgICAgICAgaWYgKG5leHRTZWdtZW50LnN0YXJ0c1dpdGgoXCJbXCIpICYmIG5leHRTZWdtZW50LmVuZHNXaXRoKFwiXVwiKSkge1xuICAgICAgICAgICAgLy8gU3RyaXAgYFtgIGFuZCBgXWAsIGxlYXZpbmcgb25seSBgc29tZXRoaW5nYFxuICAgICAgICAgICAgbGV0IHNlZ21lbnROYW1lID0gbmV4dFNlZ21lbnQuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgbGV0IGlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSAmJiBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBvcHRpb25hbCBgW2AgYW5kIGBdYCwgbGVhdmluZyBvbmx5IGBzb21ldGhpbmdgXG4gICAgICAgICAgICAgICAgc2VnbWVudE5hbWUgPSBzZWdtZW50TmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIi4uLlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGAuLi5gLCBsZWF2aW5nIG9ubHkgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgICAgICBzZWdtZW50TmFtZSA9IHNlZ21lbnROYW1lLnN1YnN0cmluZygzKTtcbiAgICAgICAgICAgICAgICBpc0NhdGNoQWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSB8fCBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgb3IgZW5kIHdpdGggZXh0cmEgYnJhY2tldHMgKCdcIiArIHNlZ21lbnROYW1lICsgXCInKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgd2l0aCBlcnJvbmVvdXMgcGVyaW9kcyAoJ1wiICsgc2VnbWVudE5hbWUgKyBcIicpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVNsdWcocHJldmlvdXNTbHVnLCBuZXh0U2x1Zykge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1NsdWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNwZWNpZmljIHNlZ21lbnQgYWxyZWFkeSBoYXMgYSBzbHVnIGJ1dCB0aGUgc2x1ZyBpcyBub3QgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBjb2xsaXNpb25zIGxpa2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhZ2VzL1twb3N0XS9pbmRleC5qc1xuICAgICAgICAgICAgICAgICAgICAvLyBwYWdlcy9baWRdL2luZGV4LmpzXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgY3VycmVudGx5IG11bHRpcGxlIGR5bmFtaWMgcGFyYW1zIG9uIHRoZSBzYW1lIHNlZ21lbnQgbGV2ZWwgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU2x1ZyAhPT0gbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXJyb3Igc2VlbXMgdG8gYmUgY29uZnVzaW5nIGZvciB1c2VycywgbmVlZHMgYW4gZXJyb3IgbGluaywgdGhlIGRlc2NyaXB0aW9uIGNhbiBiZSBiYXNlZCBvbiBhYm92ZSBjb21tZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCB1c2UgZGlmZmVyZW50IHNsdWcgbmFtZXMgZm9yIHRoZSBzYW1lIGR5bmFtaWMgcGF0aCAoJ1wiICsgcHJldmlvdXNTbHVnICsgXCInICE9PSAnXCIgKyBuZXh0U2x1ZyArIFwiJykuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5mb3JFYWNoKChzbHVnKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2x1ZyA9PT0gbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBoYXZlIHRoZSBzYW1lIHNsdWcgbmFtZSBcIicgKyBuZXh0U2x1ZyArICdcIiByZXBlYXQgd2l0aGluIGEgc2luZ2xlIGR5bmFtaWMgcGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbHVnLnJlcGxhY2UoL1xcVy9nLCBcIlwiKSA9PT0gbmV4dFNlZ21lbnQucmVwbGFjZSgvXFxXL2csIFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgaGF2ZSB0aGUgc2x1ZyBuYW1lcyBcIicgKyBzbHVnICsgJ1wiIGFuZCBcIicgKyBuZXh0U2x1ZyArICdcIiBkaWZmZXIgb25seSBieSBub24td29yZCBzeW1ib2xzIHdpdGhpbiBhIHNpbmdsZSBkeW5hbWljIHBhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5wdXNoKG5leHRTbHVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1c2UgYm90aCBhbiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgY2F0Y2gtYWxsIHJvdXRlIGF0IHRoZSBzYW1lIGxldmVsIChcIlsuLi4nICsgdGhpcy5yZXN0U2x1Z05hbWUgKyAnXVwiIGFuZCBcIicgKyB1cmxQYXRoc1swXSArICdcIiApLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgPSBzZWdtZW50TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gW1suLi5dXSBzbyB0aGF0IGl0IGNhbiBsYXRlciBiZSBzb3J0ZWQgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbWy4uLl1dXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBib3RoIGFuIG9wdGlvbmFsIGFuZCByZXF1aXJlZCBjYXRjaC1hbGwgcm91dGUgYXQgdGhlIHNhbWUgbGV2ZWwgKFwiW1suLi4nICsgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSArICddXVwiIGFuZCBcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2x1Zyh0aGlzLnJlc3RTbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHRTZWdtZW50IGlzIG92ZXJ3cml0dGVuIHRvIFsuLi5dIHNvIHRoYXQgaXQgY2FuIGxhdGVyIGJlIHNvcnRlZCBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNlZ21lbnQgPSBcIlsuLi5dXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbmFsIHJvdXRlIHBhcmFtZXRlcnMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIChcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5zbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIHNsdWdOYW1lIGlzIGtlcHQgYXMgaXQgY2FuIG9ubHkgYmUgb25lIHBhcnRpY3VsYXIgc2x1Z05hbWVcbiAgICAgICAgICAgICAgICB0aGlzLnNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gW10gc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgc29ydGVkIHNwZWNpZmljYWxseVxuICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgVXJsTm9kZSBkb2Vzbid0IGhhdmUgdGhlIG5leHRTZWdtZW50IHlldCB3ZSBjcmVhdGUgYSBuZXcgY2hpbGQgVXJsTm9kZVxuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4uaGFzKG5leHRTZWdtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zZXQobmV4dFNlZ21lbnQsIG5ldyBVcmxOb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZ2V0KG5leHRTZWdtZW50KS5faW5zZXJ0KHVybFBhdGhzLnNsaWNlKDEpLCBzbHVnTmFtZXMsIGlzQ2F0Y2hBbGwpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zbHVnTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U29ydGVkUm91dGVzKG5vcm1hbGl6ZWRQYWdlcykge1xuICAgIC8vIEZpcnN0IHRoZSBVcmxOb2RlIGlzIGNyZWF0ZWQsIGFuZCBldmVyeSBVcmxOb2RlIGNhbiBoYXZlIG9ubHkgMSBkeW5hbWljIHNlZ21lbnRcbiAgICAvLyBFZyB5b3UgY2FuJ3QgaGF2ZSBwYWdlcy9bcG9zdF0vYWJjLmpzIGFuZCBwYWdlcy9baGVsbG9dL3NvbWV0aGluZy1lbHNlLmpzXG4gICAgLy8gT25seSAxIGR5bmFtaWMgc2VnbWVudCBwZXIgbmVzdGluZyBsZXZlbFxuICAgIC8vIFNvIGluIHRoZSBjYXNlIHRoYXQgaXMgdGVzdC9pbnRlZ3JhdGlvbi9keW5hbWljLXJvdXRpbmcgaXQnbGwgYmUgdGhpczpcbiAgICAvLyBwYWdlcy9bcG9zdF0vY29tbWVudHMuanNcbiAgICAvLyBwYWdlcy9ibG9nL1twb3N0XS9jb21tZW50L1tpZF0uanNcbiAgICAvLyBCb3RoIGFyZSBmaW5lIGJlY2F1c2UgYHBhZ2VzL1twb3N0XWAgYW5kIGBwYWdlcy9ibG9nYCBhcmUgb24gdGhlIHNhbWUgbGV2ZWxcbiAgICAvLyBTbyBpbiB0aGlzIGNhc2UgYFVybE5vZGVgIGNyZWF0ZWQgaGVyZSBoYXMgYHRoaXMuc2x1Z05hbWUgPT09ICdwb3N0J2BcbiAgICAvLyBBbmQgc2luY2UgeW91ciBQUiBwYXNzZWQgdGhyb3VnaCBgc2x1Z05hbWVgIGFzIGFuIGFycmF5IGJhc2ljYWxseSBpdCdkIGluY2x1ZGluZyBpdCBpbiB0b28gbWFueSBwb3NzaWJpbGl0aWVzXG4gICAgLy8gSW5zdGVhZCB3aGF0IGhhcyB0byBiZSBwYXNzZWQgdGhyb3VnaCBpcyB0aGUgdXB3YXJkcyBwYXRoJ3MgZHluYW1pYyBuYW1lc1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgVXJsTm9kZSgpO1xuICAgIC8vIEhlcmUgdGhlIGByb290YCBnZXRzIGluamVjdGVkIG11bHRpcGxlIHBhdGhzLCBhbmQgaW5zZXJ0IHdpbGwgYnJlYWsgdGhlbSB1cCBpbnRvIHN1YmxldmVsc1xuICAgIG5vcm1hbGl6ZWRQYWdlcy5mb3JFYWNoKChwYWdlUGF0aCk9PnJvb3QuaW5zZXJ0KHBhZ2VQYXRoKSk7XG4gICAgLy8gU21vb3NoIHdpbGwgdGhlbiBzb3J0IHRob3NlIHN1YmxldmVscyB1cCB0byB0aGUgcG9pbnQgd2hlcmUgeW91IGdldCB0aGUgY29ycmVjdCByb3V0ZSBkZWZpbml0aW9uIHByaW9yaXR5XG4gICAgcmV0dXJuIHJvb3Quc21vb3NoKCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRlZC1yb3V0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldFNvcnRlZFJvdXRlcyIsIlVybE5vZGUiLCJpbnNlcnQiLCJ1cmxQYXRoIiwiX2luc2VydCIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInNtb29zaCIsIl9zbW9vc2giLCJwcmVmaXgiLCJjaGlsZHJlblBhdGhzIiwiY2hpbGRyZW4iLCJrZXlzIiwic29ydCIsInNsdWdOYW1lIiwic3BsaWNlIiwiaW5kZXhPZiIsInJlc3RTbHVnTmFtZSIsIm9wdGlvbmFsUmVzdFNsdWdOYW1lIiwicm91dGVzIiwibWFwIiwiYyIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwicHVzaCIsInBsYWNlaG9sZGVyIiwiciIsInNsaWNlIiwiRXJyb3IiLCJ1bnNoaWZ0IiwidXJsUGF0aHMiLCJzbHVnTmFtZXMiLCJpc0NhdGNoQWxsIiwibGVuZ3RoIiwibmV4dFNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzZWdtZW50TmFtZSIsImlzT3B0aW9uYWwiLCJzdWJzdHJpbmciLCJoYW5kbGVTbHVnIiwicHJldmlvdXNTbHVnIiwibmV4dFNsdWciLCJmb3JFYWNoIiwic2x1ZyIsInJlcGxhY2UiLCJoYXMiLCJzZXQiLCJjb25zdHJ1Y3RvciIsIk1hcCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    DecodeError: function() {\n        return DecodeError;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== \"undefined\";\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.name = \"PageNotFoundError\";\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQWtCTjtBQUNBLFNBQVNrQixRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJeEIsT0FBT0MsY0FBYyxDQUFDc0IsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRcEIsU0FBUztJQUNiRyxZQUFZO1FBQ1IsT0FBT0E7SUFDWDtJQUNBQyxVQUFVO1FBQ04sT0FBT0E7SUFDWDtJQUNBQyxlQUFlO1FBQ1gsT0FBT0E7SUFDWDtJQUNBQyxtQkFBbUI7UUFDZixPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsMEJBQTBCO1FBQ3RCLE9BQU9BO0lBQ1g7SUFDQUMscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsSUFBSTtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsSUFBSTtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsYUFBYTtRQUNULE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxtQkFBbUI7UUFDZixPQUFPQTtJQUNYO0lBQ0FDLG1CQUFtQjtRQUNmLE9BQU9BO0lBQ1g7SUFDQUMseUJBQXlCO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTWhCLGFBQWE7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELFNBQVNDLFNBQVNzQixFQUFFO0lBQ2hCLElBQUlDLE9BQU87SUFDWCxJQUFJQztJQUNKLE9BQU87UUFDSCxJQUFJLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQU87WUFDbkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7UUFDaEM7UUFDQSxJQUFJLENBQUNQLE1BQU07WUFDUEEsT0FBTztZQUNQQyxTQUFTRixNQUFNTTtRQUNuQjtRQUNBLE9BQU9KO0lBQ1g7QUFDSjtBQUNBLDBEQUEwRDtBQUMxRCxnRUFBZ0U7QUFDaEUsTUFBTU8scUJBQXFCO0FBQzNCLE1BQU05QixnQkFBZ0IsQ0FBQytCLE1BQU1ELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUNyRCxTQUFTOUI7SUFDTCxNQUFNLEVBQUVnQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFLEdBQUdDLE9BQU9DLFFBQVE7SUFDcEQsT0FBT0osV0FBVyxPQUFPQyxXQUFZQyxDQUFBQSxPQUFPLE1BQU1BLE9BQU8sRUFBQztBQUM5RDtBQUNBLFNBQVNqQztJQUNMLE1BQU0sRUFBRW9DLElBQUksRUFBRSxHQUFHRixPQUFPQyxRQUFRO0lBQ2hDLE1BQU1FLFNBQVN0QztJQUNmLE9BQU9xQyxLQUFLRSxTQUFTLENBQUNELE9BQU9iLE1BQU07QUFDdkM7QUFDQSxTQUFTdkIsZUFBZXNDLFNBQVM7SUFDN0IsT0FBTyxPQUFPQSxjQUFjLFdBQVdBLFlBQVlBLFVBQVVDLFdBQVcsSUFBSUQsVUFBVXZCLElBQUksSUFBSTtBQUNsRztBQUNBLFNBQVNkLFVBQVV1QyxHQUFHO0lBQ2xCLE9BQU9BLElBQUlDLFFBQVEsSUFBSUQsSUFBSUUsV0FBVztBQUMxQztBQUNBLFNBQVN4Qyx5QkFBeUIwQixHQUFHO0lBQ2pDLE1BQU1lLFdBQVdmLElBQUlnQixLQUFLLENBQUM7SUFDM0IsTUFBTUMsYUFBYUYsUUFBUSxDQUFDLEVBQUU7SUFDOUIsT0FBT0UsV0FBVSw0REFBNEQ7SUFDN0UsMENBQTBDO0tBQ3pDQyxPQUFPLENBQUMsT0FBTyxLQUFLQSxPQUFPLENBQUMsVUFBVSxPQUFRSCxDQUFBQSxRQUFRLENBQUMsRUFBRSxHQUFHLE1BQU1BLFNBQVNJLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUMsT0FBTyxFQUFDO0FBQ3RHO0FBQ0EsZUFBZTdDLG9CQUFvQjhDLEdBQUcsRUFBRUMsR0FBRztJQUN2QyxJQUFJQyxJQUFxQyxFQUFFO1FBQ3ZDLElBQUlDO1FBQ0osSUFBSSxDQUFDQSxpQkFBaUJILElBQUlJLFNBQVMsS0FBSyxPQUFPLEtBQUssSUFBSUQsZUFBZUUsZUFBZSxFQUFFO1lBQ3BGLE1BQU1DLFVBQVUsTUFBTXZELGVBQWVpRCxPQUFPO1lBQzVDLE1BQU0sSUFBSU8sTUFBTUQ7UUFDcEI7SUFDSjtJQUNBLGlEQUFpRDtJQUNqRCxNQUFNZixNQUFNVSxJQUFJVixHQUFHLElBQUlVLElBQUlBLEdBQUcsSUFBSUEsSUFBSUEsR0FBRyxDQUFDVixHQUFHO0lBQzdDLElBQUksQ0FBQ1MsSUFBSUssZUFBZSxFQUFFO1FBQ3RCLElBQUlKLElBQUlBLEdBQUcsSUFBSUEsSUFBSVosU0FBUyxFQUFFO1lBQzFCLCtCQUErQjtZQUMvQixPQUFPO2dCQUNIbUIsV0FBVyxNQUFNdEQsb0JBQW9CK0MsSUFBSVosU0FBUyxFQUFFWSxJQUFJQSxHQUFHO1lBQy9EO1FBQ0o7UUFDQSxPQUFPLENBQUM7SUFDWjtJQUNBLE1BQU1RLFFBQVEsTUFBTVQsSUFBSUssZUFBZSxDQUFDSjtJQUN4QyxJQUFJVixPQUFPdkMsVUFBVXVDLE1BQU07UUFDdkIsT0FBT2tCO0lBQ1g7SUFDQSxJQUFJLENBQUNBLE9BQU87UUFDUixNQUFNSCxVQUFVLE1BQU12RCxlQUFlaUQsT0FBTyxpRUFBaUVTLFFBQVE7UUFDckgsTUFBTSxJQUFJRixNQUFNRDtJQUNwQjtJQUNBLElBQUlKLElBQXFDLEVBQUU7UUFDdkMsSUFBSTdELE9BQU9xRSxJQUFJLENBQUNELE9BQU9uQyxNQUFNLEtBQUssS0FBSyxDQUFDMkIsSUFBSUEsR0FBRyxFQUFFO1lBQzdDVSxRQUFRQyxJQUFJLENBQUMsS0FBSzdELGVBQWVpRCxPQUFPO1FBQzVDO0lBQ0o7SUFDQSxPQUFPUztBQUNYO0FBQ0EsTUFBTXRELEtBQUssT0FBTzBELGdCQUFnQjtBQUNsQyxNQUFNekQsS0FBS0QsTUFBTTtJQUNiO0lBQ0E7SUFDQTtDQUNILENBQUMyRCxLQUFLLENBQUMsQ0FBQ0MsU0FBUyxPQUFPRixXQUFXLENBQUNFLE9BQU8sS0FBSztBQUNqRCxNQUFNMUQsb0JBQW9Ca0Q7QUFDMUI7QUFDQSxNQUFNakQsdUJBQXVCaUQ7QUFDN0I7QUFDQSxNQUFNaEQsMEJBQTBCZ0Q7SUFDNUJTLFlBQVlDLElBQUksQ0FBQztRQUNiLEtBQUs7UUFDTCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3BELElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3dDLE9BQU8sR0FBRyxrQ0FBa0NXO0lBQ3JEO0FBQ0o7QUFDQSxNQUFNekQsMEJBQTBCK0M7SUFDNUJTLFlBQVlDLElBQUksRUFBRVgsT0FBTyxDQUFDO1FBQ3RCLEtBQUs7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBRywwQ0FBMENXLE9BQU8sTUFBTVg7SUFDMUU7QUFDSjtBQUNBLE1BQU03QyxnQ0FBZ0M4QztJQUNsQ1MsYUFBYTtRQUNULEtBQUs7UUFDTCxJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1osT0FBTyxHQUFHO0lBQ25CO0FBQ0o7QUFDQSxTQUFTNUMsZUFBZXlELEtBQUs7SUFDekIsT0FBT0MsS0FBS0MsU0FBUyxDQUFDO1FBQ2xCZixTQUFTYSxNQUFNYixPQUFPO1FBQ3RCZ0IsT0FBT0gsTUFBTUcsS0FBSztJQUN0QjtBQUNKLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcz9lN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgV0VCX1ZJVEFMUzogbnVsbCxcbiAgICBleGVjT25jZTogbnVsbCxcbiAgICBpc0Fic29sdXRlVXJsOiBudWxsLFxuICAgIGdldExvY2F0aW9uT3JpZ2luOiBudWxsLFxuICAgIGdldFVSTDogbnVsbCxcbiAgICBnZXREaXNwbGF5TmFtZTogbnVsbCxcbiAgICBpc1Jlc1NlbnQ6IG51bGwsXG4gICAgbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzOiBudWxsLFxuICAgIGxvYWRHZXRJbml0aWFsUHJvcHM6IG51bGwsXG4gICAgU1A6IG51bGwsXG4gICAgU1Q6IG51bGwsXG4gICAgRGVjb2RlRXJyb3I6IG51bGwsXG4gICAgTm9ybWFsaXplRXJyb3I6IG51bGwsXG4gICAgUGFnZU5vdEZvdW5kRXJyb3I6IG51bGwsXG4gICAgTWlzc2luZ1N0YXRpY1BhZ2U6IG51bGwsXG4gICAgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I6IG51bGwsXG4gICAgc3RyaW5naWZ5RXJyb3I6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgV0VCX1ZJVEFMUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBXRUJfVklUQUxTO1xuICAgIH0sXG4gICAgZXhlY09uY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXhlY09uY2U7XG4gICAgfSxcbiAgICBpc0Fic29sdXRlVXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzb2x1dGVVcmw7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbk9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRMb2NhdGlvbk9yaWdpbjtcbiAgICB9LFxuICAgIGdldFVSTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRVUkw7XG4gICAgfSxcbiAgICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZTtcbiAgICB9LFxuICAgIGlzUmVzU2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc1Jlc1NlbnQ7XG4gICAgfSxcbiAgICBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzO1xuICAgIH0sXG4gICAgbG9hZEdldEluaXRpYWxQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzO1xuICAgIH0sXG4gICAgU1A6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1A7XG4gICAgfSxcbiAgICBTVDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTVDtcbiAgICB9LFxuICAgIERlY29kZUVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERlY29kZUVycm9yO1xuICAgIH0sXG4gICAgTm9ybWFsaXplRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTm9ybWFsaXplRXJyb3I7XG4gICAgfSxcbiAgICBQYWdlTm90Rm91bmRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYWdlTm90Rm91bmRFcnJvcjtcbiAgICB9LFxuICAgIE1pc3NpbmdTdGF0aWNQYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1pc3NpbmdTdGF0aWNQYWdlO1xuICAgIH0sXG4gICAgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I7XG4gICAgfSxcbiAgICBzdHJpbmdpZnlFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlFcnJvcjtcbiAgICB9XG59KTtcbmNvbnN0IFdFQl9WSVRBTFMgPSBbXG4gICAgXCJDTFNcIixcbiAgICBcIkZDUFwiLFxuICAgIFwiRklEXCIsXG4gICAgXCJJTlBcIixcbiAgICBcIkxDUFwiLFxuICAgIFwiVFRGQlwiXG5dO1xuZnVuY3Rpb24gZXhlY09uY2UoZm4pIHtcbiAgICBsZXQgdXNlZCA9IGZhbHNlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgICAgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG4vLyBTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4vLyBBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi87XG5jb25zdCBpc0Fic29sdXRlVXJsID0gKHVybCk9PkFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KHVybCk7XG5mdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBwcm90b2NvbCArIFwiLy9cIiArIGhvc3RuYW1lICsgKHBvcnQgPyBcIjpcIiArIHBvcnQgOiBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKENvbXBvbmVudCkge1xuICAgIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiID8gQ29tcG9uZW50IDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiVW5rbm93blwiO1xufVxuZnVuY3Rpb24gaXNSZXNTZW50KHJlcykge1xuICAgIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybCkge1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KFwiP1wiKTtcbiAgICBjb25zdCB1cmxOb1F1ZXJ5ID0gdXJsUGFydHNbMF07XG4gICAgcmV0dXJuIHVybE5vUXVlcnkvLyBmaXJzdCB3ZSByZXBsYWNlIGFueSBub24tZW5jb2RlZCBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmRcbiAgICAvLyB0aGVuIG5vcm1hbGl6ZSByZXBlYXRlZCBmb3J3YXJkIHNsYXNoZXNcbiAgICAucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIikgKyAodXJsUGFydHNbMV0gPyBcIj9cIiArIHVybFBhcnRzLnNsaWNlKDEpLmpvaW4oXCI/XCIpIDogXCJcIik7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgY3R4KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YXIgX0FwcF9wcm90b3R5cGU7XG4gICAgICAgIGlmICgoX0FwcF9wcm90b3R5cGUgPSBBcHAucHJvdG90eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX0FwcF9wcm90b3R5cGUuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1wiJyArIGdldERpc3BsYXlOYW1lKEFwcCkgKyAnLmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gICAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCBjdHguY3R4ICYmIGN0eC5jdHgucmVzO1xuICAgIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgICAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpO1xuICAgIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnXCInICsgZ2V0RGlzcGxheU5hbWUoQXBwKSArICcuZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIicgKyBwcm9wcyArICdcIiBpbnN0ZWFkLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXCIgKyBnZXREaXNwbGF5TmFtZShBcHApICsgXCIgcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gYGdldEluaXRpYWxQcm9wc2AuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5jb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IFNUID0gU1AgJiYgW1xuICAgIFwibWFya1wiLFxuICAgIFwibWVhc3VyZVwiLFxuICAgIFwiZ2V0RW50cmllc0J5TmFtZVwiXG5dLmV2ZXJ5KChtZXRob2QpPT50eXBlb2YgcGVyZm9ybWFuY2VbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiKTtcbmNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuY2xhc3MgTm9ybWFsaXplRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5jbGFzcyBQYWdlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYWdlKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFTk9FTlRcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJQYWdlTm90Rm91bmRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkNhbm5vdCBmaW5kIG1vZHVsZSBmb3IgcGFnZTogXCIgKyBwYWdlO1xuICAgIH1cbn1cbmNsYXNzIE1pc3NpbmdTdGF0aWNQYWdlIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhZ2UsIG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkZhaWxlZCB0byBsb2FkIHN0YXRpYyBmaWxlIGZvciBwYWdlOiBcIiArIHBhZ2UgKyBcIiBcIiArIG1lc3NhZ2U7XG4gICAgfVxufVxuY2xhc3MgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFTk9FTlRcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJDYW5ub3QgZmluZCB0aGUgbWlkZGxld2FyZSBtb2R1bGVcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJXRUJfVklUQUxTIiwiZXhlY09uY2UiLCJpc0Fic29sdXRlVXJsIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJnZXRVUkwiLCJnZXREaXNwbGF5TmFtZSIsImlzUmVzU2VudCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJTUCIsIlNUIiwiRGVjb2RlRXJyb3IiLCJOb3JtYWxpemVFcnJvciIsIlBhZ2VOb3RGb3VuZEVycm9yIiwiTWlzc2luZ1N0YXRpY1BhZ2UiLCJNaWRkbGV3YXJlTm90Rm91bmRFcnJvciIsInN0cmluZ2lmeUVycm9yIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJ1cmwiLCJ0ZXN0IiwicHJvdG9jb2wiLCJob3N0bmFtZSIsInBvcnQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJvcmlnaW4iLCJzdWJzdHJpbmciLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsInJlcyIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJ1cmxQYXJ0cyIsInNwbGl0IiwidXJsTm9RdWVyeSIsInJlcGxhY2UiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJwcm9jZXNzIiwiX0FwcF9wcm90b3R5cGUiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInBlcmZvcm1hbmNlIiwiZXZlcnkiLCJtZXRob2QiLCJjb25zdHJ1Y3RvciIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/profile/page.tsx":
/*!**********************************!*\
  !*** ./src/app/profile/page.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ProfilePage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_ui_button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/ui/button */ \"(app-pages-browser)/./src/components/ui/button.tsx\");\n/* harmony import */ var _components_ui_card__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/ui/card */ \"(app-pages-browser)/./src/components/ui/card.tsx\");\n/* harmony import */ var _components_ui_avatar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/ui/avatar */ \"(app-pages-browser)/./src/components/ui/avatar.tsx\");\n/* harmony import */ var _components_ui_badge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/ui/badge */ \"(app-pages-browser)/./src/components/ui/badge.tsx\");\n/* harmony import */ var _components_ui_input__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/ui/input */ \"(app-pages-browser)/./src/components/ui/input.tsx\");\n/* harmony import */ var _components_ui_textarea__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/ui/textarea */ \"(app-pages-browser)/./src/components/ui/textarea.tsx\");\n/* harmony import */ var _barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Edit2,FileText,MapPin,Upload,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/camera.js\");\n/* harmony import */ var _barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Edit2,FileText,MapPin,Upload,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/pen.js\");\n/* harmony import */ var _barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Edit2,FileText,MapPin,Upload,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/map-pin.js\");\n/* harmony import */ var _barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Edit2,FileText,MapPin,Upload,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\");\n/* harmony import */ var _barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Edit2,FileText,MapPin,Upload,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/file-text.js\");\n/* harmony import */ var _barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! __barrel_optimize__?names=Camera,Edit2,FileText,MapPin,Upload,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/upload.js\");\n/* harmony import */ var _clerk_clerk_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @clerk/clerk-react */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/index.mjs\");\n/* harmony import */ var pdfjs_dist__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! pdfjs-dist */ \"(app-pages-browser)/./node_modules/pdfjs-dist/build/pdf.mjs\");\n/* harmony import */ var _components_NavBar__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/components/NavBar */ \"(app-pages-browser)/./src/components/NavBar.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\nconst API_BASE_URL = \"https://h1bbackend.azurewebsites.net/api\";\n// Initialize PDF.js worker\npdfjs_dist__WEBPACK_IMPORTED_MODULE_9__.GlobalWorkerOptions.workerSrc = \"https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.worker.mjs\";\nfunction ProfilePage() {\n    _s();\n    const { isSignedIn } = (0,_clerk_clerk_react__WEBPACK_IMPORTED_MODULE_8__.useAuth)();\n    const [bio, setBio] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Passionate developer with a knack for creating efficient and scalable web applications. Always eager to learn new technologies and solve complex problems.\");\n    const [isEditingBio, setIsEditingBio] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [skills, setSkills] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        \"React\",\n        \"Node.js\",\n        \"TypeScript\",\n        \"GraphQL\",\n        \"AWS\"\n    ]);\n    const [isEditingSkills, setIsEditingSkills] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [newSkill, setNewSkill] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Add a skill\");\n    const [about, setAbout] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Your About Section. Write a brief description about yourself.\");\n    const [isEditingAbout, setIsEditingAbout] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [resumeFile, setResumeFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [uploadTime, setUploadTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [jobTitle, setJobTitle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Update your Job Title\");\n    const [city, setCity] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Update your location\");\n    const [isEditingJobTitle, setIsEditingJobTitle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isEditingCity, setIsEditingCity] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [pdfContent, setPdfContent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [isLoadingPdf, setIsLoadingPdf] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [name, setName] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"FirstName LastName\");\n    const [profilePictureLink, setProfilePictureLink] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [isEditingProfilePicture, setIsEditingProfilePicture] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [resumeUploadedDate, setResumeUploadedDate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // references for file inputs\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const profilePictureInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    async function getContent(src) {\n        const doc = await pdfjs_dist__WEBPACK_IMPORTED_MODULE_9__.getDocument({\n            data: src\n        }).promise;\n        const page = await doc.getPage(1);\n        return await page.getTextContent();\n    }\n    async function getItems(src) {\n        const content = await getContent(src);\n        let fullText = \"\";\n        content.items.forEach((item)=>{\n            if (item.str) {\n                fullText += item.str + \" \";\n            }\n        });\n        return fullText.trim();\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        getUserData();\n    }, []);\n    const getUserData = async ()=>{\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/profile\"), {\n            credentials: \"include\"\n        });\n        if (!response.ok) {\n            console.error(\"Error fetching user data\");\n            return;\n        }\n        const data = await response.json();\n        console.log(\"The data is \" + JSON.stringify(data));\n        if (data.resume_uploaded_date) {\n            setResumeUploadedDate(data.resume_uploaded_date);\n        } else {\n            setResumeUploadedDate(\"\");\n        }\n        setName(data.name.split(\" \").map((word)=>word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(\" \"));\n        setJobTitle(data.title);\n        setCity(data.location);\n        // setSkills(data.skills);\n        setBio(data.bio);\n        setAbout(data.about);\n        // setPdfContent(data.resume);\n        setProfilePictureLink(data.profile_picture_link);\n    };\n    const handleResumeUpload = async (event)=>{\n        var _event_target_files;\n        const file = (_event_target_files = event.target.files) === null || _event_target_files === void 0 ? void 0 : _event_target_files[0];\n        if (file) {\n            if (file.type === \"application/pdf\") {\n                setResumeFile(file);\n                setUploadTime(new Date().toLocaleString());\n                setIsLoadingPdf(true);\n                try {\n                    const arrayBuffer = await file.arrayBuffer();\n                    const text = await getItems(arrayBuffer);\n                    console.log(\"The text is \" + text);\n                    setPdfContent(text);\n                    //set the extracted pdf content to the database\n                    const response = await fetch(\"\".concat(API_BASE_URL, \"/resume\"), {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            resume: text\n                        }),\n                        credentials: \"include\"\n                    });\n                    if (response.ok) {\n                        alert(\"Resume uploaded successfully\");\n                    } else {\n                        alert(\"Error uploading resume. Please try again.\");\n                    }\n                } catch (error) {\n                    console.error(\"Error reading PDF:\", error);\n                    alert(\"Error reading PDF file. Please try again.\");\n                } finally{\n                    setIsLoadingPdf(false);\n                }\n            } else {\n                alert(\"Please upload a PDF file\");\n            }\n        }\n    };\n    const handleProfilePictureUpload = async (event)=>{\n        var _event_target_files;\n        const file = (_event_target_files = event.target.files) === null || _event_target_files === void 0 ? void 0 : _event_target_files[0];\n        if (file) {\n            const formData = new FormData();\n            formData.append(\"profilePicture\", file);\n            try {\n                const response = await fetch(\"\".concat(API_BASE_URL, \"/upload-profile-picture\"), {\n                    method: \"POST\",\n                    body: formData,\n                    credentials: \"include\"\n                });\n                if (response.ok) {\n                    const data = await response.json();\n                    setProfilePictureLink(data.profilePictureLink);\n                    setIsEditingProfilePicture(false);\n                } else {\n                    alert(\"Error uploading profile picture. Please try again.\");\n                }\n            } catch (error) {\n                console.error(\"Error uploading profile picture:\", error);\n                alert(\"Error uploading profile picture. Please try again.\");\n            }\n        }\n    };\n    const triggerFileInputClick = ()=>{\n        var _fileInputRef_current;\n        (_fileInputRef_current = fileInputRef.current) === null || _fileInputRef_current === void 0 ? void 0 : _fileInputRef_current.click();\n    };\n    const triggerProfilePictureUpload = ()=>{\n        var _profilePictureInputRef_current;\n        (_profilePictureInputRef_current = profilePictureInputRef.current) === null || _profilePictureInputRef_current === void 0 ? void 0 : _profilePictureInputRef_current.click();\n    };\n    const handleAddSkill = async ()=>{\n        if (newSkill && !skills.includes(newSkill)) {\n            const updatedSkills = [\n                ...skills,\n                newSkill\n            ];\n            try {\n                // await updateUserProfile({ skills: updatedSkills });\n                setSkills(updatedSkills);\n                setNewSkill(\"\");\n            } catch (error) {\n                console.error(\"Error updating skills:\", error);\n                alert(\"Failed to update skills. Please try again.\");\n            }\n        }\n    };\n    const handleRemoveSkill = async (skillToRemove)=>{\n        const updatedSkills = skills.filter((skill)=>skill !== skillToRemove);\n        try {\n            // await updateUserProfile({ skills: updatedSkills });\n            setSkills(updatedSkills);\n        } catch (error) {\n            console.error(\"Error updating skills:\", error);\n            alert(\"Failed to update skills. Please try again.\");\n        }\n    };\n    const handleUpdateJobTitle = async (jobTitle)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/update-title\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    jobTitle: jobTitle\n                }),\n                credentials: \"include\"\n            });\n            if (response.ok) {\n                console.log(\"Successfully updated job title\");\n            } else {\n                alert(\"Error updating job title. Please try again.\");\n            }\n            setIsEditingJobTitle(false);\n        } catch (error) {\n            console.error(\"Error updating job title:\", error);\n            alert(\"Failed to update job title. Please try again.\");\n        }\n    };\n    const handleUpdateCity = async (city)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/update-location\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    location: city\n                }),\n                credentials: \"include\"\n            });\n            if (response.ok) {\n                console.log(\"Successfully updated the location\");\n            } else {\n                alert(\"Error updating job title. Please try again.\");\n            }\n            setIsEditingCity(false);\n        } catch (error) {\n            console.error(\"Error updating city:\", error);\n            alert(\"Failed to update city. Please try again.\");\n        }\n    };\n    const handleUpdateSkills = async (skills)=>{\n        try {\n            // await updateUserProfile({ skills });\n            setIsEditingSkills(false);\n        } catch (error) {\n            console.error(\"Error updating skills:\", error);\n            alert(\"Failed to update skills. Please try again.\");\n        }\n    };\n    const handleUpdateBio = async (bio)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/update-bio\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    bio: bio\n                }),\n                credentials: \"include\"\n            });\n            if (response.ok) {\n                console.log(\"Successfully updated users bio\");\n            } else {\n                alert(\"Error updating bio. Please try again.\");\n            }\n            setIsEditingBio(false);\n        } catch (error) {\n            console.error(\"Error updating bio:\", error);\n            alert(\"Failed to update bio. Please try again.\");\n        }\n    };\n    const handleUpdateAbout = async (about)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/update-about\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    about: about\n                }),\n                credentials: \"include\"\n            });\n            if (response.ok) {\n                console.log(\"Successfully updated about section\");\n            } else {\n                alert(\"Error updating About section. Please try again.\");\n            }\n            setIsEditingAbout(false);\n        } catch (error) {\n            console.error(\"Error updating about:\", error);\n            alert(\"Failed to update about section. Please try again.\");\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex \",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_NavBar__WEBPACK_IMPORTED_MODULE_10__.NavBar, {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                lineNumber: 316,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"ml-64 flex-1 p-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"container mx-auto space-y-6 w-[90%] md:w-[50%]\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.Card, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardHeader, {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex items-center space-x-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"relative\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_avatar__WEBPACK_IMPORTED_MODULE_4__.Avatar, {\n                                                        className: \"h-20 w-20 md:h-32 md:w-32\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_avatar__WEBPACK_IMPORTED_MODULE_4__.AvatarImage, {\n                                                                src: profilePictureLink,\n                                                                alt: \"Profile Picture\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 325,\n                                                                columnNumber: 21\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_avatar__WEBPACK_IMPORTED_MODULE_4__.AvatarFallback, {\n                                                                children: name.split(\" \").map((n)=>n[0]).join(\"\")\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 329,\n                                                                columnNumber: 21\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 324,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                        variant: \"secondary\",\n                                                        size: \"icon\",\n                                                        className: \"absolute bottom-0 right-0\",\n                                                        onClick: triggerProfilePictureUpload,\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                                className: \"h-4 w-4\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 342,\n                                                                columnNumber: 21\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                className: \"sr-only\",\n                                                                children: \"Change profile picture\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 343,\n                                                                columnNumber: 21\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 336,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_input__WEBPACK_IMPORTED_MODULE_6__.Input, {\n                                                        ref: profilePictureInputRef,\n                                                        type: \"file\",\n                                                        accept: \"image/*\",\n                                                        onChange: handleProfilePictureUpload,\n                                                        className: \"hidden\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 345,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 323,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardTitle, {\n                                                        className: \"text-2xl\",\n                                                        children: name\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 354,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    isEditingJobTitle ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex items-center gap-2 mt-1\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_input__WEBPACK_IMPORTED_MODULE_6__.Input, {\n                                                                value: jobTitle,\n                                                                placeholder: \"Update your job title\",\n                                                                onChange: (e)=>setJobTitle(e.target.value),\n                                                                className: \"h-6 py-1 text-sm\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 357,\n                                                                columnNumber: 23\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                size: \"sm\",\n                                                                onClick: ()=>handleUpdateJobTitle(jobTitle),\n                                                                children: \"Save\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 363,\n                                                                columnNumber: 23\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 356,\n                                                        columnNumber: 21\n                                                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"text-sm text-muted-foreground flex items-center gap-2\",\n                                                        children: [\n                                                            jobTitle,\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                variant: \"ghost\",\n                                                                size: \"sm\",\n                                                                onClick: ()=>setIsEditingJobTitle(true),\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                                                        className: \"h-3 w-3\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 378,\n                                                                        columnNumber: 25\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                        className: \"sr-only\",\n                                                                        children: \"Edit job title\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 379,\n                                                                        columnNumber: 25\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 373,\n                                                                columnNumber: 23\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 371,\n                                                        columnNumber: 21\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex items-center mt-1 text-sm text-muted-foreground\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n                                                                className: \"mr-1 h-4 w-4\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 384,\n                                                                columnNumber: 21\n                                                            }, this),\n                                                            isEditingCity ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                className: \"flex items-center gap-2\",\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_input__WEBPACK_IMPORTED_MODULE_6__.Input, {\n                                                                        value: city,\n                                                                        onChange: (e)=>setCity(e.target.value),\n                                                                        className: \"h-6 py-1 text-sm\",\n                                                                        placeholder: \"Update your location\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 387,\n                                                                        columnNumber: 25\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                        size: \"sm\",\n                                                                        onClick: ()=>handleUpdateCity(city),\n                                                                        children: \"Save\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 393,\n                                                                        columnNumber: 25\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 386,\n                                                                columnNumber: 23\n                                                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                className: \"flex items-center gap-2\",\n                                                                children: [\n                                                                    city,\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                        variant: \"ghost\",\n                                                                        size: \"sm\",\n                                                                        onClick: ()=>setIsEditingCity(true),\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                                                                className: \"h-3 w-3\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                                lineNumber: 408,\n                                                                                columnNumber: 27\n                                                                            }, this),\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                className: \"sr-only\",\n                                                                                children: \"Edit city\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                                lineNumber: 409,\n                                                                                columnNumber: 27\n                                                                            }, this)\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 403,\n                                                                        columnNumber: 25\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 401,\n                                                                columnNumber: 23\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 383,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 353,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 322,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                    lineNumber: 321,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardContent, {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"space-y-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex items-center justify-between mb-2\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                                className: \"font-semibold\",\n                                                                children: \"Top Skills\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 421,\n                                                                columnNumber: 21\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                variant: \"ghost\",\n                                                                size: \"sm\",\n                                                                onClick: ()=>setIsEditingSkills(!isEditingSkills),\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                                                        className: \"h-4 w-4\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 427,\n                                                                        columnNumber: 23\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                        className: \"sr-only\",\n                                                                        children: \"Edit skills\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 428,\n                                                                        columnNumber: 23\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 422,\n                                                                columnNumber: 21\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 420,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    isEditingSkills ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"space-y-2\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                className: \"flex flex-wrap gap-2\",\n                                                                children: skills.map((skill, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_badge__WEBPACK_IMPORTED_MODULE_5__.Badge, {\n                                                                        variant: \"secondary\",\n                                                                        children: [\n                                                                            skill,\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                                                onClick: ()=>handleRemoveSkill(skill),\n                                                                                className: \"ml-1 text-xs\",\n                                                                                children: [\n                                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_14__[\"default\"], {\n                                                                                        className: \"h-3 w-3\"\n                                                                                    }, void 0, false, {\n                                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                                        lineNumber: 441,\n                                                                                        columnNumber: 31\n                                                                                    }, this),\n                                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                        className: \"sr-only\",\n                                                                                        children: \"Remove skill\"\n                                                                                    }, void 0, false, {\n                                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                                        lineNumber: 442,\n                                                                                        columnNumber: 31\n                                                                                    }, this)\n                                                                                ]\n                                                                            }, void 0, true, {\n                                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                                lineNumber: 437,\n                                                                                columnNumber: 29\n                                                                            }, this)\n                                                                        ]\n                                                                    }, index, true, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 435,\n                                                                        columnNumber: 27\n                                                                    }, this))\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 433,\n                                                                columnNumber: 23\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                className: \"flex gap-2\",\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_input__WEBPACK_IMPORTED_MODULE_6__.Input, {\n                                                                        value: newSkill,\n                                                                        onChange: (e)=>setNewSkill(e.target.value),\n                                                                        placeholder: \"Add a skill\",\n                                                                        className: \"flex-grow\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 448,\n                                                                        columnNumber: 25\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                        onClick: ()=>handleUpdateSkills(skills),\n                                                                        children: \"Add\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 454,\n                                                                        columnNumber: 25\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 447,\n                                                                columnNumber: 23\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 432,\n                                                        columnNumber: 21\n                                                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex flex-wrap gap-2\",\n                                                        children: skills.map((skill, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_badge__WEBPACK_IMPORTED_MODULE_5__.Badge, {\n                                                                variant: \"secondary\",\n                                                                children: skill\n                                                            }, index, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 462,\n                                                                columnNumber: 25\n                                                            }, this))\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 460,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 419,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex items-center justify-between mb-2\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                                className: \"font-semibold\",\n                                                                children: \"Bio\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 471,\n                                                                columnNumber: 21\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                variant: \"ghost\",\n                                                                size: \"sm\",\n                                                                onClick: ()=>setIsEditingBio(!isEditingBio),\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                                                        className: \"h-4 w-4\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 477,\n                                                                        columnNumber: 23\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                        className: \"sr-only\",\n                                                                        children: \"Edit bio\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                        lineNumber: 478,\n                                                                        columnNumber: 23\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 472,\n                                                                columnNumber: 21\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 470,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    isEditingBio ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"space-y-2\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_textarea__WEBPACK_IMPORTED_MODULE_7__.Textarea, {\n                                                                value: bio,\n                                                                onChange: (e)=>setBio(e.target.value),\n                                                                rows: 4\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 483,\n                                                                columnNumber: 23\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                                onClick: ()=>handleUpdateBio(bio),\n                                                                children: \"Save\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 488,\n                                                                columnNumber: 23\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 482,\n                                                        columnNumber: 21\n                                                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"text-sm text-muted-foreground\",\n                                                        children: bio\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 491,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 469,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 418,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                    lineNumber: 417,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                            lineNumber: 320,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.Card, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardHeader, {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardTitle, {\n                                        className: \"text-xl\",\n                                        children: \"Resume\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 501,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                    lineNumber: 500,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardContent, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex flex-wrap items-center justify-between mb-4\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"flex items-center\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_15__[\"default\"], {\n                                                            className: \"mr-2 h-5 w-5\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 506,\n                                                            columnNumber: 19\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"text-purple-400 font-serif\",\n                                                            children: resumeUploadedDate ? \"Resume uploaded on: \".concat(new Date(resumeUploadedDate).toLocaleDateString()) : \"No resume uploaded\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 507,\n                                                            columnNumber: 21\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 505,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"flex items-center\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                            variant: \"outline\",\n                                                            onClick: triggerFileInputClick,\n                                                            disabled: isLoadingPdf,\n                                                            children: [\n                                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_16__[\"default\"], {\n                                                                    className: \"mr-2 h-4 w-4\"\n                                                                }, void 0, false, {\n                                                                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                    lineNumber: 521,\n                                                                    columnNumber: 21\n                                                                }, this),\n                                                                isLoadingPdf ? \"Processing...\" : \"Upload Resume\"\n                                                            ]\n                                                        }, void 0, true, {\n                                                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 516,\n                                                            columnNumber: 19\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_input__WEBPACK_IMPORTED_MODULE_6__.Input, {\n                                                            ref: fileInputRef,\n                                                            type: \"file\",\n                                                            accept: \".pdf\",\n                                                            onChange: handleResumeUpload,\n                                                            className: \"hidden\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 524,\n                                                            columnNumber: 19\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 515,\n                                                    columnNumber: 17\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                            lineNumber: 504,\n                                            columnNumber: 15\n                                        }, this),\n                                        uploadTime && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-sm text-muted-foreground\",\n                                            children: [\n                                                \"Uploaded on: \",\n                                                uploadTime\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                            lineNumber: 534,\n                                            columnNumber: 17\n                                        }, this),\n                                        isLoadingPdf && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-sm text-muted-foreground mt-2\",\n                                            children: \"Reading PDF content...\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                            lineNumber: 539,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                    lineNumber: 503,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                            lineNumber: 499,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.Card, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardHeader, {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex items-center justify-between\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardTitle, {\n                                                className: \"text-xl\",\n                                                children: \"About\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 550,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                variant: \"ghost\",\n                                                size: \"sm\",\n                                                onClick: ()=>setIsEditingAbout(!isEditingAbout),\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Camera_Edit2_FileText_MapPin_Upload_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                                        className: \"h-4 w-4\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 556,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"sr-only\",\n                                                        children: \"Edit about section\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 557,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 551,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 549,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                    lineNumber: 548,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_card__WEBPACK_IMPORTED_MODULE_3__.CardContent, {\n                                    children: isEditingAbout ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"space-y-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_textarea__WEBPACK_IMPORTED_MODULE_7__.Textarea, {\n                                                value: about,\n                                                onChange: (e)=>setAbout(e.target.value),\n                                                rows: 4\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 564,\n                                                columnNumber: 19\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                                onClick: ()=>handleUpdateAbout(about),\n                                                children: \"Save\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 569,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 563,\n                                        columnNumber: 17\n                                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-sm text-muted-foreground\",\n                                        children: about\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 572,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                    lineNumber: 561,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                            lineNumber: 547,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                    lineNumber: 318,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                lineNumber: 317,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\app\\\\profile\\\\page.tsx\",\n        lineNumber: 315,\n        columnNumber: 5\n    }, this);\n}\n_s(ProfilePage, \"hY4XIwXuwbX3lzo0dCs7+RymVao=\", false, function() {\n    return [\n        _clerk_clerk_react__WEBPACK_IMPORTED_MODULE_8__.useAuth\n    ];\n});\n_c = ProfilePage;\nvar _c;\n$RefreshReg$(_c, \"ProfilePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcHJvZmlsZS9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFb0Q7QUFDSjtBQUNnQztBQUNIO0FBQy9CO0FBQ0E7QUFDTTtBQUNzQjtBQUM3QjtBQUNUO0FBQ1M7QUFDN0MsTUFBTXVCLGVBQWVDLDBDQUFvQztBQUV6RCwyQkFBMkI7QUFDM0JILDJEQUF5QixDQUFDTyxTQUFTLEdBQUk7QUFFeEIsU0FBU0M7O0lBQ3RCLE1BQU0sRUFBRUMsVUFBVSxFQUFFLEdBQUdWLDJEQUFPQTtJQUU5QixNQUFNLENBQUNXLEtBQUtDLE9BQU8sR0FBR2hDLCtDQUFRQSxDQUM1QjtJQUVGLE1BQU0sQ0FBQ2lDLGNBQWNDLGdCQUFnQixHQUFHbEMsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDbUMsUUFBUUMsVUFBVSxHQUFHcEMsK0NBQVFBLENBQUM7UUFDbkM7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsTUFBTSxDQUFDcUMsaUJBQWlCQyxtQkFBbUIsR0FBR3RDLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU0sQ0FBQ3VDLFVBQVVDLFlBQVksR0FBR3hDLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ3lDLE9BQU9DLFNBQVMsR0FBRzFDLCtDQUFRQSxDQUNoQztJQUVGLE1BQU0sQ0FBQzJDLGdCQUFnQkMsa0JBQWtCLEdBQUc1QywrQ0FBUUEsQ0FBQztJQUNyRCxNQUFNLENBQUM2QyxZQUFZQyxjQUFjLEdBQUc5QywrQ0FBUUEsQ0FBYztJQUMxRCxNQUFNLENBQUMrQyxZQUFZQyxjQUFjLEdBQUdoRCwrQ0FBUUEsQ0FBZ0I7SUFDNUQsTUFBTSxDQUFDaUQsVUFBVUMsWUFBWSxHQUFHbEQsK0NBQVFBLENBQUM7SUFDekMsTUFBTSxDQUFDbUQsTUFBTUMsUUFBUSxHQUFHcEQsK0NBQVFBLENBQUM7SUFDakMsTUFBTSxDQUFDcUQsbUJBQW1CQyxxQkFBcUIsR0FBR3RELCtDQUFRQSxDQUFDO0lBQzNELE1BQU0sQ0FBQ3VELGVBQWVDLGlCQUFpQixHQUFHeEQsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDeUQsWUFBWUMsY0FBYyxHQUFHMUQsK0NBQVFBLENBQVM7SUFDckQsTUFBTSxDQUFDMkQsY0FBY0MsZ0JBQWdCLEdBQUc1RCwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUM2RCxNQUFNQyxRQUFRLEdBQUc5RCwrQ0FBUUEsQ0FBQztJQUNqQyxNQUFNLENBQUMrRCxvQkFBb0JDLHNCQUFzQixHQUFHaEUsK0NBQVFBLENBQUM7SUFDN0QsTUFBTSxDQUFDaUUseUJBQXlCQywyQkFBMkIsR0FBR2xFLCtDQUFRQSxDQUFDO0lBQ3ZFLE1BQU0sQ0FBQ21FLG9CQUFvQkMsc0JBQXNCLEdBQUdwRSwrQ0FBUUEsQ0FDMUQ7SUFHRiw2QkFBNkI7SUFDN0IsTUFBTXFFLGVBQWVwRSw2Q0FBTUEsQ0FBbUI7SUFDOUMsTUFBTXFFLHlCQUF5QnJFLDZDQUFNQSxDQUFtQjtJQUV4RCxlQUFlc0UsV0FBV0MsR0FBZ0I7UUFDeEMsTUFBTUMsTUFBTSxNQUFNcEQsbURBQWlCLENBQUM7WUFBRXNELE1BQU1IO1FBQUksR0FBR0ksT0FBTztRQUMxRCxNQUFNQyxPQUFPLE1BQU1KLElBQUlLLE9BQU8sQ0FBQztRQUMvQixPQUFPLE1BQU1ELEtBQUtFLGNBQWM7SUFDbEM7SUFFQSxlQUFlQyxTQUFTUixHQUFnQjtRQUN0QyxNQUFNUyxVQUFVLE1BQU1WLFdBQVdDO1FBQ2pDLElBQUlVLFdBQVc7UUFDZkQsUUFBUUUsS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQ0M7WUFDckIsSUFBSUEsS0FBS0MsR0FBRyxFQUFFO2dCQUNaSixZQUFZRyxLQUFLQyxHQUFHLEdBQUc7WUFDekI7UUFDRjtRQUNBLE9BQU9KLFNBQVNLLElBQUk7SUFDdEI7SUFFQXJGLGdEQUFTQSxDQUFDO1FBQ1JzRjtJQUNGLEdBQUcsRUFBRTtJQUVMLE1BQU1BLGNBQWM7UUFDbEIsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJuRSxjQUFhLGFBQVc7WUFDdERvRSxhQUFhO1FBQ2Y7UUFDQSxJQUFJLENBQUNGLFNBQVNHLEVBQUUsRUFBRTtZQUNoQkMsUUFBUUMsS0FBSyxDQUFDO1lBQ2Q7UUFDRjtRQUNBLE1BQU1uQixPQUFPLE1BQU1jLFNBQVNNLElBQUk7UUFDaENGLFFBQVFHLEdBQUcsQ0FBQyxpQkFBZ0JDLEtBQUtDLFNBQVMsQ0FBQ3ZCO1FBQzNDLElBQUdBLEtBQUt3QixvQkFBb0IsRUFBRTtZQUM1Qi9CLHNCQUFzQk8sS0FBS3dCLG9CQUFvQjtRQUNqRCxPQUNLO1lBQ0gvQixzQkFBc0I7UUFDeEI7UUFDQU4sUUFDRWEsS0FBS2QsSUFBSSxDQUNOdUMsS0FBSyxDQUFDLEtBQ05DLEdBQUcsQ0FDRixDQUFDQyxPQUNDQSxLQUFLQyxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLRixLQUFLRyxLQUFLLENBQUMsR0FBR0MsV0FBVyxJQUUzREMsSUFBSSxDQUFDO1FBRVZ6RCxZQUFZeUIsS0FBS2lDLEtBQUs7UUFDdEJ4RCxRQUFRdUIsS0FBS2tDLFFBQVE7UUFDckIsMEJBQTBCO1FBQzFCN0UsT0FBTzJDLEtBQUs1QyxHQUFHO1FBQ2ZXLFNBQVNpQyxLQUFLbEMsS0FBSztRQUNuQiw4QkFBOEI7UUFFOUJ1QixzQkFBc0JXLEtBQUttQyxvQkFBb0I7SUFDakQ7SUFFQSxNQUFNQyxxQkFBcUIsT0FDekJDO1lBRWFBO1FBQWIsTUFBTUMsUUFBT0Qsc0JBQUFBLE1BQU1FLE1BQU0sQ0FBQ0MsS0FBSyxjQUFsQkgsMENBQUFBLG1CQUFvQixDQUFDLEVBQUU7UUFDcEMsSUFBSUMsTUFBTTtZQUNSLElBQUlBLEtBQUtHLElBQUksS0FBSyxtQkFBbUI7Z0JBQ25DdEUsY0FBY21FO2dCQUNkakUsY0FBYyxJQUFJcUUsT0FBT0MsY0FBYztnQkFDdkMxRCxnQkFBZ0I7Z0JBQ2hCLElBQUk7b0JBQ0YsTUFBTTJELGNBQWMsTUFBTU4sS0FBS00sV0FBVztvQkFDMUMsTUFBTUMsT0FBTyxNQUFNeEMsU0FBU3VDO29CQUM1QjFCLFFBQVFHLEdBQUcsQ0FBQyxpQkFBZ0J3QjtvQkFDNUI5RCxjQUFjOEQ7b0JBQ2QsK0NBQStDO29CQUMvQyxNQUFNL0IsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJuRSxjQUFhLFlBQVU7d0JBQ3JEa0csUUFBUTt3QkFDUkMsU0FBUzs0QkFDUCxnQkFBZ0I7d0JBQ2xCO3dCQUNBQyxNQUFNMUIsS0FBS0MsU0FBUyxDQUFDOzRCQUFFMEIsUUFBUUo7d0JBQUs7d0JBQ3BDN0IsYUFBYTtvQkFDZjtvQkFDQSxJQUFJRixTQUFTRyxFQUFFLEVBQUU7d0JBQ2ZpQyxNQUFNO29CQUNSLE9BQU87d0JBQ0xBLE1BQU07b0JBQ1I7Z0JBQ0YsRUFBRSxPQUFPL0IsT0FBTztvQkFDZEQsUUFBUUMsS0FBSyxDQUFDLHNCQUFzQkE7b0JBQ3BDK0IsTUFBTTtnQkFDUixTQUFVO29CQUNSakUsZ0JBQWdCO2dCQUNsQjtZQUNGLE9BQU87Z0JBQ0xpRSxNQUFNO1lBQ1I7UUFDRjtJQUNGO0lBRUEsTUFBTUMsNkJBQTZCLE9BQ2pDZDtZQUVhQTtRQUFiLE1BQU1DLFFBQU9ELHNCQUFBQSxNQUFNRSxNQUFNLENBQUNDLEtBQUssY0FBbEJILDBDQUFBQSxtQkFBb0IsQ0FBQyxFQUFFO1FBQ3BDLElBQUlDLE1BQU07WUFDUixNQUFNYyxXQUFXLElBQUlDO1lBQ3JCRCxTQUFTRSxNQUFNLENBQUMsa0JBQWtCaEI7WUFFbEMsSUFBSTtnQkFDRixNQUFNeEIsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJuRSxjQUFhLDRCQUEwQjtvQkFDckVrRyxRQUFRO29CQUNSRSxNQUFNSTtvQkFDTnBDLGFBQWE7Z0JBQ2Y7Z0JBRUEsSUFBSUYsU0FBU0csRUFBRSxFQUFFO29CQUNmLE1BQU1qQixPQUFPLE1BQU1jLFNBQVNNLElBQUk7b0JBQ2hDL0Isc0JBQXNCVyxLQUFLWixrQkFBa0I7b0JBQzdDRywyQkFBMkI7Z0JBQzdCLE9BQU87b0JBQ0wyRCxNQUFNO2dCQUNSO1lBQ0YsRUFBRSxPQUFPL0IsT0FBTztnQkFDZEQsUUFBUUMsS0FBSyxDQUFDLG9DQUFvQ0E7Z0JBQ2xEK0IsTUFBTTtZQUNSO1FBQ0Y7SUFDRjtJQUVBLE1BQU1LLHdCQUF3QjtZQUM1QjdEO1NBQUFBLHdCQUFBQSxhQUFhOEQsT0FBTyxjQUFwQjlELDRDQUFBQSxzQkFBc0IrRCxLQUFLO0lBQzdCO0lBRUEsTUFBTUMsOEJBQThCO1lBQ2xDL0Q7U0FBQUEsa0NBQUFBLHVCQUF1QjZELE9BQU8sY0FBOUI3RCxzREFBQUEsZ0NBQWdDOEQsS0FBSztJQUN2QztJQUVBLE1BQU1FLGlCQUFpQjtRQUNyQixJQUFJL0YsWUFBWSxDQUFDSixPQUFPb0csUUFBUSxDQUFDaEcsV0FBVztZQUMxQyxNQUFNaUcsZ0JBQWdCO21CQUFJckc7Z0JBQVFJO2FBQVM7WUFDM0MsSUFBSTtnQkFDRixzREFBc0Q7Z0JBQ3RESCxVQUFVb0c7Z0JBQ1ZoRyxZQUFZO1lBQ2QsRUFBRSxPQUFPc0QsT0FBTztnQkFDZEQsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQkE7Z0JBQ3hDK0IsTUFBTTtZQUNSO1FBQ0Y7SUFDRjtJQUVBLE1BQU1ZLG9CQUFvQixPQUFPQztRQUMvQixNQUFNRixnQkFBZ0JyRyxPQUFPd0csTUFBTSxDQUFDLENBQUNDLFFBQVVBLFVBQVVGO1FBQ3pELElBQUk7WUFDRixzREFBc0Q7WUFDdER0RyxVQUFVb0c7UUFDWixFQUFFLE9BQU8xQyxPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDK0IsTUFBTTtRQUNSO0lBQ0Y7SUFFQSxNQUFNZ0IsdUJBQXVCLE9BQU81RjtRQUNsQyxJQUFJO1lBQ0YsTUFBTXdDLFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFibkUsY0FBYSxrQkFBZ0I7Z0JBQzNEa0csUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxNQUFNMUIsS0FBS0MsU0FBUyxDQUFDO29CQUFFakQsVUFBVUE7Z0JBQVM7Z0JBQzFDMEMsYUFBYTtZQUNmO1lBQ0EsSUFBSUYsU0FBU0csRUFBRSxFQUFFO2dCQUNmQyxRQUFRRyxHQUFHLENBQUM7WUFDZCxPQUFPO2dCQUNMNkIsTUFBTTtZQUNSO1lBQ0F2RSxxQkFBcUI7UUFDdkIsRUFBRSxPQUFPd0MsT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMsNkJBQTZCQTtZQUMzQytCLE1BQU07UUFDUjtJQUNGO0lBRUEsTUFBTWlCLG1CQUFtQixPQUFPM0Y7UUFDOUIsSUFBSTtZQUNGLE1BQU1zQyxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYm5FLGNBQWEscUJBQW1CO2dCQUM5RGtHLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQ1AsZ0JBQWdCO2dCQUNsQjtnQkFDQUMsTUFBTTFCLEtBQUtDLFNBQVMsQ0FBQztvQkFBRVcsVUFBVTFEO2dCQUFLO2dCQUN0Q3dDLGFBQWE7WUFDZjtZQUNBLElBQUlGLFNBQVNHLEVBQUUsRUFBRTtnQkFDZkMsUUFBUUcsR0FBRyxDQUFDO1lBQ2QsT0FBTztnQkFDTDZCLE1BQU07WUFDUjtZQUNBckUsaUJBQWlCO1FBQ25CLEVBQUUsT0FBT3NDLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QkE7WUFDdEMrQixNQUFNO1FBQ1I7SUFDRjtJQUVBLE1BQU1rQixxQkFBcUIsT0FBTzVHO1FBQ2hDLElBQUk7WUFDRix1Q0FBdUM7WUFDdkNHLG1CQUFtQjtRQUNyQixFQUFFLE9BQU93RCxPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDK0IsTUFBTTtRQUNSO0lBQ0Y7SUFFQSxNQUFNbUIsa0JBQWtCLE9BQU9qSDtRQUM3QixJQUFJO1lBQ0YsTUFBTTBELFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFibkUsY0FBYSxnQkFBYztnQkFDekRrRyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU0xQixLQUFLQyxTQUFTLENBQUM7b0JBQUVuRSxLQUFLQTtnQkFBSTtnQkFDaEM0RCxhQUFhO1lBQ2Y7WUFDQSxJQUFJRixTQUFTRyxFQUFFLEVBQUU7Z0JBQ2ZDLFFBQVFHLEdBQUcsQ0FBQztZQUNkLE9BQU87Z0JBQ0w2QixNQUFNO1lBQ1I7WUFDQTNGLGdCQUFnQjtRQUNsQixFQUFFLE9BQU80RCxPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQyx1QkFBdUJBO1lBQ3JDK0IsTUFBTTtRQUNSO0lBQ0Y7SUFFQSxNQUFNb0Isb0JBQW9CLE9BQU94RztRQUMvQixJQUFJO1lBQ0YsTUFBTWdELFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFibkUsY0FBYSxrQkFBZ0I7Z0JBQzNEa0csUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxNQUFNMUIsS0FBS0MsU0FBUyxDQUFDO29CQUFFekQsT0FBT0E7Z0JBQU07Z0JBQ3BDa0QsYUFBYTtZQUNmO1lBQ0EsSUFBSUYsU0FBU0csRUFBRSxFQUFFO2dCQUNmQyxRQUFRRyxHQUFHLENBQUM7WUFDZCxPQUFPO2dCQUNMNkIsTUFBTTtZQUNSO1lBQ0FqRixrQkFBa0I7UUFDcEIsRUFBRSxPQUFPa0QsT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMseUJBQXlCQTtZQUN2QytCLE1BQU07UUFDUjtJQUNGO0lBRUEscUJBQ0UsOERBQUNxQjtRQUFJQyxXQUFVOzswQkFDYiw4REFBQzdILHVEQUFNQTs7Ozs7MEJBQ1AsOERBQUM0SDtnQkFBSUMsV0FBVTswQkFDYiw0RUFBQ0Q7b0JBQUlDLFdBQVU7O3NDQUViLDhEQUFDL0kscURBQUlBOzs4Q0FDSCw4REFBQ0UsMkRBQVVBOzhDQUNULDRFQUFDNEk7d0NBQUlDLFdBQVU7OzBEQUNiLDhEQUFDRDtnREFBSUMsV0FBVTs7a0VBQ2IsOERBQUMzSSx5REFBTUE7d0RBQUMySSxXQUFVOzswRUFDaEIsOERBQUN6SSw4REFBV0E7Z0VBQ1Y4RCxLQUFLVDtnRUFDTHFGLEtBQUk7Ozs7OzswRUFFTiw4REFBQzNJLGlFQUFjQTswRUFDWm9ELEtBQ0V1QyxLQUFLLENBQUMsS0FDTkMsR0FBRyxDQUFDLENBQUNnRCxJQUFNQSxDQUFDLENBQUMsRUFBRSxFQUNmMUMsSUFBSSxDQUFDOzs7Ozs7Ozs7Ozs7a0VBR1osOERBQUN4Ryx5REFBTUE7d0RBQ0xtSixTQUFRO3dEQUNSQyxNQUFLO3dEQUNMSixXQUFVO3dEQUNWSyxTQUFTbkI7OzBFQUVULDhEQUFDbEgsa0hBQU1BO2dFQUFDZ0ksV0FBVTs7Ozs7OzBFQUNsQiw4REFBQ007Z0VBQUtOLFdBQVU7MEVBQVU7Ozs7Ozs7Ozs7OztrRUFFNUIsOERBQUN2SSx1REFBS0E7d0RBQ0o4SSxLQUFLcEY7d0RBQ0w4QyxNQUFLO3dEQUNMdUMsUUFBTzt3REFDUEMsVUFBVTlCO3dEQUNWcUIsV0FBVTs7Ozs7Ozs7Ozs7OzBEQUdkLDhEQUFDRDs7a0VBQ0MsOERBQUMzSSwwREFBU0E7d0RBQUM0SSxXQUFVO2tFQUFZdEY7Ozs7OztvREFDaENSLGtDQUNDLDhEQUFDNkY7d0RBQUlDLFdBQVU7OzBFQUNiLDhEQUFDdkksdURBQUtBO2dFQUNKaUosT0FBTzVHO2dFQUNQNkcsYUFBWTtnRUFDWkYsVUFBVSxDQUFDRyxJQUFNN0csWUFBWTZHLEVBQUU3QyxNQUFNLENBQUMyQyxLQUFLO2dFQUMzQ1YsV0FBVTs7Ozs7OzBFQUVaLDhEQUFDaEoseURBQU1BO2dFQUNMb0osTUFBSztnRUFDTEMsU0FBUyxJQUFNWCxxQkFBcUI1RjswRUFDckM7Ozs7Ozs7Ozs7OzZFQUtILDhEQUFDK0c7d0RBQUViLFdBQVU7OzREQUNWbEc7MEVBQ0QsOERBQUM5Qyx5REFBTUE7Z0VBQ0xtSixTQUFRO2dFQUNSQyxNQUFLO2dFQUNMQyxTQUFTLElBQU1sRyxxQkFBcUI7O2tGQUVwQyw4REFBQ3JDLGtIQUFLQTt3RUFBQ2tJLFdBQVU7Ozs7OztrRkFDakIsOERBQUNNO3dFQUFLTixXQUFVO2tGQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7a0VBSWhDLDhEQUFDRDt3REFBSUMsV0FBVTs7MEVBQ2IsOERBQUNySSxrSEFBTUE7Z0VBQUNxSSxXQUFVOzs7Ozs7NERBQ2pCNUYsOEJBQ0MsOERBQUMyRjtnRUFBSUMsV0FBVTs7a0ZBQ2IsOERBQUN2SSx1REFBS0E7d0VBQ0ppSixPQUFPMUc7d0VBQ1B5RyxVQUFVLENBQUNHLElBQU0zRyxRQUFRMkcsRUFBRTdDLE1BQU0sQ0FBQzJDLEtBQUs7d0VBQ3ZDVixXQUFVO3dFQUNWVyxhQUFZOzs7Ozs7a0ZBRWQsOERBQUMzSix5REFBTUE7d0VBQ0xvSixNQUFLO3dFQUNMQyxTQUFTLElBQU1WLGlCQUFpQjNGO2tGQUNqQzs7Ozs7Ozs7Ozs7cUZBS0gsOERBQUNzRztnRUFBS04sV0FBVTs7b0VBQ2JoRztrRkFDRCw4REFBQ2hELHlEQUFNQTt3RUFDTG1KLFNBQVE7d0VBQ1JDLE1BQUs7d0VBQ0xDLFNBQVMsSUFBTWhHLGlCQUFpQjs7MEZBRWhDLDhEQUFDdkMsa0hBQUtBO2dGQUFDa0ksV0FBVTs7Ozs7OzBGQUNqQiw4REFBQ007Z0ZBQUtOLFdBQVU7MEZBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhDQVF4Qyw4REFBQzlJLDREQUFXQTs4Q0FDViw0RUFBQzZJO3dDQUFJQyxXQUFVOzswREFDYiw4REFBQ0Q7O2tFQUNDLDhEQUFDQTt3REFBSUMsV0FBVTs7MEVBQ2IsOERBQUNjO2dFQUFHZCxXQUFVOzBFQUFnQjs7Ozs7OzBFQUM5Qiw4REFBQ2hKLHlEQUFNQTtnRUFDTG1KLFNBQVE7Z0VBQ1JDLE1BQUs7Z0VBQ0xDLFNBQVMsSUFBTWxILG1CQUFtQixDQUFDRDs7a0ZBRW5DLDhEQUFDcEIsa0hBQUtBO3dFQUFDa0ksV0FBVTs7Ozs7O2tGQUNqQiw4REFBQ007d0VBQUtOLFdBQVU7a0ZBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7OztvREFHN0I5RyxnQ0FDQyw4REFBQzZHO3dEQUFJQyxXQUFVOzswRUFDYiw4REFBQ0Q7Z0VBQUlDLFdBQVU7MEVBQ1poSCxPQUFPa0UsR0FBRyxDQUFDLENBQUN1QyxPQUFPc0Isc0JBQ2xCLDhEQUFDdkosdURBQUtBO3dFQUFhMkksU0FBUTs7NEVBQ3hCVjswRkFDRCw4REFBQ3VCO2dGQUNDWCxTQUFTLElBQU1mLGtCQUFrQkc7Z0ZBQ2pDTyxXQUFVOztrR0FFViw4REFBQ2pJLGtIQUFDQTt3RkFBQ2lJLFdBQVU7Ozs7OztrR0FDYiw4REFBQ007d0ZBQUtOLFdBQVU7a0dBQVU7Ozs7Ozs7Ozs7Ozs7dUVBUGxCZTs7Ozs7Ozs7OzswRUFZaEIsOERBQUNoQjtnRUFBSUMsV0FBVTs7a0ZBQ2IsOERBQUN2SSx1REFBS0E7d0VBQ0ppSixPQUFPdEg7d0VBQ1BxSCxVQUFVLENBQUNHLElBQU12SCxZQUFZdUgsRUFBRTdDLE1BQU0sQ0FBQzJDLEtBQUs7d0VBQzNDQyxhQUFZO3dFQUNaWCxXQUFVOzs7Ozs7a0ZBRVosOERBQUNoSix5REFBTUE7d0VBQUNxSixTQUFTLElBQU1ULG1CQUFtQjVHO2tGQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs2RUFNdkQsOERBQUMrRzt3REFBSUMsV0FBVTtrRUFDWmhILE9BQU9rRSxHQUFHLENBQUMsQ0FBQ3VDLE9BQU9zQixzQkFDbEIsOERBQUN2Six1REFBS0E7Z0VBQWEySSxTQUFROzBFQUN4QlY7K0RBRFNzQjs7Ozs7Ozs7Ozs7Ozs7OzswREFPcEIsOERBQUNoQjs7a0VBQ0MsOERBQUNBO3dEQUFJQyxXQUFVOzswRUFDYiw4REFBQ2M7Z0VBQUdkLFdBQVU7MEVBQWdCOzs7Ozs7MEVBQzlCLDhEQUFDaEoseURBQU1BO2dFQUNMbUosU0FBUTtnRUFDUkMsTUFBSztnRUFDTEMsU0FBUyxJQUFNdEgsZ0JBQWdCLENBQUNEOztrRkFFaEMsOERBQUNoQixrSEFBS0E7d0VBQUNrSSxXQUFVOzs7Ozs7a0ZBQ2pCLDhEQUFDTTt3RUFBS04sV0FBVTtrRkFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7O29EQUc3QmxILDZCQUNDLDhEQUFDaUg7d0RBQUlDLFdBQVU7OzBFQUNiLDhEQUFDdEksNkRBQVFBO2dFQUNQZ0osT0FBTzlIO2dFQUNQNkgsVUFBVSxDQUFDRyxJQUFNL0gsT0FBTytILEVBQUU3QyxNQUFNLENBQUMyQyxLQUFLO2dFQUN0Q08sTUFBTTs7Ozs7OzBFQUVSLDhEQUFDaksseURBQU1BO2dFQUFDcUosU0FBUyxJQUFNUixnQkFBZ0JqSDswRUFBTTs7Ozs7Ozs7Ozs7NkVBRy9DLDhEQUFDaUk7d0RBQUViLFdBQVU7a0VBQWlDcEg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NDQVF4RCw4REFBQzNCLHFEQUFJQTs7OENBQ0gsOERBQUNFLDJEQUFVQTs4Q0FDVCw0RUFBQ0MsMERBQVNBO3dDQUFDNEksV0FBVTtrREFBVTs7Ozs7Ozs7Ozs7OENBRWpDLDhEQUFDOUksNERBQVdBOztzREFDViw4REFBQzZJOzRDQUFJQyxXQUFVOzs4REFDYiw4REFBQ0Q7b0RBQUlDLFdBQVU7O3NFQUNiLDhEQUFDcEksa0hBQVFBOzREQUFDb0ksV0FBVTs7Ozs7O3NFQUNsQiw4REFBQ007NERBQUtOLFdBQVU7c0VBQ2ZoRixxQkFDRyx1QkFFdUIsT0FGQSxJQUFJa0QsS0FDekJsRCxvQkFDQWtHLGtCQUFrQixNQUNwQjs7Ozs7Ozs7Ozs7OzhEQUdSLDhEQUFDbkI7b0RBQUlDLFdBQVU7O3NFQUNiLDhEQUFDaEoseURBQU1BOzREQUNMbUosU0FBUTs0REFDUkUsU0FBU3RCOzREQUNUb0MsVUFBVTNHOzs4RUFFViw4REFBQzNDLGtIQUFNQTtvRUFBQ21JLFdBQVU7Ozs7OztnRUFDakJ4RixlQUFlLGtCQUFrQjs7Ozs7OztzRUFFcEMsOERBQUMvQyx1REFBS0E7NERBQ0o4SSxLQUFLckY7NERBQ0wrQyxNQUFLOzREQUNMdUMsUUFBTzs0REFDUEMsVUFBVTdDOzREQUNWb0MsV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQUlmcEcsNEJBQ0MsOERBQUNpSDs0Q0FBRWIsV0FBVTs7Z0RBQWdDO2dEQUM3QnBHOzs7Ozs7O3dDQUdqQlksOEJBQ0MsOERBQUNxRzs0Q0FBRWIsV0FBVTtzREFBcUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQ0FReEQsOERBQUMvSSxxREFBSUE7OzhDQUNILDhEQUFDRSwyREFBVUE7OENBQ1QsNEVBQUM0STt3Q0FBSUMsV0FBVTs7MERBQ2IsOERBQUM1SSwwREFBU0E7Z0RBQUM0SSxXQUFVOzBEQUFVOzs7Ozs7MERBQy9CLDhEQUFDaEoseURBQU1BO2dEQUNMbUosU0FBUTtnREFDUkMsTUFBSztnREFDTEMsU0FBUyxJQUFNNUcsa0JBQWtCLENBQUNEOztrRUFFbEMsOERBQUMxQixrSEFBS0E7d0RBQUNrSSxXQUFVOzs7Ozs7a0VBQ2pCLDhEQUFDTTt3REFBS04sV0FBVTtrRUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OENBSWhDLDhEQUFDOUksNERBQVdBOzhDQUNUc0MsK0JBQ0MsOERBQUN1Rzt3Q0FBSUMsV0FBVTs7MERBQ2IsOERBQUN0SSw2REFBUUE7Z0RBQ1BnSixPQUFPcEg7Z0RBQ1BtSCxVQUFVLENBQUNHLElBQU1ySCxTQUFTcUgsRUFBRTdDLE1BQU0sQ0FBQzJDLEtBQUs7Z0RBQ3hDTyxNQUFNOzs7Ozs7MERBRVIsOERBQUNqSyx5REFBTUE7Z0RBQUNxSixTQUFTLElBQU1QLGtCQUFrQnhHOzBEQUFROzs7Ozs7Ozs7Ozs2REFHbkQsOERBQUN1SDt3Q0FBRWIsV0FBVTtrREFBaUMxRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVE5RDtHQWpqQndCWjs7UUFDQ1QsdURBQU9BOzs7S0FEUlMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9wcm9maWxlL3BhZ2UudHN4P2M0ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSBcIkAvY29tcG9uZW50cy91aS9idXR0b25cIjtcclxuaW1wb3J0IHsgQ2FyZCwgQ2FyZENvbnRlbnQsIENhcmRIZWFkZXIsIENhcmRUaXRsZSB9IGZyb20gXCJAL2NvbXBvbmVudHMvdWkvY2FyZFwiO1xyXG5pbXBvcnQgeyBBdmF0YXIsIEF2YXRhckZhbGxiYWNrLCBBdmF0YXJJbWFnZSB9IGZyb20gXCJAL2NvbXBvbmVudHMvdWkvYXZhdGFyXCI7XHJcbmltcG9ydCB7IEJhZGdlIH0gZnJvbSBcIkAvY29tcG9uZW50cy91aS9iYWRnZVwiO1xyXG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gXCJAL2NvbXBvbmVudHMvdWkvaW5wdXRcIjtcclxuaW1wb3J0IHsgVGV4dGFyZWEgfSBmcm9tIFwiQC9jb21wb25lbnRzL3VpL3RleHRhcmVhXCI7XHJcbmltcG9ydCB7IE1hcFBpbiwgRmlsZVRleHQsIFVwbG9hZCwgRWRpdDIsIFgsIENhbWVyYSB9IGZyb20gXCJsdWNpZGUtcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gXCJAY2xlcmsvY2xlcmstcmVhY3RcIjtcclxuaW1wb3J0ICogYXMgcGRmanMgZnJvbSBcInBkZmpzLWRpc3RcIjtcclxuaW1wb3J0IHsgTmF2QmFyIH0gZnJvbSBcIkAvY29tcG9uZW50cy9OYXZCYXJcIjtcclxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBQREYuanMgd29ya2VyXHJcbnBkZmpzLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID0gYGh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL3BkZi5qcy80LjguNjkvcGRmLndvcmtlci5tanNgO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUHJvZmlsZVBhZ2UoKSB7XHJcbiAgY29uc3QgeyBpc1NpZ25lZEluIH0gPSB1c2VBdXRoKCk7XHJcblxyXG4gIGNvbnN0IFtiaW8sIHNldEJpb10gPSB1c2VTdGF0ZShcclxuICAgIFwiUGFzc2lvbmF0ZSBkZXZlbG9wZXIgd2l0aCBhIGtuYWNrIGZvciBjcmVhdGluZyBlZmZpY2llbnQgYW5kIHNjYWxhYmxlIHdlYiBhcHBsaWNhdGlvbnMuIEFsd2F5cyBlYWdlciB0byBsZWFybiBuZXcgdGVjaG5vbG9naWVzIGFuZCBzb2x2ZSBjb21wbGV4IHByb2JsZW1zLlwiXHJcbiAgKTtcclxuICBjb25zdCBbaXNFZGl0aW5nQmlvLCBzZXRJc0VkaXRpbmdCaW9dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtza2lsbHMsIHNldFNraWxsc10gPSB1c2VTdGF0ZShbXHJcbiAgICBcIlJlYWN0XCIsXHJcbiAgICBcIk5vZGUuanNcIixcclxuICAgIFwiVHlwZVNjcmlwdFwiLFxyXG4gICAgXCJHcmFwaFFMXCIsXHJcbiAgICBcIkFXU1wiLFxyXG4gIF0pO1xyXG4gIGNvbnN0IFtpc0VkaXRpbmdTa2lsbHMsIHNldElzRWRpdGluZ1NraWxsc10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW25ld1NraWxsLCBzZXROZXdTa2lsbF0gPSB1c2VTdGF0ZShcIkFkZCBhIHNraWxsXCIpO1xyXG4gIGNvbnN0IFthYm91dCwgc2V0QWJvdXRdID0gdXNlU3RhdGUoXHJcbiAgICBcIllvdXIgQWJvdXQgU2VjdGlvbi4gV3JpdGUgYSBicmllZiBkZXNjcmlwdGlvbiBhYm91dCB5b3Vyc2VsZi5cIlxyXG4gICk7XHJcbiAgY29uc3QgW2lzRWRpdGluZ0Fib3V0LCBzZXRJc0VkaXRpbmdBYm91dF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW3Jlc3VtZUZpbGUsIHNldFJlc3VtZUZpbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFt1cGxvYWRUaW1lLCBzZXRVcGxvYWRUaW1lXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtqb2JUaXRsZSwgc2V0Sm9iVGl0bGVdID0gdXNlU3RhdGUoXCJVcGRhdGUgeW91ciBKb2IgVGl0bGVcIik7XHJcbiAgY29uc3QgW2NpdHksIHNldENpdHldID0gdXNlU3RhdGUoXCJVcGRhdGUgeW91ciBsb2NhdGlvblwiKTtcclxuICBjb25zdCBbaXNFZGl0aW5nSm9iVGl0bGUsIHNldElzRWRpdGluZ0pvYlRpdGxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbaXNFZGl0aW5nQ2l0eSwgc2V0SXNFZGl0aW5nQ2l0eV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW3BkZkNvbnRlbnQsIHNldFBkZkNvbnRlbnRdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcclxuICBjb25zdCBbaXNMb2FkaW5nUGRmLCBzZXRJc0xvYWRpbmdQZGZdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtuYW1lLCBzZXROYW1lXSA9IHVzZVN0YXRlKFwiRmlyc3ROYW1lIExhc3ROYW1lXCIpO1xyXG4gIGNvbnN0IFtwcm9maWxlUGljdHVyZUxpbmssIHNldFByb2ZpbGVQaWN0dXJlTGlua10gPSB1c2VTdGF0ZShcIlwiKTtcclxuICBjb25zdCBbaXNFZGl0aW5nUHJvZmlsZVBpY3R1cmUsIHNldElzRWRpdGluZ1Byb2ZpbGVQaWN0dXJlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbcmVzdW1lVXBsb2FkZWREYXRlLCBzZXRSZXN1bWVVcGxvYWRlZERhdGVdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4oXHJcbiAgICBudWxsXHJcbiAgKTtcclxuXHJcbiAgLy8gcmVmZXJlbmNlcyBmb3IgZmlsZSBpbnB1dHNcclxuICBjb25zdCBmaWxlSW5wdXRSZWYgPSB1c2VSZWY8SFRNTElucHV0RWxlbWVudD4obnVsbCk7XHJcbiAgY29uc3QgcHJvZmlsZVBpY3R1cmVJbnB1dFJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsKTtcclxuXHJcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0Q29udGVudChzcmM6IEFycmF5QnVmZmVyKSB7XHJcbiAgICBjb25zdCBkb2MgPSBhd2FpdCBwZGZqcy5nZXREb2N1bWVudCh7IGRhdGE6IHNyYyB9KS5wcm9taXNlO1xyXG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IGRvYy5nZXRQYWdlKDEpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHBhZ2UuZ2V0VGV4dENvbnRlbnQoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEl0ZW1zKHNyYzogQXJyYXlCdWZmZXIpIHtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBnZXRDb250ZW50KHNyYyk7XHJcbiAgICBsZXQgZnVsbFRleHQgPSBcIlwiO1xyXG4gICAgY29udGVudC5pdGVtcy5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcclxuICAgICAgaWYgKGl0ZW0uc3RyKSB7XHJcbiAgICAgICAgZnVsbFRleHQgKz0gaXRlbS5zdHIgKyBcIiBcIjtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZnVsbFRleHQudHJpbSgpO1xyXG4gIH1cclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGdldFVzZXJEYXRhKCk7XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCBnZXRVc2VyRGF0YSA9IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9wcm9maWxlYCwge1xyXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHVzZXIgZGF0YVwiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGNvbnNvbGUubG9nKFwiVGhlIGRhdGEgaXMgXCIrIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuICAgIGlmKGRhdGEucmVzdW1lX3VwbG9hZGVkX2RhdGUpIHtcclxuICAgICAgc2V0UmVzdW1lVXBsb2FkZWREYXRlKGRhdGEucmVzdW1lX3VwbG9hZGVkX2RhdGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHNldFJlc3VtZVVwbG9hZGVkRGF0ZShcIlwiKTtcclxuICAgIH1cclxuICAgIHNldE5hbWUoXHJcbiAgICAgIGRhdGEubmFtZVxyXG4gICAgICAgIC5zcGxpdChcIiBcIilcclxuICAgICAgICAubWFwKFxyXG4gICAgICAgICAgKHdvcmQ6IHN0cmluZykgPT5cclxuICAgICAgICAgICAgd29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIClcclxuICAgICAgICAuam9pbihcIiBcIilcclxuICAgICk7XHJcbiAgICBzZXRKb2JUaXRsZShkYXRhLnRpdGxlKTtcclxuICAgIHNldENpdHkoZGF0YS5sb2NhdGlvbik7XHJcbiAgICAvLyBzZXRTa2lsbHMoZGF0YS5za2lsbHMpO1xyXG4gICAgc2V0QmlvKGRhdGEuYmlvKTtcclxuICAgIHNldEFib3V0KGRhdGEuYWJvdXQpO1xyXG4gICAgLy8gc2V0UGRmQ29udGVudChkYXRhLnJlc3VtZSk7XHJcblxyXG4gICAgc2V0UHJvZmlsZVBpY3R1cmVMaW5rKGRhdGEucHJvZmlsZV9waWN0dXJlX2xpbmspO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVJlc3VtZVVwbG9hZCA9IGFzeW5jIChcclxuICAgIGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxyXG4gICkgPT4ge1xyXG4gICAgY29uc3QgZmlsZSA9IGV2ZW50LnRhcmdldC5maWxlcz8uWzBdO1xyXG4gICAgaWYgKGZpbGUpIHtcclxuICAgICAgaWYgKGZpbGUudHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9wZGZcIikge1xyXG4gICAgICAgIHNldFJlc3VtZUZpbGUoZmlsZSk7XHJcbiAgICAgICAgc2V0VXBsb2FkVGltZShuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCkpO1xyXG4gICAgICAgIHNldElzTG9hZGluZ1BkZih0cnVlKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgZ2V0SXRlbXMoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJUaGUgdGV4dCBpcyBcIisgdGV4dCk7XHJcbiAgICAgICAgICBzZXRQZGZDb250ZW50KHRleHQpO1xyXG4gICAgICAgICAgLy9zZXQgdGhlIGV4dHJhY3RlZCBwZGYgY29udGVudCB0byB0aGUgZGF0YWJhc2VcclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9yZXN1bWVgLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyByZXN1bWU6IHRleHQgfSksXHJcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgIGFsZXJ0KFwiUmVzdW1lIHVwbG9hZGVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFsZXJ0KFwiRXJyb3IgdXBsb2FkaW5nIHJlc3VtZS4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWFkaW5nIFBERjpcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgYWxlcnQoXCJFcnJvciByZWFkaW5nIFBERiBmaWxlLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgc2V0SXNMb2FkaW5nUGRmKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWxlcnQoXCJQbGVhc2UgdXBsb2FkIGEgUERGIGZpbGVcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVQcm9maWxlUGljdHVyZVVwbG9hZCA9IGFzeW5jIChcclxuICAgIGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxyXG4gICkgPT4ge1xyXG4gICAgY29uc3QgZmlsZSA9IGV2ZW50LnRhcmdldC5maWxlcz8uWzBdO1xyXG4gICAgaWYgKGZpbGUpIHtcclxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwicHJvZmlsZVBpY3R1cmVcIiwgZmlsZSk7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS91cGxvYWQtcHJvZmlsZS1waWN0dXJlYCwge1xyXG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4gICAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICBzZXRQcm9maWxlUGljdHVyZUxpbmsoZGF0YS5wcm9maWxlUGljdHVyZUxpbmspO1xyXG4gICAgICAgICAgc2V0SXNFZGl0aW5nUHJvZmlsZVBpY3R1cmUoZmFsc2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhbGVydChcIkVycm9yIHVwbG9hZGluZyBwcm9maWxlIHBpY3R1cmUuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIHByb2ZpbGUgcGljdHVyZTpcIiwgZXJyb3IpO1xyXG4gICAgICAgIGFsZXJ0KFwiRXJyb3IgdXBsb2FkaW5nIHByb2ZpbGUgcGljdHVyZS4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCB0cmlnZ2VyRmlsZUlucHV0Q2xpY2sgPSAoKSA9PiB7XHJcbiAgICBmaWxlSW5wdXRSZWYuY3VycmVudD8uY2xpY2soKTtcclxuICB9O1xyXG5cclxuICBjb25zdCB0cmlnZ2VyUHJvZmlsZVBpY3R1cmVVcGxvYWQgPSAoKSA9PiB7XHJcbiAgICBwcm9maWxlUGljdHVyZUlucHV0UmVmLmN1cnJlbnQ/LmNsaWNrKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlQWRkU2tpbGwgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAobmV3U2tpbGwgJiYgIXNraWxscy5pbmNsdWRlcyhuZXdTa2lsbCkpIHtcclxuICAgICAgY29uc3QgdXBkYXRlZFNraWxscyA9IFsuLi5za2lsbHMsIG5ld1NraWxsXTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBhd2FpdCB1cGRhdGVVc2VyUHJvZmlsZSh7IHNraWxsczogdXBkYXRlZFNraWxscyB9KTtcclxuICAgICAgICBzZXRTa2lsbHModXBkYXRlZFNraWxscyk7XHJcbiAgICAgICAgc2V0TmV3U2tpbGwoXCJcIik7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwZGF0aW5nIHNraWxsczpcIiwgZXJyb3IpO1xyXG4gICAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHVwZGF0ZSBza2lsbHMuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlUmVtb3ZlU2tpbGwgPSBhc3luYyAoc2tpbGxUb1JlbW92ZTogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCB1cGRhdGVkU2tpbGxzID0gc2tpbGxzLmZpbHRlcigoc2tpbGwpID0+IHNraWxsICE9PSBza2lsbFRvUmVtb3ZlKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIGF3YWl0IHVwZGF0ZVVzZXJQcm9maWxlKHsgc2tpbGxzOiB1cGRhdGVkU2tpbGxzIH0pO1xyXG4gICAgICBzZXRTa2lsbHModXBkYXRlZFNraWxscyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgc2tpbGxzOlwiLCBlcnJvcik7XHJcbiAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHVwZGF0ZSBza2lsbHMuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVVwZGF0ZUpvYlRpdGxlID0gYXN5bmMgKGpvYlRpdGxlOiBzdHJpbmcpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS91cGRhdGUtdGl0bGVgLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgam9iVGl0bGU6IGpvYlRpdGxlIH0pLFxyXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgam9iIHRpdGxlXCIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFsZXJ0KFwiRXJyb3IgdXBkYXRpbmcgam9iIHRpdGxlLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcclxuICAgICAgfVxyXG4gICAgICBzZXRJc0VkaXRpbmdKb2JUaXRsZShmYWxzZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgam9iIHRpdGxlOlwiLCBlcnJvcik7XHJcbiAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHVwZGF0ZSBqb2IgdGl0bGUuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVVwZGF0ZUNpdHkgPSBhc3luYyAoY2l0eTogc3RyaW5nKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vdXBkYXRlLWxvY2F0aW9uYCwge1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGxvY2F0aW9uOiBjaXR5IH0pLFxyXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgdGhlIGxvY2F0aW9uXCIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFsZXJ0KFwiRXJyb3IgdXBkYXRpbmcgam9iIHRpdGxlLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcclxuICAgICAgfVxyXG4gICAgICBzZXRJc0VkaXRpbmdDaXR5KGZhbHNlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGRhdGluZyBjaXR5OlwiLCBlcnJvcik7XHJcbiAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHVwZGF0ZSBjaXR5LiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVVcGRhdGVTa2lsbHMgPSBhc3luYyAoc2tpbGxzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gYXdhaXQgdXBkYXRlVXNlclByb2ZpbGUoeyBza2lsbHMgfSk7XHJcbiAgICAgIHNldElzRWRpdGluZ1NraWxscyhmYWxzZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgc2tpbGxzOlwiLCBlcnJvcik7XHJcbiAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHVwZGF0ZSBza2lsbHMuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVVwZGF0ZUJpbyA9IGFzeW5jIChiaW86IHN0cmluZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VwZGF0ZS1iaW9gLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgYmlvOiBiaW8gfSksXHJcbiAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTdWNjZXNzZnVsbHkgdXBkYXRlZCB1c2VycyBiaW9cIik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWxlcnQoXCJFcnJvciB1cGRhdGluZyBiaW8uIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHNldElzRWRpdGluZ0JpbyhmYWxzZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgYmlvOlwiLCBlcnJvcik7XHJcbiAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHVwZGF0ZSBiaW8uIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVVwZGF0ZUFib3V0ID0gYXN5bmMgKGFib3V0OiBzdHJpbmcpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS91cGRhdGUtYWJvdXRgLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgYWJvdXQ6IGFib3V0IH0pLFxyXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgYWJvdXQgc2VjdGlvblwiKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhbGVydChcIkVycm9yIHVwZGF0aW5nIEFib3V0IHNlY3Rpb24uIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHNldElzRWRpdGluZ0Fib3V0KGZhbHNlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGRhdGluZyBhYm91dDpcIiwgZXJyb3IpO1xyXG4gICAgICBhbGVydChcIkZhaWxlZCB0byB1cGRhdGUgYWJvdXQgc2VjdGlvbi4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBcIj5cclxuICAgICAgPE5hdkJhciAvPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1sLTY0IGZsZXgtMSBwLTRcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBteC1hdXRvIHNwYWNlLXktNiB3LVs5MCVdIG1kOnctWzUwJV1cIj5cclxuICAgICAgICAgIHsvKiBVc2VyIFByb2ZpbGUgQ2FyZCAqL31cclxuICAgICAgICAgIDxDYXJkPlxyXG4gICAgICAgICAgICA8Q2FyZEhlYWRlcj5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtNFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZVwiPlxyXG4gICAgICAgICAgICAgICAgICA8QXZhdGFyIGNsYXNzTmFtZT1cImgtMjAgdy0yMCBtZDpoLTMyIG1kOnctMzJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8QXZhdGFySW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICAgIHNyYz17cHJvZmlsZVBpY3R1cmVMaW5rfVxyXG4gICAgICAgICAgICAgICAgICAgICAgYWx0PVwiUHJvZmlsZSBQaWN0dXJlXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxBdmF0YXJGYWxsYmFjaz5cclxuICAgICAgICAgICAgICAgICAgICAgIHtuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChcIiBcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgobikgPT4gblswXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCJcIil9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9BdmF0YXJGYWxsYmFjaz5cclxuICAgICAgICAgICAgICAgICAgPC9BdmF0YXI+XHJcbiAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcclxuICAgICAgICAgICAgICAgICAgICBzaXplPVwiaWNvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgYm90dG9tLTAgcmlnaHQtMFwiXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dHJpZ2dlclByb2ZpbGVQaWN0dXJlVXBsb2FkfVxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPENhbWVyYSBjbGFzc05hbWU9XCJoLTQgdy00XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzci1vbmx5XCI+Q2hhbmdlIHByb2ZpbGUgcGljdHVyZTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgIDxJbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZj17cHJvZmlsZVBpY3R1cmVJbnB1dFJlZn1cclxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiZmlsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0PVwiaW1hZ2UvKlwiXHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZVByb2ZpbGVQaWN0dXJlVXBsb2FkfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImhpZGRlblwiXHJcbiAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxDYXJkVGl0bGUgY2xhc3NOYW1lPVwidGV4dC0yeGxcIj57bmFtZX08L0NhcmRUaXRsZT5cclxuICAgICAgICAgICAgICAgICAge2lzRWRpdGluZ0pvYlRpdGxlID8gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgbXQtMVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPElucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtqb2JUaXRsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJVcGRhdGUgeW91ciBqb2IgdGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldEpvYlRpdGxlKGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaC02IHB5LTEgdGV4dC1zbVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplPVwic21cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBoYW5kbGVVcGRhdGVKb2JUaXRsZShqb2JUaXRsZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNhdmVcclxuICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1tdXRlZC1mb3JlZ3JvdW5kIGZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7am9iVGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJnaG9zdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU9XCJzbVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldElzRWRpdGluZ0pvYlRpdGxlKHRydWUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8RWRpdDIgY2xhc3NOYW1lPVwiaC0zIHctM1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNyLW9ubHlcIj5FZGl0IGpvYiB0aXRsZTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBtdC0xIHRleHQtc20gdGV4dC1tdXRlZC1mb3JlZ3JvdW5kXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPE1hcFBpbiBjbGFzc05hbWU9XCJtci0xIGgtNCB3LTRcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIHtpc0VkaXRpbmdDaXR5ID8gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y2l0eX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldENpdHkoZS50YXJnZXQudmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImgtNiBweS0xIHRleHQtc21cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVXBkYXRlIHlvdXIgbG9jYXRpb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBoYW5kbGVVcGRhdGVDaXR5KGNpdHkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgU2F2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICkgOiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2l0eX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJnaG9zdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRJc0VkaXRpbmdDaXR5KHRydWUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEVkaXQyIGNsYXNzTmFtZT1cImgtMyB3LTNcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNyLW9ubHlcIj5FZGl0IGNpdHk8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvQ2FyZEhlYWRlcj5cclxuICAgICAgICAgICAgPENhcmRDb250ZW50PlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS00XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBtYi0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj5Ub3AgU2tpbGxzPC9oMz5cclxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50PVwiZ2hvc3RcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldElzRWRpdGluZ1NraWxscyghaXNFZGl0aW5nU2tpbGxzKX1cclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8RWRpdDIgY2xhc3NOYW1lPVwiaC00IHctNFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzci1vbmx5XCI+RWRpdCBza2lsbHM8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICB7aXNFZGl0aW5nU2tpbGxzID8gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC13cmFwIGdhcC0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtza2lsbHMubWFwKChza2lsbCwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8QmFkZ2Uga2V5PXtpbmRleH0gdmFyaWFudD1cInNlY29uZGFyeVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3NraWxsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBoYW5kbGVSZW1vdmVTa2lsbChza2lsbCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1sLTEgdGV4dC14c1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxYIGNsYXNzTmFtZT1cImgtMyB3LTNcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzci1vbmx5XCI+UmVtb3ZlIHNraWxsPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CYWRnZT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17bmV3U2tpbGx9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXROZXdTa2lsbChlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJBZGQgYSBza2lsbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmxleC1ncm93XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBoYW5kbGVVcGRhdGVTa2lsbHMoc2tpbGxzKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgQWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICkgOiAoXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBnYXAtMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAge3NraWxscy5tYXAoKHNraWxsLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QmFkZ2Uga2V5PXtpbmRleH0gdmFyaWFudD1cInNlY29uZGFyeVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtza2lsbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9CYWRnZT5cclxuICAgICAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBtYi0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj5CaW88L2gzPlxyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJnaG9zdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBzaXplPVwic21cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0SXNFZGl0aW5nQmlvKCFpc0VkaXRpbmdCaW8pfVxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgIDxFZGl0MiBjbGFzc05hbWU9XCJoLTQgdy00XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNyLW9ubHlcIj5FZGl0IGJpbzwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIHtpc0VkaXRpbmdCaW8gPyAoXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxUZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17YmlvfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldEJpbyhlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3M9ezR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBoYW5kbGVVcGRhdGVCaW8oYmlvKX0+U2F2ZTwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1tdXRlZC1mb3JlZ3JvdW5kXCI+e2Jpb308L3A+XHJcbiAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9DYXJkQ29udGVudD5cclxuICAgICAgICAgIDwvQ2FyZD5cclxuXHJcbiAgICAgICAgICB7LyogUmVzdW1lIFVwbG9hZCBDYXJkICovfVxyXG4gICAgICAgICAgPENhcmQ+XHJcbiAgICAgICAgICAgIDxDYXJkSGVhZGVyPlxyXG4gICAgICAgICAgICAgIDxDYXJkVGl0bGUgY2xhc3NOYW1lPVwidGV4dC14bFwiPlJlc3VtZTwvQ2FyZFRpdGxlPlxyXG4gICAgICAgICAgICA8L0NhcmRIZWFkZXI+XHJcbiAgICAgICAgICAgIDxDYXJkQ29udGVudD5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC13cmFwIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gbWItNFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgICA8RmlsZVRleHQgY2xhc3NOYW1lPVwibXItMiBoLTUgdy01XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXB1cnBsZS00MDAgZm9udC1zZXJpZlwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHtyZXN1bWVVcGxvYWRlZERhdGVcclxuICAgICAgICAgICAgICAgICAgICAgID8gYFJlc3VtZSB1cGxvYWRlZCBvbjogJHtuZXcgRGF0ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bWVVcGxvYWRlZERhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgKS50b0xvY2FsZURhdGVTdHJpbmcoKX1gXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiTm8gcmVzdW1lIHVwbG9hZGVkXCJ9XHJcbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudD1cIm91dGxpbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RyaWdnZXJGaWxlSW5wdXRDbGlja31cclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17aXNMb2FkaW5nUGRmfVxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPFVwbG9hZCBjbGFzc05hbWU9XCJtci0yIGgtNCB3LTRcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIHtpc0xvYWRpbmdQZGYgPyBcIlByb2Nlc3NpbmcuLi5cIiA6IFwiVXBsb2FkIFJlc3VtZVwifVxyXG4gICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgPElucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmPXtmaWxlSW5wdXRSZWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImZpbGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdD1cIi5wZGZcIlxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVSZXN1bWVVcGxvYWR9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaGlkZGVuXCJcclxuICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIHt1cGxvYWRUaW1lICYmIChcclxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1tdXRlZC1mb3JlZ3JvdW5kXCI+XHJcbiAgICAgICAgICAgICAgICAgIFVwbG9hZGVkIG9uOiB7dXBsb2FkVGltZX1cclxuICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgIHtpc0xvYWRpbmdQZGYgJiYgKFxyXG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LW11dGVkLWZvcmVncm91bmQgbXQtMlwiPlxyXG4gICAgICAgICAgICAgICAgICBSZWFkaW5nIFBERiBjb250ZW50Li4uXHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgPC9DYXJkQ29udGVudD5cclxuICAgICAgICAgIDwvQ2FyZD5cclxuXHJcbiAgICAgICAgICB7LyogQWJvdXQgU2VjdGlvbiAqL31cclxuICAgICAgICAgIDxDYXJkPlxyXG4gICAgICAgICAgICA8Q2FyZEhlYWRlcj5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiPlxyXG4gICAgICAgICAgICAgICAgPENhcmRUaXRsZSBjbGFzc05hbWU9XCJ0ZXh0LXhsXCI+QWJvdXQ8L0NhcmRUaXRsZT5cclxuICAgICAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICAgICAgdmFyaWFudD1cImdob3N0XCJcclxuICAgICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcclxuICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0SXNFZGl0aW5nQWJvdXQoIWlzRWRpdGluZ0Fib3V0KX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgPEVkaXQyIGNsYXNzTmFtZT1cImgtNCB3LTRcIiAvPlxyXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJzci1vbmx5XCI+RWRpdCBhYm91dCBzZWN0aW9uPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvQ2FyZEhlYWRlcj5cclxuICAgICAgICAgICAgPENhcmRDb250ZW50PlxyXG4gICAgICAgICAgICAgIHtpc0VkaXRpbmdBYm91dCA/IChcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxUZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXthYm91dH1cclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldEFib3V0KGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICByb3dzPXs0fVxyXG4gICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eygpID0+IGhhbmRsZVVwZGF0ZUFib3V0KGFib3V0KX0+U2F2ZTwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1tdXRlZC1mb3JlZ3JvdW5kXCI+e2Fib3V0fTwvcD5cclxuICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICA8L0NhcmRDb250ZW50PlxyXG4gICAgICAgICAgPC9DYXJkPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiQnV0dG9uIiwiQ2FyZCIsIkNhcmRDb250ZW50IiwiQ2FyZEhlYWRlciIsIkNhcmRUaXRsZSIsIkF2YXRhciIsIkF2YXRhckZhbGxiYWNrIiwiQXZhdGFySW1hZ2UiLCJCYWRnZSIsIklucHV0IiwiVGV4dGFyZWEiLCJNYXBQaW4iLCJGaWxlVGV4dCIsIlVwbG9hZCIsIkVkaXQyIiwiWCIsIkNhbWVyYSIsInVzZUF1dGgiLCJwZGZqcyIsIk5hdkJhciIsIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwiLCJHbG9iYWxXb3JrZXJPcHRpb25zIiwid29ya2VyU3JjIiwiUHJvZmlsZVBhZ2UiLCJpc1NpZ25lZEluIiwiYmlvIiwic2V0QmlvIiwiaXNFZGl0aW5nQmlvIiwic2V0SXNFZGl0aW5nQmlvIiwic2tpbGxzIiwic2V0U2tpbGxzIiwiaXNFZGl0aW5nU2tpbGxzIiwic2V0SXNFZGl0aW5nU2tpbGxzIiwibmV3U2tpbGwiLCJzZXROZXdTa2lsbCIsImFib3V0Iiwic2V0QWJvdXQiLCJpc0VkaXRpbmdBYm91dCIsInNldElzRWRpdGluZ0Fib3V0IiwicmVzdW1lRmlsZSIsInNldFJlc3VtZUZpbGUiLCJ1cGxvYWRUaW1lIiwic2V0VXBsb2FkVGltZSIsImpvYlRpdGxlIiwic2V0Sm9iVGl0bGUiLCJjaXR5Iiwic2V0Q2l0eSIsImlzRWRpdGluZ0pvYlRpdGxlIiwic2V0SXNFZGl0aW5nSm9iVGl0bGUiLCJpc0VkaXRpbmdDaXR5Iiwic2V0SXNFZGl0aW5nQ2l0eSIsInBkZkNvbnRlbnQiLCJzZXRQZGZDb250ZW50IiwiaXNMb2FkaW5nUGRmIiwic2V0SXNMb2FkaW5nUGRmIiwibmFtZSIsInNldE5hbWUiLCJwcm9maWxlUGljdHVyZUxpbmsiLCJzZXRQcm9maWxlUGljdHVyZUxpbmsiLCJpc0VkaXRpbmdQcm9maWxlUGljdHVyZSIsInNldElzRWRpdGluZ1Byb2ZpbGVQaWN0dXJlIiwicmVzdW1lVXBsb2FkZWREYXRlIiwic2V0UmVzdW1lVXBsb2FkZWREYXRlIiwiZmlsZUlucHV0UmVmIiwicHJvZmlsZVBpY3R1cmVJbnB1dFJlZiIsImdldENvbnRlbnQiLCJzcmMiLCJkb2MiLCJnZXREb2N1bWVudCIsImRhdGEiLCJwcm9taXNlIiwicGFnZSIsImdldFBhZ2UiLCJnZXRUZXh0Q29udGVudCIsImdldEl0ZW1zIiwiY29udGVudCIsImZ1bGxUZXh0IiwiaXRlbXMiLCJmb3JFYWNoIiwiaXRlbSIsInN0ciIsInRyaW0iLCJnZXRVc2VyRGF0YSIsInJlc3BvbnNlIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsIm9rIiwiY29uc29sZSIsImVycm9yIiwianNvbiIsImxvZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXN1bWVfdXBsb2FkZWRfZGF0ZSIsInNwbGl0IiwibWFwIiwid29yZCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsImpvaW4iLCJ0aXRsZSIsImxvY2F0aW9uIiwicHJvZmlsZV9waWN0dXJlX2xpbmsiLCJoYW5kbGVSZXN1bWVVcGxvYWQiLCJldmVudCIsImZpbGUiLCJ0YXJnZXQiLCJmaWxlcyIsInR5cGUiLCJEYXRlIiwidG9Mb2NhbGVTdHJpbmciLCJhcnJheUJ1ZmZlciIsInRleHQiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInJlc3VtZSIsImFsZXJ0IiwiaGFuZGxlUHJvZmlsZVBpY3R1cmVVcGxvYWQiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwidHJpZ2dlckZpbGVJbnB1dENsaWNrIiwiY3VycmVudCIsImNsaWNrIiwidHJpZ2dlclByb2ZpbGVQaWN0dXJlVXBsb2FkIiwiaGFuZGxlQWRkU2tpbGwiLCJpbmNsdWRlcyIsInVwZGF0ZWRTa2lsbHMiLCJoYW5kbGVSZW1vdmVTa2lsbCIsInNraWxsVG9SZW1vdmUiLCJmaWx0ZXIiLCJza2lsbCIsImhhbmRsZVVwZGF0ZUpvYlRpdGxlIiwiaGFuZGxlVXBkYXRlQ2l0eSIsImhhbmRsZVVwZGF0ZVNraWxscyIsImhhbmRsZVVwZGF0ZUJpbyIsImhhbmRsZVVwZGF0ZUFib3V0IiwiZGl2IiwiY2xhc3NOYW1lIiwiYWx0IiwibiIsInZhcmlhbnQiLCJzaXplIiwib25DbGljayIsInNwYW4iLCJyZWYiLCJhY2NlcHQiLCJvbkNoYW5nZSIsInZhbHVlIiwicGxhY2Vob2xkZXIiLCJlIiwicCIsImgzIiwiaW5kZXgiLCJidXR0b24iLCJyb3dzIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiZGlzYWJsZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/profile/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/NavBar.tsx":
/*!***********************************!*\
  !*** ./src/components/NavBar.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NavBar: function() { return /* binding */ NavBar; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/navigation.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_navigation__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_ui_button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/ui/button */ \"(app-pages-browser)/./src/components/ui/button.tsx\");\n/* harmony import */ var _barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Briefcase,Contact,Home,LogOut,Menu,User,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\");\n/* harmony import */ var _barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=Briefcase,Contact,Home,LogOut,Menu,User,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/menu.js\");\n/* harmony import */ var _barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Briefcase,Contact,Home,LogOut,Menu,User,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/house.js\");\n/* harmony import */ var _barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Briefcase,Contact,Home,LogOut,Menu,User,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/briefcase.js\");\n/* harmony import */ var _barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=Briefcase,Contact,Home,LogOut,Menu,User,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/user.js\");\n/* harmony import */ var _barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=Briefcase,Contact,Home,LogOut,Menu,User,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/contact.js\");\n/* harmony import */ var _barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! __barrel_optimize__?names=Briefcase,Contact,Home,LogOut,Menu,User,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/log-out.js\");\n/* harmony import */ var _clerk_nextjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @clerk/nextjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ NavBar auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction NavBar() {\n    _s();\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.usePathname)();\n    const { signOut } = (0,_clerk_nextjs__WEBPACK_IMPORTED_MODULE_5__.useClerk)();\n    const toggleSidebar = ()=>setIsOpen(!isOpen);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                variant: \"outline\",\n                size: \"icon\",\n                className: \"fixed top-4 left-4 z-50\",\n                onClick: toggleSidebar,\n                children: isOpen ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                    className: \"h-4 w-4\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                    lineNumber: 25,\n                    columnNumber: 19\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                    className: \"h-4 w-4\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                    lineNumber: 25,\n                    columnNumber: 47\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                lineNumber: 19,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                className: \"bg-background border-r h-screen w-64 fixed left-0 top-0 p-4 transition-transform duration-300 ease-in-out transform \".concat(isOpen ? \"translate-x-0\" : \"-translate-x-full\"),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-col space-y-4 mt-16\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                            href: \"/match\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                                variant: pathname === \"/match\" ? \"default\" : \"ghost\",\n                                className: \"w-full justify-start\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                        className: \"mr-2 h-4 w-4\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                                        lineNumber: 34,\n                                        columnNumber: 15\n                                    }, this),\n                                    \"Home\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                                lineNumber: 30,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                            lineNumber: 29,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                            href: \"/jobsApplied\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                                variant: pathname === \"/jobsApplied\" ? \"default\" : \"ghost\",\n                                className: \"w-full justify-start\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                        className: \"mr-2 h-4 w-4\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                                        lineNumber: 43,\n                                        columnNumber: 15\n                                    }, this),\n                                    \"Jobs Applied\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                                lineNumber: 39,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                            lineNumber: 38,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                            href: \"/profile\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                                variant: pathname === \"/profile\" ? \"default\" : \"ghost\",\n                                className: \"w-full justify-start\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                        className: \"mr-2 h-4 w-4\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                                        lineNumber: 52,\n                                        columnNumber: 15\n                                    }, this),\n                                    \"Profile\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                                lineNumber: 48,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                            lineNumber: 47,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                            href: \"/about\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                                variant: pathname === \"/about\" ? \"default\" : \"ghost\",\n                                className: \"w-full justify-start\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                        className: \"mr-2 h-4 w-4\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                                        lineNumber: 61,\n                                        columnNumber: 15\n                                    }, this),\n                                    \"About Us\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                                lineNumber: 57,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                            lineNumber: 56,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                            variant: \"ghost\",\n                            className: \"w-full justify-start\",\n                            onClick: ()=>signOut({\n                                    redirectUrl: \"/\"\n                                }),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Briefcase_Contact_Home_LogOut_Menu_User_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                    className: \"mr-2 h-4 w-4\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                                    lineNumber: 66,\n                                    columnNumber: 13\n                                }, this),\n                                \"Logout\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                            lineNumber: 65,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                    lineNumber: 28,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\NavBar.tsx\",\n                lineNumber: 27,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(NavBar, \"Q8WC7jTCx3obgickjhBghNfOqxw=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.usePathname,\n        _clerk_nextjs__WEBPACK_IMPORTED_MODULE_5__.useClerk\n    ];\n});\n_c = NavBar;\nvar _c;\n$RefreshReg$(_c, \"NavBar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05hdkJhci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVpQztBQUNKO0FBQ2lCO0FBQ0U7QUFDK0I7QUFDdEM7QUFFbEMsU0FBU1k7O0lBQ2QsTUFBTSxDQUFDQyxRQUFRQyxVQUFVLEdBQUdkLCtDQUFRQSxDQUFDO0lBQ3JDLE1BQU1lLFdBQVdiLDREQUFXQTtJQUM1QixNQUFNLEVBQUVjLE9BQU8sRUFBRSxHQUFHTCx1REFBUUE7SUFFNUIsTUFBTU0sZ0JBQWdCLElBQU1ILFVBQVUsQ0FBQ0Q7SUFFdkMscUJBQ0U7OzBCQUNFLDhEQUFDVix5REFBTUE7Z0JBQ0xlLFNBQVE7Z0JBQ1JDLE1BQUs7Z0JBQ0xDLFdBQVU7Z0JBQ1ZDLFNBQVNKOzBCQUVSSix1QkFBUyw4REFBQ0gscUhBQUNBO29CQUFDVSxXQUFVOzs7Ozt5Q0FBZSw4REFBQ1gscUhBQUlBO29CQUFDVyxXQUFVOzs7Ozs7Ozs7OzswQkFFeEQsOERBQUNFO2dCQUFJRixXQUFXLHVIQUFzSyxPQUEvQ1AsU0FBUyxrQkFBa0I7MEJBQ2hLLDRFQUFDVTtvQkFBSUgsV0FBVTs7c0NBQ2IsOERBQUNuQixrREFBSUE7NEJBQUN1QixNQUFLO3NDQUNULDRFQUFDckIseURBQU1BO2dDQUNMZSxTQUFTSCxhQUFhLFdBQVcsWUFBWTtnQ0FDN0NLLFdBQVU7O2tEQUVWLDhEQUFDaEIscUhBQUlBO3dDQUFDZ0IsV0FBVTs7Ozs7O29DQUFpQjs7Ozs7Ozs7Ozs7O3NDQUlyQyw4REFBQ25CLGtEQUFJQTs0QkFBQ3VCLE1BQUs7c0NBQ1QsNEVBQUNyQix5REFBTUE7Z0NBQ0xlLFNBQVNILGFBQWEsaUJBQWlCLFlBQVk7Z0NBQ25ESyxXQUFVOztrREFFViw4REFBQ2YscUhBQVNBO3dDQUFDZSxXQUFVOzs7Ozs7b0NBQWlCOzs7Ozs7Ozs7Ozs7c0NBSTFDLDhEQUFDbkIsa0RBQUlBOzRCQUFDdUIsTUFBSztzQ0FDVCw0RUFBQ3JCLHlEQUFNQTtnQ0FDTGUsU0FBU0gsYUFBYSxhQUFhLFlBQVk7Z0NBQy9DSyxXQUFVOztrREFFViw4REFBQ2Qsc0hBQUlBO3dDQUFDYyxXQUFVOzs7Ozs7b0NBQWlCOzs7Ozs7Ozs7Ozs7c0NBSXJDLDhEQUFDbkIsa0RBQUlBOzRCQUFDdUIsTUFBSztzQ0FDVCw0RUFBQ3JCLHlEQUFNQTtnQ0FDTGUsU0FBU0gsYUFBYSxXQUFXLFlBQVk7Z0NBQzdDSyxXQUFVOztrREFFViw4REFBQ1osc0hBQU9BO3dDQUFDWSxXQUFVOzs7Ozs7b0NBQWlCOzs7Ozs7Ozs7Ozs7c0NBSXhDLDhEQUFDakIseURBQU1BOzRCQUFDZSxTQUFROzRCQUFRRSxXQUFVOzRCQUF1QkMsU0FBUyxJQUFNTCxRQUFRO29DQUFFUyxhQUFhO2dDQUFJOzs4Q0FDakcsOERBQUNsQixzSEFBTUE7b0NBQUNhLFdBQVU7Ozs7OztnQ0FBaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTy9DO0dBL0RnQlI7O1FBRUdWLHdEQUFXQTtRQUNSUyxtREFBUUE7OztLQUhkQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9OYXZCYXIudHN4P2Q5ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xyXG5pbXBvcnQgeyB1c2VQYXRobmFtZSB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSBcIkAvY29tcG9uZW50cy91aS9idXR0b25cIjtcclxuaW1wb3J0IHsgSG9tZSwgQnJpZWZjYXNlLCBVc2VyLCBMb2dPdXQsIENvbnRhY3QsIE1lbnUsIFggfSBmcm9tICdsdWNpZGUtcmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VDbGVyayB9IGZyb20gXCJAY2xlcmsvbmV4dGpzXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTmF2QmFyKCkge1xyXG4gIGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSB1c2VTdGF0ZSh0cnVlKTtcclxuICBjb25zdCBwYXRobmFtZSA9IHVzZVBhdGhuYW1lKCk7XHJcbiAgY29uc3QgeyBzaWduT3V0IH0gPSB1c2VDbGVyaygpO1xyXG5cclxuICBjb25zdCB0b2dnbGVTaWRlYmFyID0gKCkgPT4gc2V0SXNPcGVuKCFpc09wZW4pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPD5cclxuICAgICAgPEJ1dHRvblxyXG4gICAgICAgIHZhcmlhbnQ9XCJvdXRsaW5lXCJcclxuICAgICAgICBzaXplPVwiaWNvblwiXHJcbiAgICAgICAgY2xhc3NOYW1lPVwiZml4ZWQgdG9wLTQgbGVmdC00IHotNTBcIlxyXG4gICAgICAgIG9uQ2xpY2s9e3RvZ2dsZVNpZGViYXJ9XHJcbiAgICAgID5cclxuICAgICAgICB7aXNPcGVuID8gPFggY2xhc3NOYW1lPVwiaC00IHctNFwiIC8+IDogPE1lbnUgY2xhc3NOYW1lPVwiaC00IHctNFwiIC8+fVxyXG4gICAgICA8L0J1dHRvbj5cclxuICAgICAgPG5hdiBjbGFzc05hbWU9e2BiZy1iYWNrZ3JvdW5kIGJvcmRlci1yIGgtc2NyZWVuIHctNjQgZml4ZWQgbGVmdC0wIHRvcC0wIHAtNCB0cmFuc2l0aW9uLXRyYW5zZm9ybSBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXQgdHJhbnNmb3JtICR7aXNPcGVuID8gJ3RyYW5zbGF0ZS14LTAnIDogJy10cmFuc2xhdGUteC1mdWxsJ31gfT5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgc3BhY2UteS00IG10LTE2XCI+XHJcbiAgICAgICAgICA8TGluayBocmVmPVwiL21hdGNoXCI+XHJcbiAgICAgICAgICAgIDxCdXR0b25cclxuICAgICAgICAgICAgICB2YXJpYW50PXtwYXRobmFtZSA9PT0gXCIvbWF0Y2hcIiA/IFwiZGVmYXVsdFwiIDogXCJnaG9zdFwifVxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBqdXN0aWZ5LXN0YXJ0XCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIDxIb21lIGNsYXNzTmFtZT1cIm1yLTIgaC00IHctNFwiIC8+XHJcbiAgICAgICAgICAgICAgSG9tZVxyXG4gICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvam9ic0FwcGxpZWRcIj5cclxuICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgIHZhcmlhbnQ9e3BhdGhuYW1lID09PSBcIi9qb2JzQXBwbGllZFwiID8gXCJkZWZhdWx0XCIgOiBcImdob3N0XCJ9XHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGp1c3RpZnktc3RhcnRcIlxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgPEJyaWVmY2FzZSBjbGFzc05hbWU9XCJtci0yIGgtNCB3LTRcIiAvPlxyXG4gICAgICAgICAgICAgIEpvYnMgQXBwbGllZFxyXG4gICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvcHJvZmlsZVwiPlxyXG4gICAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgICAgdmFyaWFudD17cGF0aG5hbWUgPT09IFwiL3Byb2ZpbGVcIiA/IFwiZGVmYXVsdFwiIDogXCJnaG9zdFwifVxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBqdXN0aWZ5LXN0YXJ0XCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIDxVc2VyIGNsYXNzTmFtZT1cIm1yLTIgaC00IHctNFwiIC8+XHJcbiAgICAgICAgICAgICAgUHJvZmlsZVxyXG4gICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvYWJvdXRcIj5cclxuICAgICAgICAgICAgPEJ1dHRvblxyXG4gICAgICAgICAgICAgIHZhcmlhbnQ9e3BhdGhuYW1lID09PSBcIi9hYm91dFwiID8gXCJkZWZhdWx0XCIgOiBcImdob3N0XCJ9XHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGp1c3RpZnktc3RhcnRcIlxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgPENvbnRhY3QgY2xhc3NOYW1lPVwibXItMiBoLTQgdy00XCIgLz5cclxuICAgICAgICAgICAgICBBYm91dCBVc1xyXG4gICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgIDxCdXR0b24gdmFyaWFudD1cImdob3N0XCIgY2xhc3NOYW1lPVwidy1mdWxsIGp1c3RpZnktc3RhcnRcIiBvbkNsaWNrPXsoKSA9PiBzaWduT3V0KHsgcmVkaXJlY3RVcmw6ICcvJyB9KX0+XHJcbiAgICAgICAgICAgIDxMb2dPdXQgY2xhc3NOYW1lPVwibXItMiBoLTQgdy00XCIgLz5cclxuICAgICAgICAgICAgTG9nb3V0XHJcbiAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9uYXY+XHJcbiAgICA8Lz5cclxuICApO1xyXG59XHJcblxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJMaW5rIiwidXNlUGF0aG5hbWUiLCJCdXR0b24iLCJIb21lIiwiQnJpZWZjYXNlIiwiVXNlciIsIkxvZ091dCIsIkNvbnRhY3QiLCJNZW51IiwiWCIsInVzZUNsZXJrIiwiTmF2QmFyIiwiaXNPcGVuIiwic2V0SXNPcGVuIiwicGF0aG5hbWUiLCJzaWduT3V0IiwidG9nZ2xlU2lkZWJhciIsInZhcmlhbnQiLCJzaXplIiwiY2xhc3NOYW1lIiwib25DbGljayIsIm5hdiIsImRpdiIsImhyZWYiLCJyZWRpcmVjdFVybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/NavBar.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/avatar.tsx":
/*!**************************************!*\
  !*** ./src/components/ui/avatar.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Avatar: function() { return /* binding */ Avatar; },\n/* harmony export */   AvatarFallback: function() { return /* binding */ AvatarFallback; },\n/* harmony export */   AvatarImage: function() { return /* binding */ AvatarImage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _radix_ui_react_avatar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @radix-ui/react-avatar */ \"(app-pages-browser)/./node_modules/@radix-ui/react-avatar/dist/index.mjs\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n/* __next_internal_client_entry_do_not_use__ Avatar,AvatarImage,AvatarFallback auto */ \n\n\n\nconst Avatar = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c = (param, ref)=>/*#__PURE__*/ {\n    let { className, ...props } = param;\n    return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_radix_ui_react_avatar__WEBPACK_IMPORTED_MODULE_3__.Root, {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\avatar.tsx\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, undefined);\n});\n_c1 = Avatar;\nAvatar.displayName = _radix_ui_react_avatar__WEBPACK_IMPORTED_MODULE_3__.Root.displayName;\nconst AvatarImage = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c2 = (param, ref)=>/*#__PURE__*/ {\n    let { className, ...props } = param;\n    return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_radix_ui_react_avatar__WEBPACK_IMPORTED_MODULE_3__.Image, {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"aspect-square h-full w-full\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\avatar.tsx\",\n        lineNumber: 27,\n        columnNumber: 3\n    }, undefined);\n});\n_c3 = AvatarImage;\nAvatarImage.displayName = _radix_ui_react_avatar__WEBPACK_IMPORTED_MODULE_3__.Image.displayName;\nconst AvatarFallback = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c4 = (param, ref)=>/*#__PURE__*/ {\n    let { className, ...props } = param;\n    return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_radix_ui_react_avatar__WEBPACK_IMPORTED_MODULE_3__.Fallback, {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"flex h-full w-full items-center justify-center rounded-full bg-muted\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\avatar.tsx\",\n        lineNumber: 39,\n        columnNumber: 3\n    }, undefined);\n});\n_c5 = AvatarFallback;\nAvatarFallback.displayName = _radix_ui_react_avatar__WEBPACK_IMPORTED_MODULE_3__.Fallback.displayName;\n\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"Avatar$React.forwardRef\");\n$RefreshReg$(_c1, \"Avatar\");\n$RefreshReg$(_c2, \"AvatarImage$React.forwardRef\");\n$RefreshReg$(_c3, \"AvatarImage\");\n$RefreshReg$(_c4, \"AvatarFallback$React.forwardRef\");\n$RefreshReg$(_c5, \"AvatarFallback\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2F2YXRhci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRThCO0FBQzJCO0FBRXpCO0FBRWhDLE1BQU1HLHVCQUFTSCw2Q0FBZ0IsTUFHN0IsUUFBMEJLO1FBQXpCLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFPO1dBQ3hCLDhEQUFDTix3REFBb0I7UUFDbkJJLEtBQUtBO1FBQ0xDLFdBQVdKLDhDQUFFQSxDQUNYLGlFQUNBSTtRQUVELEdBQUdDLEtBQUs7Ozs7OztBQUNWOztBQUVISixPQUFPTSxXQUFXLEdBQUdSLHdEQUFvQixDQUFDUSxXQUFXO0FBRXJELE1BQU1DLDRCQUFjViw2Q0FBZ0IsT0FHbEMsUUFBMEJLO1FBQXpCLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFPO1dBQ3hCLDhEQUFDTix5REFBcUI7UUFDcEJJLEtBQUtBO1FBQ0xDLFdBQVdKLDhDQUFFQSxDQUFDLCtCQUErQkk7UUFDNUMsR0FBR0MsS0FBSzs7Ozs7O0FBQ1Y7O0FBRUhHLFlBQVlELFdBQVcsR0FBR1IseURBQXFCLENBQUNRLFdBQVc7QUFFM0QsTUFBTUcsK0JBQWlCWiw2Q0FBZ0IsT0FHckMsUUFBMEJLO1FBQXpCLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFPO1dBQ3hCLDhEQUFDTiw0REFBd0I7UUFDdkJJLEtBQUtBO1FBQ0xDLFdBQVdKLDhDQUFFQSxDQUNYLHdFQUNBSTtRQUVELEdBQUdDLEtBQUs7Ozs7OztBQUNWOztBQUVISyxlQUFlSCxXQUFXLEdBQUdSLDREQUF3QixDQUFDUSxXQUFXO0FBRW5CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL2F2YXRhci50c3g/MWQwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxyXG5cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCJcclxuaW1wb3J0ICogYXMgQXZhdGFyUHJpbWl0aXZlIGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtYXZhdGFyXCJcclxuXHJcbmltcG9ydCB7IGNuIH0gZnJvbSBcIkAvbGliL3V0aWxzXCJcclxuXHJcbmNvbnN0IEF2YXRhciA9IFJlYWN0LmZvcndhcmRSZWY8XHJcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgQXZhdGFyUHJpbWl0aXZlLlJvb3Q+LFxyXG4gIFJlYWN0LkNvbXBvbmVudFByb3BzV2l0aG91dFJlZjx0eXBlb2YgQXZhdGFyUHJpbWl0aXZlLlJvb3Q+XHJcbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IChcclxuICA8QXZhdGFyUHJpbWl0aXZlLlJvb3RcclxuICAgIHJlZj17cmVmfVxyXG4gICAgY2xhc3NOYW1lPXtjbihcclxuICAgICAgXCJyZWxhdGl2ZSBmbGV4IGgtMTAgdy0xMCBzaHJpbmstMCBvdmVyZmxvdy1oaWRkZW4gcm91bmRlZC1mdWxsXCIsXHJcbiAgICAgIGNsYXNzTmFtZVxyXG4gICAgKX1cclxuICAgIHsuLi5wcm9wc31cclxuICAvPlxyXG4pKVxyXG5BdmF0YXIuZGlzcGxheU5hbWUgPSBBdmF0YXJQcmltaXRpdmUuUm9vdC5kaXNwbGF5TmFtZVxyXG5cclxuY29uc3QgQXZhdGFySW1hZ2UgPSBSZWFjdC5mb3J3YXJkUmVmPFxyXG4gIFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIEF2YXRhclByaW1pdGl2ZS5JbWFnZT4sXHJcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBBdmF0YXJQcmltaXRpdmUuSW1hZ2U+XHJcbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IChcclxuICA8QXZhdGFyUHJpbWl0aXZlLkltYWdlXHJcbiAgICByZWY9e3JlZn1cclxuICAgIGNsYXNzTmFtZT17Y24oXCJhc3BlY3Qtc3F1YXJlIGgtZnVsbCB3LWZ1bGxcIiwgY2xhc3NOYW1lKX1cclxuICAgIHsuLi5wcm9wc31cclxuICAvPlxyXG4pKVxyXG5BdmF0YXJJbWFnZS5kaXNwbGF5TmFtZSA9IEF2YXRhclByaW1pdGl2ZS5JbWFnZS5kaXNwbGF5TmFtZVxyXG5cclxuY29uc3QgQXZhdGFyRmFsbGJhY2sgPSBSZWFjdC5mb3J3YXJkUmVmPFxyXG4gIFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIEF2YXRhclByaW1pdGl2ZS5GYWxsYmFjaz4sXHJcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBBdmF0YXJQcmltaXRpdmUuRmFsbGJhY2s+XHJcbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IChcclxuICA8QXZhdGFyUHJpbWl0aXZlLkZhbGxiYWNrXHJcbiAgICByZWY9e3JlZn1cclxuICAgIGNsYXNzTmFtZT17Y24oXHJcbiAgICAgIFwiZmxleCBoLWZ1bGwgdy1mdWxsIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLWZ1bGwgYmctbXV0ZWRcIixcclxuICAgICAgY2xhc3NOYW1lXHJcbiAgICApfVxyXG4gICAgey4uLnByb3BzfVxyXG4gIC8+XHJcbikpXHJcbkF2YXRhckZhbGxiYWNrLmRpc3BsYXlOYW1lID0gQXZhdGFyUHJpbWl0aXZlLkZhbGxiYWNrLmRpc3BsYXlOYW1lXHJcblxyXG5leHBvcnQgeyBBdmF0YXIsIEF2YXRhckltYWdlLCBBdmF0YXJGYWxsYmFjayB9XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkF2YXRhclByaW1pdGl2ZSIsImNuIiwiQXZhdGFyIiwiZm9yd2FyZFJlZiIsInJlZiIsImNsYXNzTmFtZSIsInByb3BzIiwiUm9vdCIsImRpc3BsYXlOYW1lIiwiQXZhdGFySW1hZ2UiLCJJbWFnZSIsIkF2YXRhckZhbGxiYWNrIiwiRmFsbGJhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/avatar.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/badge.tsx":
/*!*************************************!*\
  !*** ./src/components/ui/badge.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Badge: function() { return /* binding */ Badge; },\n/* harmony export */   badgeVariants: function() { return /* binding */ badgeVariants; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var class_variance_authority__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! class-variance-authority */ \"(app-pages-browser)/./node_modules/class-variance-authority/dist/index.mjs\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n\n\n\n\nconst badgeVariants = (0,class_variance_authority__WEBPACK_IMPORTED_MODULE_2__.cva)(\"inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\", {\n    variants: {\n        variant: {\n            default: \"border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80\",\n            secondary: \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n            destructive: \"border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80\",\n            outline: \"text-foreground\"\n        }\n    },\n    defaultVariants: {\n        variant: \"default\"\n    }\n});\nfunction Badge(param) {\n    let { className, variant, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.cn)(badgeVariants({\n            variant\n        }), className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\badge.tsx\",\n        lineNumber: 32,\n        columnNumber: 5\n    }, this);\n}\n_c = Badge;\n\nvar _c;\n$RefreshReg$(_c, \"Badge\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2JhZGdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4QjtBQUNtQztBQUVqQztBQUVoQyxNQUFNRyxnQkFBZ0JGLDZEQUFHQSxDQUN2Qix3S0FDQTtJQUNFRyxVQUFVO1FBQ1JDLFNBQVM7WUFDUEMsU0FDRTtZQUNGQyxXQUNFO1lBQ0ZDLGFBQ0U7WUFDRkMsU0FBUztRQUNYO0lBQ0Y7SUFDQUMsaUJBQWlCO1FBQ2ZMLFNBQVM7SUFDWDtBQUNGO0FBT0YsU0FBU00sTUFBTSxLQUE0QztRQUE1QyxFQUFFQyxTQUFTLEVBQUVQLE9BQU8sRUFBRSxHQUFHUSxPQUFtQixHQUE1QztJQUNiLHFCQUNFLDhEQUFDQztRQUFJRixXQUFXViw4Q0FBRUEsQ0FBQ0MsY0FBYztZQUFFRTtRQUFRLElBQUlPO1FBQWEsR0FBR0MsS0FBSzs7Ozs7O0FBRXhFO0tBSlNGO0FBTXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL2JhZGdlLnRzeD9hMDBhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXHJcbmltcG9ydCB7IGN2YSwgdHlwZSBWYXJpYW50UHJvcHMgfSBmcm9tIFwiY2xhc3MtdmFyaWFuY2UtYXV0aG9yaXR5XCJcclxuXHJcbmltcG9ydCB7IGNuIH0gZnJvbSBcIkAvbGliL3V0aWxzXCJcclxuXHJcbmNvbnN0IGJhZGdlVmFyaWFudHMgPSBjdmEoXHJcbiAgXCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIgcm91bmRlZC1tZCBib3JkZXIgcHgtMi41IHB5LTAuNSB0ZXh0LXhzIGZvbnQtc2VtaWJvbGQgdHJhbnNpdGlvbi1jb2xvcnMgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLXJpbmcgZm9jdXM6cmluZy1vZmZzZXQtMlwiLFxyXG4gIHtcclxuICAgIHZhcmlhbnRzOiB7XHJcbiAgICAgIHZhcmlhbnQ6IHtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgXCJib3JkZXItdHJhbnNwYXJlbnQgYmctcHJpbWFyeSB0ZXh0LXByaW1hcnktZm9yZWdyb3VuZCBzaGFkb3cgaG92ZXI6YmctcHJpbWFyeS84MFwiLFxyXG4gICAgICAgIHNlY29uZGFyeTpcclxuICAgICAgICAgIFwiYm9yZGVyLXRyYW5zcGFyZW50IGJnLXNlY29uZGFyeSB0ZXh0LXNlY29uZGFyeS1mb3JlZ3JvdW5kIGhvdmVyOmJnLXNlY29uZGFyeS84MFwiLFxyXG4gICAgICAgIGRlc3RydWN0aXZlOlxyXG4gICAgICAgICAgXCJib3JkZXItdHJhbnNwYXJlbnQgYmctZGVzdHJ1Y3RpdmUgdGV4dC1kZXN0cnVjdGl2ZS1mb3JlZ3JvdW5kIHNoYWRvdyBob3ZlcjpiZy1kZXN0cnVjdGl2ZS84MFwiLFxyXG4gICAgICAgIG91dGxpbmU6IFwidGV4dC1mb3JlZ3JvdW5kXCIsXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgZGVmYXVsdFZhcmlhbnRzOiB7XHJcbiAgICAgIHZhcmlhbnQ6IFwiZGVmYXVsdFwiLFxyXG4gICAgfSxcclxuICB9XHJcbilcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmFkZ2VQcm9wc1xyXG4gIGV4dGVuZHMgUmVhY3QuSFRNTEF0dHJpYnV0ZXM8SFRNTERpdkVsZW1lbnQ+LFxyXG4gICAgVmFyaWFudFByb3BzPHR5cGVvZiBiYWRnZVZhcmlhbnRzPiB7fVxyXG5cclxuZnVuY3Rpb24gQmFkZ2UoeyBjbGFzc05hbWUsIHZhcmlhbnQsIC4uLnByb3BzIH06IEJhZGdlUHJvcHMpIHtcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9e2NuKGJhZGdlVmFyaWFudHMoeyB2YXJpYW50IH0pLCBjbGFzc05hbWUpfSB7Li4ucHJvcHN9IC8+XHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgeyBCYWRnZSwgYmFkZ2VWYXJpYW50cyB9XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImN2YSIsImNuIiwiYmFkZ2VWYXJpYW50cyIsInZhcmlhbnRzIiwidmFyaWFudCIsImRlZmF1bHQiLCJzZWNvbmRhcnkiLCJkZXN0cnVjdGl2ZSIsIm91dGxpbmUiLCJkZWZhdWx0VmFyaWFudHMiLCJCYWRnZSIsImNsYXNzTmFtZSIsInByb3BzIiwiZGl2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/badge.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/button.tsx":
/*!**************************************!*\
  !*** ./src/components/ui/button.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: function() { return /* binding */ Button; },\n/* harmony export */   buttonVariants: function() { return /* binding */ buttonVariants; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(app-pages-browser)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var class_variance_authority__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! class-variance-authority */ \"(app-pages-browser)/./node_modules/class-variance-authority/dist/index.mjs\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n\n\n\n\n\nconst buttonVariants = (0,class_variance_authority__WEBPACK_IMPORTED_MODULE_2__.cva)(\"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50\", {\n    variants: {\n        variant: {\n            default: \"bg-primary text-primary-foreground shadow hover:bg-primary/90\",\n            destructive: \"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90\",\n            outline: \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\n            secondary: \"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80\",\n            ghost: \"hover:bg-accent hover:text-accent-foreground\",\n            link: \"text-primary underline-offset-4 hover:underline\"\n        },\n        size: {\n            default: \"h-9 px-4 py-2\",\n            sm: \"h-8 rounded-md px-3 text-xs\",\n            lg: \"h-10 rounded-md px-8\",\n            icon: \"h-9 w-9\"\n        }\n    },\n    defaultVariants: {\n        variant: \"default\",\n        size: \"default\"\n    }\n});\nconst Button = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c = (param, ref)=>{\n    let { className, variant, size, asChild = false, ...props } = param;\n    const Comp = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_4__.Slot : \"button\";\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Comp, {\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.cn)(buttonVariants({\n            variant,\n            size,\n            className\n        })),\n        ref: ref,\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\button.tsx\",\n        lineNumber: 47,\n        columnNumber: 7\n    }, undefined);\n});\n_c1 = Button;\nButton.displayName = \"Button\";\n\nvar _c, _c1;\n$RefreshReg$(_c, \"Button$React.forwardRef\");\n$RefreshReg$(_c1, \"Button\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2J1dHRvbi50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQThCO0FBQ2E7QUFDc0I7QUFFakM7QUFFaEMsTUFBTUksaUJBQWlCRiw2REFBR0EsQ0FDeEIsdU9BQ0E7SUFDRUcsVUFBVTtRQUNSQyxTQUFTO1lBQ1BDLFNBQ0U7WUFDRkMsYUFDRTtZQUNGQyxTQUNFO1lBQ0ZDLFdBQ0U7WUFDRkMsT0FBTztZQUNQQyxNQUFNO1FBQ1I7UUFDQUMsTUFBTTtZQUNKTixTQUFTO1lBQ1RPLElBQUk7WUFDSkMsSUFBSTtZQUNKQyxNQUFNO1FBQ1I7SUFDRjtJQUNBQyxpQkFBaUI7UUFDZlgsU0FBUztRQUNUTyxNQUFNO0lBQ1I7QUFDRjtBQVNGLE1BQU1LLHVCQUFTbEIsNkNBQWdCLE1BQzdCLFFBQTBEb0I7UUFBekQsRUFBRUMsU0FBUyxFQUFFZixPQUFPLEVBQUVPLElBQUksRUFBRVMsVUFBVSxLQUFLLEVBQUUsR0FBR0MsT0FBTztJQUN0RCxNQUFNQyxPQUFPRixVQUFVckIsc0RBQUlBLEdBQUc7SUFDOUIscUJBQ0UsOERBQUN1QjtRQUNDSCxXQUFXbEIsOENBQUVBLENBQUNDLGVBQWU7WUFBRUU7WUFBU087WUFBTVE7UUFBVTtRQUN4REQsS0FBS0E7UUFDSixHQUFHRyxLQUFLOzs7Ozs7QUFHZjs7QUFFRkwsT0FBT08sV0FBVyxHQUFHO0FBRVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvYnV0dG9uLnRzeD82YTBhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXHJcbmltcG9ydCB7IFNsb3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXNsb3RcIlxyXG5pbXBvcnQgeyBjdmEsIHR5cGUgVmFyaWFudFByb3BzIH0gZnJvbSBcImNsYXNzLXZhcmlhbmNlLWF1dGhvcml0eVwiXHJcblxyXG5pbXBvcnQgeyBjbiB9IGZyb20gXCJAL2xpYi91dGlsc1wiXHJcblxyXG5jb25zdCBidXR0b25WYXJpYW50cyA9IGN2YShcclxuICBcImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB3aGl0ZXNwYWNlLW5vd3JhcCByb3VuZGVkLW1kIHRleHQtc20gZm9udC1tZWRpdW0gdHJhbnNpdGlvbi1jb2xvcnMgZm9jdXMtdmlzaWJsZTpvdXRsaW5lLW5vbmUgZm9jdXMtdmlzaWJsZTpyaW5nLTEgZm9jdXMtdmlzaWJsZTpyaW5nLXJpbmcgZGlzYWJsZWQ6cG9pbnRlci1ldmVudHMtbm9uZSBkaXNhYmxlZDpvcGFjaXR5LTUwXCIsXHJcbiAge1xyXG4gICAgdmFyaWFudHM6IHtcclxuICAgICAgdmFyaWFudDoge1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBcImJnLXByaW1hcnkgdGV4dC1wcmltYXJ5LWZvcmVncm91bmQgc2hhZG93IGhvdmVyOmJnLXByaW1hcnkvOTBcIixcclxuICAgICAgICBkZXN0cnVjdGl2ZTpcclxuICAgICAgICAgIFwiYmctZGVzdHJ1Y3RpdmUgdGV4dC1kZXN0cnVjdGl2ZS1mb3JlZ3JvdW5kIHNoYWRvdy1zbSBob3ZlcjpiZy1kZXN0cnVjdGl2ZS85MFwiLFxyXG4gICAgICAgIG91dGxpbmU6XHJcbiAgICAgICAgICBcImJvcmRlciBib3JkZXItaW5wdXQgYmctYmFja2dyb3VuZCBzaGFkb3ctc20gaG92ZXI6YmctYWNjZW50IGhvdmVyOnRleHQtYWNjZW50LWZvcmVncm91bmRcIixcclxuICAgICAgICBzZWNvbmRhcnk6XHJcbiAgICAgICAgICBcImJnLXNlY29uZGFyeSB0ZXh0LXNlY29uZGFyeS1mb3JlZ3JvdW5kIHNoYWRvdy1zbSBob3ZlcjpiZy1zZWNvbmRhcnkvODBcIixcclxuICAgICAgICBnaG9zdDogXCJob3ZlcjpiZy1hY2NlbnQgaG92ZXI6dGV4dC1hY2NlbnQtZm9yZWdyb3VuZFwiLFxyXG4gICAgICAgIGxpbms6IFwidGV4dC1wcmltYXJ5IHVuZGVybGluZS1vZmZzZXQtNCBob3Zlcjp1bmRlcmxpbmVcIixcclxuICAgICAgfSxcclxuICAgICAgc2l6ZToge1xyXG4gICAgICAgIGRlZmF1bHQ6IFwiaC05IHB4LTQgcHktMlwiLFxyXG4gICAgICAgIHNtOiBcImgtOCByb3VuZGVkLW1kIHB4LTMgdGV4dC14c1wiLFxyXG4gICAgICAgIGxnOiBcImgtMTAgcm91bmRlZC1tZCBweC04XCIsXHJcbiAgICAgICAgaWNvbjogXCJoLTkgdy05XCIsXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgZGVmYXVsdFZhcmlhbnRzOiB7XHJcbiAgICAgIHZhcmlhbnQ6IFwiZGVmYXVsdFwiLFxyXG4gICAgICBzaXplOiBcImRlZmF1bHRcIixcclxuICAgIH0sXHJcbiAgfVxyXG4pXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJ1dHRvblByb3BzXHJcbiAgZXh0ZW5kcyBSZWFjdC5CdXR0b25IVE1MQXR0cmlidXRlczxIVE1MQnV0dG9uRWxlbWVudD4sXHJcbiAgICBWYXJpYW50UHJvcHM8dHlwZW9mIGJ1dHRvblZhcmlhbnRzPiB7XHJcbiAgYXNDaGlsZD86IGJvb2xlYW5cclxufVxyXG5cclxuY29uc3QgQnV0dG9uID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MQnV0dG9uRWxlbWVudCwgQnV0dG9uUHJvcHM+KFxyXG4gICh7IGNsYXNzTmFtZSwgdmFyaWFudCwgc2l6ZSwgYXNDaGlsZCA9IGZhbHNlLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcclxuICAgIGNvbnN0IENvbXAgPSBhc0NoaWxkID8gU2xvdCA6IFwiYnV0dG9uXCJcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxDb21wXHJcbiAgICAgICAgY2xhc3NOYW1lPXtjbihidXR0b25WYXJpYW50cyh7IHZhcmlhbnQsIHNpemUsIGNsYXNzTmFtZSB9KSl9XHJcbiAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgey4uLnByb3BzfVxyXG4gICAgICAvPlxyXG4gICAgKVxyXG4gIH1cclxuKVxyXG5CdXR0b24uZGlzcGxheU5hbWUgPSBcIkJ1dHRvblwiXHJcblxyXG5leHBvcnQgeyBCdXR0b24sIGJ1dHRvblZhcmlhbnRzIH1cclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiU2xvdCIsImN2YSIsImNuIiwiYnV0dG9uVmFyaWFudHMiLCJ2YXJpYW50cyIsInZhcmlhbnQiLCJkZWZhdWx0IiwiZGVzdHJ1Y3RpdmUiLCJvdXRsaW5lIiwic2Vjb25kYXJ5IiwiZ2hvc3QiLCJsaW5rIiwic2l6ZSIsInNtIiwibGciLCJpY29uIiwiZGVmYXVsdFZhcmlhbnRzIiwiQnV0dG9uIiwiZm9yd2FyZFJlZiIsInJlZiIsImNsYXNzTmFtZSIsImFzQ2hpbGQiLCJwcm9wcyIsIkNvbXAiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/button.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/card.tsx":
/*!************************************!*\
  !*** ./src/components/ui/card.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Card: function() { return /* binding */ Card; },\n/* harmony export */   CardContent: function() { return /* binding */ CardContent; },\n/* harmony export */   CardDescription: function() { return /* binding */ CardDescription; },\n/* harmony export */   CardFooter: function() { return /* binding */ CardFooter; },\n/* harmony export */   CardHeader: function() { return /* binding */ CardHeader; },\n/* harmony export */   CardTitle: function() { return /* binding */ CardTitle; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n\n\n\nconst Card = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c = (param, ref)=>/*#__PURE__*/ {\n    let { className, ...props } = param;\n    return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"rounded-xl border bg-card text-card-foreground shadow\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\card.tsx\",\n        lineNumber: 9,\n        columnNumber: 3\n    }, undefined);\n});\n_c1 = Card;\nCard.displayName = \"Card\";\nconst CardHeader = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c2 = (param, ref)=>/*#__PURE__*/ {\n    let { className, ...props } = param;\n    return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"flex flex-col space-y-1.5 p-6\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\card.tsx\",\n        lineNumber: 24,\n        columnNumber: 3\n    }, undefined);\n});\n_c3 = CardHeader;\nCardHeader.displayName = \"CardHeader\";\nconst CardTitle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c4 = (param, ref)=>/*#__PURE__*/ {\n    let { className, ...props } = param;\n    return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"font-semibold leading-none tracking-tight\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\card.tsx\",\n        lineNumber: 36,\n        columnNumber: 3\n    }, undefined);\n});\n_c5 = CardTitle;\nCardTitle.displayName = \"CardTitle\";\nconst CardDescription = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c6 = (param, ref)=>/*#__PURE__*/ {\n    let { className, ...props } = param;\n    return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"text-sm text-muted-foreground\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\card.tsx\",\n        lineNumber: 48,\n        columnNumber: 3\n    }, undefined);\n});\n_c7 = CardDescription;\nCardDescription.displayName = \"CardDescription\";\nconst CardContent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c8 = (param, ref)=>/*#__PURE__*/ {\n    let { className, ...props } = param;\n    return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"p-6 pt-0\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\card.tsx\",\n        lineNumber: 60,\n        columnNumber: 3\n    }, undefined);\n});\n_c9 = CardContent;\nCardContent.displayName = \"CardContent\";\nconst CardFooter = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c10 = (param, ref)=>/*#__PURE__*/ {\n    let { className, ...props } = param;\n    return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"flex items-center p-6 pt-0\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\card.tsx\",\n        lineNumber: 68,\n        columnNumber: 3\n    }, undefined);\n});\n_c11 = CardFooter;\nCardFooter.displayName = \"CardFooter\";\n\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;\n$RefreshReg$(_c, \"Card$React.forwardRef\");\n$RefreshReg$(_c1, \"Card\");\n$RefreshReg$(_c2, \"CardHeader$React.forwardRef\");\n$RefreshReg$(_c3, \"CardHeader\");\n$RefreshReg$(_c4, \"CardTitle$React.forwardRef\");\n$RefreshReg$(_c5, \"CardTitle\");\n$RefreshReg$(_c6, \"CardDescription$React.forwardRef\");\n$RefreshReg$(_c7, \"CardDescription\");\n$RefreshReg$(_c8, \"CardContent$React.forwardRef\");\n$RefreshReg$(_c9, \"CardContent\");\n$RefreshReg$(_c10, \"CardFooter$React.forwardRef\");\n$RefreshReg$(_c11, \"CardFooter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2NhcmQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThCO0FBRUU7QUFFaEMsTUFBTUUscUJBQU9GLDZDQUFnQixNQUczQixRQUEwQkk7UUFBekIsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87V0FDeEIsOERBQUNDO1FBQ0NILEtBQUtBO1FBQ0xDLFdBQVdKLDhDQUFFQSxDQUNYLHlEQUNBSTtRQUVELEdBQUdDLEtBQUs7Ozs7OztBQUNWOztBQUVISixLQUFLTSxXQUFXLEdBQUc7QUFFbkIsTUFBTUMsMkJBQWFULDZDQUFnQixPQUdqQyxRQUEwQkk7UUFBekIsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87V0FDeEIsOERBQUNDO1FBQ0NILEtBQUtBO1FBQ0xDLFdBQVdKLDhDQUFFQSxDQUFDLGlDQUFpQ0k7UUFDOUMsR0FBR0MsS0FBSzs7Ozs7O0FBQ1Y7O0FBRUhHLFdBQVdELFdBQVcsR0FBRztBQUV6QixNQUFNRSwwQkFBWVYsNkNBQWdCLE9BR2hDLFFBQTBCSTtRQUF6QixFQUFFQyxTQUFTLEVBQUUsR0FBR0MsT0FBTztXQUN4Qiw4REFBQ0M7UUFDQ0gsS0FBS0E7UUFDTEMsV0FBV0osOENBQUVBLENBQUMsNkNBQTZDSTtRQUMxRCxHQUFHQyxLQUFLOzs7Ozs7QUFDVjs7QUFFSEksVUFBVUYsV0FBVyxHQUFHO0FBRXhCLE1BQU1HLGdDQUFrQlgsNkNBQWdCLE9BR3RDLFFBQTBCSTtRQUF6QixFQUFFQyxTQUFTLEVBQUUsR0FBR0MsT0FBTztXQUN4Qiw4REFBQ0M7UUFDQ0gsS0FBS0E7UUFDTEMsV0FBV0osOENBQUVBLENBQUMsaUNBQWlDSTtRQUM5QyxHQUFHQyxLQUFLOzs7Ozs7QUFDVjs7QUFFSEssZ0JBQWdCSCxXQUFXLEdBQUc7QUFFOUIsTUFBTUksNEJBQWNaLDZDQUFnQixPQUdsQyxRQUEwQkk7UUFBekIsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87V0FDeEIsOERBQUNDO1FBQUlILEtBQUtBO1FBQUtDLFdBQVdKLDhDQUFFQSxDQUFDLFlBQVlJO1FBQWEsR0FBR0MsS0FBSzs7Ozs7O0FBQUc7O0FBRW5FTSxZQUFZSixXQUFXLEdBQUc7QUFFMUIsTUFBTUssMkJBQWFiLDZDQUFnQixRQUdqQyxRQUEwQkk7UUFBekIsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLE9BQU87V0FDeEIsOERBQUNDO1FBQ0NILEtBQUtBO1FBQ0xDLFdBQVdKLDhDQUFFQSxDQUFDLDhCQUE4Qkk7UUFDM0MsR0FBR0MsS0FBSzs7Ozs7O0FBQ1Y7O0FBRUhPLFdBQVdMLFdBQVcsR0FBRztBQUV1RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS9jYXJkLnRzeD9lN2QyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXHJcblxyXG5pbXBvcnQgeyBjbiB9IGZyb20gXCJAL2xpYi91dGlsc1wiXHJcblxyXG5jb25zdCBDYXJkID0gUmVhY3QuZm9yd2FyZFJlZjxcclxuICBIVE1MRGl2RWxlbWVudCxcclxuICBSZWFjdC5IVE1MQXR0cmlidXRlczxIVE1MRGl2RWxlbWVudD5cclxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxyXG4gIDxkaXZcclxuICAgIHJlZj17cmVmfVxyXG4gICAgY2xhc3NOYW1lPXtjbihcclxuICAgICAgXCJyb3VuZGVkLXhsIGJvcmRlciBiZy1jYXJkIHRleHQtY2FyZC1mb3JlZ3JvdW5kIHNoYWRvd1wiLFxyXG4gICAgICBjbGFzc05hbWVcclxuICAgICl9XHJcbiAgICB7Li4ucHJvcHN9XHJcbiAgLz5cclxuKSlcclxuQ2FyZC5kaXNwbGF5TmFtZSA9IFwiQ2FyZFwiXHJcblxyXG5jb25zdCBDYXJkSGVhZGVyID0gUmVhY3QuZm9yd2FyZFJlZjxcclxuICBIVE1MRGl2RWxlbWVudCxcclxuICBSZWFjdC5IVE1MQXR0cmlidXRlczxIVE1MRGl2RWxlbWVudD5cclxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxyXG4gIDxkaXZcclxuICAgIHJlZj17cmVmfVxyXG4gICAgY2xhc3NOYW1lPXtjbihcImZsZXggZmxleC1jb2wgc3BhY2UteS0xLjUgcC02XCIsIGNsYXNzTmFtZSl9XHJcbiAgICB7Li4ucHJvcHN9XHJcbiAgLz5cclxuKSlcclxuQ2FyZEhlYWRlci5kaXNwbGF5TmFtZSA9IFwiQ2FyZEhlYWRlclwiXHJcblxyXG5jb25zdCBDYXJkVGl0bGUgPSBSZWFjdC5mb3J3YXJkUmVmPFxyXG4gIEhUTUxEaXZFbGVtZW50LFxyXG4gIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PlxyXG4+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXHJcbiAgPGRpdlxyXG4gICAgcmVmPXtyZWZ9XHJcbiAgICBjbGFzc05hbWU9e2NuKFwiZm9udC1zZW1pYm9sZCBsZWFkaW5nLW5vbmUgdHJhY2tpbmctdGlnaHRcIiwgY2xhc3NOYW1lKX1cclxuICAgIHsuLi5wcm9wc31cclxuICAvPlxyXG4pKVxyXG5DYXJkVGl0bGUuZGlzcGxheU5hbWUgPSBcIkNhcmRUaXRsZVwiXHJcblxyXG5jb25zdCBDYXJkRGVzY3JpcHRpb24gPSBSZWFjdC5mb3J3YXJkUmVmPFxyXG4gIEhUTUxEaXZFbGVtZW50LFxyXG4gIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PlxyXG4+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXHJcbiAgPGRpdlxyXG4gICAgcmVmPXtyZWZ9XHJcbiAgICBjbGFzc05hbWU9e2NuKFwidGV4dC1zbSB0ZXh0LW11dGVkLWZvcmVncm91bmRcIiwgY2xhc3NOYW1lKX1cclxuICAgIHsuLi5wcm9wc31cclxuICAvPlxyXG4pKVxyXG5DYXJkRGVzY3JpcHRpb24uZGlzcGxheU5hbWUgPSBcIkNhcmREZXNjcmlwdGlvblwiXHJcblxyXG5jb25zdCBDYXJkQ29udGVudCA9IFJlYWN0LmZvcndhcmRSZWY8XHJcbiAgSFRNTERpdkVsZW1lbnQsXHJcbiAgUmVhY3QuSFRNTEF0dHJpYnV0ZXM8SFRNTERpdkVsZW1lbnQ+XHJcbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IChcclxuICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9e2NuKFwicC02IHB0LTBcIiwgY2xhc3NOYW1lKX0gey4uLnByb3BzfSAvPlxyXG4pKVxyXG5DYXJkQ29udGVudC5kaXNwbGF5TmFtZSA9IFwiQ2FyZENvbnRlbnRcIlxyXG5cclxuY29uc3QgQ2FyZEZvb3RlciA9IFJlYWN0LmZvcndhcmRSZWY8XHJcbiAgSFRNTERpdkVsZW1lbnQsXHJcbiAgUmVhY3QuSFRNTEF0dHJpYnV0ZXM8SFRNTERpdkVsZW1lbnQ+XHJcbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IChcclxuICA8ZGl2XHJcbiAgICByZWY9e3JlZn1cclxuICAgIGNsYXNzTmFtZT17Y24oXCJmbGV4IGl0ZW1zLWNlbnRlciBwLTYgcHQtMFwiLCBjbGFzc05hbWUpfVxyXG4gICAgey4uLnByb3BzfVxyXG4gIC8+XHJcbikpXHJcbkNhcmRGb290ZXIuZGlzcGxheU5hbWUgPSBcIkNhcmRGb290ZXJcIlxyXG5cclxuZXhwb3J0IHsgQ2FyZCwgQ2FyZEhlYWRlciwgQ2FyZEZvb3RlciwgQ2FyZFRpdGxlLCBDYXJkRGVzY3JpcHRpb24sIENhcmRDb250ZW50IH1cclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY24iLCJDYXJkIiwiZm9yd2FyZFJlZiIsInJlZiIsImNsYXNzTmFtZSIsInByb3BzIiwiZGl2IiwiZGlzcGxheU5hbWUiLCJDYXJkSGVhZGVyIiwiQ2FyZFRpdGxlIiwiQ2FyZERlc2NyaXB0aW9uIiwiQ2FyZENvbnRlbnQiLCJDYXJkRm9vdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/card.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/input.tsx":
/*!*************************************!*\
  !*** ./src/components/ui/input.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Input: function() { return /* binding */ Input; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n\n\n\nconst Input = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c = (param, ref)=>{\n    let { className, type, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n        type: type,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\", className),\n        ref: ref,\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\input.tsx\",\n        lineNumber: 8,\n        columnNumber: 7\n    }, undefined);\n});\n_c1 = Input;\nInput.displayName = \"Input\";\n\nvar _c, _c1;\n$RefreshReg$(_c, \"Input$React.forwardRef\");\n$RefreshReg$(_c1, \"Input\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2lucHV0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBOEI7QUFFRTtBQUVoQyxNQUFNRSxzQkFBUUYsNkNBQWdCLE1BQzVCLFFBQWdDSTtRQUEvQixFQUFFQyxTQUFTLEVBQUVDLElBQUksRUFBRSxHQUFHQyxPQUFPO0lBQzVCLHFCQUNFLDhEQUFDQztRQUNDRixNQUFNQTtRQUNORCxXQUFXSiw4Q0FBRUEsQ0FDWCwyV0FDQUk7UUFFRkQsS0FBS0E7UUFDSixHQUFHRyxLQUFLOzs7Ozs7QUFHZjs7QUFFRkwsTUFBTU8sV0FBVyxHQUFHO0FBRUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvaW5wdXQudHN4P2M5ODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCJcblxuaW1wb3J0IHsgY24gfSBmcm9tIFwiQC9saWIvdXRpbHNcIlxuXG5jb25zdCBJbnB1dCA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTElucHV0RWxlbWVudCwgUmVhY3QuQ29tcG9uZW50UHJvcHM8XCJpbnB1dFwiPj4oXG4gICh7IGNsYXNzTmFtZSwgdHlwZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxpbnB1dFxuICAgICAgICB0eXBlPXt0eXBlfVxuICAgICAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgICAgIFwiZmxleCBoLTkgdy1mdWxsIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci1pbnB1dCBiZy10cmFuc3BhcmVudCBweC0zIHB5LTEgdGV4dC1iYXNlIHNoYWRvdy1zbSB0cmFuc2l0aW9uLWNvbG9ycyBmaWxlOmJvcmRlci0wIGZpbGU6YmctdHJhbnNwYXJlbnQgZmlsZTp0ZXh0LXNtIGZpbGU6Zm9udC1tZWRpdW0gZmlsZTp0ZXh0LWZvcmVncm91bmQgcGxhY2Vob2xkZXI6dGV4dC1tdXRlZC1mb3JlZ3JvdW5kIGZvY3VzLXZpc2libGU6b3V0bGluZS1ub25lIGZvY3VzLXZpc2libGU6cmluZy0xIGZvY3VzLXZpc2libGU6cmluZy1yaW5nIGRpc2FibGVkOmN1cnNvci1ub3QtYWxsb3dlZCBkaXNhYmxlZDpvcGFjaXR5LTUwIG1kOnRleHQtc21cIixcbiAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgKX1cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgIC8+XG4gICAgKVxuICB9XG4pXG5JbnB1dC5kaXNwbGF5TmFtZSA9IFwiSW5wdXRcIlxuXG5leHBvcnQgeyBJbnB1dCB9XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjbiIsIklucHV0IiwiZm9yd2FyZFJlZiIsInJlZiIsImNsYXNzTmFtZSIsInR5cGUiLCJwcm9wcyIsImlucHV0IiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/input.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/textarea.tsx":
/*!****************************************!*\
  !*** ./src/components/ui/textarea.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Textarea: function() { return /* binding */ Textarea; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n\n\n\nconst Textarea = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c = (param, ref)=>{\n    let { className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\", className),\n        ref: ref,\n        ...props\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sebik\\\\Desktop\\\\H1B\\\\H1BMatch_FrontEnd\\\\src\\\\components\\\\ui\\\\textarea.tsx\",\n        lineNumber: 10,\n        columnNumber: 5\n    }, undefined);\n});\n_c1 = Textarea;\nTextarea.displayName = \"Textarea\";\n\nvar _c, _c1;\n$RefreshReg$(_c, \"Textarea$React.forwardRef\");\n$RefreshReg$(_c1, \"Textarea\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3RleHRhcmVhLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBOEI7QUFFRTtBQUVoQyxNQUFNRSx5QkFBV0YsNkNBQWdCLE1BRy9CLFFBQTBCSTtRQUF6QixFQUFFQyxTQUFTLEVBQUUsR0FBR0MsT0FBTztJQUN4QixxQkFDRSw4REFBQ0M7UUFDQ0YsV0FBV0osOENBQUVBLENBQ1gsNlFBQ0FJO1FBRUZELEtBQUtBO1FBQ0osR0FBR0UsS0FBSzs7Ozs7O0FBR2Y7O0FBQ0FKLFNBQVNNLFdBQVcsR0FBRztBQUVKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL3RleHRhcmVhLnRzeD81OTMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXHJcblxyXG5pbXBvcnQgeyBjbiB9IGZyb20gXCJAL2xpYi91dGlsc1wiXHJcblxyXG5jb25zdCBUZXh0YXJlYSA9IFJlYWN0LmZvcndhcmRSZWY8XHJcbiAgSFRNTFRleHRBcmVhRWxlbWVudCxcclxuICBSZWFjdC5Db21wb25lbnRQcm9wczxcInRleHRhcmVhXCI+XHJcbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPHRleHRhcmVhXHJcbiAgICAgIGNsYXNzTmFtZT17Y24oXHJcbiAgICAgICAgXCJmbGV4IG1pbi1oLVs2MHB4XSB3LWZ1bGwgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLWlucHV0IGJnLXRyYW5zcGFyZW50IHB4LTMgcHktMiB0ZXh0LWJhc2Ugc2hhZG93LXNtIHBsYWNlaG9sZGVyOnRleHQtbXV0ZWQtZm9yZWdyb3VuZCBmb2N1cy12aXNpYmxlOm91dGxpbmUtbm9uZSBmb2N1cy12aXNpYmxlOnJpbmctMSBmb2N1cy12aXNpYmxlOnJpbmctcmluZyBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgZGlzYWJsZWQ6b3BhY2l0eS01MCBtZDp0ZXh0LXNtXCIsXHJcbiAgICAgICAgY2xhc3NOYW1lXHJcbiAgICAgICl9XHJcbiAgICAgIHJlZj17cmVmfVxyXG4gICAgICB7Li4ucHJvcHN9XHJcbiAgICAvPlxyXG4gIClcclxufSlcclxuVGV4dGFyZWEuZGlzcGxheU5hbWUgPSBcIlRleHRhcmVhXCJcclxuXHJcbmV4cG9ydCB7IFRleHRhcmVhIH1cclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY24iLCJUZXh0YXJlYSIsImZvcndhcmRSZWYiLCJyZWYiLCJjbGFzc05hbWUiLCJwcm9wcyIsInRleHRhcmVhIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/textarea.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/utils.ts":
/*!**************************!*\
  !*** ./src/lib/utils.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cn: function() { return /* binding */ cn; }\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tailwind-merge */ \"(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\");\n\n\nfunction cn() {\n    for(var _len = arguments.length, inputs = new Array(_len), _key = 0; _key < _len; _key++){\n        inputs[_key] = arguments[_key];\n    }\n    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_1__.twMerge)((0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(inputs));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDO0FBQ0o7QUFFakMsU0FBU0U7SUFBRztRQUFHQyxPQUFILHVCQUF1QjtJQUFEO0lBQ3ZDLE9BQU9GLHVEQUFPQSxDQUFDRCwwQ0FBSUEsQ0FBQ0c7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi91dGlscy50cz83YzFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNsc3gsIHR5cGUgQ2xhc3NWYWx1ZSB9IGZyb20gXCJjbHN4XCJcclxuaW1wb3J0IHsgdHdNZXJnZSB9IGZyb20gXCJ0YWlsd2luZC1tZXJnZVwiXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY24oLi4uaW5wdXRzOiBDbGFzc1ZhbHVlW10pIHtcclxuICByZXR1cm4gdHdNZXJnZShjbHN4KGlucHV0cykpXHJcbn1cclxuIl0sIm5hbWVzIjpbImNsc3giLCJ0d01lcmdlIiwiY24iLCJpbnB1dHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/utils.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/compiled/client-only/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz9hZTljIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n      // component, which we don't yet support. Attach a noop catch handler to\n      // silence the error.\n      // TODO: Implement component stacks for async client components?\n\n      if (maybePromise && typeof maybePromise.catch === 'function') {\n        maybePromise.catch(function () {});\n      }\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULGlDQUFpQztBQUNqQztBQUNBLFNBQVM7QUFDVCwyQkFBMkI7QUFDM0I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7O0FBRWxHO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDJEQUEyRCxVQUFVO0FBQ3JFLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLEdBQUc7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDOztBQUU1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMsZ0RBQWdELE1BQU0sYUFBYTs7QUFFakg7QUFDQSwrQ0FBK0Msa0NBQWtDLE9BQU87O0FBRXhGLHVHQUF1RyxjQUFjLFVBQVUsZ0dBQWdHLGtCQUFrQixVQUFVLFVBQVU7O0FBRXJRO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzkzMDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRleHQyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gKGNvbnRleHQyLmRpc3BsYXlOYW1lIHx8IGNvbnRleHQyLl9nbG9iYWxOYW1lKSArICcuUHJvdmlkZXInO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n      // component, which we don't yet support. Attach a noop catch handler to\n      // silence the error.\n      // TODO: Implement component stacks for async client components?\n\n      if (maybePromise && typeof maybePromise.catch === 'function') {\n        maybePromise.catch(function () {});\n      }\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx = jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs = jsxWithValidationStatic ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLHNHQUEwQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNULDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkg7QUFDM0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvRUFBb0U7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsMkRBQTJELFVBQVU7QUFDckUseUJBQXlCLFVBQVU7QUFDbkM7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsR0FBRztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLEdBQUc7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUEsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxZQUFZO0FBQ1osR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzPzM0N2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zZXJ2ZXJfY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGV4dDIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiAoY29udGV4dDIuZGlzcGxheU5hbWUgfHwgY29udGV4dDIuX2dsb2JhbE5hbWUpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgIHZhciBtYXliZVByb21pc2UgPSBmbigpOyAvLyBJZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHJldHVybnMgYSBwcm9taXNlLCBpdCdzIGxpa2VseSBhbiBhc3luY1xuICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgIC8vIFRPRE86IEltcGxlbWVudCBjb21wb25lbnQgc3RhY2tzIGZvciBhc3luYyBjbGllbnQgY29tcG9uZW50cz9cblxuICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2tleScpKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcbi8vIGV2ZW4gd2l0aCB0aGUgcHJvZCB0cmFuc2Zvcm0uIFRoaXMgbWVhbnMgdGhhdCBqc3hERVYgaXMgcHVyZWx5XG4vLyBvcHQtaW4gYmVoYXZpb3IgZm9yIGJldHRlciBtZXNzYWdlcyBidXQgdGhhdCB3ZSB3b24ndCBzdG9wXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xuICB9XG59XG5cbnZhciBqc3ggPSBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cbi8vIGZvciBub3cgd2UgY2FuIHNoaXAgaWRlbnRpY2FsIHByb2QgZnVuY3Rpb25zXG5cbnZhciBqc3hzID0ganN4V2l0aFZhbGlkYXRpb25TdGF0aWMgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4ID0ganN4O1xuZXhwb3J0cy5qc3hzID0ganN4cztcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/ODRlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-runtime.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHNMQUFrRTtBQUNwRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1ydW50aW1lLmpzP2RkZjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"(app-pages-browser)/./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2xpbmsuanMiLCJtYXBwaW5ncyI6IkFBQUEsNkhBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2xpbmsuanM/MTU1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvbGluaycpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/navigation.js":
/*!*****************************************!*\
  !*** ./node_modules/next/navigation.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUEsK0pBQStEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25hdmlnYXRpb24uanM/Nzc1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvY29tcG9uZW50cy9uYXZpZ2F0aW9uJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsbUZBQU87O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87OztBQUdQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzP2Y4YzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8vIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5cbnZhciB1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdC51c2VMYXlvdXRFZmZlY3QsXG4gICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG52YXIgZGlkV2Fybk9sZDE4QWxwaGEgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IGZhbHNlOyAvLyBEaXNjbGFpbWVyOiBUaGlzIHNoaW0gYnJlYWtzIG1hbnkgb2YgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3Jrc1xuLy8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcbi8vIC0tIGNoYW5nZSBhbnkgb25lIG9mIHRoZW0gYW5kIGl0IHdpbGwgYnJlYWsuIFRoZSBtb3N0IGltcG9ydGFudCBhc3N1bXB0aW9uXG4vLyBpcyB0aGF0IHVwZGF0ZXMgYXJlIGFsd2F5cyBzeW5jaHJvbm91cywgYmVjYXVzZSBjb25jdXJyZW50IHJlbmRlcmluZyBpc1xuLy8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuLy8gdXNlU3luY0V4dGVybmFsU3RvcmUgQVBJLiBBbmQgd2Ugb25seSB1c2UgdGhpcyBzaGltIHdoZW4gdGhlIGJ1aWx0LWluIEFQSVxuLy8gZG9lcyBub3QgZXhpc3QuXG4vL1xuLy8gRG8gbm90IGFzc3VtZSB0aGF0IHRoZSBjbGV2ZXIgaGFja3MgdXNlZCBieSB0aGlzIGhvb2sgYWxzbyB3b3JrIGluIGdlbmVyYWwuXG4vLyBUaGUgcG9pbnQgb2YgdGhpcyBzaGltIGlzIHRvIHJlcGxhY2UgdGhlIG5lZWQgZm9yIGhhY2tzIGJ5IG90aGVyIGxpYnJhcmllcy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4vLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcbi8vIGZyb20gYGdldFNuYXBzaG90YC5cbmdldFNlcnZlclNuYXBzaG90KSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG4gICAgICBpZiAoUmVhY3Quc3RhcnRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0ICcgKyAnZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlICcgKyAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSAnICsgJ3RvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBBZ2FpbiwgdGhpc1xuICAvLyBicmVha3MgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBoZXJlIGJlY2F1c2Ugb2Ygc3BlY2lmaWNcbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIHZhciB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAge1xuICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gIC8vXG4gIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAvL1xuICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAvL1xuICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHtcbiAgICBpbnN0OiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgICB9XG4gIH0pLFxuICAgICAgaW5zdCA9IF91c2VTdGF0ZVswXS5pbnN0LFxuICAgICAgZm9yY2VVcGRhdGUgPSBfdXNlU3RhdGVbMV07IC8vIFRyYWNrIHRoZSBsYXRlc3QgZ2V0U25hcHNob3QgZnVuY3Rpb24gd2l0aCBhIHJlZi4gVGhpcyBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuICAvLyBoYXBwZW5zIG9uIHN1YnNjcmliZS5cblxuXG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4gICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAgIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyByaWdodCBiZWZvcmUgc3Vic2NyaWJpbmcuIFN1YnNlcXVlbnQgY2hhbmdlcyB3aWxsIGJlXG4gICAgLy8gZGV0ZWN0ZWQgaW4gdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgIC8vIHVwIHRvIHRoZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnkgdG8gd3JhcCB0aGVpciBzdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cbiAgICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgICBpbnN0OiBpbnN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cbiAgICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbiAgfSwgW3N1YnNjcmliZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2ZcbiAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4gIC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG4gIHJldHVybiBnZXRTbmFwc2hvdCgpO1xufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBpc1NlcnZlckVudmlyb25tZW50ID0gIWNhblVzZURPTTtcblxudmFyIHNoaW0gPSBpc1NlcnZlckVudmlyb25tZW50ID8gdXNlU3luY0V4dGVybmFsU3RvcmUkMSA6IHVzZVN5bmNFeHRlcm5hbFN0b3JlO1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdW5kZWZpbmVkID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmUkMjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0TUFBOEU7QUFDaEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanM/YzUwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-LVLBRUHJ.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@clerk/clerk-react/dist/chunk-LVLBRUHJ.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthContext: function() { return /* binding */ AuthContext; },\n/* harmony export */   AuthenticateWithRedirectCallback: function() { return /* binding */ AuthenticateWithRedirectCallback; },\n/* harmony export */   ClerkLoaded: function() { return /* binding */ ClerkLoaded; },\n/* harmony export */   ClerkLoading: function() { return /* binding */ ClerkLoading; },\n/* harmony export */   IsomorphicClerkContext: function() { return /* binding */ IsomorphicClerkContext; },\n/* harmony export */   MultisessionAppSupport: function() { return /* binding */ MultisessionAppSupport; },\n/* harmony export */   Protect: function() { return /* binding */ Protect; },\n/* harmony export */   RedirectToCreateOrganization: function() { return /* binding */ RedirectToCreateOrganization; },\n/* harmony export */   RedirectToOrganizationProfile: function() { return /* binding */ RedirectToOrganizationProfile; },\n/* harmony export */   RedirectToSignIn: function() { return /* binding */ RedirectToSignIn; },\n/* harmony export */   RedirectToSignUp: function() { return /* binding */ RedirectToSignUp; },\n/* harmony export */   RedirectToUserProfile: function() { return /* binding */ RedirectToUserProfile; },\n/* harmony export */   SignedIn: function() { return /* binding */ SignedIn; },\n/* harmony export */   SignedOut: function() { return /* binding */ SignedOut; },\n/* harmony export */   customLinkWrongProps: function() { return /* binding */ customLinkWrongProps; },\n/* harmony export */   customMenuItemsIgnoredComponent: function() { return /* binding */ customMenuItemsIgnoredComponent; },\n/* harmony export */   customPageWrongProps: function() { return /* binding */ customPageWrongProps; },\n/* harmony export */   customPagesIgnoredComponent: function() { return /* binding */ customPagesIgnoredComponent; },\n/* harmony export */   errorThrower: function() { return /* binding */ errorThrower; },\n/* harmony export */   incompatibleRoutingWithPathProvidedError: function() { return /* binding */ incompatibleRoutingWithPathProvidedError; },\n/* harmony export */   multipleChildrenInButtonComponent: function() { return /* binding */ multipleChildrenInButtonComponent; },\n/* harmony export */   multipleClerkProvidersError: function() { return /* binding */ multipleClerkProvidersError; },\n/* harmony export */   noPathProvidedError: function() { return /* binding */ noPathProvidedError; },\n/* harmony export */   organizationProfileLinkRenderedError: function() { return /* binding */ organizationProfileLinkRenderedError; },\n/* harmony export */   organizationProfilePageRenderedError: function() { return /* binding */ organizationProfilePageRenderedError; },\n/* harmony export */   setErrorThrowerOptions: function() { return /* binding */ setErrorThrowerOptions; },\n/* harmony export */   unsupportedNonBrowserDomainOrProxyUrlFunction: function() { return /* binding */ unsupportedNonBrowserDomainOrProxyUrlFunction; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; },\n/* harmony export */   useClerk: function() { return /* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useClerk; },\n/* harmony export */   useEmailLink: function() { return /* binding */ useEmailLink; },\n/* harmony export */   useOrganization: function() { return /* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useOrganization; },\n/* harmony export */   useOrganizationList: function() { return /* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useOrganizationList; },\n/* harmony export */   useSession: function() { return /* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useSession; },\n/* harmony export */   useSessionList: function() { return /* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useSessionList; },\n/* harmony export */   useSignIn: function() { return /* binding */ useSignIn; },\n/* harmony export */   useSignUp: function() { return /* binding */ useSignUp; },\n/* harmony export */   useUser: function() { return /* reexport safe */ _clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useUser; },\n/* harmony export */   userButtonIgnoredComponent: function() { return /* binding */ userButtonIgnoredComponent; },\n/* harmony export */   userButtonMenuActionRenderedError: function() { return /* binding */ userButtonMenuActionRenderedError; },\n/* harmony export */   userButtonMenuItemLinkWrongProps: function() { return /* binding */ userButtonMenuItemLinkWrongProps; },\n/* harmony export */   userButtonMenuItemsActionWrongsProps: function() { return /* binding */ userButtonMenuItemsActionWrongsProps; },\n/* harmony export */   userButtonMenuItemsRenderedError: function() { return /* binding */ userButtonMenuItemsRenderedError; },\n/* harmony export */   userButtonMenuLinkRenderedError: function() { return /* binding */ userButtonMenuLinkRenderedError; },\n/* harmony export */   userProfileLinkRenderedError: function() { return /* binding */ userProfileLinkRenderedError; },\n/* harmony export */   userProfilePageRenderedError: function() { return /* binding */ userProfilePageRenderedError; },\n/* harmony export */   withClerk: function() { return /* binding */ withClerk; }\n/* harmony export */ });\n/* harmony import */ var _clerk_shared_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @clerk/shared/error */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/error.mjs\");\n/* harmony import */ var _clerk_shared_authorization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @clerk/shared/authorization */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/authorization.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @clerk/shared/react */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/react/index.mjs\");\n/* harmony import */ var _clerk_shared_telemetry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @clerk/shared/telemetry */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/telemetry.mjs\");\n// src/errors/errorThrower.ts\n\nvar errorThrower = (0,_clerk_shared_error__WEBPACK_IMPORTED_MODULE_0__.buildErrorThrower)({ packageName: \"@clerk/clerk-react\" });\nfunction setErrorThrowerOptions(options) {\n  errorThrower.setMessages(options).setPackageName(options);\n}\n\n// src/hooks/useAuth.ts\n\n\n\n// src/contexts/AuthContext.ts\n\nvar [AuthContext, useAuthContext] = (0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.createContextAndHook)(\"AuthContext\");\n\n// src/contexts/IsomorphicClerkContext.tsx\n\nvar IsomorphicClerkContext = _clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.ClerkInstanceContext;\nvar useIsomorphicClerkContext = _clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useClerkInstanceContext;\n\n// src/errors/messages.ts\nvar multipleClerkProvidersError = \"You've added multiple <ClerkProvider> components in your React component tree. Wrap your components in a single <ClerkProvider>.\";\nvar multipleChildrenInButtonComponent = (name) => `You've passed multiple children components to <${name}/>. You can only pass a single child component or text.`;\nvar invalidStateError = \"Invalid state. Feel free to submit a bug or reach out to support here: https://clerk.com/support\";\nvar unsupportedNonBrowserDomainOrProxyUrlFunction = \"Unsupported usage of isSatellite, domain or proxyUrl. The usage of isSatellite, domain or proxyUrl as function is not supported in non-browser environments.\";\nvar userProfilePageRenderedError = \"<UserProfile.Page /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.\";\nvar userProfileLinkRenderedError = \"<UserProfile.Link /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.\";\nvar organizationProfilePageRenderedError = \"<OrganizationProfile.Page /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.\";\nvar organizationProfileLinkRenderedError = \"<OrganizationProfile.Link /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.\";\nvar customPagesIgnoredComponent = (componentName) => `<${componentName} /> can only accept <${componentName}.Page /> and <${componentName}.Link /> as its children. Any other provided component will be ignored.`;\nvar customPageWrongProps = (componentName) => `Missing props. <${componentName}.Page /> component requires the following props: url, label, labelIcon, alongside with children to be rendered inside the page.`;\nvar customLinkWrongProps = (componentName) => `Missing props. <${componentName}.Link /> component requires the following props: url, label and labelIcon.`;\nvar noPathProvidedError = (componentName) => `The <${componentName}/> component uses path-based routing by default unless a different routing strategy is provided using the \\`routing\\` prop. When path-based routing is used, you need to provide the path where the component is mounted on by using the \\`path\\` prop. Example: <${componentName} path={'/my-path'} />`;\nvar incompatibleRoutingWithPathProvidedError = (componentName) => `The \\`path\\` prop will only be respected when the Clerk component uses path-based routing. To resolve this error, pass \\`routing='path'\\` to the <${componentName}/> component, or drop the \\`path\\` prop to switch to hash-based routing. For more details please refer to our docs: https://clerk.com/docs`;\nvar userButtonIgnoredComponent = `<UserButton /> can only accept <UserButton.UserProfilePage />, <UserButton.UserProfileLink /> and <UserButton.MenuItems /> as its children. Any other provided component will be ignored.`;\nvar customMenuItemsIgnoredComponent = \"<UserButton.MenuItems /> component can only accept <UserButton.Action /> and <UserButton.Link /> as its children. Any other provided component will be ignored.\";\nvar userButtonMenuItemsRenderedError = \"<UserButton.MenuItems /> component needs to be a direct child of `<UserButton />`.\";\nvar userButtonMenuActionRenderedError = \"<UserButton.Action /> component needs to be a direct child of `<UserButton.MenuItems />`.\";\nvar userButtonMenuLinkRenderedError = \"<UserButton.Link /> component needs to be a direct child of `<UserButton.MenuItems />`.\";\nvar userButtonMenuItemLinkWrongProps = \"Missing props. <UserButton.Link /> component requires the following props: href, label and labelIcon.\";\nvar userButtonMenuItemsActionWrongsProps = \"Missing props. <UserButton.Action /> component requires the following props: label.\";\n\n// src/hooks/useAssertWrappedByClerkProvider.ts\n\nvar useAssertWrappedByClerkProvider = (source) => {\n  (0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useAssertWrappedByClerkProvider)(() => {\n    errorThrower.throwMissingClerkProviderError({ source });\n  });\n};\n\n// src/hooks/utils.ts\nvar clerkLoaded = (isomorphicClerk) => {\n  return new Promise((resolve) => {\n    if (isomorphicClerk.loaded) {\n      resolve();\n    }\n    isomorphicClerk.addOnLoaded(resolve);\n  });\n};\nvar createGetToken = (isomorphicClerk) => {\n  return async (options) => {\n    await clerkLoaded(isomorphicClerk);\n    if (!isomorphicClerk.session) {\n      return null;\n    }\n    return isomorphicClerk.session.getToken(options);\n  };\n};\nvar createSignOut = (isomorphicClerk) => {\n  return async (...args) => {\n    await clerkLoaded(isomorphicClerk);\n    return isomorphicClerk.signOut(...args);\n  };\n};\n\n// src/hooks/useAuth.ts\nvar useAuth = () => {\n  useAssertWrappedByClerkProvider(\"useAuth\");\n  const { sessionId, userId, actor, orgId, orgRole, orgSlug, orgPermissions, __experimental_factorVerificationAge } = useAuthContext();\n  const isomorphicClerk = useIsomorphicClerkContext();\n  const getToken = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(createGetToken(isomorphicClerk), [isomorphicClerk]);\n  const signOut = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(createSignOut(isomorphicClerk), [isomorphicClerk]);\n  const has = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(\n    (params) => {\n      return (0,_clerk_shared_authorization__WEBPACK_IMPORTED_MODULE_1__.createCheckAuthorization)({\n        userId,\n        orgId,\n        orgRole,\n        orgPermissions,\n        __experimental_factorVerificationAge\n      })(params);\n    },\n    [userId, __experimental_factorVerificationAge, orgId, orgRole, orgPermissions]\n  );\n  if (sessionId === void 0 && userId === void 0) {\n    return {\n      isLoaded: false,\n      isSignedIn: void 0,\n      sessionId,\n      userId,\n      actor: void 0,\n      orgId: void 0,\n      orgRole: void 0,\n      orgSlug: void 0,\n      has: void 0,\n      signOut,\n      getToken\n    };\n  }\n  if (sessionId === null && userId === null) {\n    return {\n      isLoaded: true,\n      isSignedIn: false,\n      sessionId,\n      userId,\n      actor: null,\n      orgId: null,\n      orgRole: null,\n      orgSlug: null,\n      has: () => false,\n      signOut,\n      getToken\n    };\n  }\n  if (!!sessionId && !!userId && !!orgId && !!orgRole) {\n    return {\n      isLoaded: true,\n      isSignedIn: true,\n      sessionId,\n      userId,\n      actor: actor || null,\n      orgId,\n      orgRole,\n      orgSlug: orgSlug || null,\n      has,\n      signOut,\n      getToken\n    };\n  }\n  if (!!sessionId && !!userId && !orgId) {\n    return {\n      isLoaded: true,\n      isSignedIn: true,\n      sessionId,\n      userId,\n      actor: actor || null,\n      orgId: null,\n      orgRole: null,\n      orgSlug: null,\n      has,\n      signOut,\n      getToken\n    };\n  }\n  return errorThrower.throw(invalidStateError);\n};\n\n// src/hooks/useEmailLink.ts\n\nfunction useEmailLink(resource) {\n  const { startEmailLinkFlow, cancelEmailLinkFlow } = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => resource.createEmailLinkFlow(), [resource]);\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    return cancelEmailLinkFlow;\n  }, []);\n  return {\n    startEmailLinkFlow,\n    cancelEmailLinkFlow\n  };\n}\n\n// src/hooks/useSignIn.ts\n\n\nvar useSignIn = () => {\n  var _a;\n  useAssertWrappedByClerkProvider(\"useSignIn\");\n  const isomorphicClerk = useIsomorphicClerkContext();\n  const client = (0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useClientContext)();\n  (_a = isomorphicClerk.telemetry) == null ? void 0 : _a.record((0,_clerk_shared_telemetry__WEBPACK_IMPORTED_MODULE_4__.eventMethodCalled)(\"useSignIn\"));\n  if (!client) {\n    return { isLoaded: false, signIn: void 0, setActive: void 0 };\n  }\n  return {\n    isLoaded: true,\n    signIn: client.signIn,\n    setActive: isomorphicClerk.setActive\n  };\n};\n\n// src/hooks/useSignUp.ts\n\n\nvar useSignUp = () => {\n  var _a;\n  useAssertWrappedByClerkProvider(\"useSignUp\");\n  const isomorphicClerk = useIsomorphicClerkContext();\n  const client = (0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useClientContext)();\n  (_a = isomorphicClerk.telemetry) == null ? void 0 : _a.record((0,_clerk_shared_telemetry__WEBPACK_IMPORTED_MODULE_4__.eventMethodCalled)(\"useSignUp\"));\n  if (!client) {\n    return { isLoaded: false, signUp: void 0, setActive: void 0 };\n  }\n  return {\n    isLoaded: true,\n    signUp: client.signUp,\n    setActive: isomorphicClerk.setActive\n  };\n};\n\n// src/hooks/index.ts\n\n\n// src/components/controlComponents.tsx\n\n\n// src/contexts/SessionContext.tsx\n\n\n// src/components/withClerk.tsx\n\nvar withClerk = (Component, displayName) => {\n  displayName = displayName || Component.displayName || Component.name || \"Component\";\n  Component.displayName = displayName;\n  const HOC = (props) => {\n    useAssertWrappedByClerkProvider(displayName || \"withClerk\");\n    const clerk = useIsomorphicClerkContext();\n    if (!clerk.loaded) {\n      return null;\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n      Component,\n      {\n        ...props,\n        clerk\n      }\n    );\n  };\n  HOC.displayName = `withClerk(${displayName})`;\n  return HOC;\n};\n\n// src/components/controlComponents.tsx\nvar SignedIn = ({ children }) => {\n  useAssertWrappedByClerkProvider(\"SignedIn\");\n  const { userId } = useAuthContext();\n  if (userId) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n  }\n  return null;\n};\nvar SignedOut = ({ children }) => {\n  useAssertWrappedByClerkProvider(\"SignedOut\");\n  const { userId } = useAuthContext();\n  if (userId === null) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n  }\n  return null;\n};\nvar ClerkLoaded = ({ children }) => {\n  useAssertWrappedByClerkProvider(\"ClerkLoaded\");\n  const isomorphicClerk = useIsomorphicClerkContext();\n  if (!isomorphicClerk.loaded) {\n    return null;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n};\nvar ClerkLoading = ({ children }) => {\n  useAssertWrappedByClerkProvider(\"ClerkLoading\");\n  const isomorphicClerk = useIsomorphicClerkContext();\n  if (isomorphicClerk.loaded) {\n    return null;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n};\nvar Protect = ({ children, fallback, ...restAuthorizedParams }) => {\n  useAssertWrappedByClerkProvider(\"Protect\");\n  const { isLoaded, has, userId } = useAuth();\n  if (!isLoaded) {\n    return null;\n  }\n  const unauthorized = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, fallback != null ? fallback : null);\n  const authorized = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, null, children);\n  if (!userId) {\n    return unauthorized;\n  }\n  if (typeof restAuthorizedParams.condition === \"function\") {\n    if (restAuthorizedParams.condition(has)) {\n      return authorized;\n    }\n    return unauthorized;\n  }\n  if (restAuthorizedParams.role || restAuthorizedParams.permission) {\n    if (has(restAuthorizedParams)) {\n      return authorized;\n    }\n    return unauthorized;\n  }\n  return authorized;\n};\nvar RedirectToSignIn = withClerk(({ clerk, ...props }) => {\n  const { client, session } = clerk;\n  const hasActiveSessions = client.activeSessions && client.activeSessions.length > 0;\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    if (session === null && hasActiveSessions) {\n      void clerk.redirectToAfterSignOut();\n    } else {\n      void clerk.redirectToSignIn(props);\n    }\n  }, []);\n  return null;\n}, \"RedirectToSignIn\");\nvar RedirectToSignUp = withClerk(({ clerk, ...props }) => {\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    void clerk.redirectToSignUp(props);\n  }, []);\n  return null;\n}, \"RedirectToSignUp\");\nvar RedirectToUserProfile = withClerk(({ clerk }) => {\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    void clerk.redirectToUserProfile();\n  }, []);\n  return null;\n}, \"RedirectToUserProfile\");\nvar RedirectToOrganizationProfile = withClerk(({ clerk }) => {\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    void clerk.redirectToOrganizationProfile();\n  }, []);\n  return null;\n}, \"RedirectToOrganizationProfile\");\nvar RedirectToCreateOrganization = withClerk(({ clerk }) => {\n  react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n    void clerk.redirectToCreateOrganization();\n  }, []);\n  return null;\n}, \"RedirectToCreateOrganization\");\nvar AuthenticateWithRedirectCallback = withClerk(\n  ({ clerk, ...handleRedirectCallbackParams }) => {\n    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(() => {\n      void clerk.handleRedirectCallback(handleRedirectCallbackParams);\n    }, []);\n    return null;\n  },\n  \"AuthenticateWithRedirectCallback\"\n);\nvar MultisessionAppSupport = ({ children }) => {\n  useAssertWrappedByClerkProvider(\"MultisessionAppSupport\");\n  const session = (0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_3__.useSessionContext)();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, { key: session ? session.id : \"no-users\" }, children);\n};\n\n\n//# sourceMappingURL=chunk-LVLBRUHJ.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvY2xlcmstcmVhY3QvZGlzdC9jaHVuay1MVkxCUlVISi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0Q7QUFDeEQsbUJBQW1CLHNFQUFpQixHQUFHLG1DQUFtQztBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUU7QUFDbkM7O0FBRXBDO0FBQzJEO0FBQzNELG9DQUFvQyx5RUFBb0I7O0FBRXhEO0FBQ29GO0FBQ3BGLDZCQUE2QixxRUFBb0I7QUFDakQsZ0NBQWdDLHdFQUF1Qjs7QUFFdkQ7QUFDQTtBQUNBLG9HQUFvRyxLQUFLO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxlQUFlLHNCQUFzQixjQUFjLGdCQUFnQixjQUFjO0FBQzFJLGlFQUFpRSxjQUFjO0FBQy9FLGlFQUFpRSxjQUFjO0FBQy9FLHFEQUFxRCxjQUFjLG9RQUFvUSxlQUFlLE1BQU0sWUFBWTtBQUN4Vyx1TkFBdU4sY0FBYztBQUNyTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMrRztBQUMvRztBQUNBLEVBQUUsb0ZBQXFDO0FBQ3ZDLGtEQUFrRCxRQUFRO0FBQzFELEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBHQUEwRztBQUNwSDtBQUNBLG1CQUFtQixrREFBVztBQUM5QixrQkFBa0Isa0RBQVc7QUFDN0IsY0FBYyxrREFBVztBQUN6QjtBQUNBLGFBQWEscUZBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBCO0FBQzFCO0FBQ0EsVUFBVSwwQ0FBMEMsRUFBRSwwQ0FBYTtBQUNuRSxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUQ7QUFDSztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxRUFBZ0I7QUFDakMsZ0VBQWdFLDBFQUFpQjtBQUNqRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM0RTtBQUNNO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFpQjtBQUNsQyxnRUFBZ0UsMEVBQWtCO0FBQ2xGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBUTZCOztBQUU3QjtBQUMyQjs7QUFFM0I7QUFDd0U7O0FBRXhFO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnREFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQSwyQkFBMkIsZ0RBQW9CLENBQUMsMkNBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQSwyQkFBMkIsZ0RBQW9CLENBQUMsMkNBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBb0IsQ0FBQywyQ0FBZTtBQUM3RDtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQW9CLENBQUMsMkNBQWU7QUFDN0Q7QUFDQSxpQkFBaUIsNkNBQTZDO0FBQzlEO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdEQUFvQixDQUFDLDJDQUFlO0FBQzNFLHFDQUFxQyxnREFBb0IsQ0FBQywyQ0FBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRCxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRCxvQ0FBb0MsaUJBQWlCO0FBQ3JELEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELHlDQUF5QyxPQUFPO0FBQ2hELEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELGlEQUFpRCxPQUFPO0FBQ3hELEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELGdEQUFnRCxPQUFPO0FBQ3ZELEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsS0FBSyx3Q0FBd0M7QUFDN0MsSUFBSSw0Q0FBZ0I7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0Esa0JBQWtCLHNFQUFpQjtBQUNuQyx5QkFBeUIsZ0RBQW9CLENBQUMsMkNBQWUsSUFBSSx3Q0FBd0M7QUFDekc7O0FBaURFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9jbGVyay1yZWFjdC9kaXN0L2NodW5rLUxWTEJSVUhKLm1qcz9mZDI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvcnMvZXJyb3JUaHJvd2VyLnRzXG5pbXBvcnQgeyBidWlsZEVycm9yVGhyb3dlciB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL2Vycm9yXCI7XG52YXIgZXJyb3JUaHJvd2VyID0gYnVpbGRFcnJvclRocm93ZXIoeyBwYWNrYWdlTmFtZTogXCJAY2xlcmsvY2xlcmstcmVhY3RcIiB9KTtcbmZ1bmN0aW9uIHNldEVycm9yVGhyb3dlck9wdGlvbnMob3B0aW9ucykge1xuICBlcnJvclRocm93ZXIuc2V0TWVzc2FnZXMob3B0aW9ucykuc2V0UGFja2FnZU5hbWUob3B0aW9ucyk7XG59XG5cbi8vIHNyYy9ob29rcy91c2VBdXRoLnRzXG5pbXBvcnQgeyBjcmVhdGVDaGVja0F1dGhvcml6YXRpb24gfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9hdXRob3JpemF0aW9uXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY29udGV4dHMvQXV0aENvbnRleHQudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHRBbmRIb29rIH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvcmVhY3RcIjtcbnZhciBbQXV0aENvbnRleHQsIHVzZUF1dGhDb250ZXh0XSA9IGNyZWF0ZUNvbnRleHRBbmRIb29rKFwiQXV0aENvbnRleHRcIik7XG5cbi8vIHNyYy9jb250ZXh0cy9Jc29tb3JwaGljQ2xlcmtDb250ZXh0LnRzeFxuaW1wb3J0IHsgQ2xlcmtJbnN0YW5jZUNvbnRleHQsIHVzZUNsZXJrSW5zdGFuY2VDb250ZXh0IH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvcmVhY3RcIjtcbnZhciBJc29tb3JwaGljQ2xlcmtDb250ZXh0ID0gQ2xlcmtJbnN0YW5jZUNvbnRleHQ7XG52YXIgdXNlSXNvbW9ycGhpY0NsZXJrQ29udGV4dCA9IHVzZUNsZXJrSW5zdGFuY2VDb250ZXh0O1xuXG4vLyBzcmMvZXJyb3JzL21lc3NhZ2VzLnRzXG52YXIgbXVsdGlwbGVDbGVya1Byb3ZpZGVyc0Vycm9yID0gXCJZb3UndmUgYWRkZWQgbXVsdGlwbGUgPENsZXJrUHJvdmlkZXI+IGNvbXBvbmVudHMgaW4geW91ciBSZWFjdCBjb21wb25lbnQgdHJlZS4gV3JhcCB5b3VyIGNvbXBvbmVudHMgaW4gYSBzaW5nbGUgPENsZXJrUHJvdmlkZXI+LlwiO1xudmFyIG11bHRpcGxlQ2hpbGRyZW5JbkJ1dHRvbkNvbXBvbmVudCA9IChuYW1lKSA9PiBgWW91J3ZlIHBhc3NlZCBtdWx0aXBsZSBjaGlsZHJlbiBjb21wb25lbnRzIHRvIDwke25hbWV9Lz4uIFlvdSBjYW4gb25seSBwYXNzIGEgc2luZ2xlIGNoaWxkIGNvbXBvbmVudCBvciB0ZXh0LmA7XG52YXIgaW52YWxpZFN0YXRlRXJyb3IgPSBcIkludmFsaWQgc3RhdGUuIEZlZWwgZnJlZSB0byBzdWJtaXQgYSBidWcgb3IgcmVhY2ggb3V0IHRvIHN1cHBvcnQgaGVyZTogaHR0cHM6Ly9jbGVyay5jb20vc3VwcG9ydFwiO1xudmFyIHVuc3VwcG9ydGVkTm9uQnJvd3NlckRvbWFpbk9yUHJveHlVcmxGdW5jdGlvbiA9IFwiVW5zdXBwb3J0ZWQgdXNhZ2Ugb2YgaXNTYXRlbGxpdGUsIGRvbWFpbiBvciBwcm94eVVybC4gVGhlIHVzYWdlIG9mIGlzU2F0ZWxsaXRlLCBkb21haW4gb3IgcHJveHlVcmwgYXMgZnVuY3Rpb24gaXMgbm90IHN1cHBvcnRlZCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuXCI7XG52YXIgdXNlclByb2ZpbGVQYWdlUmVuZGVyZWRFcnJvciA9IFwiPFVzZXJQcm9maWxlLlBhZ2UgLz4gY29tcG9uZW50IG5lZWRzIHRvIGJlIGEgZGlyZWN0IGNoaWxkIG9mIGA8VXNlclByb2ZpbGUgLz5gIG9yIGA8VXNlckJ1dHRvbiAvPmAuXCI7XG52YXIgdXNlclByb2ZpbGVMaW5rUmVuZGVyZWRFcnJvciA9IFwiPFVzZXJQcm9maWxlLkxpbmsgLz4gY29tcG9uZW50IG5lZWRzIHRvIGJlIGEgZGlyZWN0IGNoaWxkIG9mIGA8VXNlclByb2ZpbGUgLz5gIG9yIGA8VXNlckJ1dHRvbiAvPmAuXCI7XG52YXIgb3JnYW5pemF0aW9uUHJvZmlsZVBhZ2VSZW5kZXJlZEVycm9yID0gXCI8T3JnYW5pemF0aW9uUHJvZmlsZS5QYWdlIC8+IGNvbXBvbmVudCBuZWVkcyB0byBiZSBhIGRpcmVjdCBjaGlsZCBvZiBgPE9yZ2FuaXphdGlvblByb2ZpbGUgLz5gIG9yIGA8T3JnYW5pemF0aW9uU3dpdGNoZXIgLz5gLlwiO1xudmFyIG9yZ2FuaXphdGlvblByb2ZpbGVMaW5rUmVuZGVyZWRFcnJvciA9IFwiPE9yZ2FuaXphdGlvblByb2ZpbGUuTGluayAvPiBjb21wb25lbnQgbmVlZHMgdG8gYmUgYSBkaXJlY3QgY2hpbGQgb2YgYDxPcmdhbml6YXRpb25Qcm9maWxlIC8+YCBvciBgPE9yZ2FuaXphdGlvblN3aXRjaGVyIC8+YC5cIjtcbnZhciBjdXN0b21QYWdlc0lnbm9yZWRDb21wb25lbnQgPSAoY29tcG9uZW50TmFtZSkgPT4gYDwke2NvbXBvbmVudE5hbWV9IC8+IGNhbiBvbmx5IGFjY2VwdCA8JHtjb21wb25lbnROYW1lfS5QYWdlIC8+IGFuZCA8JHtjb21wb25lbnROYW1lfS5MaW5rIC8+IGFzIGl0cyBjaGlsZHJlbi4gQW55IG90aGVyIHByb3ZpZGVkIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuYDtcbnZhciBjdXN0b21QYWdlV3JvbmdQcm9wcyA9IChjb21wb25lbnROYW1lKSA9PiBgTWlzc2luZyBwcm9wcy4gPCR7Y29tcG9uZW50TmFtZX0uUGFnZSAvPiBjb21wb25lbnQgcmVxdWlyZXMgdGhlIGZvbGxvd2luZyBwcm9wczogdXJsLCBsYWJlbCwgbGFiZWxJY29uLCBhbG9uZ3NpZGUgd2l0aCBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIHBhZ2UuYDtcbnZhciBjdXN0b21MaW5rV3JvbmdQcm9wcyA9IChjb21wb25lbnROYW1lKSA9PiBgTWlzc2luZyBwcm9wcy4gPCR7Y29tcG9uZW50TmFtZX0uTGluayAvPiBjb21wb25lbnQgcmVxdWlyZXMgdGhlIGZvbGxvd2luZyBwcm9wczogdXJsLCBsYWJlbCBhbmQgbGFiZWxJY29uLmA7XG52YXIgbm9QYXRoUHJvdmlkZWRFcnJvciA9IChjb21wb25lbnROYW1lKSA9PiBgVGhlIDwke2NvbXBvbmVudE5hbWV9Lz4gY29tcG9uZW50IHVzZXMgcGF0aC1iYXNlZCByb3V0aW5nIGJ5IGRlZmF1bHQgdW5sZXNzIGEgZGlmZmVyZW50IHJvdXRpbmcgc3RyYXRlZ3kgaXMgcHJvdmlkZWQgdXNpbmcgdGhlIFxcYHJvdXRpbmdcXGAgcHJvcC4gV2hlbiBwYXRoLWJhc2VkIHJvdXRpbmcgaXMgdXNlZCwgeW91IG5lZWQgdG8gcHJvdmlkZSB0aGUgcGF0aCB3aGVyZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgb24gYnkgdXNpbmcgdGhlIFxcYHBhdGhcXGAgcHJvcC4gRXhhbXBsZTogPCR7Y29tcG9uZW50TmFtZX0gcGF0aD17Jy9teS1wYXRoJ30gLz5gO1xudmFyIGluY29tcGF0aWJsZVJvdXRpbmdXaXRoUGF0aFByb3ZpZGVkRXJyb3IgPSAoY29tcG9uZW50TmFtZSkgPT4gYFRoZSBcXGBwYXRoXFxgIHByb3Agd2lsbCBvbmx5IGJlIHJlc3BlY3RlZCB3aGVuIHRoZSBDbGVyayBjb21wb25lbnQgdXNlcyBwYXRoLWJhc2VkIHJvdXRpbmcuIFRvIHJlc29sdmUgdGhpcyBlcnJvciwgcGFzcyBcXGByb3V0aW5nPSdwYXRoJ1xcYCB0byB0aGUgPCR7Y29tcG9uZW50TmFtZX0vPiBjb21wb25lbnQsIG9yIGRyb3AgdGhlIFxcYHBhdGhcXGAgcHJvcCB0byBzd2l0Y2ggdG8gaGFzaC1iYXNlZCByb3V0aW5nLiBGb3IgbW9yZSBkZXRhaWxzIHBsZWFzZSByZWZlciB0byBvdXIgZG9jczogaHR0cHM6Ly9jbGVyay5jb20vZG9jc2A7XG52YXIgdXNlckJ1dHRvbklnbm9yZWRDb21wb25lbnQgPSBgPFVzZXJCdXR0b24gLz4gY2FuIG9ubHkgYWNjZXB0IDxVc2VyQnV0dG9uLlVzZXJQcm9maWxlUGFnZSAvPiwgPFVzZXJCdXR0b24uVXNlclByb2ZpbGVMaW5rIC8+IGFuZCA8VXNlckJ1dHRvbi5NZW51SXRlbXMgLz4gYXMgaXRzIGNoaWxkcmVuLiBBbnkgb3RoZXIgcHJvdmlkZWQgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5gO1xudmFyIGN1c3RvbU1lbnVJdGVtc0lnbm9yZWRDb21wb25lbnQgPSBcIjxVc2VyQnV0dG9uLk1lbnVJdGVtcyAvPiBjb21wb25lbnQgY2FuIG9ubHkgYWNjZXB0IDxVc2VyQnV0dG9uLkFjdGlvbiAvPiBhbmQgPFVzZXJCdXR0b24uTGluayAvPiBhcyBpdHMgY2hpbGRyZW4uIEFueSBvdGhlciBwcm92aWRlZCBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlwiO1xudmFyIHVzZXJCdXR0b25NZW51SXRlbXNSZW5kZXJlZEVycm9yID0gXCI8VXNlckJ1dHRvbi5NZW51SXRlbXMgLz4gY29tcG9uZW50IG5lZWRzIHRvIGJlIGEgZGlyZWN0IGNoaWxkIG9mIGA8VXNlckJ1dHRvbiAvPmAuXCI7XG52YXIgdXNlckJ1dHRvbk1lbnVBY3Rpb25SZW5kZXJlZEVycm9yID0gXCI8VXNlckJ1dHRvbi5BY3Rpb24gLz4gY29tcG9uZW50IG5lZWRzIHRvIGJlIGEgZGlyZWN0IGNoaWxkIG9mIGA8VXNlckJ1dHRvbi5NZW51SXRlbXMgLz5gLlwiO1xudmFyIHVzZXJCdXR0b25NZW51TGlua1JlbmRlcmVkRXJyb3IgPSBcIjxVc2VyQnV0dG9uLkxpbmsgLz4gY29tcG9uZW50IG5lZWRzIHRvIGJlIGEgZGlyZWN0IGNoaWxkIG9mIGA8VXNlckJ1dHRvbi5NZW51SXRlbXMgLz5gLlwiO1xudmFyIHVzZXJCdXR0b25NZW51SXRlbUxpbmtXcm9uZ1Byb3BzID0gXCJNaXNzaW5nIHByb3BzLiA8VXNlckJ1dHRvbi5MaW5rIC8+IGNvbXBvbmVudCByZXF1aXJlcyB0aGUgZm9sbG93aW5nIHByb3BzOiBocmVmLCBsYWJlbCBhbmQgbGFiZWxJY29uLlwiO1xudmFyIHVzZXJCdXR0b25NZW51SXRlbXNBY3Rpb25Xcm9uZ3NQcm9wcyA9IFwiTWlzc2luZyBwcm9wcy4gPFVzZXJCdXR0b24uQWN0aW9uIC8+IGNvbXBvbmVudCByZXF1aXJlcyB0aGUgZm9sbG93aW5nIHByb3BzOiBsYWJlbC5cIjtcblxuLy8gc3JjL2hvb2tzL3VzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIudHNcbmltcG9ydCB7IHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIgYXMgdXNlU2hhcmVkQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlciB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL3JlYWN0XCI7XG52YXIgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlciA9IChzb3VyY2UpID0+IHtcbiAgdXNlU2hhcmVkQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcigoKSA9PiB7XG4gICAgZXJyb3JUaHJvd2VyLnRocm93TWlzc2luZ0NsZXJrUHJvdmlkZXJFcnJvcih7IHNvdXJjZSB9KTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvaG9va3MvdXRpbHMudHNcbnZhciBjbGVya0xvYWRlZCA9IChpc29tb3JwaGljQ2xlcmspID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgaWYgKGlzb21vcnBoaWNDbGVyay5sb2FkZWQpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9XG4gICAgaXNvbW9ycGhpY0NsZXJrLmFkZE9uTG9hZGVkKHJlc29sdmUpO1xuICB9KTtcbn07XG52YXIgY3JlYXRlR2V0VG9rZW4gPSAoaXNvbW9ycGhpY0NsZXJrKSA9PiB7XG4gIHJldHVybiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGF3YWl0IGNsZXJrTG9hZGVkKGlzb21vcnBoaWNDbGVyayk7XG4gICAgaWYgKCFpc29tb3JwaGljQ2xlcmsuc2Vzc2lvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpc29tb3JwaGljQ2xlcmsuc2Vzc2lvbi5nZXRUb2tlbihvcHRpb25zKTtcbiAgfTtcbn07XG52YXIgY3JlYXRlU2lnbk91dCA9IChpc29tb3JwaGljQ2xlcmspID0+IHtcbiAgcmV0dXJuIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgYXdhaXQgY2xlcmtMb2FkZWQoaXNvbW9ycGhpY0NsZXJrKTtcbiAgICByZXR1cm4gaXNvbW9ycGhpY0NsZXJrLnNpZ25PdXQoLi4uYXJncyk7XG4gIH07XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlQXV0aC50c1xudmFyIHVzZUF1dGggPSAoKSA9PiB7XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoXCJ1c2VBdXRoXCIpO1xuICBjb25zdCB7IHNlc3Npb25JZCwgdXNlcklkLCBhY3Rvciwgb3JnSWQsIG9yZ1JvbGUsIG9yZ1NsdWcsIG9yZ1Blcm1pc3Npb25zLCBfX2V4cGVyaW1lbnRhbF9mYWN0b3JWZXJpZmljYXRpb25BZ2UgfSA9IHVzZUF1dGhDb250ZXh0KCk7XG4gIGNvbnN0IGlzb21vcnBoaWNDbGVyayA9IHVzZUlzb21vcnBoaWNDbGVya0NvbnRleHQoKTtcbiAgY29uc3QgZ2V0VG9rZW4gPSB1c2VDYWxsYmFjayhjcmVhdGVHZXRUb2tlbihpc29tb3JwaGljQ2xlcmspLCBbaXNvbW9ycGhpY0NsZXJrXSk7XG4gIGNvbnN0IHNpZ25PdXQgPSB1c2VDYWxsYmFjayhjcmVhdGVTaWduT3V0KGlzb21vcnBoaWNDbGVyayksIFtpc29tb3JwaGljQ2xlcmtdKTtcbiAgY29uc3QgaGFzID0gdXNlQ2FsbGJhY2soXG4gICAgKHBhcmFtcykgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNoZWNrQXV0aG9yaXphdGlvbih7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgb3JnSWQsXG4gICAgICAgIG9yZ1JvbGUsXG4gICAgICAgIG9yZ1Blcm1pc3Npb25zLFxuICAgICAgICBfX2V4cGVyaW1lbnRhbF9mYWN0b3JWZXJpZmljYXRpb25BZ2VcbiAgICAgIH0pKHBhcmFtcyk7XG4gICAgfSxcbiAgICBbdXNlcklkLCBfX2V4cGVyaW1lbnRhbF9mYWN0b3JWZXJpZmljYXRpb25BZ2UsIG9yZ0lkLCBvcmdSb2xlLCBvcmdQZXJtaXNzaW9uc11cbiAgKTtcbiAgaWYgKHNlc3Npb25JZCA9PT0gdm9pZCAwICYmIHVzZXJJZCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGVkOiBmYWxzZSxcbiAgICAgIGlzU2lnbmVkSW46IHZvaWQgMCxcbiAgICAgIHNlc3Npb25JZCxcbiAgICAgIHVzZXJJZCxcbiAgICAgIGFjdG9yOiB2b2lkIDAsXG4gICAgICBvcmdJZDogdm9pZCAwLFxuICAgICAgb3JnUm9sZTogdm9pZCAwLFxuICAgICAgb3JnU2x1Zzogdm9pZCAwLFxuICAgICAgaGFzOiB2b2lkIDAsXG4gICAgICBzaWduT3V0LFxuICAgICAgZ2V0VG9rZW5cbiAgICB9O1xuICB9XG4gIGlmIChzZXNzaW9uSWQgPT09IG51bGwgJiYgdXNlcklkID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGVkOiB0cnVlLFxuICAgICAgaXNTaWduZWRJbjogZmFsc2UsXG4gICAgICBzZXNzaW9uSWQsXG4gICAgICB1c2VySWQsXG4gICAgICBhY3RvcjogbnVsbCxcbiAgICAgIG9yZ0lkOiBudWxsLFxuICAgICAgb3JnUm9sZTogbnVsbCxcbiAgICAgIG9yZ1NsdWc6IG51bGwsXG4gICAgICBoYXM6ICgpID0+IGZhbHNlLFxuICAgICAgc2lnbk91dCxcbiAgICAgIGdldFRva2VuXG4gICAgfTtcbiAgfVxuICBpZiAoISFzZXNzaW9uSWQgJiYgISF1c2VySWQgJiYgISFvcmdJZCAmJiAhIW9yZ1JvbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkZWQ6IHRydWUsXG4gICAgICBpc1NpZ25lZEluOiB0cnVlLFxuICAgICAgc2Vzc2lvbklkLFxuICAgICAgdXNlcklkLFxuICAgICAgYWN0b3I6IGFjdG9yIHx8IG51bGwsXG4gICAgICBvcmdJZCxcbiAgICAgIG9yZ1JvbGUsXG4gICAgICBvcmdTbHVnOiBvcmdTbHVnIHx8IG51bGwsXG4gICAgICBoYXMsXG4gICAgICBzaWduT3V0LFxuICAgICAgZ2V0VG9rZW5cbiAgICB9O1xuICB9XG4gIGlmICghIXNlc3Npb25JZCAmJiAhIXVzZXJJZCAmJiAhb3JnSWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkZWQ6IHRydWUsXG4gICAgICBpc1NpZ25lZEluOiB0cnVlLFxuICAgICAgc2Vzc2lvbklkLFxuICAgICAgdXNlcklkLFxuICAgICAgYWN0b3I6IGFjdG9yIHx8IG51bGwsXG4gICAgICBvcmdJZDogbnVsbCxcbiAgICAgIG9yZ1JvbGU6IG51bGwsXG4gICAgICBvcmdTbHVnOiBudWxsLFxuICAgICAgaGFzLFxuICAgICAgc2lnbk91dCxcbiAgICAgIGdldFRva2VuXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZXJyb3JUaHJvd2VyLnRocm93KGludmFsaWRTdGF0ZUVycm9yKTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2VFbWFpbExpbmsudHNcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUVtYWlsTGluayhyZXNvdXJjZSkge1xuICBjb25zdCB7IHN0YXJ0RW1haWxMaW5rRmxvdywgY2FuY2VsRW1haWxMaW5rRmxvdyB9ID0gUmVhY3QudXNlTWVtbygoKSA9PiByZXNvdXJjZS5jcmVhdGVFbWFpbExpbmtGbG93KCksIFtyZXNvdXJjZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBjYW5jZWxFbWFpbExpbmtGbG93O1xuICB9LCBbXSk7XG4gIHJldHVybiB7XG4gICAgc3RhcnRFbWFpbExpbmtGbG93LFxuICAgIGNhbmNlbEVtYWlsTGlua0Zsb3dcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZVNpZ25Jbi50c1xuaW1wb3J0IHsgdXNlQ2xpZW50Q29udGV4dCB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL3JlYWN0XCI7XG5pbXBvcnQgeyBldmVudE1ldGhvZENhbGxlZCB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL3RlbGVtZXRyeVwiO1xudmFyIHVzZVNpZ25JbiA9ICgpID0+IHtcbiAgdmFyIF9hO1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKFwidXNlU2lnbkluXCIpO1xuICBjb25zdCBpc29tb3JwaGljQ2xlcmsgPSB1c2VJc29tb3JwaGljQ2xlcmtDb250ZXh0KCk7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudENvbnRleHQoKTtcbiAgKF9hID0gaXNvbW9ycGhpY0NsZXJrLnRlbGVtZXRyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlY29yZChldmVudE1ldGhvZENhbGxlZChcInVzZVNpZ25JblwiKSk7XG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuIHsgaXNMb2FkZWQ6IGZhbHNlLCBzaWduSW46IHZvaWQgMCwgc2V0QWN0aXZlOiB2b2lkIDAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzTG9hZGVkOiB0cnVlLFxuICAgIHNpZ25JbjogY2xpZW50LnNpZ25JbixcbiAgICBzZXRBY3RpdmU6IGlzb21vcnBoaWNDbGVyay5zZXRBY3RpdmVcbiAgfTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2VTaWduVXAudHNcbmltcG9ydCB7IHVzZUNsaWVudENvbnRleHQgYXMgdXNlQ2xpZW50Q29udGV4dDIgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9yZWFjdFwiO1xuaW1wb3J0IHsgZXZlbnRNZXRob2RDYWxsZWQgYXMgZXZlbnRNZXRob2RDYWxsZWQyIH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvdGVsZW1ldHJ5XCI7XG52YXIgdXNlU2lnblVwID0gKCkgPT4ge1xuICB2YXIgX2E7XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoXCJ1c2VTaWduVXBcIik7XG4gIGNvbnN0IGlzb21vcnBoaWNDbGVyayA9IHVzZUlzb21vcnBoaWNDbGVya0NvbnRleHQoKTtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50Q29udGV4dDIoKTtcbiAgKF9hID0gaXNvbW9ycGhpY0NsZXJrLnRlbGVtZXRyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlY29yZChldmVudE1ldGhvZENhbGxlZDIoXCJ1c2VTaWduVXBcIikpO1xuICBpZiAoIWNsaWVudCkge1xuICAgIHJldHVybiB7IGlzTG9hZGVkOiBmYWxzZSwgc2lnblVwOiB2b2lkIDAsIHNldEFjdGl2ZTogdm9pZCAwIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRlZDogdHJ1ZSxcbiAgICBzaWduVXA6IGNsaWVudC5zaWduVXAsXG4gICAgc2V0QWN0aXZlOiBpc29tb3JwaGljQ2xlcmsuc2V0QWN0aXZlXG4gIH07XG59O1xuXG4vLyBzcmMvaG9va3MvaW5kZXgudHNcbmltcG9ydCB7XG4gIHVzZUNsZXJrLFxuICB1c2VPcmdhbml6YXRpb24sXG4gIHVzZU9yZ2FuaXphdGlvbkxpc3QsXG4gIHVzZVNlc3Npb25MaXN0LFxuICB1c2VVc2VyLFxuICB1c2VTZXNzaW9uXG59IGZyb20gXCJAY2xlcmsvc2hhcmVkL3JlYWN0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL2NvbnRyb2xDb21wb25lbnRzLnRzeFxuaW1wb3J0IFJlYWN0MyBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbnRleHRzL1Nlc3Npb25Db250ZXh0LnRzeFxuaW1wb3J0IHsgU2Vzc2lvbkNvbnRleHQsIHVzZVNlc3Npb25Db250ZXh0IH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvcmVhY3RcIjtcblxuLy8gc3JjL2NvbXBvbmVudHMvd2l0aENsZXJrLnRzeFxuaW1wb3J0IFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbnZhciB3aXRoQ2xlcmsgPSAoQ29tcG9uZW50LCBkaXNwbGF5TmFtZSkgPT4ge1xuICBkaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCBcIkNvbXBvbmVudFwiO1xuICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgY29uc3QgSE9DID0gKHByb3BzKSA9PiB7XG4gICAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihkaXNwbGF5TmFtZSB8fCBcIndpdGhDbGVya1wiKTtcbiAgICBjb25zdCBjbGVyayA9IHVzZUlzb21vcnBoaWNDbGVya0NvbnRleHQoKTtcbiAgICBpZiAoIWNsZXJrLmxvYWRlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDb21wb25lbnQsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBjbGVya1xuICAgICAgfVxuICAgICk7XG4gIH07XG4gIEhPQy5kaXNwbGF5TmFtZSA9IGB3aXRoQ2xlcmsoJHtkaXNwbGF5TmFtZX0pYDtcbiAgcmV0dXJuIEhPQztcbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL2NvbnRyb2xDb21wb25lbnRzLnRzeFxudmFyIFNpZ25lZEluID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKFwiU2lnbmVkSW5cIik7XG4gIGNvbnN0IHsgdXNlcklkIH0gPSB1c2VBdXRoQ29udGV4dCgpO1xuICBpZiAodXNlcklkKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZWFjdDMuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgU2lnbmVkT3V0ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKFwiU2lnbmVkT3V0XCIpO1xuICBjb25zdCB7IHVzZXJJZCB9ID0gdXNlQXV0aENvbnRleHQoKTtcbiAgaWYgKHVzZXJJZCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoUmVhY3QzLkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIENsZXJrTG9hZGVkID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKFwiQ2xlcmtMb2FkZWRcIik7XG4gIGNvbnN0IGlzb21vcnBoaWNDbGVyayA9IHVzZUlzb21vcnBoaWNDbGVya0NvbnRleHQoKTtcbiAgaWYgKCFpc29tb3JwaGljQ2xlcmsubG9hZGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZWFjdDMuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn07XG52YXIgQ2xlcmtMb2FkaW5nID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKFwiQ2xlcmtMb2FkaW5nXCIpO1xuICBjb25zdCBpc29tb3JwaGljQ2xlcmsgPSB1c2VJc29tb3JwaGljQ2xlcmtDb250ZXh0KCk7XG4gIGlmIChpc29tb3JwaGljQ2xlcmsubG9hZGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZWFjdDMuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn07XG52YXIgUHJvdGVjdCA9ICh7IGNoaWxkcmVuLCBmYWxsYmFjaywgLi4ucmVzdEF1dGhvcml6ZWRQYXJhbXMgfSkgPT4ge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKFwiUHJvdGVjdFwiKTtcbiAgY29uc3QgeyBpc0xvYWRlZCwgaGFzLCB1c2VySWQgfSA9IHVzZUF1dGgoKTtcbiAgaWYgKCFpc0xvYWRlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHVuYXV0aG9yaXplZCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZWFjdDMuRnJhZ21lbnQsIG51bGwsIGZhbGxiYWNrICE9IG51bGwgPyBmYWxsYmFjayA6IG51bGwpO1xuICBjb25zdCBhdXRob3JpemVkID0gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlYWN0My5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xuICBpZiAoIXVzZXJJZCkge1xuICAgIHJldHVybiB1bmF1dGhvcml6ZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXN0QXV0aG9yaXplZFBhcmFtcy5jb25kaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGlmIChyZXN0QXV0aG9yaXplZFBhcmFtcy5jb25kaXRpb24oaGFzKSkge1xuICAgICAgcmV0dXJuIGF1dGhvcml6ZWQ7XG4gICAgfVxuICAgIHJldHVybiB1bmF1dGhvcml6ZWQ7XG4gIH1cbiAgaWYgKHJlc3RBdXRob3JpemVkUGFyYW1zLnJvbGUgfHwgcmVzdEF1dGhvcml6ZWRQYXJhbXMucGVybWlzc2lvbikge1xuICAgIGlmIChoYXMocmVzdEF1dGhvcml6ZWRQYXJhbXMpKSB7XG4gICAgICByZXR1cm4gYXV0aG9yaXplZDtcbiAgICB9XG4gICAgcmV0dXJuIHVuYXV0aG9yaXplZDtcbiAgfVxuICByZXR1cm4gYXV0aG9yaXplZDtcbn07XG52YXIgUmVkaXJlY3RUb1NpZ25JbiA9IHdpdGhDbGVyaygoeyBjbGVyaywgLi4ucHJvcHMgfSkgPT4ge1xuICBjb25zdCB7IGNsaWVudCwgc2Vzc2lvbiB9ID0gY2xlcms7XG4gIGNvbnN0IGhhc0FjdGl2ZVNlc3Npb25zID0gY2xpZW50LmFjdGl2ZVNlc3Npb25zICYmIGNsaWVudC5hY3RpdmVTZXNzaW9ucy5sZW5ndGggPiAwO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2Vzc2lvbiA9PT0gbnVsbCAmJiBoYXNBY3RpdmVTZXNzaW9ucykge1xuICAgICAgdm9pZCBjbGVyay5yZWRpcmVjdFRvQWZ0ZXJTaWduT3V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgY2xlcmsucmVkaXJlY3RUb1NpZ25Jbihwcm9wcyk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiBudWxsO1xufSwgXCJSZWRpcmVjdFRvU2lnbkluXCIpO1xudmFyIFJlZGlyZWN0VG9TaWduVXAgPSB3aXRoQ2xlcmsoKHsgY2xlcmssIC4uLnByb3BzIH0pID0+IHtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdm9pZCBjbGVyay5yZWRpcmVjdFRvU2lnblVwKHByb3BzKTtcbiAgfSwgW10pO1xuICByZXR1cm4gbnVsbDtcbn0sIFwiUmVkaXJlY3RUb1NpZ25VcFwiKTtcbnZhciBSZWRpcmVjdFRvVXNlclByb2ZpbGUgPSB3aXRoQ2xlcmsoKHsgY2xlcmsgfSkgPT4ge1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2b2lkIGNsZXJrLnJlZGlyZWN0VG9Vc2VyUHJvZmlsZSgpO1xuICB9LCBbXSk7XG4gIHJldHVybiBudWxsO1xufSwgXCJSZWRpcmVjdFRvVXNlclByb2ZpbGVcIik7XG52YXIgUmVkaXJlY3RUb09yZ2FuaXphdGlvblByb2ZpbGUgPSB3aXRoQ2xlcmsoKHsgY2xlcmsgfSkgPT4ge1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2b2lkIGNsZXJrLnJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlKCk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59LCBcIlJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlXCIpO1xudmFyIFJlZGlyZWN0VG9DcmVhdGVPcmdhbml6YXRpb24gPSB3aXRoQ2xlcmsoKHsgY2xlcmsgfSkgPT4ge1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2b2lkIGNsZXJrLnJlZGlyZWN0VG9DcmVhdGVPcmdhbml6YXRpb24oKTtcbiAgfSwgW10pO1xuICByZXR1cm4gbnVsbDtcbn0sIFwiUmVkaXJlY3RUb0NyZWF0ZU9yZ2FuaXphdGlvblwiKTtcbnZhciBBdXRoZW50aWNhdGVXaXRoUmVkaXJlY3RDYWxsYmFjayA9IHdpdGhDbGVyayhcbiAgKHsgY2xlcmssIC4uLmhhbmRsZVJlZGlyZWN0Q2FsbGJhY2tQYXJhbXMgfSkgPT4ge1xuICAgIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgdm9pZCBjbGVyay5oYW5kbGVSZWRpcmVjdENhbGxiYWNrKGhhbmRsZVJlZGlyZWN0Q2FsbGJhY2tQYXJhbXMpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgXCJBdXRoZW50aWNhdGVXaXRoUmVkaXJlY3RDYWxsYmFja1wiXG4pO1xudmFyIE11bHRpc2Vzc2lvbkFwcFN1cHBvcnQgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoXCJNdWx0aXNlc3Npb25BcHBTdXBwb3J0XCIpO1xuICBjb25zdCBzZXNzaW9uID0gdXNlU2Vzc2lvbkNvbnRleHQoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZWFjdDMuRnJhZ21lbnQsIHsga2V5OiBzZXNzaW9uID8gc2Vzc2lvbi5pZCA6IFwibm8tdXNlcnNcIiB9LCBjaGlsZHJlbik7XG59O1xuXG5leHBvcnQge1xuICBlcnJvclRocm93ZXIsXG4gIHNldEVycm9yVGhyb3dlck9wdGlvbnMsXG4gIG11bHRpcGxlQ2xlcmtQcm92aWRlcnNFcnJvcixcbiAgbXVsdGlwbGVDaGlsZHJlbkluQnV0dG9uQ29tcG9uZW50LFxuICB1bnN1cHBvcnRlZE5vbkJyb3dzZXJEb21haW5PclByb3h5VXJsRnVuY3Rpb24sXG4gIHVzZXJQcm9maWxlUGFnZVJlbmRlcmVkRXJyb3IsXG4gIHVzZXJQcm9maWxlTGlua1JlbmRlcmVkRXJyb3IsXG4gIG9yZ2FuaXphdGlvblByb2ZpbGVQYWdlUmVuZGVyZWRFcnJvcixcbiAgb3JnYW5pemF0aW9uUHJvZmlsZUxpbmtSZW5kZXJlZEVycm9yLFxuICBjdXN0b21QYWdlc0lnbm9yZWRDb21wb25lbnQsXG4gIGN1c3RvbVBhZ2VXcm9uZ1Byb3BzLFxuICBjdXN0b21MaW5rV3JvbmdQcm9wcyxcbiAgbm9QYXRoUHJvdmlkZWRFcnJvcixcbiAgaW5jb21wYXRpYmxlUm91dGluZ1dpdGhQYXRoUHJvdmlkZWRFcnJvcixcbiAgdXNlckJ1dHRvbklnbm9yZWRDb21wb25lbnQsXG4gIGN1c3RvbU1lbnVJdGVtc0lnbm9yZWRDb21wb25lbnQsXG4gIHVzZXJCdXR0b25NZW51SXRlbXNSZW5kZXJlZEVycm9yLFxuICB1c2VyQnV0dG9uTWVudUFjdGlvblJlbmRlcmVkRXJyb3IsXG4gIHVzZXJCdXR0b25NZW51TGlua1JlbmRlcmVkRXJyb3IsXG4gIHVzZXJCdXR0b25NZW51SXRlbUxpbmtXcm9uZ1Byb3BzLFxuICB1c2VyQnV0dG9uTWVudUl0ZW1zQWN0aW9uV3JvbmdzUHJvcHMsXG4gIElzb21vcnBoaWNDbGVya0NvbnRleHQsXG4gIHdpdGhDbGVyayxcbiAgQXV0aENvbnRleHQsXG4gIHVzZUF1dGgsXG4gIHVzZUVtYWlsTGluayxcbiAgdXNlU2lnbkluLFxuICB1c2VTaWduVXAsXG4gIHVzZUNsZXJrLFxuICB1c2VPcmdhbml6YXRpb24sXG4gIHVzZU9yZ2FuaXphdGlvbkxpc3QsXG4gIHVzZVNlc3Npb25MaXN0LFxuICB1c2VVc2VyLFxuICB1c2VTZXNzaW9uLFxuICBTaWduZWRJbixcbiAgU2lnbmVkT3V0LFxuICBDbGVya0xvYWRlZCxcbiAgQ2xlcmtMb2FkaW5nLFxuICBQcm90ZWN0LFxuICBSZWRpcmVjdFRvU2lnbkluLFxuICBSZWRpcmVjdFRvU2lnblVwLFxuICBSZWRpcmVjdFRvVXNlclByb2ZpbGUsXG4gIFJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlLFxuICBSZWRpcmVjdFRvQ3JlYXRlT3JnYW5pemF0aW9uLFxuICBBdXRoZW50aWNhdGVXaXRoUmVkaXJlY3RDYWxsYmFjayxcbiAgTXVsdGlzZXNzaW9uQXBwU3VwcG9ydFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUxWTEJSVUhKLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-LVLBRUHJ.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-OANWQR3B.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@clerk/clerk-react/dist/chunk-OANWQR3B.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __privateAdd: function() { return /* binding */ __privateAdd; },\n/* harmony export */   __privateGet: function() { return /* binding */ __privateGet; },\n/* harmony export */   __privateMethod: function() { return /* binding */ __privateMethod; },\n/* harmony export */   __privateSet: function() { return /* binding */ __privateSet; }\n/* harmony export */ });\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n\n//# sourceMappingURL=chunk-OANWQR3B.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvY2xlcmstcmVhY3QvZGlzdC9jaHVuay1PQU5XUVIzQi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBT0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL2NsZXJrLXJlYWN0L2Rpc3QvY2h1bmstT0FOV1FSM0IubWpzP2RkNDciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fdHlwZUVycm9yID0gKG1zZykgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbn07XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiBtZW1iZXIuaGFzKG9iaikgfHwgX190eXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKSk7XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4gbWVtYmVyLmhhcyhvYmopID8gX190eXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSksIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpLCBtZXRob2QpO1xuXG5leHBvcnQge1xuICBfX3ByaXZhdGVHZXQsXG4gIF9fcHJpdmF0ZUFkZCxcbiAgX19wcml2YXRlU2V0LFxuICBfX3ByaXZhdGVNZXRob2Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1PQU5XUVIzQi5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-OANWQR3B.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@clerk/clerk-react/dist/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthenticateWithRedirectCallback: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.AuthenticateWithRedirectCallback; },\n/* harmony export */   ClerkLoaded: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkLoaded; },\n/* harmony export */   ClerkLoading: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkLoading; },\n/* harmony export */   ClerkProvider: function() { return /* binding */ ClerkProvider; },\n/* harmony export */   CreateOrganization: function() { return /* binding */ CreateOrganization; },\n/* harmony export */   GoogleOneTap: function() { return /* binding */ GoogleOneTap; },\n/* harmony export */   OrganizationList: function() { return /* binding */ OrganizationList; },\n/* harmony export */   OrganizationProfile: function() { return /* binding */ OrganizationProfile; },\n/* harmony export */   OrganizationSwitcher: function() { return /* binding */ OrganizationSwitcher; },\n/* harmony export */   Protect: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.Protect; },\n/* harmony export */   RedirectToCreateOrganization: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToCreateOrganization; },\n/* harmony export */   RedirectToOrganizationProfile: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToOrganizationProfile; },\n/* harmony export */   RedirectToSignIn: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToSignIn; },\n/* harmony export */   RedirectToSignUp: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToSignUp; },\n/* harmony export */   RedirectToUserProfile: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.RedirectToUserProfile; },\n/* harmony export */   SignIn: function() { return /* binding */ SignIn; },\n/* harmony export */   SignInButton: function() { return /* binding */ SignInButton; },\n/* harmony export */   SignInWithMetamaskButton: function() { return /* binding */ SignInWithMetamaskButton; },\n/* harmony export */   SignOutButton: function() { return /* binding */ SignOutButton; },\n/* harmony export */   SignUp: function() { return /* binding */ SignUp; },\n/* harmony export */   SignUpButton: function() { return /* binding */ SignUpButton; },\n/* harmony export */   SignedIn: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.SignedIn; },\n/* harmony export */   SignedOut: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.SignedOut; },\n/* harmony export */   UserButton: function() { return /* binding */ UserButton; },\n/* harmony export */   UserProfile: function() { return /* binding */ UserProfile; },\n/* harmony export */   __experimental_UserVerification: function() { return /* binding */ __experimental_UserVerification; },\n/* harmony export */   useAuth: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.useAuth; },\n/* harmony export */   useClerk: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.useClerk; },\n/* harmony export */   useEmailLink: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.useEmailLink; },\n/* harmony export */   useOrganization: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.useOrganization; },\n/* harmony export */   useOrganizationList: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.useOrganizationList; },\n/* harmony export */   useSession: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.useSession; },\n/* harmony export */   useSessionList: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.useSessionList; },\n/* harmony export */   useSignIn: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.useSignIn; },\n/* harmony export */   useSignUp: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.useSignUp; },\n/* harmony export */   useUser: function() { return /* reexport safe */ _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.useUser; }\n/* harmony export */ });\n/* harmony import */ var _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-LVLBRUHJ.mjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-LVLBRUHJ.mjs\");\n/* harmony import */ var _chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-OANWQR3B.mjs */ \"(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/chunk-OANWQR3B.mjs\");\n/* harmony import */ var _clerk_shared_loadClerkJsScript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @clerk/shared/loadClerkJsScript */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/loadClerkJsScript.mjs\");\n/* harmony import */ var _clerk_shared__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @clerk/shared */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/index.mjs\");\n/* harmony import */ var _clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @clerk/shared/react */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/react/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _clerk_shared_keys__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @clerk/shared/keys */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/keys.mjs\");\n/* harmony import */ var _clerk_shared_browser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @clerk/shared/browser */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/browser.mjs\");\n/* harmony import */ var _clerk_shared_handleValueOrFn__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @clerk/shared/handleValueOrFn */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/handleValueOrFn.mjs\");\n\n\n\n// src/polyfills.ts\nif (typeof window !== \"undefined\" && !window.global) {\n  window.global = typeof global === \"undefined\" ? window : global;\n}\n\n// src/index.ts\n\n\n// src/components/uiComponents.tsx\n\n\n\n\n// src/utils/childrenUtils.tsx\n\nvar assertSingleChild = (children) => (name) => {\n  try {\n    return react__WEBPACK_IMPORTED_MODULE_5__.Children.only(children);\n  } catch (e) {\n    return _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.errorThrower.throw((0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.multipleChildrenInButtonComponent)(name));\n  }\n};\nvar normalizeWithDefaultValue = (children, defaultText) => {\n  if (!children) {\n    children = defaultText;\n  }\n  if (typeof children === \"string\") {\n    children = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"button\", null, children);\n  }\n  return children;\n};\nvar safeExecute = (cb) => (...args) => {\n  if (cb && typeof cb === \"function\") {\n    return cb(...args);\n  }\n};\n\n// src/utils/isConstructor.ts\nfunction isConstructor(f) {\n  return typeof f === \"function\";\n}\n\n// src/utils/useMaxAllowedInstancesGuard.tsx\n\nvar counts = /* @__PURE__ */ new Map();\nfunction useMaxAllowedInstancesGuard(name, error, maxCount = 1) {\n  react__WEBPACK_IMPORTED_MODULE_5__.useEffect(() => {\n    const count = counts.get(name) || 0;\n    if (count == maxCount) {\n      return _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.errorThrower.throw(error);\n    }\n    counts.set(name, count + 1);\n    return () => {\n      counts.set(name, (counts.get(name) || 1) - 1);\n    };\n  }, []);\n}\nfunction withMaxAllowedInstancesGuard(WrappedComponent, name, error) {\n  const displayName = WrappedComponent.displayName || WrappedComponent.name || name || \"Component\";\n  const Hoc = (props) => {\n    useMaxAllowedInstancesGuard(name, error);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(WrappedComponent, { ...props });\n  };\n  Hoc.displayName = `withMaxAllowedInstancesGuard(${displayName})`;\n  return Hoc;\n}\n\n// src/utils/useCustomElementPortal.tsx\n\n\nvar useCustomElementPortal = (elements) => {\n  const initialState = Array(elements.length).fill(null);\n  const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(initialState);\n  return elements.map((el, index) => ({\n    id: el.id,\n    mount: (node) => setNodes((prevState) => prevState.map((n, i) => i === index ? node : n)),\n    unmount: () => setNodes((prevState) => prevState.map((n, i) => i === index ? null : n)),\n    portal: () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, nodes[index] ? (0,react_dom__WEBPACK_IMPORTED_MODULE_6__.createPortal)(el.component, nodes[index]) : null)\n  }));\n};\n\n// src/utils/useCustomPages.tsx\n\n\n\n// src/utils/componentValidation.ts\n\nvar isThatComponent = (v, component) => {\n  return !!v && react__WEBPACK_IMPORTED_MODULE_5__.isValidElement(v) && (v == null ? void 0 : v.type) === component;\n};\n\n// src/utils/useCustomPages.tsx\nvar useUserProfileCustomPages = (children) => {\n  const reorderItemsLabels = [\"account\", \"security\"];\n  return useCustomPages({\n    children,\n    reorderItemsLabels,\n    LinkComponent: UserProfileLink,\n    PageComponent: UserProfilePage,\n    MenuItemsComponent: MenuItems,\n    componentName: \"UserProfile\"\n  });\n};\nvar useOrganizationProfileCustomPages = (children) => {\n  const reorderItemsLabels = [\"general\", \"members\"];\n  return useCustomPages({\n    children,\n    reorderItemsLabels,\n    LinkComponent: OrganizationProfileLink,\n    PageComponent: OrganizationProfilePage,\n    componentName: \"OrganizationProfile\"\n  });\n};\nvar useCustomPages = ({\n  children,\n  LinkComponent,\n  PageComponent,\n  MenuItemsComponent,\n  reorderItemsLabels,\n  componentName\n}) => {\n  const validChildren = [];\n  react__WEBPACK_IMPORTED_MODULE_5__.Children.forEach(children, (child) => {\n    if (!isThatComponent(child, PageComponent) && !isThatComponent(child, LinkComponent) && !isThatComponent(child, MenuItemsComponent)) {\n      if (child) {\n        (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)((0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.customPagesIgnoredComponent)(componentName));\n      }\n      return;\n    }\n    const { props } = child;\n    const { children: children2, label, url, labelIcon } = props;\n    if (isThatComponent(child, PageComponent)) {\n      if (isReorderItem(props, reorderItemsLabels)) {\n        validChildren.push({ label });\n      } else if (isCustomPage(props)) {\n        validChildren.push({ label, labelIcon, children: children2, url });\n      } else {\n        (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)((0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.customPageWrongProps)(componentName));\n        return;\n      }\n    }\n    if (isThatComponent(child, LinkComponent)) {\n      if (isExternalLink(props)) {\n        validChildren.push({ label, labelIcon, url });\n      } else {\n        (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)((0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.customLinkWrongProps)(componentName));\n        return;\n      }\n    }\n  });\n  const customPageContents = [];\n  const customPageLabelIcons = [];\n  const customLinkLabelIcons = [];\n  validChildren.forEach((cp, index) => {\n    if (isCustomPage(cp)) {\n      customPageContents.push({ component: cp.children, id: index });\n      customPageLabelIcons.push({ component: cp.labelIcon, id: index });\n      return;\n    }\n    if (isExternalLink(cp)) {\n      customLinkLabelIcons.push({ component: cp.labelIcon, id: index });\n    }\n  });\n  const customPageContentsPortals = useCustomElementPortal(customPageContents);\n  const customPageLabelIconsPortals = useCustomElementPortal(customPageLabelIcons);\n  const customLinkLabelIconsPortals = useCustomElementPortal(customLinkLabelIcons);\n  const customPages = [];\n  const customPagesPortals = [];\n  validChildren.forEach((cp, index) => {\n    if (isReorderItem(cp, reorderItemsLabels)) {\n      customPages.push({ label: cp.label });\n      return;\n    }\n    if (isCustomPage(cp)) {\n      const {\n        portal: contentPortal,\n        mount,\n        unmount\n      } = customPageContentsPortals.find((p) => p.id === index);\n      const {\n        portal: labelPortal,\n        mount: mountIcon,\n        unmount: unmountIcon\n      } = customPageLabelIconsPortals.find((p) => p.id === index);\n      customPages.push({ label: cp.label, url: cp.url, mount, unmount, mountIcon, unmountIcon });\n      customPagesPortals.push(contentPortal);\n      customPagesPortals.push(labelPortal);\n      return;\n    }\n    if (isExternalLink(cp)) {\n      const {\n        portal: labelPortal,\n        mount: mountIcon,\n        unmount: unmountIcon\n      } = customLinkLabelIconsPortals.find((p) => p.id === index);\n      customPages.push({ label: cp.label, url: cp.url, mountIcon, unmountIcon });\n      customPagesPortals.push(labelPortal);\n      return;\n    }\n  });\n  return { customPages, customPagesPortals };\n};\nvar isReorderItem = (childProps, validItems) => {\n  const { children, label, url, labelIcon } = childProps;\n  return !children && !url && !labelIcon && validItems.some((v) => v === label);\n};\nvar isCustomPage = (childProps) => {\n  const { children, label, url, labelIcon } = childProps;\n  return !!children && !!url && !!labelIcon && !!label;\n};\nvar isExternalLink = (childProps) => {\n  const { children, label, url, labelIcon } = childProps;\n  return !children && !!url && !!labelIcon && !!label;\n};\n\n// src/utils/useCustomMenuItems.tsx\n\n\nvar useUserButtonCustomMenuItems = (children) => {\n  const reorderItemsLabels = [\"manageAccount\", \"signOut\"];\n  return useCustomMenuItems({\n    children,\n    reorderItemsLabels,\n    MenuItemsComponent: MenuItems,\n    MenuActionComponent: MenuAction,\n    MenuLinkComponent: MenuLink,\n    UserProfileLinkComponent: UserProfileLink,\n    UserProfilePageComponent: UserProfilePage\n  });\n};\nvar useCustomMenuItems = ({\n  children,\n  MenuItemsComponent,\n  MenuActionComponent,\n  MenuLinkComponent,\n  UserProfileLinkComponent,\n  UserProfilePageComponent,\n  reorderItemsLabels\n}) => {\n  const validChildren = [];\n  const customMenuItems = [];\n  const customMenuItemsPortals = [];\n  react__WEBPACK_IMPORTED_MODULE_5__.Children.forEach(children, (child) => {\n    if (!isThatComponent(child, MenuItemsComponent) && !isThatComponent(child, UserProfileLinkComponent) && !isThatComponent(child, UserProfilePageComponent)) {\n      if (child) {\n        (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonIgnoredComponent);\n      }\n      return;\n    }\n    if (isThatComponent(child, UserProfileLinkComponent) || isThatComponent(child, UserProfilePageComponent)) {\n      return;\n    }\n    const { props } = child;\n    react__WEBPACK_IMPORTED_MODULE_5__.Children.forEach(props.children, (child2) => {\n      if (!isThatComponent(child2, MenuActionComponent) && !isThatComponent(child2, MenuLinkComponent)) {\n        if (child2) {\n          (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.customMenuItemsIgnoredComponent);\n        }\n        return;\n      }\n      const { props: props2 } = child2;\n      const { label, labelIcon, href, onClick, open } = props2;\n      if (isThatComponent(child2, MenuActionComponent)) {\n        if (isReorderItem2(props2, reorderItemsLabels)) {\n          validChildren.push({ label });\n        } else if (isCustomMenuItem(props2)) {\n          const baseItem = {\n            label,\n            labelIcon\n          };\n          if (onClick !== void 0) {\n            validChildren.push({\n              ...baseItem,\n              onClick\n            });\n          } else if (open !== void 0) {\n            validChildren.push({\n              ...baseItem,\n              open: open.startsWith(\"/\") ? open : `/${open}`\n            });\n          } else {\n            (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(\"Custom menu item must have either onClick or open property\");\n            return;\n          }\n        } else {\n          (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonMenuItemsActionWrongsProps);\n          return;\n        }\n      }\n      if (isThatComponent(child2, MenuLinkComponent)) {\n        if (isExternalLink2(props2)) {\n          validChildren.push({ label, labelIcon, href });\n        } else {\n          (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonMenuItemLinkWrongProps);\n          return;\n        }\n      }\n    });\n  });\n  const customMenuItemLabelIcons = [];\n  const customLinkLabelIcons = [];\n  validChildren.forEach((mi, index) => {\n    if (isCustomMenuItem(mi)) {\n      customMenuItemLabelIcons.push({ component: mi.labelIcon, id: index });\n    }\n    if (isExternalLink2(mi)) {\n      customLinkLabelIcons.push({ component: mi.labelIcon, id: index });\n    }\n  });\n  const customMenuItemLabelIconsPortals = useCustomElementPortal(customMenuItemLabelIcons);\n  const customLinkLabelIconsPortals = useCustomElementPortal(customLinkLabelIcons);\n  validChildren.forEach((mi, index) => {\n    if (isReorderItem2(mi, reorderItemsLabels)) {\n      customMenuItems.push({\n        label: mi.label\n      });\n    }\n    if (isCustomMenuItem(mi)) {\n      const {\n        portal: iconPortal,\n        mount: mountIcon,\n        unmount: unmountIcon\n      } = customMenuItemLabelIconsPortals.find((p) => p.id === index);\n      const menuItem = {\n        label: mi.label,\n        mountIcon,\n        unmountIcon\n      };\n      if (\"onClick\" in mi) {\n        menuItem.onClick = mi.onClick;\n      } else if (\"open\" in mi) {\n        menuItem.open = mi.open;\n      }\n      customMenuItems.push(menuItem);\n      customMenuItemsPortals.push(iconPortal);\n    }\n    if (isExternalLink2(mi)) {\n      const {\n        portal: iconPortal,\n        mount: mountIcon,\n        unmount: unmountIcon\n      } = customLinkLabelIconsPortals.find((p) => p.id === index);\n      customMenuItems.push({\n        label: mi.label,\n        href: mi.href,\n        mountIcon,\n        unmountIcon\n      });\n      customMenuItemsPortals.push(iconPortal);\n    }\n  });\n  return { customMenuItems, customMenuItemsPortals };\n};\nvar isReorderItem2 = (childProps, validItems) => {\n  const { children, label, onClick, labelIcon } = childProps;\n  return !children && !onClick && !labelIcon && validItems.some((v) => v === label);\n};\nvar isCustomMenuItem = (childProps) => {\n  const { label, labelIcon, onClick, open } = childProps;\n  return !!labelIcon && !!label && (typeof onClick === \"function\" || typeof open === \"string\");\n};\nvar isExternalLink2 = (childProps) => {\n  const { label, href, labelIcon } = childProps;\n  return !!href && !!labelIcon && !!label;\n};\n\n// src/components/uiComponents.tsx\nvar isMountProps = (props) => {\n  return \"mount\" in props;\n};\nvar isOpenProps = (props) => {\n  return \"open\" in props;\n};\nvar Portal = class extends react__WEBPACK_IMPORTED_MODULE_5__.PureComponent {\n  constructor() {\n    super(...arguments);\n    this.portalRef = react__WEBPACK_IMPORTED_MODULE_5__.createRef();\n  }\n  componentDidUpdate(_prevProps) {\n    var _a, _b, _c, _d;\n    if (!isMountProps(_prevProps) || !isMountProps(this.props)) {\n      return;\n    }\n    const prevProps = (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.without)(_prevProps.props, \"customPages\", \"customMenuItems\", \"children\");\n    const newProps = (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.without)(this.props.props, \"customPages\", \"customMenuItems\", \"children\");\n    const customPagesChanged = ((_a = prevProps.customPages) == null ? void 0 : _a.length) !== ((_b = newProps.customPages) == null ? void 0 : _b.length);\n    const customMenuItemsChanged = ((_c = prevProps.customMenuItems) == null ? void 0 : _c.length) !== ((_d = newProps.customMenuItems) == null ? void 0 : _d.length);\n    if (!(0,_clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.isDeeplyEqual)(prevProps, newProps) || customPagesChanged || customMenuItemsChanged) {\n      this.props.updateProps({ node: this.portalRef.current, props: this.props.props });\n    }\n  }\n  componentDidMount() {\n    if (this.portalRef.current) {\n      if (isMountProps(this.props)) {\n        this.props.mount(this.portalRef.current, this.props.props);\n      }\n      if (isOpenProps(this.props)) {\n        this.props.open(this.props.props);\n      }\n    }\n  }\n  componentWillUnmount() {\n    if (this.portalRef.current) {\n      if (isMountProps(this.props)) {\n        this.props.unmount(this.portalRef.current);\n      }\n      if (isOpenProps(this.props)) {\n        this.props.close();\n      }\n    }\n  }\n  render() {\n    var _a, _b, _c, _d;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\"div\", { ref: this.portalRef }), isMountProps(this.props) && ((_b = (_a = this.props) == null ? void 0 : _a.customPagesPortals) == null ? void 0 : _b.map((portal, index) => (0,react__WEBPACK_IMPORTED_MODULE_5__.createElement)(portal, { key: index }))), isMountProps(this.props) && ((_d = (_c = this.props) == null ? void 0 : _c.customMenuItemsPortals) == null ? void 0 : _d.map((portal, index) => (0,react__WEBPACK_IMPORTED_MODULE_5__.createElement)(portal, { key: index }))));\n  }\n};\nvar SignIn = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk, ...props }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n    Portal,\n    {\n      mount: clerk.mountSignIn,\n      unmount: clerk.unmountSignIn,\n      updateProps: clerk.__unstable__updateProps,\n      props\n    }\n  );\n}, \"SignIn\");\nvar SignUp = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk, ...props }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n    Portal,\n    {\n      mount: clerk.mountSignUp,\n      unmount: clerk.unmountSignUp,\n      updateProps: clerk.__unstable__updateProps,\n      props\n    }\n  );\n}, \"SignUp\");\nfunction UserProfilePage({ children }) {\n  (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.userProfilePageRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, children);\n}\nfunction UserProfileLink({ children }) {\n  (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.userProfileLinkRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, children);\n}\nvar _UserProfile = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, ...props }) => {\n    const { customPages, customPagesPortals } = useUserProfileCustomPages(props.children);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n      Portal,\n      {\n        mount: clerk.mountUserProfile,\n        unmount: clerk.unmountUserProfile,\n        updateProps: clerk.__unstable__updateProps,\n        props: { ...props, customPages },\n        customPagesPortals\n      }\n    );\n  },\n  \"UserProfile\"\n);\nvar UserProfile = Object.assign(_UserProfile, {\n  Page: UserProfilePage,\n  Link: UserProfileLink\n});\nvar _UserButton = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, ...props }) => {\n    const { customPages, customPagesPortals } = useUserProfileCustomPages(props.children);\n    const userProfileProps = Object.assign(props.userProfileProps || {}, { customPages });\n    const { customMenuItems, customMenuItemsPortals } = useUserButtonCustomMenuItems(props.children);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n      Portal,\n      {\n        mount: clerk.mountUserButton,\n        unmount: clerk.unmountUserButton,\n        updateProps: clerk.__unstable__updateProps,\n        props: { ...props, userProfileProps, customMenuItems },\n        customPagesPortals,\n        customMenuItemsPortals\n      }\n    );\n  },\n  \"UserButton\"\n);\nfunction MenuItems({ children }) {\n  (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonMenuItemsRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, children);\n}\nfunction MenuAction({ children }) {\n  (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonMenuActionRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, children);\n}\nfunction MenuLink({ children }) {\n  (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.userButtonMenuLinkRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, children);\n}\nvar UserButton = Object.assign(_UserButton, {\n  UserProfilePage,\n  UserProfileLink,\n  MenuItems,\n  Action: MenuAction,\n  Link: MenuLink\n});\nvar __experimental_UserVerification = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, ...props }) => {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n      Portal,\n      {\n        mount: clerk.__experimental_mountUserVerification,\n        unmount: clerk.__experimental_unmountUserVerification,\n        updateProps: clerk.__unstable__updateProps,\n        props\n      }\n    );\n  },\n  \"__experimental_UserVerification\"\n);\nfunction OrganizationProfilePage({ children }) {\n  (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.organizationProfilePageRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, children);\n}\nfunction OrganizationProfileLink({ children }) {\n  (0,_clerk_shared__WEBPACK_IMPORTED_MODULE_3__.logErrorInDevMode)(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.organizationProfileLinkRenderedError);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(react__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, children);\n}\nvar _OrganizationProfile = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, ...props }) => {\n    const { customPages, customPagesPortals } = useOrganizationProfileCustomPages(props.children);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n      Portal,\n      {\n        mount: clerk.mountOrganizationProfile,\n        unmount: clerk.unmountOrganizationProfile,\n        updateProps: clerk.__unstable__updateProps,\n        props: { ...props, customPages },\n        customPagesPortals\n      }\n    );\n  },\n  \"OrganizationProfile\"\n);\nvar OrganizationProfile = Object.assign(_OrganizationProfile, {\n  Page: OrganizationProfilePage,\n  Link: OrganizationProfileLink\n});\nvar CreateOrganization = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk, ...props }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n    Portal,\n    {\n      mount: clerk.mountCreateOrganization,\n      unmount: clerk.unmountCreateOrganization,\n      updateProps: clerk.__unstable__updateProps,\n      props\n    }\n  );\n}, \"CreateOrganization\");\nvar _OrganizationSwitcher = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, ...props }) => {\n    const { customPages, customPagesPortals } = useOrganizationProfileCustomPages(props.children);\n    const organizationProfileProps = Object.assign(props.organizationProfileProps || {}, { customPages });\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n      Portal,\n      {\n        mount: clerk.mountOrganizationSwitcher,\n        unmount: clerk.unmountOrganizationSwitcher,\n        updateProps: clerk.__unstable__updateProps,\n        props: { ...props, organizationProfileProps },\n        customPagesPortals\n      }\n    );\n  },\n  \"OrganizationSwitcher\"\n);\nvar OrganizationSwitcher = Object.assign(_OrganizationSwitcher, {\n  OrganizationProfilePage,\n  OrganizationProfileLink\n});\nvar OrganizationList = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk, ...props }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n    Portal,\n    {\n      mount: clerk.mountOrganizationList,\n      unmount: clerk.unmountOrganizationList,\n      updateProps: clerk.__unstable__updateProps,\n      props\n    }\n  );\n}, \"OrganizationList\");\nvar GoogleOneTap = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk, ...props }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n    Portal,\n    {\n      open: clerk.openGoogleOneTap,\n      close: clerk.closeGoogleOneTap,\n      props\n    }\n  );\n}, \"GoogleOneTap\");\n\n// src/components/SignInButton.tsx\n\nvar SignInButton = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk, children, ...props }) => {\n  const { signUpFallbackRedirectUrl, forceRedirectUrl, fallbackRedirectUrl, signUpForceRedirectUrl, mode, ...rest } = props;\n  children = normalizeWithDefaultValue(children, \"Sign in\");\n  const child = assertSingleChild(children)(\"SignInButton\");\n  const clickHandler = () => {\n    const opts = {\n      forceRedirectUrl,\n      fallbackRedirectUrl,\n      signUpFallbackRedirectUrl,\n      signUpForceRedirectUrl\n    };\n    if (mode === \"modal\") {\n      return clerk.openSignIn(opts);\n    }\n    return clerk.redirectToSignIn({\n      ...opts,\n      signInFallbackRedirectUrl: fallbackRedirectUrl,\n      signInForceRedirectUrl: forceRedirectUrl\n    });\n  };\n  const wrappedChildClickHandler = async (e) => {\n    if (child && typeof child === \"object\" && \"props\" in child) {\n      await safeExecute(child.props.onClick)(e);\n    }\n    return clickHandler();\n  };\n  const childProps = { ...rest, onClick: wrappedChildClickHandler };\n  return react__WEBPACK_IMPORTED_MODULE_5__.cloneElement(child, childProps);\n}, \"SignInButton\");\n\n// src/components/SignUpButton.tsx\n\nvar SignUpButton = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(({ clerk, children, ...props }) => {\n  const {\n    fallbackRedirectUrl,\n    forceRedirectUrl,\n    signInFallbackRedirectUrl,\n    signInForceRedirectUrl,\n    mode,\n    unsafeMetadata,\n    ...rest\n  } = props;\n  children = normalizeWithDefaultValue(children, \"Sign up\");\n  const child = assertSingleChild(children)(\"SignUpButton\");\n  const clickHandler = () => {\n    const opts = {\n      fallbackRedirectUrl,\n      forceRedirectUrl,\n      signInFallbackRedirectUrl,\n      signInForceRedirectUrl,\n      unsafeMetadata\n    };\n    if (mode === \"modal\") {\n      return clerk.openSignUp(opts);\n    }\n    return clerk.redirectToSignUp({\n      ...opts,\n      signUpFallbackRedirectUrl: fallbackRedirectUrl,\n      signUpForceRedirectUrl: forceRedirectUrl\n    });\n  };\n  const wrappedChildClickHandler = async (e) => {\n    if (child && typeof child === \"object\" && \"props\" in child) {\n      await safeExecute(child.props.onClick)(e);\n    }\n    return clickHandler();\n  };\n  const childProps = { ...rest, onClick: wrappedChildClickHandler };\n  return react__WEBPACK_IMPORTED_MODULE_5__.cloneElement(child, childProps);\n}, \"SignUpButton\");\n\n// src/components/SignOutButton.tsx\n\nvar SignOutButton = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, children, ...props }) => {\n    const { redirectUrl = \"/\", signOutOptions, ...rest } = props;\n    children = normalizeWithDefaultValue(children, \"Sign out\");\n    const child = assertSingleChild(children)(\"SignOutButton\");\n    const clickHandler = () => clerk.signOut({ redirectUrl });\n    const wrappedChildClickHandler = async (e) => {\n      await safeExecute(child.props.onClick)(e);\n      return clickHandler();\n    };\n    const childProps = { ...rest, onClick: wrappedChildClickHandler };\n    return react__WEBPACK_IMPORTED_MODULE_5__.cloneElement(child, childProps);\n  },\n  \"SignOutButton\"\n);\n\n// src/components/SignInWithMetamaskButton.tsx\n\nvar SignInWithMetamaskButton = (0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.withClerk)(\n  ({ clerk, children, ...props }) => {\n    const { redirectUrl, ...rest } = props;\n    children = normalizeWithDefaultValue(children, \"Sign in with Metamask\");\n    const child = assertSingleChild(children)(\"SignInWithMetamaskButton\");\n    const clickHandler = async () => {\n      async function authenticate() {\n        await clerk.authenticateWithMetamask({ redirectUrl: redirectUrl || void 0 });\n      }\n      void authenticate();\n    };\n    const wrappedChildClickHandler = async (e) => {\n      await safeExecute(child.props.onClick)(e);\n      return clickHandler();\n    };\n    const childProps = { ...rest, onClick: wrappedChildClickHandler };\n    return react__WEBPACK_IMPORTED_MODULE_5__.cloneElement(child, childProps);\n  },\n  \"SignInWithMetamask\"\n);\n\n// src/contexts/ClerkProvider.tsx\n\n\n\n// src/contexts/ClerkContextProvider.tsx\n\n\n\n// src/isomorphicClerk.ts\n\n\n\nvar SDK_METADATA = {\n  name: \"@clerk/clerk-react\",\n  version: \"5.9.4\",\n  environment: \"development\"\n};\nvar _loaded, _domain, _proxyUrl, _publishableKey, _instance, _IsomorphicClerk_instances, waitForClerkJS_fn;\nvar _IsomorphicClerk = class _IsomorphicClerk {\n  constructor(options) {\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateAdd)(this, _IsomorphicClerk_instances);\n    this.clerkjs = null;\n    this.preopenOneTap = null;\n    this.preopenUserVerification = null;\n    this.preopenSignIn = null;\n    this.preopenSignUp = null;\n    this.preopenUserProfile = null;\n    this.preopenOrganizationProfile = null;\n    this.preopenCreateOrganization = null;\n    this.premountSignInNodes = /* @__PURE__ */ new Map();\n    this.premountSignUpNodes = /* @__PURE__ */ new Map();\n    this.premountUserProfileNodes = /* @__PURE__ */ new Map();\n    this.premountUserButtonNodes = /* @__PURE__ */ new Map();\n    this.premountOrganizationProfileNodes = /* @__PURE__ */ new Map();\n    this.premountCreateOrganizationNodes = /* @__PURE__ */ new Map();\n    this.premountOrganizationSwitcherNodes = /* @__PURE__ */ new Map();\n    this.premountOrganizationListNodes = /* @__PURE__ */ new Map();\n    this.premountUserVerificationNodes = /* @__PURE__ */ new Map();\n    this.premountMethodCalls = /* @__PURE__ */ new Map();\n    // A separate Map of `addListener` method calls to handle multiple listeners.\n    this.premountAddListenerCalls = /* @__PURE__ */ new Map();\n    this.loadedListeners = [];\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateAdd)(this, _loaded, false);\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateAdd)(this, _domain);\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateAdd)(this, _proxyUrl);\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateAdd)(this, _publishableKey);\n    this.buildSignInUrl = (opts) => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildSignInUrl(opts)) || \"\";\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildSignInUrl\", callback);\n      }\n    };\n    this.buildSignUpUrl = (opts) => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildSignUpUrl(opts)) || \"\";\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildSignUpUrl\", callback);\n      }\n    };\n    this.buildAfterSignInUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildAfterSignInUrl()) || \"\";\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildAfterSignInUrl\", callback);\n      }\n    };\n    this.buildAfterSignUpUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildAfterSignUpUrl()) || \"\";\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildAfterSignUpUrl\", callback);\n      }\n    };\n    this.buildAfterSignOutUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildAfterSignOutUrl()) || \"\";\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildAfterSignOutUrl\", callback);\n      }\n    };\n    this.buildAfterMultiSessionSingleSignOutUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildAfterMultiSessionSingleSignOutUrl()) || \"\";\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildAfterMultiSessionSingleSignOutUrl\", callback);\n      }\n    };\n    this.buildUserProfileUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildUserProfileUrl()) || \"\";\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildUserProfileUrl\", callback);\n      }\n    };\n    this.buildCreateOrganizationUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildCreateOrganizationUrl()) || \"\";\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildCreateOrganizationUrl\", callback);\n      }\n    };\n    this.buildOrganizationProfileUrl = () => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildOrganizationProfileUrl()) || \"\";\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildOrganizationProfileUrl\", callback);\n      }\n    };\n    this.buildUrlWithAuth = (to) => {\n      const callback = () => {\n        var _a;\n        return ((_a = this.clerkjs) == null ? void 0 : _a.buildUrlWithAuth(to)) || \"\";\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"buildUrlWithAuth\", callback);\n      }\n    };\n    this.handleUnauthenticated = () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.handleUnauthenticated();\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        void callback();\n      } else {\n        this.premountMethodCalls.set(\"handleUnauthenticated\", callback);\n      }\n    };\n    this.addOnLoaded = (cb) => {\n      this.loadedListeners.push(cb);\n      if (this.loaded) {\n        this.emitLoaded();\n      }\n    };\n    this.emitLoaded = () => {\n      this.loadedListeners.forEach((cb) => cb());\n      this.loadedListeners = [];\n    };\n    this.hydrateClerkJS = (clerkjs) => {\n      if (!clerkjs) {\n        throw new Error(\"Failed to hydrate latest Clerk JS\");\n      }\n      this.clerkjs = clerkjs;\n      this.premountMethodCalls.forEach((cb) => cb());\n      this.premountAddListenerCalls.forEach((listenerHandlers, listener) => {\n        listenerHandlers.nativeUnsubscribe = clerkjs.addListener(listener);\n      });\n      if (this.preopenSignIn !== null) {\n        clerkjs.openSignIn(this.preopenSignIn);\n      }\n      if (this.preopenSignUp !== null) {\n        clerkjs.openSignUp(this.preopenSignUp);\n      }\n      if (this.preopenUserProfile !== null) {\n        clerkjs.openUserProfile(this.preopenUserProfile);\n      }\n      if (this.preopenUserVerification !== null) {\n        clerkjs.__experimental_openUserVerification(this.preopenUserVerification);\n      }\n      if (this.preopenOneTap !== null) {\n        clerkjs.openGoogleOneTap(this.preopenOneTap);\n      }\n      if (this.preopenOrganizationProfile !== null) {\n        clerkjs.openOrganizationProfile(this.preopenOrganizationProfile);\n      }\n      if (this.preopenCreateOrganization !== null) {\n        clerkjs.openCreateOrganization(this.preopenCreateOrganization);\n      }\n      this.premountSignInNodes.forEach((props, node) => {\n        clerkjs.mountSignIn(node, props);\n      });\n      this.premountSignUpNodes.forEach((props, node) => {\n        clerkjs.mountSignUp(node, props);\n      });\n      this.premountUserProfileNodes.forEach((props, node) => {\n        clerkjs.mountUserProfile(node, props);\n      });\n      this.premountUserVerificationNodes.forEach((props, node) => {\n        clerkjs.__experimental_mountUserVerification(node, props);\n      });\n      this.premountUserButtonNodes.forEach((props, node) => {\n        clerkjs.mountUserButton(node, props);\n      });\n      this.premountOrganizationListNodes.forEach((props, node) => {\n        clerkjs.mountOrganizationList(node, props);\n      });\n      (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateSet)(this, _loaded, true);\n      this.emitLoaded();\n      return this.clerkjs;\n    };\n    this.__unstable__updateProps = async (props) => {\n      const clerkjs = await (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _IsomorphicClerk_instances, waitForClerkJS_fn).call(this);\n      if (clerkjs && \"__unstable__updateProps\" in clerkjs) {\n        return clerkjs.__unstable__updateProps(props);\n      }\n    };\n    /**\n     * `setActive` can be used to set the active session and/or organization.\n     */\n    this.setActive = ({ session, organization, beforeEmit }) => {\n      if (this.clerkjs) {\n        return this.clerkjs.setActive({ session, organization, beforeEmit });\n      } else {\n        return Promise.reject();\n      }\n    };\n    this.openSignIn = (props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.openSignIn(props);\n      } else {\n        this.preopenSignIn = props;\n      }\n    };\n    this.closeSignIn = () => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.closeSignIn();\n      } else {\n        this.preopenSignIn = null;\n      }\n    };\n    this.__experimental_openUserVerification = (props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.__experimental_openUserVerification(props);\n      } else {\n        this.preopenUserVerification = props;\n      }\n    };\n    this.__experimental_closeUserVerification = () => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.__experimental_closeUserVerification();\n      } else {\n        this.preopenUserVerification = null;\n      }\n    };\n    this.openGoogleOneTap = (props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.openGoogleOneTap(props);\n      } else {\n        this.preopenOneTap = props;\n      }\n    };\n    this.closeGoogleOneTap = () => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.closeGoogleOneTap();\n      } else {\n        this.preopenOneTap = null;\n      }\n    };\n    this.openUserProfile = (props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.openUserProfile(props);\n      } else {\n        this.preopenUserProfile = props;\n      }\n    };\n    this.closeUserProfile = () => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.closeUserProfile();\n      } else {\n        this.preopenUserProfile = null;\n      }\n    };\n    this.openOrganizationProfile = (props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.openOrganizationProfile(props);\n      } else {\n        this.preopenOrganizationProfile = props;\n      }\n    };\n    this.closeOrganizationProfile = () => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.closeOrganizationProfile();\n      } else {\n        this.preopenOrganizationProfile = null;\n      }\n    };\n    this.openCreateOrganization = (props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.openCreateOrganization(props);\n      } else {\n        this.preopenCreateOrganization = props;\n      }\n    };\n    this.closeCreateOrganization = () => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.closeCreateOrganization();\n      } else {\n        this.preopenCreateOrganization = null;\n      }\n    };\n    this.openSignUp = (props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.openSignUp(props);\n      } else {\n        this.preopenSignUp = props;\n      }\n    };\n    this.closeSignUp = () => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.closeSignUp();\n      } else {\n        this.preopenSignUp = null;\n      }\n    };\n    this.mountSignIn = (node, props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.mountSignIn(node, props);\n      } else {\n        this.premountSignInNodes.set(node, props);\n      }\n    };\n    this.unmountSignIn = (node) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.unmountSignIn(node);\n      } else {\n        this.premountSignInNodes.delete(node);\n      }\n    };\n    this.__experimental_mountUserVerification = (node, props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.__experimental_mountUserVerification(node, props);\n      } else {\n        this.premountUserVerificationNodes.set(node, props);\n      }\n    };\n    this.__experimental_unmountUserVerification = (node) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.__experimental_unmountUserVerification(node);\n      } else {\n        this.premountUserVerificationNodes.delete(node);\n      }\n    };\n    this.mountSignUp = (node, props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.mountSignUp(node, props);\n      } else {\n        this.premountSignUpNodes.set(node, props);\n      }\n    };\n    this.unmountSignUp = (node) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.unmountSignUp(node);\n      } else {\n        this.premountSignUpNodes.delete(node);\n      }\n    };\n    this.mountUserProfile = (node, props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.mountUserProfile(node, props);\n      } else {\n        this.premountUserProfileNodes.set(node, props);\n      }\n    };\n    this.unmountUserProfile = (node) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.unmountUserProfile(node);\n      } else {\n        this.premountUserProfileNodes.delete(node);\n      }\n    };\n    this.mountOrganizationProfile = (node, props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.mountOrganizationProfile(node, props);\n      } else {\n        this.premountOrganizationProfileNodes.set(node, props);\n      }\n    };\n    this.unmountOrganizationProfile = (node) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.unmountOrganizationProfile(node);\n      } else {\n        this.premountOrganizationProfileNodes.delete(node);\n      }\n    };\n    this.mountCreateOrganization = (node, props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.mountCreateOrganization(node, props);\n      } else {\n        this.premountCreateOrganizationNodes.set(node, props);\n      }\n    };\n    this.unmountCreateOrganization = (node) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.unmountCreateOrganization(node);\n      } else {\n        this.premountCreateOrganizationNodes.delete(node);\n      }\n    };\n    this.mountOrganizationSwitcher = (node, props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.mountOrganizationSwitcher(node, props);\n      } else {\n        this.premountOrganizationSwitcherNodes.set(node, props);\n      }\n    };\n    this.unmountOrganizationSwitcher = (node) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.unmountOrganizationSwitcher(node);\n      } else {\n        this.premountOrganizationSwitcherNodes.delete(node);\n      }\n    };\n    this.mountOrganizationList = (node, props) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.mountOrganizationList(node, props);\n      } else {\n        this.premountOrganizationListNodes.set(node, props);\n      }\n    };\n    this.unmountOrganizationList = (node) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.unmountOrganizationList(node);\n      } else {\n        this.premountOrganizationListNodes.delete(node);\n      }\n    };\n    this.mountUserButton = (node, userButtonProps) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.mountUserButton(node, userButtonProps);\n      } else {\n        this.premountUserButtonNodes.set(node, userButtonProps);\n      }\n    };\n    this.unmountUserButton = (node) => {\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        this.clerkjs.unmountUserButton(node);\n      } else {\n        this.premountUserButtonNodes.delete(node);\n      }\n    };\n    this.addListener = (listener) => {\n      if (this.clerkjs) {\n        return this.clerkjs.addListener(listener);\n      } else {\n        const unsubscribe = () => {\n          var _a;\n          const listenerHandlers = this.premountAddListenerCalls.get(listener);\n          if (listenerHandlers) {\n            (_a = listenerHandlers.nativeUnsubscribe) == null ? void 0 : _a.call(listenerHandlers);\n            this.premountAddListenerCalls.delete(listener);\n          }\n        };\n        this.premountAddListenerCalls.set(listener, { unsubscribe, nativeUnsubscribe: void 0 });\n        return unsubscribe;\n      }\n    };\n    this.navigate = (to) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.navigate(to);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        void callback();\n      } else {\n        this.premountMethodCalls.set(\"navigate\", callback);\n      }\n    };\n    this.redirectWithAuth = async (...args) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectWithAuth(...args);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectWithAuth\", callback);\n        return;\n      }\n    };\n    this.redirectToSignIn = async (opts) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToSignIn(opts);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToSignIn\", callback);\n        return;\n      }\n    };\n    this.redirectToSignUp = async (opts) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToSignUp(opts);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToSignUp\", callback);\n        return;\n      }\n    };\n    this.redirectToUserProfile = async () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToUserProfile();\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToUserProfile\", callback);\n        return;\n      }\n    };\n    this.redirectToAfterSignUp = () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToAfterSignUp();\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToAfterSignUp\", callback);\n      }\n    };\n    this.redirectToAfterSignIn = () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToAfterSignIn();\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToAfterSignIn\", callback);\n      }\n    };\n    this.redirectToAfterSignOut = () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToAfterSignOut();\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToAfterSignOut\", callback);\n      }\n    };\n    this.redirectToOrganizationProfile = async () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToOrganizationProfile();\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToOrganizationProfile\", callback);\n        return;\n      }\n    };\n    this.redirectToCreateOrganization = async () => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.redirectToCreateOrganization();\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"redirectToCreateOrganization\", callback);\n        return;\n      }\n    };\n    this.handleRedirectCallback = (params) => {\n      var _a;\n      const callback = () => {\n        var _a2;\n        return (_a2 = this.clerkjs) == null ? void 0 : _a2.handleRedirectCallback(params);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        void ((_a = callback()) == null ? void 0 : _a.catch(() => {\n        }));\n      } else {\n        this.premountMethodCalls.set(\"handleRedirectCallback\", callback);\n      }\n    };\n    this.handleGoogleOneTapCallback = (signInOrUp, params) => {\n      var _a;\n      const callback = () => {\n        var _a2;\n        return (_a2 = this.clerkjs) == null ? void 0 : _a2.handleGoogleOneTapCallback(signInOrUp, params);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        void ((_a = callback()) == null ? void 0 : _a.catch(() => {\n        }));\n      } else {\n        this.premountMethodCalls.set(\"handleGoogleOneTapCallback\", callback);\n      }\n    };\n    this.handleEmailLinkVerification = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.handleEmailLinkVerification(params);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"handleEmailLinkVerification\", callback);\n      }\n    };\n    this.authenticateWithMetamask = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.authenticateWithMetamask(params);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"authenticateWithMetamask\", callback);\n      }\n    };\n    this.authenticateWithCoinbaseWallet = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.authenticateWithCoinbaseWallet(params);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"authenticateWithCoinbaseWallet\", callback);\n      }\n    };\n    this.authenticateWithWeb3 = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.authenticateWithWeb3(params);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"authenticateWithWeb3\", callback);\n      }\n    };\n    this.authenticateWithGoogleOneTap = async (params) => {\n      const clerkjs = await (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _IsomorphicClerk_instances, waitForClerkJS_fn).call(this);\n      return clerkjs.authenticateWithGoogleOneTap(params);\n    };\n    this.createOrganization = async (params) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.createOrganization(params);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"createOrganization\", callback);\n      }\n    };\n    this.getOrganization = async (organizationId) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.getOrganization(organizationId);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"getOrganization\", callback);\n      }\n    };\n    this.signOut = async (signOutCallbackOrOptions, options) => {\n      const callback = () => {\n        var _a;\n        return (_a = this.clerkjs) == null ? void 0 : _a.signOut(signOutCallbackOrOptions, options);\n      };\n      if (this.clerkjs && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n        return callback();\n      } else {\n        this.premountMethodCalls.set(\"signOut\", callback);\n      }\n    };\n    const { Clerk = null, publishableKey } = options || {};\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateSet)(this, _publishableKey, publishableKey);\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateSet)(this, _proxyUrl, options == null ? void 0 : options.proxyUrl);\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateSet)(this, _domain, options == null ? void 0 : options.domain);\n    this.options = options;\n    this.Clerk = Clerk;\n    this.mode = (0,_clerk_shared_browser__WEBPACK_IMPORTED_MODULE_8__.inBrowser)() ? \"browser\" : \"server\";\n    if (!this.options.sdkMetadata) {\n      this.options.sdkMetadata = SDK_METADATA;\n    }\n    void this.loadClerkJS();\n  }\n  get publishableKey() {\n    return (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _publishableKey);\n  }\n  get loaded() {\n    return (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded);\n  }\n  static getOrCreateInstance(options) {\n    if (!(0,_clerk_shared_browser__WEBPACK_IMPORTED_MODULE_8__.inBrowser)() || !(0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _instance) || options.Clerk && (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _instance).Clerk !== options.Clerk) {\n      (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateSet)(this, _instance, new _IsomorphicClerk(options));\n    }\n    return (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _instance);\n  }\n  static clearInstance() {\n    (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateSet)(this, _instance, null);\n  }\n  get domain() {\n    if (typeof window !== \"undefined\" && window.location) {\n      return (0,_clerk_shared_handleValueOrFn__WEBPACK_IMPORTED_MODULE_9__.handleValueOrFn)((0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _domain), new URL(window.location.href), \"\");\n    }\n    if (typeof (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _domain) === \"function\") {\n      return _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.errorThrower.throw(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.unsupportedNonBrowserDomainOrProxyUrlFunction);\n    }\n    return (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _domain) || \"\";\n  }\n  get proxyUrl() {\n    if (typeof window !== \"undefined\" && window.location) {\n      return (0,_clerk_shared_handleValueOrFn__WEBPACK_IMPORTED_MODULE_9__.handleValueOrFn)((0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _proxyUrl), new URL(window.location.href), \"\");\n    }\n    if (typeof (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _proxyUrl) === \"function\") {\n      return _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.errorThrower.throw(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.unsupportedNonBrowserDomainOrProxyUrlFunction);\n    }\n    return (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _proxyUrl) || \"\";\n  }\n  get sdkMetadata() {\n    var _a;\n    return ((_a = this.clerkjs) == null ? void 0 : _a.sdkMetadata) || this.options.sdkMetadata || void 0;\n  }\n  get instanceType() {\n    var _a;\n    return (_a = this.clerkjs) == null ? void 0 : _a.instanceType;\n  }\n  get frontendApi() {\n    var _a;\n    return ((_a = this.clerkjs) == null ? void 0 : _a.frontendApi) || \"\";\n  }\n  get isStandardBrowser() {\n    var _a;\n    return ((_a = this.clerkjs) == null ? void 0 : _a.isStandardBrowser) || this.options.standardBrowser || false;\n  }\n  get isSatellite() {\n    if (typeof window !== \"undefined\" && window.location) {\n      return (0,_clerk_shared_handleValueOrFn__WEBPACK_IMPORTED_MODULE_9__.handleValueOrFn)(this.options.isSatellite, new URL(window.location.href), false);\n    }\n    if (typeof this.options.isSatellite === \"function\") {\n      return _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.errorThrower.throw(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.unsupportedNonBrowserDomainOrProxyUrlFunction);\n    }\n    return false;\n  }\n  async loadClerkJS() {\n    var _a;\n    if (this.mode !== \"browser\" || (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _loaded)) {\n      return;\n    }\n    if (typeof window !== \"undefined\") {\n      window.__clerk_publishable_key = (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _publishableKey);\n      window.__clerk_proxy_url = this.proxyUrl;\n      window.__clerk_domain = this.domain;\n    }\n    try {\n      if (this.Clerk) {\n        let c;\n        if (isConstructor(this.Clerk)) {\n          c = new this.Clerk((0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _publishableKey), {\n            proxyUrl: this.proxyUrl,\n            domain: this.domain\n          });\n          await c.load(this.options);\n        } else {\n          c = this.Clerk;\n          if (!c.loaded) {\n            await c.load(this.options);\n          }\n        }\n        global.Clerk = c;\n      } else {\n        if (!global.Clerk) {\n          await (0,_clerk_shared_loadClerkJsScript__WEBPACK_IMPORTED_MODULE_2__.loadClerkJsScript)({\n            ...this.options,\n            publishableKey: (0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateGet)(this, _publishableKey),\n            proxyUrl: this.proxyUrl,\n            domain: this.domain,\n            nonce: this.options.nonce\n          });\n        }\n        if (!global.Clerk) {\n          throw new Error(\"Failed to download latest ClerkJS. Contact support@clerk.com.\");\n        }\n        await global.Clerk.load(this.options);\n      }\n      if ((_a = global.Clerk) == null ? void 0 : _a.loaded) {\n        return this.hydrateClerkJS(global.Clerk);\n      }\n      return;\n    } catch (err) {\n      const error = err;\n      if (false) {} else {\n        throw err;\n      }\n      return;\n    }\n  }\n  get version() {\n    var _a;\n    return (_a = this.clerkjs) == null ? void 0 : _a.version;\n  }\n  get client() {\n    if (this.clerkjs) {\n      return this.clerkjs.client;\n    } else {\n      return void 0;\n    }\n  }\n  get session() {\n    if (this.clerkjs) {\n      return this.clerkjs.session;\n    } else {\n      return void 0;\n    }\n  }\n  get user() {\n    if (this.clerkjs) {\n      return this.clerkjs.user;\n    } else {\n      return void 0;\n    }\n  }\n  get organization() {\n    if (this.clerkjs) {\n      return this.clerkjs.organization;\n    } else {\n      return void 0;\n    }\n  }\n  get telemetry() {\n    if (this.clerkjs) {\n      return this.clerkjs.telemetry;\n    } else {\n      return void 0;\n    }\n  }\n  get __unstable__environment() {\n    if (this.clerkjs) {\n      return this.clerkjs.__unstable__environment;\n    } else {\n      return void 0;\n    }\n  }\n  __unstable__setEnvironment(...args) {\n    if (this.clerkjs && \"__unstable__setEnvironment\" in this.clerkjs) {\n      this.clerkjs.__unstable__setEnvironment(args);\n    } else {\n      return void 0;\n    }\n  }\n};\n_loaded = new WeakMap();\n_domain = new WeakMap();\n_proxyUrl = new WeakMap();\n_publishableKey = new WeakMap();\n_instance = new WeakMap();\n_IsomorphicClerk_instances = new WeakSet();\nwaitForClerkJS_fn = function() {\n  return new Promise((resolve) => {\n    this.addOnLoaded(() => resolve(this.clerkjs));\n  });\n};\n(0,_chunk_OANWQR3B_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateAdd)(_IsomorphicClerk, _instance);\nvar IsomorphicClerk = _IsomorphicClerk;\n\n// src/utils/deriveState.ts\nvar deriveState = (clerkLoaded, state, initialState) => {\n  if (!clerkLoaded && initialState) {\n    return deriveFromSsrInitialState(initialState);\n  }\n  return deriveFromClientSideState(state);\n};\nvar deriveFromSsrInitialState = (initialState) => {\n  const userId = initialState.userId;\n  const user = initialState.user;\n  const sessionId = initialState.sessionId;\n  const session = initialState.session;\n  const organization = initialState.organization;\n  const orgId = initialState.orgId;\n  const orgRole = initialState.orgRole;\n  const orgPermissions = initialState.orgPermissions;\n  const orgSlug = initialState.orgSlug;\n  const actor = initialState.actor;\n  const __experimental_factorVerificationAge = initialState.__experimental_factorVerificationAge;\n  return {\n    userId,\n    user,\n    sessionId,\n    session,\n    organization,\n    orgId,\n    orgRole,\n    orgPermissions,\n    orgSlug,\n    actor,\n    __experimental_factorVerificationAge\n  };\n};\nvar deriveFromClientSideState = (state) => {\n  var _a;\n  const userId = state.user ? state.user.id : state.user;\n  const user = state.user;\n  const sessionId = state.session ? state.session.id : state.session;\n  const session = state.session;\n  const __experimental_factorVerificationAge = state.session ? state.session.__experimental_factorVerificationAge : null;\n  const actor = session == null ? void 0 : session.actor;\n  const organization = state.organization;\n  const orgId = state.organization ? state.organization.id : state.organization;\n  const orgSlug = organization == null ? void 0 : organization.slug;\n  const membership = organization ? (_a = user == null ? void 0 : user.organizationMemberships) == null ? void 0 : _a.find((om) => om.organization.id === orgId) : organization;\n  const orgPermissions = membership ? membership.permissions : membership;\n  const orgRole = membership ? membership.role : membership;\n  return {\n    userId,\n    user,\n    sessionId,\n    session,\n    organization,\n    orgId,\n    orgRole,\n    orgSlug,\n    orgPermissions,\n    actor,\n    __experimental_factorVerificationAge\n  };\n};\n\n// src/contexts/ClerkContextProvider.tsx\nfunction ClerkContextProvider(props) {\n  const { isomorphicClerkOptions, initialState, children } = props;\n  const { isomorphicClerk: clerk, loaded: clerkLoaded } = useLoadedIsomorphicClerk(isomorphicClerkOptions);\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_5__.useState({\n    client: clerk.client,\n    session: clerk.session,\n    user: clerk.user,\n    organization: clerk.organization\n  });\n  react__WEBPACK_IMPORTED_MODULE_5__.useEffect(() => {\n    return clerk.addListener((e) => setState({ ...e }));\n  }, []);\n  const derivedState = deriveState(clerkLoaded, state, initialState);\n  const clerkCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => ({ value: clerk }), [clerkLoaded]);\n  const clientCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => ({ value: state.client }), [state.client]);\n  const {\n    sessionId,\n    session,\n    userId,\n    user,\n    orgId,\n    actor,\n    organization,\n    orgRole,\n    orgSlug,\n    orgPermissions,\n    __experimental_factorVerificationAge\n  } = derivedState;\n  const authCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => {\n    const value = {\n      sessionId,\n      userId,\n      actor,\n      orgId,\n      orgRole,\n      orgSlug,\n      orgPermissions,\n      __experimental_factorVerificationAge\n    };\n    return { value };\n  }, [sessionId, userId, actor, orgId, orgRole, orgSlug, __experimental_factorVerificationAge]);\n  const sessionCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => ({ value: session }), [sessionId, session]);\n  const userCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => ({ value: user }), [userId, user]);\n  const organizationCtx = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => {\n    const value = {\n      organization\n    };\n    return { value };\n  }, [orgId, organization]);\n  return (\n    // @ts-expect-error value passed is of type IsomorphicClerk where the context expects LoadedClerk\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.IsomorphicClerkContext.Provider, { value: clerkCtx }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.ClientContext.Provider, { value: clientCtx }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.SessionContext.Provider, { value: sessionCtx }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.OrganizationProvider, { ...organizationCtx.value }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.AuthContext.Provider, { value: authCtx }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(_clerk_shared_react__WEBPACK_IMPORTED_MODULE_4__.UserContext.Provider, { value: userCtx }, children))))))\n  );\n}\nvar useLoadedIsomorphicClerk = (options) => {\n  const [loaded, setLoaded] = react__WEBPACK_IMPORTED_MODULE_5__.useState(false);\n  const isomorphicClerk = react__WEBPACK_IMPORTED_MODULE_5__.useMemo(() => IsomorphicClerk.getOrCreateInstance(options), []);\n  react__WEBPACK_IMPORTED_MODULE_5__.useEffect(() => {\n    void isomorphicClerk.__unstable__updateProps({ appearance: options.appearance });\n  }, [options.appearance]);\n  react__WEBPACK_IMPORTED_MODULE_5__.useEffect(() => {\n    void isomorphicClerk.__unstable__updateProps({ options });\n  }, [options.localization]);\n  react__WEBPACK_IMPORTED_MODULE_5__.useEffect(() => {\n    isomorphicClerk.addOnLoaded(() => setLoaded(true));\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_5__.useEffect(() => {\n    return () => {\n      IsomorphicClerk.clearInstance();\n    };\n  }, []);\n  return { isomorphicClerk, loaded };\n};\n\n// src/contexts/ClerkProvider.tsx\nfunction ClerkProviderBase(props) {\n  const { initialState, children, ...restIsomorphicClerkOptions } = props;\n  const { publishableKey = \"\", Clerk: userInitialisedClerk } = restIsomorphicClerkOptions;\n  if (!userInitialisedClerk) {\n    if (!publishableKey) {\n      _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.errorThrower.throwMissingPublishableKeyError();\n    } else if (publishableKey && !(0,_clerk_shared_keys__WEBPACK_IMPORTED_MODULE_7__.isPublishableKey)(publishableKey)) {\n      _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.errorThrower.throwInvalidPublishableKeyError({ key: publishableKey });\n    }\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_5__.createElement(\n    ClerkContextProvider,\n    {\n      initialState,\n      isomorphicClerkOptions: restIsomorphicClerkOptions\n    },\n    children\n  );\n}\nvar ClerkProvider = withMaxAllowedInstancesGuard(ClerkProviderBase, \"ClerkProvider\", _chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.multipleClerkProvidersError);\nClerkProvider.displayName = \"ClerkProvider\";\n\n// src/index.ts\n(0,_chunk_LVLBRUHJ_mjs__WEBPACK_IMPORTED_MODULE_0__.setErrorThrowerOptions)({ packageName: \"@clerk/clerk-react\" });\n(0,_clerk_shared_loadClerkJsScript__WEBPACK_IMPORTED_MODULE_2__.setClerkJsLoadingErrorPackageName)(\"@clerk/clerk-react\");\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvY2xlcmstcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRDOEI7QUFNQTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDb0Y7O0FBRXBGO0FBQ2lGO0FBQzdCO0FBQ047O0FBRTlDO0FBQzBCO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDJDQUFjO0FBQ3pCLElBQUk7QUFDSixXQUFXLDZEQUFZLE9BQU8sc0ZBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdEQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQSxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYSw2REFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW9CLHFCQUFxQixVQUFVO0FBQzlFO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTs7QUFFQTtBQUN5QztBQUNBO0FBQ3pDO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0RBQW9CLENBQUMsMkNBQWUsdUJBQXVCLHVEQUFZO0FBQ3pHLEdBQUc7QUFDSDs7QUFFQTtBQUNrRDtBQUN2Qjs7QUFFM0I7QUFDMkI7QUFDM0I7QUFDQSxnQkFBZ0IsaURBQXFCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsRUFBRSwyQ0FBZTtBQUNqQjtBQUNBO0FBQ0EsUUFBUSxnRUFBaUIsQ0FBQyxnRkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQyxRQUFRO0FBQ1IsNkJBQTZCLDRDQUE0QztBQUN6RSxRQUFRO0FBQ1IsUUFBUSxnRUFBaUIsQ0FBQyx5RUFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQsUUFBUTtBQUNSLFFBQVEsZ0VBQWlCLENBQUMseUVBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQ0FBb0M7QUFDdEU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5QixzRUFBc0U7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5QixzREFBc0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTs7QUFFQTtBQUN3RTtBQUM3QztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyQ0FBZTtBQUNqQjtBQUNBO0FBQ0EsUUFBUSxnRUFBa0IsQ0FBQywyRUFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLElBQUksMkNBQWU7QUFDbkI7QUFDQTtBQUNBLFVBQVUsZ0VBQWtCLENBQUMsZ0ZBQStCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNELGFBQWE7QUFDYixZQUFZO0FBQ1osWUFBWSxnRUFBa0I7QUFDOUI7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVLGdFQUFrQixDQUFDLHFGQUFvQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RCxVQUFVO0FBQ1YsVUFBVSxnRUFBa0IsQ0FBQyxpRkFBZ0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvQ0FBb0M7QUFDMUU7QUFDQTtBQUNBLGtDQUFrQyxvQ0FBb0M7QUFDdEU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVLHNDQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFrQztBQUM1QztBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFvQjtBQUMvQztBQUNBO0FBQ0EscUJBQXFCLDRDQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQU87QUFDN0IscUJBQXFCLHNEQUFPO0FBQzVCO0FBQ0E7QUFDQSxTQUFTLGtFQUFhO0FBQ3RCLCtCQUErQix1REFBdUQ7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFvQixDQUFDLDJDQUFlLHdCQUF3QixnREFBb0IsVUFBVSxxQkFBcUIsK0lBQStJLG9EQUFhLFdBQVcsWUFBWSxxSkFBcUosb0RBQWEsV0FBVyxZQUFZO0FBQ3RmO0FBQ0E7QUFDQSxhQUFhLDhEQUFTLElBQUksaUJBQWlCO0FBQzNDLHlCQUF5QixnREFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhLDhEQUFTLElBQUksaUJBQWlCO0FBQzNDLHlCQUF5QixnREFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkIsVUFBVTtBQUNyQyxFQUFFLGdFQUFrQixDQUFDLDZFQUE0QjtBQUNqRCx5QkFBeUIsZ0RBQW9CLENBQUMsMkNBQWU7QUFDN0Q7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQyxFQUFFLGdFQUFrQixDQUFDLDZFQUE0QjtBQUNqRCx5QkFBeUIsZ0RBQW9CLENBQUMsMkNBQWU7QUFDN0Q7QUFDQSxtQkFBbUIsOERBQVM7QUFDNUIsS0FBSyxpQkFBaUI7QUFDdEIsWUFBWSxrQ0FBa0M7QUFDOUMsMkJBQTJCLGdEQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0IsOERBQVM7QUFDM0IsS0FBSyxpQkFBaUI7QUFDdEIsWUFBWSxrQ0FBa0M7QUFDOUMsdUVBQXVFLElBQUksYUFBYTtBQUN4RixZQUFZLDBDQUEwQztBQUN0RCwyQkFBMkIsZ0RBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQTZDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQixFQUFFLGdFQUFrQixDQUFDLGlGQUFnQztBQUNyRCx5QkFBeUIsZ0RBQW9CLENBQUMsMkNBQWU7QUFDN0Q7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQyxFQUFFLGdFQUFrQixDQUFDLGtGQUFpQztBQUN0RCx5QkFBeUIsZ0RBQW9CLENBQUMsMkNBQWU7QUFDN0Q7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QixFQUFFLGdFQUFrQixDQUFDLGdGQUErQjtBQUNwRCx5QkFBeUIsZ0RBQW9CLENBQUMsMkNBQWU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0NBQXNDLDhEQUFTO0FBQy9DLEtBQUssaUJBQWlCO0FBQ3RCLDJCQUEyQixnREFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0MsRUFBRSxnRUFBa0IsQ0FBQyxxRkFBb0M7QUFDekQseUJBQXlCLGdEQUFvQixDQUFDLDJDQUFlO0FBQzdEO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0MsRUFBRSxnRUFBa0IsQ0FBQyxxRkFBb0M7QUFDekQseUJBQXlCLGdEQUFvQixDQUFDLDJDQUFlO0FBQzdEO0FBQ0EsMkJBQTJCLDhEQUFTO0FBQ3BDLEtBQUssaUJBQWlCO0FBQ3RCLFlBQVksa0NBQWtDO0FBQzlDLDJCQUEyQixnREFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCLDhEQUFTLElBQUksaUJBQWlCO0FBQ3ZELHlCQUF5QixnREFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEIsOERBQVM7QUFDckMsS0FBSyxpQkFBaUI7QUFDdEIsWUFBWSxrQ0FBa0M7QUFDOUMsdUZBQXVGLElBQUksYUFBYTtBQUN4RywyQkFBMkIsZ0RBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1Qiw4REFBUyxJQUFJLGlCQUFpQjtBQUNyRCx5QkFBeUIsZ0RBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLDhEQUFTLElBQUksaUJBQWlCO0FBQ2pELHlCQUF5QixnREFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQzJCO0FBQzNCLG1CQUFtQiw4REFBUyxJQUFJLDJCQUEyQjtBQUMzRCxVQUFVLDBHQUEwRztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixTQUFTLCtDQUFtQjtBQUM1QixDQUFDOztBQUVEO0FBQzJCO0FBQzNCLG1CQUFtQiw4REFBUyxJQUFJLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsU0FBUywrQ0FBbUI7QUFDNUIsQ0FBQzs7QUFFRDtBQUM0QjtBQUM1QixvQkFBb0IsOERBQVM7QUFDN0IsS0FBSywyQkFBMkI7QUFDaEMsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLFdBQVcsK0NBQW9CO0FBQy9CLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQzRCO0FBQzVCLCtCQUErQiw4REFBUztBQUN4QyxLQUFLLDJCQUEyQjtBQUNoQyxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQ0FBb0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsV0FBVywrQ0FBb0I7QUFDL0IsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDc0Q7QUFDMUI7O0FBRTVCO0FBQ3VHO0FBQzNFOztBQUU1QjtBQUNrRDtBQUNjO0FBQ0k7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBWTtBQUNoQixJQUFJLGlFQUFZO0FBQ2hCLElBQUksaUVBQVk7QUFDaEIsSUFBSSxpRUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpRUFBWTtBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpRUFBWTtBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpRUFBWTtBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU0saUVBQVk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0VBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0NBQXdDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpRUFBWTtBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpRUFBWTtBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpRUFBWTtBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpRUFBWTtBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0VBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVk7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpRUFBWTtBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDLElBQUksaUVBQVk7QUFDaEIsSUFBSSxpRUFBWTtBQUNoQixJQUFJLGlFQUFZO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpRUFBWTtBQUN2QjtBQUNBO0FBQ0EsV0FBVyxpRUFBWTtBQUN2QjtBQUNBO0FBQ0EsU0FBUyxnRUFBUyxPQUFPLGlFQUFZLHNDQUFzQyxpRUFBWTtBQUN2RixNQUFNLGlFQUFZO0FBQ2xCO0FBQ0EsV0FBVyxpRUFBWTtBQUN2QjtBQUNBO0FBQ0EsSUFBSSxpRUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhFQUFlLENBQUMsaUVBQVk7QUFDekM7QUFDQSxlQUFlLGlFQUFZO0FBQzNCLGFBQWEsNkRBQVksT0FBTyw4RkFBNkM7QUFDN0U7QUFDQSxXQUFXLGlFQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEVBQWUsQ0FBQyxpRUFBWTtBQUN6QztBQUNBLGVBQWUsaUVBQVk7QUFDM0IsYUFBYSw2REFBWSxPQUFPLDhGQUE2QztBQUM3RTtBQUNBLFdBQVcsaUVBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhFQUFlO0FBQzVCO0FBQ0E7QUFDQSxhQUFhLDZEQUFZLE9BQU8sOEZBQTZDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUVBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlFQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFZO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0JBQWdCLGtGQUFpQjtBQUNqQztBQUNBLDRCQUE0QixpRUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxVQUFVLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlFQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsaURBQWlEO0FBQzNELFVBQVUsOENBQThDO0FBQ3hELDRCQUE0QiwyQ0FBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBaUI7QUFDbkIsK0NBQStDLE1BQU07QUFDckQsR0FBRztBQUNIO0FBQ0EsbUJBQW1CLDBDQUFlLFVBQVUsY0FBYztBQUMxRCxvQkFBb0IsMENBQWUsVUFBVSxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtCQUFrQiwwQ0FBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0gscUJBQXFCLDBDQUFlLFVBQVUsZ0JBQWdCO0FBQzlELGtCQUFrQiwwQ0FBZSxVQUFVLGFBQWE7QUFDeEQsMEJBQTBCLDBDQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixnREFBcUIsQ0FBQyx1RUFBc0IsYUFBYSxpQkFBaUIsa0JBQWtCLGdEQUFxQixDQUFDLDhEQUFhLGFBQWEsa0JBQWtCLGtCQUFrQixnREFBcUIsQ0FBQywrREFBYyxhQUFhLG1CQUFtQixrQkFBa0IsZ0RBQXFCLENBQUMscUVBQW9CLElBQUksMEJBQTBCLGtCQUFrQixnREFBcUIsQ0FBQyw0REFBVyxhQUFhLGdCQUFnQixrQkFBa0IsZ0RBQXFCLENBQUMsNERBQVcsYUFBYSxnQkFBZ0I7QUFDbGdCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBZ0I7QUFDOUMsMEJBQTBCLDBDQUFlO0FBQ3pDLEVBQUUsNENBQWlCO0FBQ25CLG1EQUFtRCxnQ0FBZ0M7QUFDbkYsR0FBRztBQUNILEVBQUUsNENBQWlCO0FBQ25CLG1EQUFtRCxTQUFTO0FBQzVELEdBQUc7QUFDSCxFQUFFLDRDQUFpQjtBQUNuQjtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFpQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHdEQUF3RDtBQUNsRSxVQUFVLG1EQUFtRDtBQUM3RDtBQUNBO0FBQ0EsTUFBTSw2REFBWTtBQUNsQixNQUFNLDRCQUE0QixvRUFBZ0I7QUFDbEQsTUFBTSw2REFBWSxtQ0FBbUMscUJBQXFCO0FBQzFFO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRiw0RUFBMkI7QUFDaEg7O0FBRUE7QUFDQSwyRUFBc0IsR0FBRyxtQ0FBbUM7QUFDNUQsa0dBQWlDO0FBc0MvQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvY2xlcmstcmVhY3QvZGlzdC9pbmRleC5tanM/YzBkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBdXRoQ29udGV4dCxcbiAgQXV0aGVudGljYXRlV2l0aFJlZGlyZWN0Q2FsbGJhY2ssXG4gIENsZXJrTG9hZGVkLFxuICBDbGVya0xvYWRpbmcsXG4gIElzb21vcnBoaWNDbGVya0NvbnRleHQsXG4gIFByb3RlY3QsXG4gIFJlZGlyZWN0VG9DcmVhdGVPcmdhbml6YXRpb24sXG4gIFJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlLFxuICBSZWRpcmVjdFRvU2lnbkluLFxuICBSZWRpcmVjdFRvU2lnblVwLFxuICBSZWRpcmVjdFRvVXNlclByb2ZpbGUsXG4gIFNpZ25lZEluLFxuICBTaWduZWRPdXQsXG4gIGN1c3RvbUxpbmtXcm9uZ1Byb3BzLFxuICBjdXN0b21NZW51SXRlbXNJZ25vcmVkQ29tcG9uZW50LFxuICBjdXN0b21QYWdlV3JvbmdQcm9wcyxcbiAgY3VzdG9tUGFnZXNJZ25vcmVkQ29tcG9uZW50LFxuICBlcnJvclRocm93ZXIsXG4gIG11bHRpcGxlQ2hpbGRyZW5JbkJ1dHRvbkNvbXBvbmVudCxcbiAgbXVsdGlwbGVDbGVya1Byb3ZpZGVyc0Vycm9yLFxuICBvcmdhbml6YXRpb25Qcm9maWxlTGlua1JlbmRlcmVkRXJyb3IsXG4gIG9yZ2FuaXphdGlvblByb2ZpbGVQYWdlUmVuZGVyZWRFcnJvcixcbiAgc2V0RXJyb3JUaHJvd2VyT3B0aW9ucyxcbiAgdW5zdXBwb3J0ZWROb25Ccm93c2VyRG9tYWluT3JQcm94eVVybEZ1bmN0aW9uLFxuICB1c2VBdXRoLFxuICB1c2VDbGVyayxcbiAgdXNlRW1haWxMaW5rLFxuICB1c2VPcmdhbml6YXRpb24sXG4gIHVzZU9yZ2FuaXphdGlvbkxpc3QsXG4gIHVzZVNlc3Npb24sXG4gIHVzZVNlc3Npb25MaXN0LFxuICB1c2VTaWduSW4sXG4gIHVzZVNpZ25VcCxcbiAgdXNlVXNlcixcbiAgdXNlckJ1dHRvbklnbm9yZWRDb21wb25lbnQsXG4gIHVzZXJCdXR0b25NZW51QWN0aW9uUmVuZGVyZWRFcnJvcixcbiAgdXNlckJ1dHRvbk1lbnVJdGVtTGlua1dyb25nUHJvcHMsXG4gIHVzZXJCdXR0b25NZW51SXRlbXNBY3Rpb25Xcm9uZ3NQcm9wcyxcbiAgdXNlckJ1dHRvbk1lbnVJdGVtc1JlbmRlcmVkRXJyb3IsXG4gIHVzZXJCdXR0b25NZW51TGlua1JlbmRlcmVkRXJyb3IsXG4gIHVzZXJQcm9maWxlTGlua1JlbmRlcmVkRXJyb3IsXG4gIHVzZXJQcm9maWxlUGFnZVJlbmRlcmVkRXJyb3IsXG4gIHdpdGhDbGVya1xufSBmcm9tIFwiLi9jaHVuay1MVkxCUlVISi5tanNcIjtcbmltcG9ydCB7XG4gIF9fcHJpdmF0ZUFkZCxcbiAgX19wcml2YXRlR2V0LFxuICBfX3ByaXZhdGVNZXRob2QsXG4gIF9fcHJpdmF0ZVNldFxufSBmcm9tIFwiLi9jaHVuay1PQU5XUVIzQi5tanNcIjtcblxuLy8gc3JjL3BvbHlmaWxscy50c1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXdpbmRvdy5nbG9iYWwpIHtcbiAgd2luZG93Lmdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBnbG9iYWw7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgc2V0Q2xlcmtKc0xvYWRpbmdFcnJvclBhY2thZ2VOYW1lIH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvbG9hZENsZXJrSnNTY3JpcHRcIjtcblxuLy8gc3JjL2NvbXBvbmVudHMvdWlDb21wb25lbnRzLnRzeFxuaW1wb3J0IHsgbG9nRXJyb3JJbkRldk1vZGUgYXMgbG9nRXJyb3JJbkRldk1vZGUzLCB3aXRob3V0IH0gZnJvbSBcIkBjbGVyay9zaGFyZWRcIjtcbmltcG9ydCB7IGlzRGVlcGx5RXF1YWwgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9yZWFjdFwiO1xuaW1wb3J0IFJlYWN0NywgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91dGlscy9jaGlsZHJlblV0aWxzLnRzeFxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xudmFyIGFzc2VydFNpbmdsZUNoaWxkID0gKGNoaWxkcmVuKSA9PiAobmFtZSkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlcnJvclRocm93ZXIudGhyb3cobXVsdGlwbGVDaGlsZHJlbkluQnV0dG9uQ29tcG9uZW50KG5hbWUpKTtcbiAgfVxufTtcbnZhciBub3JtYWxpemVXaXRoRGVmYXVsdFZhbHVlID0gKGNoaWxkcmVuLCBkZWZhdWx0VGV4dCkgPT4ge1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4gPSBkZWZhdWx0VGV4dDtcbiAgfVxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiKSB7XG4gICAgY2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBudWxsLCBjaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufTtcbnZhciBzYWZlRXhlY3V0ZSA9IChjYikgPT4gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNiKC4uLmFyZ3MpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvaXNDb25zdHJ1Y3Rvci50c1xuZnVuY3Rpb24gaXNDb25zdHJ1Y3RvcihmKSB7XG4gIHJldHVybiB0eXBlb2YgZiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvdXRpbHMvdXNlTWF4QWxsb3dlZEluc3RhbmNlc0d1YXJkLnRzeFxuaW1wb3J0IFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbnZhciBjb3VudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gdXNlTWF4QWxsb3dlZEluc3RhbmNlc0d1YXJkKG5hbWUsIGVycm9yLCBtYXhDb3VudCA9IDEpIHtcbiAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY291bnQgPSBjb3VudHMuZ2V0KG5hbWUpIHx8IDA7XG4gICAgaWYgKGNvdW50ID09IG1heENvdW50KSB7XG4gICAgICByZXR1cm4gZXJyb3JUaHJvd2VyLnRocm93KGVycm9yKTtcbiAgICB9XG4gICAgY291bnRzLnNldChuYW1lLCBjb3VudCArIDEpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb3VudHMuc2V0KG5hbWUsIChjb3VudHMuZ2V0KG5hbWUpIHx8IDEpIC0gMSk7XG4gICAgfTtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gd2l0aE1heEFsbG93ZWRJbnN0YW5jZXNHdWFyZChXcmFwcGVkQ29tcG9uZW50LCBuYW1lLCBlcnJvcikge1xuICBjb25zdCBkaXNwbGF5TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8IG5hbWUgfHwgXCJDb21wb25lbnRcIjtcbiAgY29uc3QgSG9jID0gKHByb3BzKSA9PiB7XG4gICAgdXNlTWF4QWxsb3dlZEluc3RhbmNlc0d1YXJkKG5hbWUsIGVycm9yKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIHsgLi4ucHJvcHMgfSk7XG4gIH07XG4gIEhvYy5kaXNwbGF5TmFtZSA9IGB3aXRoTWF4QWxsb3dlZEluc3RhbmNlc0d1YXJkKCR7ZGlzcGxheU5hbWV9KWA7XG4gIHJldHVybiBIb2M7XG59XG5cbi8vIHNyYy91dGlscy91c2VDdXN0b21FbGVtZW50UG9ydGFsLnRzeFxuaW1wb3J0IFJlYWN0MywgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xudmFyIHVzZUN1c3RvbUVsZW1lbnRQb3J0YWwgPSAoZWxlbWVudHMpID0+IHtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gQXJyYXkoZWxlbWVudHMubGVuZ3RoKS5maWxsKG51bGwpO1xuICBjb25zdCBbbm9kZXMsIHNldE5vZGVzXSA9IHVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gIHJldHVybiBlbGVtZW50cy5tYXAoKGVsLCBpbmRleCkgPT4gKHtcbiAgICBpZDogZWwuaWQsXG4gICAgbW91bnQ6IChub2RlKSA9PiBzZXROb2RlcygocHJldlN0YXRlKSA9PiBwcmV2U3RhdGUubWFwKChuLCBpKSA9PiBpID09PSBpbmRleCA/IG5vZGUgOiBuKSksXG4gICAgdW5tb3VudDogKCkgPT4gc2V0Tm9kZXMoKHByZXZTdGF0ZSkgPT4gcHJldlN0YXRlLm1hcCgobiwgaSkgPT4gaSA9PT0gaW5kZXggPyBudWxsIDogbikpLFxuICAgIHBvcnRhbDogKCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlYWN0My5GcmFnbWVudCwgbnVsbCwgbm9kZXNbaW5kZXhdID8gY3JlYXRlUG9ydGFsKGVsLmNvbXBvbmVudCwgbm9kZXNbaW5kZXhdKSA6IG51bGwpXG4gIH0pKTtcbn07XG5cbi8vIHNyYy91dGlscy91c2VDdXN0b21QYWdlcy50c3hcbmltcG9ydCB7IGxvZ0Vycm9ySW5EZXZNb2RlIH0gZnJvbSBcIkBjbGVyay9zaGFyZWRcIjtcbmltcG9ydCBSZWFjdDUgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91dGlscy9jb21wb25lbnRWYWxpZGF0aW9uLnRzXG5pbXBvcnQgUmVhY3Q0IGZyb20gXCJyZWFjdFwiO1xudmFyIGlzVGhhdENvbXBvbmVudCA9ICh2LCBjb21wb25lbnQpID0+IHtcbiAgcmV0dXJuICEhdiAmJiBSZWFjdDQuaXNWYWxpZEVsZW1lbnQodikgJiYgKHYgPT0gbnVsbCA/IHZvaWQgMCA6IHYudHlwZSkgPT09IGNvbXBvbmVudDtcbn07XG5cbi8vIHNyYy91dGlscy91c2VDdXN0b21QYWdlcy50c3hcbnZhciB1c2VVc2VyUHJvZmlsZUN1c3RvbVBhZ2VzID0gKGNoaWxkcmVuKSA9PiB7XG4gIGNvbnN0IHJlb3JkZXJJdGVtc0xhYmVscyA9IFtcImFjY291bnRcIiwgXCJzZWN1cml0eVwiXTtcbiAgcmV0dXJuIHVzZUN1c3RvbVBhZ2VzKHtcbiAgICBjaGlsZHJlbixcbiAgICByZW9yZGVySXRlbXNMYWJlbHMsXG4gICAgTGlua0NvbXBvbmVudDogVXNlclByb2ZpbGVMaW5rLFxuICAgIFBhZ2VDb21wb25lbnQ6IFVzZXJQcm9maWxlUGFnZSxcbiAgICBNZW51SXRlbXNDb21wb25lbnQ6IE1lbnVJdGVtcyxcbiAgICBjb21wb25lbnROYW1lOiBcIlVzZXJQcm9maWxlXCJcbiAgfSk7XG59O1xudmFyIHVzZU9yZ2FuaXphdGlvblByb2ZpbGVDdXN0b21QYWdlcyA9IChjaGlsZHJlbikgPT4ge1xuICBjb25zdCByZW9yZGVySXRlbXNMYWJlbHMgPSBbXCJnZW5lcmFsXCIsIFwibWVtYmVyc1wiXTtcbiAgcmV0dXJuIHVzZUN1c3RvbVBhZ2VzKHtcbiAgICBjaGlsZHJlbixcbiAgICByZW9yZGVySXRlbXNMYWJlbHMsXG4gICAgTGlua0NvbXBvbmVudDogT3JnYW5pemF0aW9uUHJvZmlsZUxpbmssXG4gICAgUGFnZUNvbXBvbmVudDogT3JnYW5pemF0aW9uUHJvZmlsZVBhZ2UsXG4gICAgY29tcG9uZW50TmFtZTogXCJPcmdhbml6YXRpb25Qcm9maWxlXCJcbiAgfSk7XG59O1xudmFyIHVzZUN1c3RvbVBhZ2VzID0gKHtcbiAgY2hpbGRyZW4sXG4gIExpbmtDb21wb25lbnQsXG4gIFBhZ2VDb21wb25lbnQsXG4gIE1lbnVJdGVtc0NvbXBvbmVudCxcbiAgcmVvcmRlckl0ZW1zTGFiZWxzLFxuICBjb21wb25lbnROYW1lXG59KSA9PiB7XG4gIGNvbnN0IHZhbGlkQ2hpbGRyZW4gPSBbXTtcbiAgUmVhY3Q1LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgIGlmICghaXNUaGF0Q29tcG9uZW50KGNoaWxkLCBQYWdlQ29tcG9uZW50KSAmJiAhaXNUaGF0Q29tcG9uZW50KGNoaWxkLCBMaW5rQ29tcG9uZW50KSAmJiAhaXNUaGF0Q29tcG9uZW50KGNoaWxkLCBNZW51SXRlbXNDb21wb25lbnQpKSB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgbG9nRXJyb3JJbkRldk1vZGUoY3VzdG9tUGFnZXNJZ25vcmVkQ29tcG9uZW50KGNvbXBvbmVudE5hbWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gY2hpbGQ7XG4gICAgY29uc3QgeyBjaGlsZHJlbjogY2hpbGRyZW4yLCBsYWJlbCwgdXJsLCBsYWJlbEljb24gfSA9IHByb3BzO1xuICAgIGlmIChpc1RoYXRDb21wb25lbnQoY2hpbGQsIFBhZ2VDb21wb25lbnQpKSB7XG4gICAgICBpZiAoaXNSZW9yZGVySXRlbShwcm9wcywgcmVvcmRlckl0ZW1zTGFiZWxzKSkge1xuICAgICAgICB2YWxpZENoaWxkcmVuLnB1c2goeyBsYWJlbCB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21QYWdlKHByb3BzKSkge1xuICAgICAgICB2YWxpZENoaWxkcmVuLnB1c2goeyBsYWJlbCwgbGFiZWxJY29uLCBjaGlsZHJlbjogY2hpbGRyZW4yLCB1cmwgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dFcnJvckluRGV2TW9kZShjdXN0b21QYWdlV3JvbmdQcm9wcyhjb21wb25lbnROYW1lKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzVGhhdENvbXBvbmVudChjaGlsZCwgTGlua0NvbXBvbmVudCkpIHtcbiAgICAgIGlmIChpc0V4dGVybmFsTGluayhwcm9wcykpIHtcbiAgICAgICAgdmFsaWRDaGlsZHJlbi5wdXNoKHsgbGFiZWwsIGxhYmVsSWNvbiwgdXJsIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nRXJyb3JJbkRldk1vZGUoY3VzdG9tTGlua1dyb25nUHJvcHMoY29tcG9uZW50TmFtZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29uc3QgY3VzdG9tUGFnZUNvbnRlbnRzID0gW107XG4gIGNvbnN0IGN1c3RvbVBhZ2VMYWJlbEljb25zID0gW107XG4gIGNvbnN0IGN1c3RvbUxpbmtMYWJlbEljb25zID0gW107XG4gIHZhbGlkQ2hpbGRyZW4uZm9yRWFjaCgoY3AsIGluZGV4KSA9PiB7XG4gICAgaWYgKGlzQ3VzdG9tUGFnZShjcCkpIHtcbiAgICAgIGN1c3RvbVBhZ2VDb250ZW50cy5wdXNoKHsgY29tcG9uZW50OiBjcC5jaGlsZHJlbiwgaWQ6IGluZGV4IH0pO1xuICAgICAgY3VzdG9tUGFnZUxhYmVsSWNvbnMucHVzaCh7IGNvbXBvbmVudDogY3AubGFiZWxJY29uLCBpZDogaW5kZXggfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0V4dGVybmFsTGluayhjcCkpIHtcbiAgICAgIGN1c3RvbUxpbmtMYWJlbEljb25zLnB1c2goeyBjb21wb25lbnQ6IGNwLmxhYmVsSWNvbiwgaWQ6IGluZGV4IH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGN1c3RvbVBhZ2VDb250ZW50c1BvcnRhbHMgPSB1c2VDdXN0b21FbGVtZW50UG9ydGFsKGN1c3RvbVBhZ2VDb250ZW50cyk7XG4gIGNvbnN0IGN1c3RvbVBhZ2VMYWJlbEljb25zUG9ydGFscyA9IHVzZUN1c3RvbUVsZW1lbnRQb3J0YWwoY3VzdG9tUGFnZUxhYmVsSWNvbnMpO1xuICBjb25zdCBjdXN0b21MaW5rTGFiZWxJY29uc1BvcnRhbHMgPSB1c2VDdXN0b21FbGVtZW50UG9ydGFsKGN1c3RvbUxpbmtMYWJlbEljb25zKTtcbiAgY29uc3QgY3VzdG9tUGFnZXMgPSBbXTtcbiAgY29uc3QgY3VzdG9tUGFnZXNQb3J0YWxzID0gW107XG4gIHZhbGlkQ2hpbGRyZW4uZm9yRWFjaCgoY3AsIGluZGV4KSA9PiB7XG4gICAgaWYgKGlzUmVvcmRlckl0ZW0oY3AsIHJlb3JkZXJJdGVtc0xhYmVscykpIHtcbiAgICAgIGN1c3RvbVBhZ2VzLnB1c2goeyBsYWJlbDogY3AubGFiZWwgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVBhZ2UoY3ApKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBvcnRhbDogY29udGVudFBvcnRhbCxcbiAgICAgICAgbW91bnQsXG4gICAgICAgIHVubW91bnRcbiAgICAgIH0gPSBjdXN0b21QYWdlQ29udGVudHNQb3J0YWxzLmZpbmQoKHApID0+IHAuaWQgPT09IGluZGV4KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcG9ydGFsOiBsYWJlbFBvcnRhbCxcbiAgICAgICAgbW91bnQ6IG1vdW50SWNvbixcbiAgICAgICAgdW5tb3VudDogdW5tb3VudEljb25cbiAgICAgIH0gPSBjdXN0b21QYWdlTGFiZWxJY29uc1BvcnRhbHMuZmluZCgocCkgPT4gcC5pZCA9PT0gaW5kZXgpO1xuICAgICAgY3VzdG9tUGFnZXMucHVzaCh7IGxhYmVsOiBjcC5sYWJlbCwgdXJsOiBjcC51cmwsIG1vdW50LCB1bm1vdW50LCBtb3VudEljb24sIHVubW91bnRJY29uIH0pO1xuICAgICAgY3VzdG9tUGFnZXNQb3J0YWxzLnB1c2goY29udGVudFBvcnRhbCk7XG4gICAgICBjdXN0b21QYWdlc1BvcnRhbHMucHVzaChsYWJlbFBvcnRhbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0V4dGVybmFsTGluayhjcCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcG9ydGFsOiBsYWJlbFBvcnRhbCxcbiAgICAgICAgbW91bnQ6IG1vdW50SWNvbixcbiAgICAgICAgdW5tb3VudDogdW5tb3VudEljb25cbiAgICAgIH0gPSBjdXN0b21MaW5rTGFiZWxJY29uc1BvcnRhbHMuZmluZCgocCkgPT4gcC5pZCA9PT0gaW5kZXgpO1xuICAgICAgY3VzdG9tUGFnZXMucHVzaCh7IGxhYmVsOiBjcC5sYWJlbCwgdXJsOiBjcC51cmwsIG1vdW50SWNvbiwgdW5tb3VudEljb24gfSk7XG4gICAgICBjdXN0b21QYWdlc1BvcnRhbHMucHVzaChsYWJlbFBvcnRhbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgY3VzdG9tUGFnZXMsIGN1c3RvbVBhZ2VzUG9ydGFscyB9O1xufTtcbnZhciBpc1Jlb3JkZXJJdGVtID0gKGNoaWxkUHJvcHMsIHZhbGlkSXRlbXMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgbGFiZWwsIHVybCwgbGFiZWxJY29uIH0gPSBjaGlsZFByb3BzO1xuICByZXR1cm4gIWNoaWxkcmVuICYmICF1cmwgJiYgIWxhYmVsSWNvbiAmJiB2YWxpZEl0ZW1zLnNvbWUoKHYpID0+IHYgPT09IGxhYmVsKTtcbn07XG52YXIgaXNDdXN0b21QYWdlID0gKGNoaWxkUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgbGFiZWwsIHVybCwgbGFiZWxJY29uIH0gPSBjaGlsZFByb3BzO1xuICByZXR1cm4gISFjaGlsZHJlbiAmJiAhIXVybCAmJiAhIWxhYmVsSWNvbiAmJiAhIWxhYmVsO1xufTtcbnZhciBpc0V4dGVybmFsTGluayA9IChjaGlsZFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGxhYmVsLCB1cmwsIGxhYmVsSWNvbiB9ID0gY2hpbGRQcm9wcztcbiAgcmV0dXJuICFjaGlsZHJlbiAmJiAhIXVybCAmJiAhIWxhYmVsSWNvbiAmJiAhIWxhYmVsO1xufTtcblxuLy8gc3JjL3V0aWxzL3VzZUN1c3RvbU1lbnVJdGVtcy50c3hcbmltcG9ydCB7IGxvZ0Vycm9ySW5EZXZNb2RlIGFzIGxvZ0Vycm9ySW5EZXZNb2RlMiB9IGZyb20gXCJAY2xlcmsvc2hhcmVkXCI7XG5pbXBvcnQgUmVhY3Q2IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZVVzZXJCdXR0b25DdXN0b21NZW51SXRlbXMgPSAoY2hpbGRyZW4pID0+IHtcbiAgY29uc3QgcmVvcmRlckl0ZW1zTGFiZWxzID0gW1wibWFuYWdlQWNjb3VudFwiLCBcInNpZ25PdXRcIl07XG4gIHJldHVybiB1c2VDdXN0b21NZW51SXRlbXMoe1xuICAgIGNoaWxkcmVuLFxuICAgIHJlb3JkZXJJdGVtc0xhYmVscyxcbiAgICBNZW51SXRlbXNDb21wb25lbnQ6IE1lbnVJdGVtcyxcbiAgICBNZW51QWN0aW9uQ29tcG9uZW50OiBNZW51QWN0aW9uLFxuICAgIE1lbnVMaW5rQ29tcG9uZW50OiBNZW51TGluayxcbiAgICBVc2VyUHJvZmlsZUxpbmtDb21wb25lbnQ6IFVzZXJQcm9maWxlTGluayxcbiAgICBVc2VyUHJvZmlsZVBhZ2VDb21wb25lbnQ6IFVzZXJQcm9maWxlUGFnZVxuICB9KTtcbn07XG52YXIgdXNlQ3VzdG9tTWVudUl0ZW1zID0gKHtcbiAgY2hpbGRyZW4sXG4gIE1lbnVJdGVtc0NvbXBvbmVudCxcbiAgTWVudUFjdGlvbkNvbXBvbmVudCxcbiAgTWVudUxpbmtDb21wb25lbnQsXG4gIFVzZXJQcm9maWxlTGlua0NvbXBvbmVudCxcbiAgVXNlclByb2ZpbGVQYWdlQ29tcG9uZW50LFxuICByZW9yZGVySXRlbXNMYWJlbHNcbn0pID0+IHtcbiAgY29uc3QgdmFsaWRDaGlsZHJlbiA9IFtdO1xuICBjb25zdCBjdXN0b21NZW51SXRlbXMgPSBbXTtcbiAgY29uc3QgY3VzdG9tTWVudUl0ZW1zUG9ydGFscyA9IFtdO1xuICBSZWFjdDYuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgaWYgKCFpc1RoYXRDb21wb25lbnQoY2hpbGQsIE1lbnVJdGVtc0NvbXBvbmVudCkgJiYgIWlzVGhhdENvbXBvbmVudChjaGlsZCwgVXNlclByb2ZpbGVMaW5rQ29tcG9uZW50KSAmJiAhaXNUaGF0Q29tcG9uZW50KGNoaWxkLCBVc2VyUHJvZmlsZVBhZ2VDb21wb25lbnQpKSB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgbG9nRXJyb3JJbkRldk1vZGUyKHVzZXJCdXR0b25JZ25vcmVkQ29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzVGhhdENvbXBvbmVudChjaGlsZCwgVXNlclByb2ZpbGVMaW5rQ29tcG9uZW50KSB8fCBpc1RoYXRDb21wb25lbnQoY2hpbGQsIFVzZXJQcm9maWxlUGFnZUNvbXBvbmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gY2hpbGQ7XG4gICAgUmVhY3Q2LkNoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIChjaGlsZDIpID0+IHtcbiAgICAgIGlmICghaXNUaGF0Q29tcG9uZW50KGNoaWxkMiwgTWVudUFjdGlvbkNvbXBvbmVudCkgJiYgIWlzVGhhdENvbXBvbmVudChjaGlsZDIsIE1lbnVMaW5rQ29tcG9uZW50KSkge1xuICAgICAgICBpZiAoY2hpbGQyKSB7XG4gICAgICAgICAgbG9nRXJyb3JJbkRldk1vZGUyKGN1c3RvbU1lbnVJdGVtc0lnbm9yZWRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcHJvcHM6IHByb3BzMiB9ID0gY2hpbGQyO1xuICAgICAgY29uc3QgeyBsYWJlbCwgbGFiZWxJY29uLCBocmVmLCBvbkNsaWNrLCBvcGVuIH0gPSBwcm9wczI7XG4gICAgICBpZiAoaXNUaGF0Q29tcG9uZW50KGNoaWxkMiwgTWVudUFjdGlvbkNvbXBvbmVudCkpIHtcbiAgICAgICAgaWYgKGlzUmVvcmRlckl0ZW0yKHByb3BzMiwgcmVvcmRlckl0ZW1zTGFiZWxzKSkge1xuICAgICAgICAgIHZhbGlkQ2hpbGRyZW4ucHVzaCh7IGxhYmVsIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tTWVudUl0ZW0ocHJvcHMyKSkge1xuICAgICAgICAgIGNvbnN0IGJhc2VJdGVtID0ge1xuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBsYWJlbEljb25cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChvbkNsaWNrICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhbGlkQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgIC4uLmJhc2VJdGVtLFxuICAgICAgICAgICAgICBvbkNsaWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wZW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdmFsaWRDaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgLi4uYmFzZUl0ZW0sXG4gICAgICAgICAgICAgIG9wZW46IG9wZW4uc3RhcnRzV2l0aChcIi9cIikgPyBvcGVuIDogYC8ke29wZW59YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9ySW5EZXZNb2RlMihcIkN1c3RvbSBtZW51IGl0ZW0gbXVzdCBoYXZlIGVpdGhlciBvbkNsaWNrIG9yIG9wZW4gcHJvcGVydHlcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ0Vycm9ySW5EZXZNb2RlMih1c2VyQnV0dG9uTWVudUl0ZW1zQWN0aW9uV3JvbmdzUHJvcHMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzVGhhdENvbXBvbmVudChjaGlsZDIsIE1lbnVMaW5rQ29tcG9uZW50KSkge1xuICAgICAgICBpZiAoaXNFeHRlcm5hbExpbmsyKHByb3BzMikpIHtcbiAgICAgICAgICB2YWxpZENoaWxkcmVuLnB1c2goeyBsYWJlbCwgbGFiZWxJY29uLCBocmVmIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ0Vycm9ySW5EZXZNb2RlMih1c2VyQnV0dG9uTWVudUl0ZW1MaW5rV3JvbmdQcm9wcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBjdXN0b21NZW51SXRlbUxhYmVsSWNvbnMgPSBbXTtcbiAgY29uc3QgY3VzdG9tTGlua0xhYmVsSWNvbnMgPSBbXTtcbiAgdmFsaWRDaGlsZHJlbi5mb3JFYWNoKChtaSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaXNDdXN0b21NZW51SXRlbShtaSkpIHtcbiAgICAgIGN1c3RvbU1lbnVJdGVtTGFiZWxJY29ucy5wdXNoKHsgY29tcG9uZW50OiBtaS5sYWJlbEljb24sIGlkOiBpbmRleCB9KTtcbiAgICB9XG4gICAgaWYgKGlzRXh0ZXJuYWxMaW5rMihtaSkpIHtcbiAgICAgIGN1c3RvbUxpbmtMYWJlbEljb25zLnB1c2goeyBjb21wb25lbnQ6IG1pLmxhYmVsSWNvbiwgaWQ6IGluZGV4IH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGN1c3RvbU1lbnVJdGVtTGFiZWxJY29uc1BvcnRhbHMgPSB1c2VDdXN0b21FbGVtZW50UG9ydGFsKGN1c3RvbU1lbnVJdGVtTGFiZWxJY29ucyk7XG4gIGNvbnN0IGN1c3RvbUxpbmtMYWJlbEljb25zUG9ydGFscyA9IHVzZUN1c3RvbUVsZW1lbnRQb3J0YWwoY3VzdG9tTGlua0xhYmVsSWNvbnMpO1xuICB2YWxpZENoaWxkcmVuLmZvckVhY2goKG1pLCBpbmRleCkgPT4ge1xuICAgIGlmIChpc1Jlb3JkZXJJdGVtMihtaSwgcmVvcmRlckl0ZW1zTGFiZWxzKSkge1xuICAgICAgY3VzdG9tTWVudUl0ZW1zLnB1c2goe1xuICAgICAgICBsYWJlbDogbWkubGFiZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNDdXN0b21NZW51SXRlbShtaSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcG9ydGFsOiBpY29uUG9ydGFsLFxuICAgICAgICBtb3VudDogbW91bnRJY29uLFxuICAgICAgICB1bm1vdW50OiB1bm1vdW50SWNvblxuICAgICAgfSA9IGN1c3RvbU1lbnVJdGVtTGFiZWxJY29uc1BvcnRhbHMuZmluZCgocCkgPT4gcC5pZCA9PT0gaW5kZXgpO1xuICAgICAgY29uc3QgbWVudUl0ZW0gPSB7XG4gICAgICAgIGxhYmVsOiBtaS5sYWJlbCxcbiAgICAgICAgbW91bnRJY29uLFxuICAgICAgICB1bm1vdW50SWNvblxuICAgICAgfTtcbiAgICAgIGlmIChcIm9uQ2xpY2tcIiBpbiBtaSkge1xuICAgICAgICBtZW51SXRlbS5vbkNsaWNrID0gbWkub25DbGljaztcbiAgICAgIH0gZWxzZSBpZiAoXCJvcGVuXCIgaW4gbWkpIHtcbiAgICAgICAgbWVudUl0ZW0ub3BlbiA9IG1pLm9wZW47XG4gICAgICB9XG4gICAgICBjdXN0b21NZW51SXRlbXMucHVzaChtZW51SXRlbSk7XG4gICAgICBjdXN0b21NZW51SXRlbXNQb3J0YWxzLnB1c2goaWNvblBvcnRhbCk7XG4gICAgfVxuICAgIGlmIChpc0V4dGVybmFsTGluazIobWkpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBvcnRhbDogaWNvblBvcnRhbCxcbiAgICAgICAgbW91bnQ6IG1vdW50SWNvbixcbiAgICAgICAgdW5tb3VudDogdW5tb3VudEljb25cbiAgICAgIH0gPSBjdXN0b21MaW5rTGFiZWxJY29uc1BvcnRhbHMuZmluZCgocCkgPT4gcC5pZCA9PT0gaW5kZXgpO1xuICAgICAgY3VzdG9tTWVudUl0ZW1zLnB1c2goe1xuICAgICAgICBsYWJlbDogbWkubGFiZWwsXG4gICAgICAgIGhyZWY6IG1pLmhyZWYsXG4gICAgICAgIG1vdW50SWNvbixcbiAgICAgICAgdW5tb3VudEljb25cbiAgICAgIH0pO1xuICAgICAgY3VzdG9tTWVudUl0ZW1zUG9ydGFscy5wdXNoKGljb25Qb3J0YWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IGN1c3RvbU1lbnVJdGVtcywgY3VzdG9tTWVudUl0ZW1zUG9ydGFscyB9O1xufTtcbnZhciBpc1Jlb3JkZXJJdGVtMiA9IChjaGlsZFByb3BzLCB2YWxpZEl0ZW1zKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGxhYmVsLCBvbkNsaWNrLCBsYWJlbEljb24gfSA9IGNoaWxkUHJvcHM7XG4gIHJldHVybiAhY2hpbGRyZW4gJiYgIW9uQ2xpY2sgJiYgIWxhYmVsSWNvbiAmJiB2YWxpZEl0ZW1zLnNvbWUoKHYpID0+IHYgPT09IGxhYmVsKTtcbn07XG52YXIgaXNDdXN0b21NZW51SXRlbSA9IChjaGlsZFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgbGFiZWwsIGxhYmVsSWNvbiwgb25DbGljaywgb3BlbiB9ID0gY2hpbGRQcm9wcztcbiAgcmV0dXJuICEhbGFiZWxJY29uICYmICEhbGFiZWwgJiYgKHR5cGVvZiBvbkNsaWNrID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIG9wZW4gPT09IFwic3RyaW5nXCIpO1xufTtcbnZhciBpc0V4dGVybmFsTGluazIgPSAoY2hpbGRQcm9wcykgPT4ge1xuICBjb25zdCB7IGxhYmVsLCBocmVmLCBsYWJlbEljb24gfSA9IGNoaWxkUHJvcHM7XG4gIHJldHVybiAhIWhyZWYgJiYgISFsYWJlbEljb24gJiYgISFsYWJlbDtcbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL3VpQ29tcG9uZW50cy50c3hcbnZhciBpc01vdW50UHJvcHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIFwibW91bnRcIiBpbiBwcm9wcztcbn07XG52YXIgaXNPcGVuUHJvcHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIFwib3BlblwiIGluIHByb3BzO1xufTtcbnZhciBQb3J0YWwgPSBjbGFzcyBleHRlbmRzIFJlYWN0Ny5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBvcnRhbFJlZiA9IFJlYWN0Ny5jcmVhdGVSZWYoKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoX3ByZXZQcm9wcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBpZiAoIWlzTW91bnRQcm9wcyhfcHJldlByb3BzKSB8fCAhaXNNb3VudFByb3BzKHRoaXMucHJvcHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXZQcm9wcyA9IHdpdGhvdXQoX3ByZXZQcm9wcy5wcm9wcywgXCJjdXN0b21QYWdlc1wiLCBcImN1c3RvbU1lbnVJdGVtc1wiLCBcImNoaWxkcmVuXCIpO1xuICAgIGNvbnN0IG5ld1Byb3BzID0gd2l0aG91dCh0aGlzLnByb3BzLnByb3BzLCBcImN1c3RvbVBhZ2VzXCIsIFwiY3VzdG9tTWVudUl0ZW1zXCIsIFwiY2hpbGRyZW5cIik7XG4gICAgY29uc3QgY3VzdG9tUGFnZXNDaGFuZ2VkID0gKChfYSA9IHByZXZQcm9wcy5jdXN0b21QYWdlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09ICgoX2IgPSBuZXdQcm9wcy5jdXN0b21QYWdlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmxlbmd0aCk7XG4gICAgY29uc3QgY3VzdG9tTWVudUl0ZW1zQ2hhbmdlZCA9ICgoX2MgPSBwcmV2UHJvcHMuY3VzdG9tTWVudUl0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX2MubGVuZ3RoKSAhPT0gKChfZCA9IG5ld1Byb3BzLmN1c3RvbU1lbnVJdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmxlbmd0aCk7XG4gICAgaWYgKCFpc0RlZXBseUVxdWFsKHByZXZQcm9wcywgbmV3UHJvcHMpIHx8IGN1c3RvbVBhZ2VzQ2hhbmdlZCB8fCBjdXN0b21NZW51SXRlbXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnByb3BzLnVwZGF0ZVByb3BzKHsgbm9kZTogdGhpcy5wb3J0YWxSZWYuY3VycmVudCwgcHJvcHM6IHRoaXMucHJvcHMucHJvcHMgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnBvcnRhbFJlZi5jdXJyZW50KSB7XG4gICAgICBpZiAoaXNNb3VudFByb3BzKHRoaXMucHJvcHMpKSB7XG4gICAgICAgIHRoaXMucHJvcHMubW91bnQodGhpcy5wb3J0YWxSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5wcm9wcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPcGVuUHJvcHModGhpcy5wcm9wcykpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vcGVuKHRoaXMucHJvcHMucHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5wb3J0YWxSZWYuY3VycmVudCkge1xuICAgICAgaWYgKGlzTW91bnRQcm9wcyh0aGlzLnByb3BzKSkge1xuICAgICAgICB0aGlzLnByb3BzLnVubW91bnQodGhpcy5wb3J0YWxSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPcGVuUHJvcHModGhpcy5wcm9wcykpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMucG9ydGFsUmVmIH0pLCBpc01vdW50UHJvcHModGhpcy5wcm9wcykgJiYgKChfYiA9IChfYSA9IHRoaXMucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jdXN0b21QYWdlc1BvcnRhbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5tYXAoKHBvcnRhbCwgaW5kZXgpID0+IGNyZWF0ZUVsZW1lbnQocG9ydGFsLCB7IGtleTogaW5kZXggfSkpKSwgaXNNb3VudFByb3BzKHRoaXMucHJvcHMpICYmICgoX2QgPSAoX2MgPSB0aGlzLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY3VzdG9tTWVudUl0ZW1zUG9ydGFscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLm1hcCgocG9ydGFsLCBpbmRleCkgPT4gY3JlYXRlRWxlbWVudChwb3J0YWwsIHsga2V5OiBpbmRleCB9KSkpKTtcbiAgfVxufTtcbnZhciBTaWduSW4gPSB3aXRoQ2xlcmsoKHsgY2xlcmssIC4uLnByb3BzIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICBQb3J0YWwsXG4gICAge1xuICAgICAgbW91bnQ6IGNsZXJrLm1vdW50U2lnbkluLFxuICAgICAgdW5tb3VudDogY2xlcmsudW5tb3VudFNpZ25JbixcbiAgICAgIHVwZGF0ZVByb3BzOiBjbGVyay5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyxcbiAgICAgIHByb3BzXG4gICAgfVxuICApO1xufSwgXCJTaWduSW5cIik7XG52YXIgU2lnblVwID0gd2l0aENsZXJrKCh7IGNsZXJrLCAuLi5wcm9wcyB9KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoXG4gICAgUG9ydGFsLFxuICAgIHtcbiAgICAgIG1vdW50OiBjbGVyay5tb3VudFNpZ25VcCxcbiAgICAgIHVubW91bnQ6IGNsZXJrLnVubW91bnRTaWduVXAsXG4gICAgICB1cGRhdGVQcm9wczogY2xlcmsuX191bnN0YWJsZV9fdXBkYXRlUHJvcHMsXG4gICAgICBwcm9wc1xuICAgIH1cbiAgKTtcbn0sIFwiU2lnblVwXCIpO1xuZnVuY3Rpb24gVXNlclByb2ZpbGVQYWdlKHsgY2hpbGRyZW4gfSkge1xuICBsb2dFcnJvckluRGV2TW9kZTModXNlclByb2ZpbGVQYWdlUmVuZGVyZWRFcnJvcik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBVc2VyUHJvZmlsZUxpbmsoeyBjaGlsZHJlbiB9KSB7XG4gIGxvZ0Vycm9ySW5EZXZNb2RlMyh1c2VyUHJvZmlsZUxpbmtSZW5kZXJlZEVycm9yKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbnZhciBfVXNlclByb2ZpbGUgPSB3aXRoQ2xlcmsoXG4gICh7IGNsZXJrLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgeyBjdXN0b21QYWdlcywgY3VzdG9tUGFnZXNQb3J0YWxzIH0gPSB1c2VVc2VyUHJvZmlsZUN1c3RvbVBhZ2VzKHByb3BzLmNoaWxkcmVuKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFxuICAgICAgUG9ydGFsLFxuICAgICAge1xuICAgICAgICBtb3VudDogY2xlcmsubW91bnRVc2VyUHJvZmlsZSxcbiAgICAgICAgdW5tb3VudDogY2xlcmsudW5tb3VudFVzZXJQcm9maWxlLFxuICAgICAgICB1cGRhdGVQcm9wczogY2xlcmsuX191bnN0YWJsZV9fdXBkYXRlUHJvcHMsXG4gICAgICAgIHByb3BzOiB7IC4uLnByb3BzLCBjdXN0b21QYWdlcyB9LFxuICAgICAgICBjdXN0b21QYWdlc1BvcnRhbHNcbiAgICAgIH1cbiAgICApO1xuICB9LFxuICBcIlVzZXJQcm9maWxlXCJcbik7XG52YXIgVXNlclByb2ZpbGUgPSBPYmplY3QuYXNzaWduKF9Vc2VyUHJvZmlsZSwge1xuICBQYWdlOiBVc2VyUHJvZmlsZVBhZ2UsXG4gIExpbms6IFVzZXJQcm9maWxlTGlua1xufSk7XG52YXIgX1VzZXJCdXR0b24gPSB3aXRoQ2xlcmsoXG4gICh7IGNsZXJrLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgeyBjdXN0b21QYWdlcywgY3VzdG9tUGFnZXNQb3J0YWxzIH0gPSB1c2VVc2VyUHJvZmlsZUN1c3RvbVBhZ2VzKHByb3BzLmNoaWxkcmVuKTtcbiAgICBjb25zdCB1c2VyUHJvZmlsZVByb3BzID0gT2JqZWN0LmFzc2lnbihwcm9wcy51c2VyUHJvZmlsZVByb3BzIHx8IHt9LCB7IGN1c3RvbVBhZ2VzIH0pO1xuICAgIGNvbnN0IHsgY3VzdG9tTWVudUl0ZW1zLCBjdXN0b21NZW51SXRlbXNQb3J0YWxzIH0gPSB1c2VVc2VyQnV0dG9uQ3VzdG9tTWVudUl0ZW1zKHByb3BzLmNoaWxkcmVuKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFxuICAgICAgUG9ydGFsLFxuICAgICAge1xuICAgICAgICBtb3VudDogY2xlcmsubW91bnRVc2VyQnV0dG9uLFxuICAgICAgICB1bm1vdW50OiBjbGVyay51bm1vdW50VXNlckJ1dHRvbixcbiAgICAgICAgdXBkYXRlUHJvcHM6IGNsZXJrLl9fdW5zdGFibGVfX3VwZGF0ZVByb3BzLFxuICAgICAgICBwcm9wczogeyAuLi5wcm9wcywgdXNlclByb2ZpbGVQcm9wcywgY3VzdG9tTWVudUl0ZW1zIH0sXG4gICAgICAgIGN1c3RvbVBhZ2VzUG9ydGFscyxcbiAgICAgICAgY3VzdG9tTWVudUl0ZW1zUG9ydGFsc1xuICAgICAgfVxuICAgICk7XG4gIH0sXG4gIFwiVXNlckJ1dHRvblwiXG4pO1xuZnVuY3Rpb24gTWVudUl0ZW1zKHsgY2hpbGRyZW4gfSkge1xuICBsb2dFcnJvckluRGV2TW9kZTModXNlckJ1dHRvbk1lbnVJdGVtc1JlbmRlcmVkRXJyb3IpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlYWN0Ny5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gTWVudUFjdGlvbih7IGNoaWxkcmVuIH0pIHtcbiAgbG9nRXJyb3JJbkRldk1vZGUzKHVzZXJCdXR0b25NZW51QWN0aW9uUmVuZGVyZWRFcnJvcik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUmVhY3Q3LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBNZW51TGluayh7IGNoaWxkcmVuIH0pIHtcbiAgbG9nRXJyb3JJbkRldk1vZGUzKHVzZXJCdXR0b25NZW51TGlua1JlbmRlcmVkRXJyb3IpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlYWN0Ny5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxudmFyIFVzZXJCdXR0b24gPSBPYmplY3QuYXNzaWduKF9Vc2VyQnV0dG9uLCB7XG4gIFVzZXJQcm9maWxlUGFnZSxcbiAgVXNlclByb2ZpbGVMaW5rLFxuICBNZW51SXRlbXMsXG4gIEFjdGlvbjogTWVudUFjdGlvbixcbiAgTGluazogTWVudUxpbmtcbn0pO1xudmFyIF9fZXhwZXJpbWVudGFsX1VzZXJWZXJpZmljYXRpb24gPSB3aXRoQ2xlcmsoXG4gICh7IGNsZXJrLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICAgIFBvcnRhbCxcbiAgICAgIHtcbiAgICAgICAgbW91bnQ6IGNsZXJrLl9fZXhwZXJpbWVudGFsX21vdW50VXNlclZlcmlmaWNhdGlvbixcbiAgICAgICAgdW5tb3VudDogY2xlcmsuX19leHBlcmltZW50YWxfdW5tb3VudFVzZXJWZXJpZmljYXRpb24sXG4gICAgICAgIHVwZGF0ZVByb3BzOiBjbGVyay5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyxcbiAgICAgICAgcHJvcHNcbiAgICAgIH1cbiAgICApO1xuICB9LFxuICBcIl9fZXhwZXJpbWVudGFsX1VzZXJWZXJpZmljYXRpb25cIlxuKTtcbmZ1bmN0aW9uIE9yZ2FuaXphdGlvblByb2ZpbGVQYWdlKHsgY2hpbGRyZW4gfSkge1xuICBsb2dFcnJvckluRGV2TW9kZTMob3JnYW5pemF0aW9uUHJvZmlsZVBhZ2VSZW5kZXJlZEVycm9yKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIE9yZ2FuaXphdGlvblByb2ZpbGVMaW5rKHsgY2hpbGRyZW4gfSkge1xuICBsb2dFcnJvckluRGV2TW9kZTMob3JnYW5pemF0aW9uUHJvZmlsZUxpbmtSZW5kZXJlZEVycm9yKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZWFjdDcuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbnZhciBfT3JnYW5pemF0aW9uUHJvZmlsZSA9IHdpdGhDbGVyayhcbiAgKHsgY2xlcmssIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCB7IGN1c3RvbVBhZ2VzLCBjdXN0b21QYWdlc1BvcnRhbHMgfSA9IHVzZU9yZ2FuaXphdGlvblByb2ZpbGVDdXN0b21QYWdlcyhwcm9wcy5jaGlsZHJlbik7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICAgIFBvcnRhbCxcbiAgICAgIHtcbiAgICAgICAgbW91bnQ6IGNsZXJrLm1vdW50T3JnYW5pemF0aW9uUHJvZmlsZSxcbiAgICAgICAgdW5tb3VudDogY2xlcmsudW5tb3VudE9yZ2FuaXphdGlvblByb2ZpbGUsXG4gICAgICAgIHVwZGF0ZVByb3BzOiBjbGVyay5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyxcbiAgICAgICAgcHJvcHM6IHsgLi4ucHJvcHMsIGN1c3RvbVBhZ2VzIH0sXG4gICAgICAgIGN1c3RvbVBhZ2VzUG9ydGFsc1xuICAgICAgfVxuICAgICk7XG4gIH0sXG4gIFwiT3JnYW5pemF0aW9uUHJvZmlsZVwiXG4pO1xudmFyIE9yZ2FuaXphdGlvblByb2ZpbGUgPSBPYmplY3QuYXNzaWduKF9Pcmdhbml6YXRpb25Qcm9maWxlLCB7XG4gIFBhZ2U6IE9yZ2FuaXphdGlvblByb2ZpbGVQYWdlLFxuICBMaW5rOiBPcmdhbml6YXRpb25Qcm9maWxlTGlua1xufSk7XG52YXIgQ3JlYXRlT3JnYW5pemF0aW9uID0gd2l0aENsZXJrKCh7IGNsZXJrLCAuLi5wcm9wcyB9KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoXG4gICAgUG9ydGFsLFxuICAgIHtcbiAgICAgIG1vdW50OiBjbGVyay5tb3VudENyZWF0ZU9yZ2FuaXphdGlvbixcbiAgICAgIHVubW91bnQ6IGNsZXJrLnVubW91bnRDcmVhdGVPcmdhbml6YXRpb24sXG4gICAgICB1cGRhdGVQcm9wczogY2xlcmsuX191bnN0YWJsZV9fdXBkYXRlUHJvcHMsXG4gICAgICBwcm9wc1xuICAgIH1cbiAgKTtcbn0sIFwiQ3JlYXRlT3JnYW5pemF0aW9uXCIpO1xudmFyIF9Pcmdhbml6YXRpb25Td2l0Y2hlciA9IHdpdGhDbGVyayhcbiAgKHsgY2xlcmssIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCB7IGN1c3RvbVBhZ2VzLCBjdXN0b21QYWdlc1BvcnRhbHMgfSA9IHVzZU9yZ2FuaXphdGlvblByb2ZpbGVDdXN0b21QYWdlcyhwcm9wcy5jaGlsZHJlbik7XG4gICAgY29uc3Qgb3JnYW5pemF0aW9uUHJvZmlsZVByb3BzID0gT2JqZWN0LmFzc2lnbihwcm9wcy5vcmdhbml6YXRpb25Qcm9maWxlUHJvcHMgfHwge30sIHsgY3VzdG9tUGFnZXMgfSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICAgIFBvcnRhbCxcbiAgICAgIHtcbiAgICAgICAgbW91bnQ6IGNsZXJrLm1vdW50T3JnYW5pemF0aW9uU3dpdGNoZXIsXG4gICAgICAgIHVubW91bnQ6IGNsZXJrLnVubW91bnRPcmdhbml6YXRpb25Td2l0Y2hlcixcbiAgICAgICAgdXBkYXRlUHJvcHM6IGNsZXJrLl9fdW5zdGFibGVfX3VwZGF0ZVByb3BzLFxuICAgICAgICBwcm9wczogeyAuLi5wcm9wcywgb3JnYW5pemF0aW9uUHJvZmlsZVByb3BzIH0sXG4gICAgICAgIGN1c3RvbVBhZ2VzUG9ydGFsc1xuICAgICAgfVxuICAgICk7XG4gIH0sXG4gIFwiT3JnYW5pemF0aW9uU3dpdGNoZXJcIlxuKTtcbnZhciBPcmdhbml6YXRpb25Td2l0Y2hlciA9IE9iamVjdC5hc3NpZ24oX09yZ2FuaXphdGlvblN3aXRjaGVyLCB7XG4gIE9yZ2FuaXphdGlvblByb2ZpbGVQYWdlLFxuICBPcmdhbml6YXRpb25Qcm9maWxlTGlua1xufSk7XG52YXIgT3JnYW5pemF0aW9uTGlzdCA9IHdpdGhDbGVyaygoeyBjbGVyaywgLi4ucHJvcHMgfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFxuICAgIFBvcnRhbCxcbiAgICB7XG4gICAgICBtb3VudDogY2xlcmsubW91bnRPcmdhbml6YXRpb25MaXN0LFxuICAgICAgdW5tb3VudDogY2xlcmsudW5tb3VudE9yZ2FuaXphdGlvbkxpc3QsXG4gICAgICB1cGRhdGVQcm9wczogY2xlcmsuX191bnN0YWJsZV9fdXBkYXRlUHJvcHMsXG4gICAgICBwcm9wc1xuICAgIH1cbiAgKTtcbn0sIFwiT3JnYW5pemF0aW9uTGlzdFwiKTtcbnZhciBHb29nbGVPbmVUYXAgPSB3aXRoQ2xlcmsoKHsgY2xlcmssIC4uLnByb3BzIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcbiAgICBQb3J0YWwsXG4gICAge1xuICAgICAgb3BlbjogY2xlcmsub3Blbkdvb2dsZU9uZVRhcCxcbiAgICAgIGNsb3NlOiBjbGVyay5jbG9zZUdvb2dsZU9uZVRhcCxcbiAgICAgIHByb3BzXG4gICAgfVxuICApO1xufSwgXCJHb29nbGVPbmVUYXBcIik7XG5cbi8vIHNyYy9jb21wb25lbnRzL1NpZ25JbkJ1dHRvbi50c3hcbmltcG9ydCBSZWFjdDggZnJvbSBcInJlYWN0XCI7XG52YXIgU2lnbkluQnV0dG9uID0gd2l0aENsZXJrKCh7IGNsZXJrLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkgPT4ge1xuICBjb25zdCB7IHNpZ25VcEZhbGxiYWNrUmVkaXJlY3RVcmwsIGZvcmNlUmVkaXJlY3RVcmwsIGZhbGxiYWNrUmVkaXJlY3RVcmwsIHNpZ25VcEZvcmNlUmVkaXJlY3RVcmwsIG1vZGUsIC4uLnJlc3QgfSA9IHByb3BzO1xuICBjaGlsZHJlbiA9IG5vcm1hbGl6ZVdpdGhEZWZhdWx0VmFsdWUoY2hpbGRyZW4sIFwiU2lnbiBpblwiKTtcbiAgY29uc3QgY2hpbGQgPSBhc3NlcnRTaW5nbGVDaGlsZChjaGlsZHJlbikoXCJTaWduSW5CdXR0b25cIik7XG4gIGNvbnN0IGNsaWNrSGFuZGxlciA9ICgpID0+IHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgZm9yY2VSZWRpcmVjdFVybCxcbiAgICAgIGZhbGxiYWNrUmVkaXJlY3RVcmwsXG4gICAgICBzaWduVXBGYWxsYmFja1JlZGlyZWN0VXJsLFxuICAgICAgc2lnblVwRm9yY2VSZWRpcmVjdFVybFxuICAgIH07XG4gICAgaWYgKG1vZGUgPT09IFwibW9kYWxcIikge1xuICAgICAgcmV0dXJuIGNsZXJrLm9wZW5TaWduSW4ob3B0cyk7XG4gICAgfVxuICAgIHJldHVybiBjbGVyay5yZWRpcmVjdFRvU2lnbkluKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBzaWduSW5GYWxsYmFja1JlZGlyZWN0VXJsOiBmYWxsYmFja1JlZGlyZWN0VXJsLFxuICAgICAgc2lnbkluRm9yY2VSZWRpcmVjdFVybDogZm9yY2VSZWRpcmVjdFVybFxuICAgIH0pO1xuICB9O1xuICBjb25zdCB3cmFwcGVkQ2hpbGRDbGlja0hhbmRsZXIgPSBhc3luYyAoZSkgPT4ge1xuICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgXCJwcm9wc1wiIGluIGNoaWxkKSB7XG4gICAgICBhd2FpdCBzYWZlRXhlY3V0ZShjaGlsZC5wcm9wcy5vbkNsaWNrKShlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWNrSGFuZGxlcigpO1xuICB9O1xuICBjb25zdCBjaGlsZFByb3BzID0geyAuLi5yZXN0LCBvbkNsaWNrOiB3cmFwcGVkQ2hpbGRDbGlja0hhbmRsZXIgfTtcbiAgcmV0dXJuIFJlYWN0OC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpO1xufSwgXCJTaWduSW5CdXR0b25cIik7XG5cbi8vIHNyYy9jb21wb25lbnRzL1NpZ25VcEJ1dHRvbi50c3hcbmltcG9ydCBSZWFjdDkgZnJvbSBcInJlYWN0XCI7XG52YXIgU2lnblVwQnV0dG9uID0gd2l0aENsZXJrKCh7IGNsZXJrLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkgPT4ge1xuICBjb25zdCB7XG4gICAgZmFsbGJhY2tSZWRpcmVjdFVybCxcbiAgICBmb3JjZVJlZGlyZWN0VXJsLFxuICAgIHNpZ25JbkZhbGxiYWNrUmVkaXJlY3RVcmwsXG4gICAgc2lnbkluRm9yY2VSZWRpcmVjdFVybCxcbiAgICBtb2RlLFxuICAgIHVuc2FmZU1ldGFkYXRhLFxuICAgIC4uLnJlc3RcbiAgfSA9IHByb3BzO1xuICBjaGlsZHJlbiA9IG5vcm1hbGl6ZVdpdGhEZWZhdWx0VmFsdWUoY2hpbGRyZW4sIFwiU2lnbiB1cFwiKTtcbiAgY29uc3QgY2hpbGQgPSBhc3NlcnRTaW5nbGVDaGlsZChjaGlsZHJlbikoXCJTaWduVXBCdXR0b25cIik7XG4gIGNvbnN0IGNsaWNrSGFuZGxlciA9ICgpID0+IHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgZmFsbGJhY2tSZWRpcmVjdFVybCxcbiAgICAgIGZvcmNlUmVkaXJlY3RVcmwsXG4gICAgICBzaWduSW5GYWxsYmFja1JlZGlyZWN0VXJsLFxuICAgICAgc2lnbkluRm9yY2VSZWRpcmVjdFVybCxcbiAgICAgIHVuc2FmZU1ldGFkYXRhXG4gICAgfTtcbiAgICBpZiAobW9kZSA9PT0gXCJtb2RhbFwiKSB7XG4gICAgICByZXR1cm4gY2xlcmsub3BlblNpZ25VcChvcHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsZXJrLnJlZGlyZWN0VG9TaWduVXAoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIHNpZ25VcEZhbGxiYWNrUmVkaXJlY3RVcmw6IGZhbGxiYWNrUmVkaXJlY3RVcmwsXG4gICAgICBzaWduVXBGb3JjZVJlZGlyZWN0VXJsOiBmb3JjZVJlZGlyZWN0VXJsXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHdyYXBwZWRDaGlsZENsaWNrSGFuZGxlciA9IGFzeW5jIChlKSA9PiB7XG4gICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIiAmJiBcInByb3BzXCIgaW4gY2hpbGQpIHtcbiAgICAgIGF3YWl0IHNhZmVFeGVjdXRlKGNoaWxkLnByb3BzLm9uQ2xpY2spKGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xpY2tIYW5kbGVyKCk7XG4gIH07XG4gIGNvbnN0IGNoaWxkUHJvcHMgPSB7IC4uLnJlc3QsIG9uQ2xpY2s6IHdyYXBwZWRDaGlsZENsaWNrSGFuZGxlciB9O1xuICByZXR1cm4gUmVhY3Q5LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG59LCBcIlNpZ25VcEJ1dHRvblwiKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvU2lnbk91dEJ1dHRvbi50c3hcbmltcG9ydCBSZWFjdDEwIGZyb20gXCJyZWFjdFwiO1xudmFyIFNpZ25PdXRCdXR0b24gPSB3aXRoQ2xlcmsoXG4gICh7IGNsZXJrLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgcmVkaXJlY3RVcmwgPSBcIi9cIiwgc2lnbk91dE9wdGlvbnMsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplV2l0aERlZmF1bHRWYWx1ZShjaGlsZHJlbiwgXCJTaWduIG91dFwiKTtcbiAgICBjb25zdCBjaGlsZCA9IGFzc2VydFNpbmdsZUNoaWxkKGNoaWxkcmVuKShcIlNpZ25PdXRCdXR0b25cIik7XG4gICAgY29uc3QgY2xpY2tIYW5kbGVyID0gKCkgPT4gY2xlcmsuc2lnbk91dCh7IHJlZGlyZWN0VXJsIH0pO1xuICAgIGNvbnN0IHdyYXBwZWRDaGlsZENsaWNrSGFuZGxlciA9IGFzeW5jIChlKSA9PiB7XG4gICAgICBhd2FpdCBzYWZlRXhlY3V0ZShjaGlsZC5wcm9wcy5vbkNsaWNrKShlKTtcbiAgICAgIHJldHVybiBjbGlja0hhbmRsZXIoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7IC4uLnJlc3QsIG9uQ2xpY2s6IHdyYXBwZWRDaGlsZENsaWNrSGFuZGxlciB9O1xuICAgIHJldHVybiBSZWFjdDEwLmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG4gIH0sXG4gIFwiU2lnbk91dEJ1dHRvblwiXG4pO1xuXG4vLyBzcmMvY29tcG9uZW50cy9TaWduSW5XaXRoTWV0YW1hc2tCdXR0b24udHN4XG5pbXBvcnQgUmVhY3QxMSBmcm9tIFwicmVhY3RcIjtcbnZhciBTaWduSW5XaXRoTWV0YW1hc2tCdXR0b24gPSB3aXRoQ2xlcmsoXG4gICh7IGNsZXJrLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgcmVkaXJlY3RVcmwsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplV2l0aERlZmF1bHRWYWx1ZShjaGlsZHJlbiwgXCJTaWduIGluIHdpdGggTWV0YW1hc2tcIik7XG4gICAgY29uc3QgY2hpbGQgPSBhc3NlcnRTaW5nbGVDaGlsZChjaGlsZHJlbikoXCJTaWduSW5XaXRoTWV0YW1hc2tCdXR0b25cIik7XG4gICAgY29uc3QgY2xpY2tIYW5kbGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgYXN5bmMgZnVuY3Rpb24gYXV0aGVudGljYXRlKCkge1xuICAgICAgICBhd2FpdCBjbGVyay5hdXRoZW50aWNhdGVXaXRoTWV0YW1hc2soeyByZWRpcmVjdFVybDogcmVkaXJlY3RVcmwgfHwgdm9pZCAwIH0pO1xuICAgICAgfVxuICAgICAgdm9pZCBhdXRoZW50aWNhdGUoKTtcbiAgICB9O1xuICAgIGNvbnN0IHdyYXBwZWRDaGlsZENsaWNrSGFuZGxlciA9IGFzeW5jIChlKSA9PiB7XG4gICAgICBhd2FpdCBzYWZlRXhlY3V0ZShjaGlsZC5wcm9wcy5vbkNsaWNrKShlKTtcbiAgICAgIHJldHVybiBjbGlja0hhbmRsZXIoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7IC4uLnJlc3QsIG9uQ2xpY2s6IHdyYXBwZWRDaGlsZENsaWNrSGFuZGxlciB9O1xuICAgIHJldHVybiBSZWFjdDExLmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG4gIH0sXG4gIFwiU2lnbkluV2l0aE1ldGFtYXNrXCJcbik7XG5cbi8vIHNyYy9jb250ZXh0cy9DbGVya1Byb3ZpZGVyLnRzeFxuaW1wb3J0IHsgaXNQdWJsaXNoYWJsZUtleSB9IGZyb20gXCJAY2xlcmsvc2hhcmVkL2tleXNcIjtcbmltcG9ydCBSZWFjdDEzIGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY29udGV4dHMvQ2xlcmtDb250ZXh0UHJvdmlkZXIudHN4XG5pbXBvcnQgeyBDbGllbnRDb250ZXh0LCBPcmdhbml6YXRpb25Qcm92aWRlciwgU2Vzc2lvbkNvbnRleHQsIFVzZXJDb250ZXh0IH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvcmVhY3RcIjtcbmltcG9ydCBSZWFjdDEyIGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvaXNvbW9ycGhpY0NsZXJrLnRzXG5pbXBvcnQgeyBpbkJyb3dzZXIgfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9icm93c2VyXCI7XG5pbXBvcnQgeyBoYW5kbGVWYWx1ZU9yRm4gfSBmcm9tIFwiQGNsZXJrL3NoYXJlZC9oYW5kbGVWYWx1ZU9yRm5cIjtcbmltcG9ydCB7IGxvYWRDbGVya0pzU2NyaXB0IH0gZnJvbSBcIkBjbGVyay9zaGFyZWQvbG9hZENsZXJrSnNTY3JpcHRcIjtcbnZhciBTREtfTUVUQURBVEEgPSB7XG4gIG5hbWU6IFwiQGNsZXJrL2NsZXJrLXJlYWN0XCIsXG4gIHZlcnNpb246IFwiNS45LjRcIixcbiAgZW52aXJvbm1lbnQ6IHByb2Nlc3MuZW52Lk5PREVfRU5WXG59O1xudmFyIF9sb2FkZWQsIF9kb21haW4sIF9wcm94eVVybCwgX3B1Ymxpc2hhYmxlS2V5LCBfaW5zdGFuY2UsIF9Jc29tb3JwaGljQ2xlcmtfaW5zdGFuY2VzLCB3YWl0Rm9yQ2xlcmtKU19mbjtcbnZhciBfSXNvbW9ycGhpY0NsZXJrID0gY2xhc3MgX0lzb21vcnBoaWNDbGVyayB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX0lzb21vcnBoaWNDbGVya19pbnN0YW5jZXMpO1xuICAgIHRoaXMuY2xlcmtqcyA9IG51bGw7XG4gICAgdGhpcy5wcmVvcGVuT25lVGFwID0gbnVsbDtcbiAgICB0aGlzLnByZW9wZW5Vc2VyVmVyaWZpY2F0aW9uID0gbnVsbDtcbiAgICB0aGlzLnByZW9wZW5TaWduSW4gPSBudWxsO1xuICAgIHRoaXMucHJlb3BlblNpZ25VcCA9IG51bGw7XG4gICAgdGhpcy5wcmVvcGVuVXNlclByb2ZpbGUgPSBudWxsO1xuICAgIHRoaXMucHJlb3Blbk9yZ2FuaXphdGlvblByb2ZpbGUgPSBudWxsO1xuICAgIHRoaXMucHJlb3BlbkNyZWF0ZU9yZ2FuaXphdGlvbiA9IG51bGw7XG4gICAgdGhpcy5wcmVtb3VudFNpZ25Jbk5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50U2lnblVwTm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJlbW91bnRVc2VyUHJvZmlsZU5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50VXNlckJ1dHRvbk5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50T3JnYW5pemF0aW9uUHJvZmlsZU5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50Q3JlYXRlT3JnYW5pemF0aW9uTm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJlbW91bnRPcmdhbml6YXRpb25Td2l0Y2hlck5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50T3JnYW5pemF0aW9uTGlzdE5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50VXNlclZlcmlmaWNhdGlvbk5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8vIEEgc2VwYXJhdGUgTWFwIG9mIGBhZGRMaXN0ZW5lcmAgbWV0aG9kIGNhbGxzIHRvIGhhbmRsZSBtdWx0aXBsZSBsaXN0ZW5lcnMuXG4gICAgdGhpcy5wcmVtb3VudEFkZExpc3RlbmVyQ2FsbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubG9hZGVkTGlzdGVuZXJzID0gW107XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9sb2FkZWQsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2RvbWFpbik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wcm94eVVybCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wdWJsaXNoYWJsZUtleSk7XG4gICAgdGhpcy5idWlsZFNpZ25JblVybCA9IChvcHRzKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJ1aWxkU2lnbkluVXJsKG9wdHMpKSB8fCBcIlwiO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImJ1aWxkU2lnbkluVXJsXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYnVpbGRTaWduVXBVcmwgPSAob3B0cykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5idWlsZFNpZ25VcFVybChvcHRzKSkgfHwgXCJcIjtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJidWlsZFNpZ25VcFVybFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmJ1aWxkQWZ0ZXJTaWduSW5VcmwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJ1aWxkQWZ0ZXJTaWduSW5VcmwoKSkgfHwgXCJcIjtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJidWlsZEFmdGVyU2lnbkluVXJsXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYnVpbGRBZnRlclNpZ25VcFVybCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYnVpbGRBZnRlclNpZ25VcFVybCgpKSB8fCBcIlwiO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImJ1aWxkQWZ0ZXJTaWduVXBVcmxcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5idWlsZEFmdGVyU2lnbk91dFVybCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYnVpbGRBZnRlclNpZ25PdXRVcmwoKSkgfHwgXCJcIjtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJidWlsZEFmdGVyU2lnbk91dFVybFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmJ1aWxkQWZ0ZXJNdWx0aVNlc3Npb25TaW5nbGVTaWduT3V0VXJsID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5idWlsZEFmdGVyTXVsdGlTZXNzaW9uU2luZ2xlU2lnbk91dFVybCgpKSB8fCBcIlwiO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImJ1aWxkQWZ0ZXJNdWx0aVNlc3Npb25TaW5nbGVTaWduT3V0VXJsXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYnVpbGRVc2VyUHJvZmlsZVVybCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYnVpbGRVc2VyUHJvZmlsZVVybCgpKSB8fCBcIlwiO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImJ1aWxkVXNlclByb2ZpbGVVcmxcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5idWlsZENyZWF0ZU9yZ2FuaXphdGlvblVybCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYnVpbGRDcmVhdGVPcmdhbml6YXRpb25VcmwoKSkgfHwgXCJcIjtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJidWlsZENyZWF0ZU9yZ2FuaXphdGlvblVybFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmJ1aWxkT3JnYW5pemF0aW9uUHJvZmlsZVVybCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYnVpbGRPcmdhbml6YXRpb25Qcm9maWxlVXJsKCkpIHx8IFwiXCI7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwiYnVpbGRPcmdhbml6YXRpb25Qcm9maWxlVXJsXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYnVpbGRVcmxXaXRoQXV0aCA9ICh0bykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5idWlsZFVybFdpdGhBdXRoKHRvKSkgfHwgXCJcIjtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJidWlsZFVybFdpdGhBdXRoXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVW5hdXRoZW50aWNhdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmhhbmRsZVVuYXV0aGVudGljYXRlZCgpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHZvaWQgY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJoYW5kbGVVbmF1dGhlbnRpY2F0ZWRcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRPbkxvYWRlZCA9IChjYikgPT4ge1xuICAgICAgdGhpcy5sb2FkZWRMaXN0ZW5lcnMucHVzaChjYik7XG4gICAgICBpZiAodGhpcy5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5lbWl0TG9hZGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmVtaXRMb2FkZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxvYWRlZExpc3RlbmVycy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICB0aGlzLmxvYWRlZExpc3RlbmVycyA9IFtdO1xuICAgIH07XG4gICAgdGhpcy5oeWRyYXRlQ2xlcmtKUyA9IChjbGVya2pzKSA9PiB7XG4gICAgICBpZiAoIWNsZXJranMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGh5ZHJhdGUgbGF0ZXN0IENsZXJrIEpTXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVya2pzID0gY2xlcmtqcztcbiAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICB0aGlzLnByZW1vdW50QWRkTGlzdGVuZXJDYWxscy5mb3JFYWNoKChsaXN0ZW5lckhhbmRsZXJzLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsaXN0ZW5lckhhbmRsZXJzLm5hdGl2ZVVuc3Vic2NyaWJlID0gY2xlcmtqcy5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnByZW9wZW5TaWduSW4gIT09IG51bGwpIHtcbiAgICAgICAgY2xlcmtqcy5vcGVuU2lnbkluKHRoaXMucHJlb3BlblNpZ25Jbik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmVvcGVuU2lnblVwICE9PSBudWxsKSB7XG4gICAgICAgIGNsZXJranMub3BlblNpZ25VcCh0aGlzLnByZW9wZW5TaWduVXApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJlb3BlblVzZXJQcm9maWxlICE9PSBudWxsKSB7XG4gICAgICAgIGNsZXJranMub3BlblVzZXJQcm9maWxlKHRoaXMucHJlb3BlblVzZXJQcm9maWxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByZW9wZW5Vc2VyVmVyaWZpY2F0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGNsZXJranMuX19leHBlcmltZW50YWxfb3BlblVzZXJWZXJpZmljYXRpb24odGhpcy5wcmVvcGVuVXNlclZlcmlmaWNhdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmVvcGVuT25lVGFwICE9PSBudWxsKSB7XG4gICAgICAgIGNsZXJranMub3Blbkdvb2dsZU9uZVRhcCh0aGlzLnByZW9wZW5PbmVUYXApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJlb3Blbk9yZ2FuaXphdGlvblByb2ZpbGUgIT09IG51bGwpIHtcbiAgICAgICAgY2xlcmtqcy5vcGVuT3JnYW5pemF0aW9uUHJvZmlsZSh0aGlzLnByZW9wZW5Pcmdhbml6YXRpb25Qcm9maWxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByZW9wZW5DcmVhdGVPcmdhbml6YXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgY2xlcmtqcy5vcGVuQ3JlYXRlT3JnYW5pemF0aW9uKHRoaXMucHJlb3BlbkNyZWF0ZU9yZ2FuaXphdGlvbik7XG4gICAgICB9XG4gICAgICB0aGlzLnByZW1vdW50U2lnbkluTm9kZXMuZm9yRWFjaCgocHJvcHMsIG5vZGUpID0+IHtcbiAgICAgICAgY2xlcmtqcy5tb3VudFNpZ25Jbihub2RlLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJlbW91bnRTaWduVXBOb2Rlcy5mb3JFYWNoKChwcm9wcywgbm9kZSkgPT4ge1xuICAgICAgICBjbGVya2pzLm1vdW50U2lnblVwKG5vZGUsIHByb3BzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcmVtb3VudFVzZXJQcm9maWxlTm9kZXMuZm9yRWFjaCgocHJvcHMsIG5vZGUpID0+IHtcbiAgICAgICAgY2xlcmtqcy5tb3VudFVzZXJQcm9maWxlKG5vZGUsIHByb3BzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcmVtb3VudFVzZXJWZXJpZmljYXRpb25Ob2Rlcy5mb3JFYWNoKChwcm9wcywgbm9kZSkgPT4ge1xuICAgICAgICBjbGVya2pzLl9fZXhwZXJpbWVudGFsX21vdW50VXNlclZlcmlmaWNhdGlvbihub2RlLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJlbW91bnRVc2VyQnV0dG9uTm9kZXMuZm9yRWFjaCgocHJvcHMsIG5vZGUpID0+IHtcbiAgICAgICAgY2xlcmtqcy5tb3VudFVzZXJCdXR0b24obm9kZSwgcHJvcHMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnByZW1vdW50T3JnYW5pemF0aW9uTGlzdE5vZGVzLmZvckVhY2goKHByb3BzLCBub2RlKSA9PiB7XG4gICAgICAgIGNsZXJranMubW91bnRPcmdhbml6YXRpb25MaXN0KG5vZGUsIHByb3BzKTtcbiAgICAgIH0pO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9sb2FkZWQsIHRydWUpO1xuICAgICAgdGhpcy5lbWl0TG9hZGVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5jbGVya2pzO1xuICAgIH07XG4gICAgdGhpcy5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyA9IGFzeW5jIChwcm9wcykgPT4ge1xuICAgICAgY29uc3QgY2xlcmtqcyA9IGF3YWl0IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfSXNvbW9ycGhpY0NsZXJrX2luc3RhbmNlcywgd2FpdEZvckNsZXJrSlNfZm4pLmNhbGwodGhpcyk7XG4gICAgICBpZiAoY2xlcmtqcyAmJiBcIl9fdW5zdGFibGVfX3VwZGF0ZVByb3BzXCIgaW4gY2xlcmtqcykge1xuICAgICAgICByZXR1cm4gY2xlcmtqcy5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyhwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBgc2V0QWN0aXZlYCBjYW4gYmUgdXNlZCB0byBzZXQgdGhlIGFjdGl2ZSBzZXNzaW9uIGFuZC9vciBvcmdhbml6YXRpb24uXG4gICAgICovXG4gICAgdGhpcy5zZXRBY3RpdmUgPSAoeyBzZXNzaW9uLCBvcmdhbml6YXRpb24sIGJlZm9yZUVtaXQgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVya2pzLnNldEFjdGl2ZSh7IHNlc3Npb24sIG9yZ2FuaXphdGlvbiwgYmVmb3JlRW1pdCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuU2lnbkluID0gKHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMub3BlblNpZ25Jbihwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5TaWduSW4gPSBwcm9wcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY2xvc2VTaWduSW4gPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMuY2xvc2VTaWduSW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlb3BlblNpZ25JbiA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9fZXhwZXJpbWVudGFsX29wZW5Vc2VyVmVyaWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMuX19leHBlcmltZW50YWxfb3BlblVzZXJWZXJpZmljYXRpb24ocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuVXNlclZlcmlmaWNhdGlvbiA9IHByb3BzO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fX2V4cGVyaW1lbnRhbF9jbG9zZVVzZXJWZXJpZmljYXRpb24gPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMuX19leHBlcmltZW50YWxfY2xvc2VVc2VyVmVyaWZpY2F0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5Vc2VyVmVyaWZpY2F0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub3Blbkdvb2dsZU9uZVRhcCA9IChwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLm9wZW5Hb29nbGVPbmVUYXAocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuT25lVGFwID0gcHJvcHM7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmNsb3NlR29vZ2xlT25lVGFwID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLmNsb3NlR29vZ2xlT25lVGFwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5PbmVUYXAgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuVXNlclByb2ZpbGUgPSAocHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5vcGVuVXNlclByb2ZpbGUocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuVXNlclByb2ZpbGUgPSBwcm9wcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY2xvc2VVc2VyUHJvZmlsZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5jbG9zZVVzZXJQcm9maWxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5Vc2VyUHJvZmlsZSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9wZW5Pcmdhbml6YXRpb25Qcm9maWxlID0gKHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMub3Blbk9yZ2FuaXphdGlvblByb2ZpbGUocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuT3JnYW5pemF0aW9uUHJvZmlsZSA9IHByb3BzO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbG9zZU9yZ2FuaXphdGlvblByb2ZpbGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMuY2xvc2VPcmdhbml6YXRpb25Qcm9maWxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5Pcmdhbml6YXRpb25Qcm9maWxlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub3BlbkNyZWF0ZU9yZ2FuaXphdGlvbiA9IChwcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLm9wZW5DcmVhdGVPcmdhbml6YXRpb24ocHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVvcGVuQ3JlYXRlT3JnYW5pemF0aW9uID0gcHJvcHM7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmNsb3NlQ3JlYXRlT3JnYW5pemF0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLmNsb3NlQ3JlYXRlT3JnYW5pemF0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5DcmVhdGVPcmdhbml6YXRpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcGVuU2lnblVwID0gKHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMub3BlblNpZ25VcChwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW9wZW5TaWduVXAgPSBwcm9wcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY2xvc2VTaWduVXAgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMuY2xvc2VTaWduVXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlb3BlblNpZ25VcCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vdW50U2lnbkluID0gKG5vZGUsIHByb3BzKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMubW91bnRTaWduSW4obm9kZSwgcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFNpZ25Jbk5vZGVzLnNldChub2RlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVubW91bnRTaWduSW4gPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLnVubW91bnRTaWduSW4obm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50U2lnbkluTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fX2V4cGVyaW1lbnRhbF9tb3VudFVzZXJWZXJpZmljYXRpb24gPSAobm9kZSwgcHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5fX2V4cGVyaW1lbnRhbF9tb3VudFVzZXJWZXJpZmljYXRpb24obm9kZSwgcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFVzZXJWZXJpZmljYXRpb25Ob2Rlcy5zZXQobm9kZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fX2V4cGVyaW1lbnRhbF91bm1vdW50VXNlclZlcmlmaWNhdGlvbiA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMuX19leHBlcmltZW50YWxfdW5tb3VudFVzZXJWZXJpZmljYXRpb24obm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50VXNlclZlcmlmaWNhdGlvbk5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubW91bnRTaWduVXAgPSAobm9kZSwgcHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5tb3VudFNpZ25VcChub2RlLCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50U2lnblVwTm9kZXMuc2V0KG5vZGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudW5tb3VudFNpZ25VcCA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudFNpZ25VcChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRTaWduVXBOb2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vdW50VXNlclByb2ZpbGUgPSAobm9kZSwgcHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5tb3VudFVzZXJQcm9maWxlKG5vZGUsIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRVc2VyUHJvZmlsZU5vZGVzLnNldChub2RlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVubW91bnRVc2VyUHJvZmlsZSA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudFVzZXJQcm9maWxlKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFVzZXJQcm9maWxlTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tb3VudE9yZ2FuaXphdGlvblByb2ZpbGUgPSAobm9kZSwgcHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5tb3VudE9yZ2FuaXphdGlvblByb2ZpbGUobm9kZSwgcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE9yZ2FuaXphdGlvblByb2ZpbGVOb2Rlcy5zZXQobm9kZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51bm1vdW50T3JnYW5pemF0aW9uUHJvZmlsZSA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudE9yZ2FuaXphdGlvblByb2ZpbGUobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50T3JnYW5pemF0aW9uUHJvZmlsZU5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubW91bnRDcmVhdGVPcmdhbml6YXRpb24gPSAobm9kZSwgcHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5tb3VudENyZWF0ZU9yZ2FuaXphdGlvbihub2RlLCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50Q3JlYXRlT3JnYW5pemF0aW9uTm9kZXMuc2V0KG5vZGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudW5tb3VudENyZWF0ZU9yZ2FuaXphdGlvbiA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudENyZWF0ZU9yZ2FuaXphdGlvbihub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRDcmVhdGVPcmdhbml6YXRpb25Ob2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vdW50T3JnYW5pemF0aW9uU3dpdGNoZXIgPSAobm9kZSwgcHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5tb3VudE9yZ2FuaXphdGlvblN3aXRjaGVyKG5vZGUsIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRPcmdhbml6YXRpb25Td2l0Y2hlck5vZGVzLnNldChub2RlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVubW91bnRPcmdhbml6YXRpb25Td2l0Y2hlciA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudE9yZ2FuaXphdGlvblN3aXRjaGVyKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE9yZ2FuaXphdGlvblN3aXRjaGVyTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tb3VudE9yZ2FuaXphdGlvbkxpc3QgPSAobm9kZSwgcHJvcHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHRoaXMuY2xlcmtqcy5tb3VudE9yZ2FuaXphdGlvbkxpc3Qobm9kZSwgcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE9yZ2FuaXphdGlvbkxpc3ROb2Rlcy5zZXQobm9kZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51bm1vdW50T3JnYW5pemF0aW9uTGlzdCA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB0aGlzLmNsZXJranMudW5tb3VudE9yZ2FuaXphdGlvbkxpc3Qobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50T3JnYW5pemF0aW9uTGlzdE5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubW91bnRVc2VyQnV0dG9uID0gKG5vZGUsIHVzZXJCdXR0b25Qcm9wcykgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLm1vdW50VXNlckJ1dHRvbihub2RlLCB1c2VyQnV0dG9uUHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFVzZXJCdXR0b25Ob2Rlcy5zZXQobm9kZSwgdXNlckJ1dHRvblByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudW5tb3VudFVzZXJCdXR0b24gPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgdGhpcy5jbGVya2pzLnVubW91bnRVc2VyQnV0dG9uKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudFVzZXJCdXR0b25Ob2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZExpc3RlbmVyID0gKGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbGVya2pzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsZXJranMuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGNvbnN0IGxpc3RlbmVySGFuZGxlcnMgPSB0aGlzLnByZW1vdW50QWRkTGlzdGVuZXJDYWxscy5nZXQobGlzdGVuZXIpO1xuICAgICAgICAgIGlmIChsaXN0ZW5lckhhbmRsZXJzKSB7XG4gICAgICAgICAgICAoX2EgPSBsaXN0ZW5lckhhbmRsZXJzLm5hdGl2ZVVuc3Vic2NyaWJlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChsaXN0ZW5lckhhbmRsZXJzKTtcbiAgICAgICAgICAgIHRoaXMucHJlbW91bnRBZGRMaXN0ZW5lckNhbGxzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByZW1vdW50QWRkTGlzdGVuZXJDYWxscy5zZXQobGlzdGVuZXIsIHsgdW5zdWJzY3JpYmUsIG5hdGl2ZVVuc3Vic2NyaWJlOiB2b2lkIDAgfSk7XG4gICAgICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubmF2aWdhdGUgPSAodG8pID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYXZpZ2F0ZSh0byk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgdm9pZCBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcIm5hdmlnYXRlXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVkaXJlY3RXaXRoQXV0aCA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVkaXJlY3RXaXRoQXV0aCguLi5hcmdzKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJyZWRpcmVjdFdpdGhBdXRoXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZWRpcmVjdFRvU2lnbkluID0gYXN5bmMgKG9wdHMpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvU2lnbkluKG9wdHMpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcInJlZGlyZWN0VG9TaWduSW5cIiwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZGlyZWN0VG9TaWduVXAgPSBhc3luYyAob3B0cykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG9TaWduVXAob3B0cyk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwicmVkaXJlY3RUb1NpZ25VcFwiLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVkaXJlY3RUb1VzZXJQcm9maWxlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG9Vc2VyUHJvZmlsZSgpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcInJlZGlyZWN0VG9Vc2VyUHJvZmlsZVwiLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVkaXJlY3RUb0FmdGVyU2lnblVwID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG9BZnRlclNpZ25VcCgpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcInJlZGlyZWN0VG9BZnRlclNpZ25VcFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZGlyZWN0VG9BZnRlclNpZ25JbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvQWZ0ZXJTaWduSW4oKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcInJlZGlyZWN0VG9BZnRlclNpZ25JblwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZGlyZWN0VG9BZnRlclNpZ25PdXQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVkaXJlY3RUb0FmdGVyU2lnbk91dCgpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwicmVkaXJlY3RUb0FmdGVyU2lnbk91dFwiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlKCk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwicmVkaXJlY3RUb09yZ2FuaXphdGlvblByb2ZpbGVcIiwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZGlyZWN0VG9DcmVhdGVPcmdhbml6YXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVkaXJlY3RUb0NyZWF0ZU9yZ2FuaXphdGlvbigpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcInJlZGlyZWN0VG9DcmVhdGVPcmdhbml6YXRpb25cIiwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVJlZGlyZWN0Q2FsbGJhY2sgPSAocGFyYW1zKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuIChfYTIgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGFuZGxlUmVkaXJlY3RDYWxsYmFjayhwYXJhbXMpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHZvaWQgKChfYSA9IGNhbGxiYWNrKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJoYW5kbGVSZWRpcmVjdENhbGxiYWNrXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlR29vZ2xlT25lVGFwQ2FsbGJhY2sgPSAoc2lnbkluT3JVcCwgcGFyYW1zKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuIChfYTIgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGFuZGxlR29vZ2xlT25lVGFwQ2FsbGJhY2soc2lnbkluT3JVcCwgcGFyYW1zKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICB2b2lkICgoX2EgPSBjYWxsYmFjaygpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2F0Y2goKCkgPT4ge1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwiaGFuZGxlR29vZ2xlT25lVGFwQ2FsbGJhY2tcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVFbWFpbExpbmtWZXJpZmljYXRpb24gPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGFuZGxlRW1haWxMaW5rVmVyaWZpY2F0aW9uKHBhcmFtcyk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwiaGFuZGxlRW1haWxMaW5rVmVyaWZpY2F0aW9uXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYXV0aGVudGljYXRlV2l0aE1ldGFtYXNrID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmF1dGhlbnRpY2F0ZVdpdGhNZXRhbWFzayhwYXJhbXMpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImF1dGhlbnRpY2F0ZVdpdGhNZXRhbWFza1wiLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZVdpdGhDb2luYmFzZVdhbGxldCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdXRoZW50aWNhdGVXaXRoQ29pbmJhc2VXYWxsZXQocGFyYW1zKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJhdXRoZW50aWNhdGVXaXRoQ29pbmJhc2VXYWxsZXRcIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hdXRoZW50aWNhdGVXaXRoV2ViMyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdXRoZW50aWNhdGVXaXRoV2ViMyhwYXJhbXMpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNsZXJranMgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9sb2FkZWQpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmVtb3VudE1ldGhvZENhbGxzLnNldChcImF1dGhlbnRpY2F0ZVdpdGhXZWIzXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYXV0aGVudGljYXRlV2l0aEdvb2dsZU9uZVRhcCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0IGNsZXJranMgPSBhd2FpdCBfX3ByaXZhdGVNZXRob2QodGhpcywgX0lzb21vcnBoaWNDbGVya19pbnN0YW5jZXMsIHdhaXRGb3JDbGVya0pTX2ZuKS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIGNsZXJranMuYXV0aGVudGljYXRlV2l0aEdvb2dsZU9uZVRhcChwYXJhbXMpO1xuICAgIH07XG4gICAgdGhpcy5jcmVhdGVPcmdhbml6YXRpb24gPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY3JlYXRlT3JnYW5pemF0aW9uKHBhcmFtcyk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2xlcmtqcyAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZW1vdW50TWV0aG9kQ2FsbHMuc2V0KFwiY3JlYXRlT3JnYW5pemF0aW9uXCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0T3JnYW5pemF0aW9uID0gYXN5bmMgKG9yZ2FuaXphdGlvbklkKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0T3JnYW5pemF0aW9uKG9yZ2FuaXphdGlvbklkKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJnZXRPcmdhbml6YXRpb25cIiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zaWduT3V0ID0gYXN5bmMgKHNpZ25PdXRDYWxsYmFja09yT3B0aW9ucywgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2xlcmtqcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNpZ25PdXQoc2lnbk91dENhbGxiYWNrT3JPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jbGVya2pzICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJlbW91bnRNZXRob2RDYWxscy5zZXQoXCJzaWduT3V0XCIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHsgQ2xlcmsgPSBudWxsLCBwdWJsaXNoYWJsZUtleSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3B1Ymxpc2hhYmxlS2V5LCBwdWJsaXNoYWJsZUtleSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9wcm94eVVybCwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcm94eVVybCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9kb21haW4sIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZG9tYWluKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuQ2xlcmsgPSBDbGVyaztcbiAgICB0aGlzLm1vZGUgPSBpbkJyb3dzZXIoKSA/IFwiYnJvd3NlclwiIDogXCJzZXJ2ZXJcIjtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zZGtNZXRhZGF0YSkge1xuICAgICAgdGhpcy5vcHRpb25zLnNka01ldGFkYXRhID0gU0RLX01FVEFEQVRBO1xuICAgIH1cbiAgICB2b2lkIHRoaXMubG9hZENsZXJrSlMoKTtcbiAgfVxuICBnZXQgcHVibGlzaGFibGVLZXkoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfcHVibGlzaGFibGVLZXkpO1xuICB9XG4gIGdldCBsb2FkZWQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbG9hZGVkKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZShvcHRpb25zKSB7XG4gICAgaWYgKCFpbkJyb3dzZXIoKSB8fCAhX19wcml2YXRlR2V0KHRoaXMsIF9pbnN0YW5jZSkgfHwgb3B0aW9ucy5DbGVyayAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2luc3RhbmNlKS5DbGVyayAhPT0gb3B0aW9ucy5DbGVyaykge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9pbnN0YW5jZSwgbmV3IF9Jc29tb3JwaGljQ2xlcmsob3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9pbnN0YW5jZSk7XG4gIH1cbiAgc3RhdGljIGNsZWFySW5zdGFuY2UoKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9pbnN0YW5jZSwgbnVsbCk7XG4gIH1cbiAgZ2V0IGRvbWFpbigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVWYWx1ZU9yRm4oX19wcml2YXRlR2V0KHRoaXMsIF9kb21haW4pLCBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSwgXCJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgX19wcml2YXRlR2V0KHRoaXMsIF9kb21haW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBlcnJvclRocm93ZXIudGhyb3codW5zdXBwb3J0ZWROb25Ccm93c2VyRG9tYWluT3JQcm94eVVybEZ1bmN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfZG9tYWluKSB8fCBcIlwiO1xuICB9XG4gIGdldCBwcm94eVVybCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVWYWx1ZU9yRm4oX19wcml2YXRlR2V0KHRoaXMsIF9wcm94eVVybCksIG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBfX3ByaXZhdGVHZXQodGhpcywgX3Byb3h5VXJsKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gZXJyb3JUaHJvd2VyLnRocm93KHVuc3VwcG9ydGVkTm9uQnJvd3NlckRvbWFpbk9yUHJveHlVcmxGdW5jdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3Byb3h5VXJsKSB8fCBcIlwiO1xuICB9XG4gIGdldCBzZGtNZXRhZGF0YSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZGtNZXRhZGF0YSkgfHwgdGhpcy5vcHRpb25zLnNka01ldGFkYXRhIHx8IHZvaWQgMDtcbiAgfVxuICBnZXQgaW5zdGFuY2VUeXBlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5zdGFuY2VUeXBlO1xuICB9XG4gIGdldCBmcm9udGVuZEFwaSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLmNsZXJranMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mcm9udGVuZEFwaSkgfHwgXCJcIjtcbiAgfVxuICBnZXQgaXNTdGFuZGFyZEJyb3dzZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaXNTdGFuZGFyZEJyb3dzZXIpIHx8IHRoaXMub3B0aW9ucy5zdGFuZGFyZEJyb3dzZXIgfHwgZmFsc2U7XG4gIH1cbiAgZ2V0IGlzU2F0ZWxsaXRlKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZVZhbHVlT3JGbih0aGlzLm9wdGlvbnMuaXNTYXRlbGxpdGUsIG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmlzU2F0ZWxsaXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBlcnJvclRocm93ZXIudGhyb3codW5zdXBwb3J0ZWROb25Ccm93c2VyRG9tYWluT3JQcm94eVVybEZ1bmN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIGxvYWRDbGVya0pTKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5tb2RlICE9PSBcImJyb3dzZXJcIiB8fCBfX3ByaXZhdGVHZXQodGhpcywgX2xvYWRlZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5fX2NsZXJrX3B1Ymxpc2hhYmxlX2tleSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfcHVibGlzaGFibGVLZXkpO1xuICAgICAgd2luZG93Ll9fY2xlcmtfcHJveHlfdXJsID0gdGhpcy5wcm94eVVybDtcbiAgICAgIHdpbmRvdy5fX2NsZXJrX2RvbWFpbiA9IHRoaXMuZG9tYWluO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuQ2xlcmspIHtcbiAgICAgICAgbGV0IGM7XG4gICAgICAgIGlmIChpc0NvbnN0cnVjdG9yKHRoaXMuQ2xlcmspKSB7XG4gICAgICAgICAgYyA9IG5ldyB0aGlzLkNsZXJrKF9fcHJpdmF0ZUdldCh0aGlzLCBfcHVibGlzaGFibGVLZXkpLCB7XG4gICAgICAgICAgICBwcm94eVVybDogdGhpcy5wcm94eVVybCxcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy5kb21haW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCBjLmxvYWQodGhpcy5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjID0gdGhpcy5DbGVyaztcbiAgICAgICAgICBpZiAoIWMubG9hZGVkKSB7XG4gICAgICAgICAgICBhd2FpdCBjLmxvYWQodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsLkNsZXJrID0gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZ2xvYmFsLkNsZXJrKSB7XG4gICAgICAgICAgYXdhaXQgbG9hZENsZXJrSnNTY3JpcHQoe1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgcHVibGlzaGFibGVLZXk6IF9fcHJpdmF0ZUdldCh0aGlzLCBfcHVibGlzaGFibGVLZXkpLFxuICAgICAgICAgICAgcHJveHlVcmw6IHRoaXMucHJveHlVcmwsXG4gICAgICAgICAgICBkb21haW46IHRoaXMuZG9tYWluLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMub3B0aW9ucy5ub25jZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2xvYmFsLkNsZXJrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRvd25sb2FkIGxhdGVzdCBDbGVya0pTLiBDb250YWN0IHN1cHBvcnRAY2xlcmsuY29tLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBnbG9iYWwuQ2xlcmsubG9hZCh0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKChfYSA9IGdsb2JhbC5DbGVyaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxvYWRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oeWRyYXRlQ2xlcmtKUyhnbG9iYWwuQ2xlcmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3Iuc3RhY2sgfHwgZXJyb3IubWVzc2FnZSB8fCBlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5jbGVya2pzKSA9PSBudWxsID8gdm9pZCAwIDogX2EudmVyc2lvbjtcbiAgfVxuICBnZXQgY2xpZW50KCkge1xuICAgIGlmICh0aGlzLmNsZXJranMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsZXJranMuY2xpZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBnZXQgc2Vzc2lvbigpIHtcbiAgICBpZiAodGhpcy5jbGVya2pzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGVya2pzLnNlc3Npb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGdldCB1c2VyKCkge1xuICAgIGlmICh0aGlzLmNsZXJranMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsZXJranMudXNlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgZ2V0IG9yZ2FuaXphdGlvbigpIHtcbiAgICBpZiAodGhpcy5jbGVya2pzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGVya2pzLm9yZ2FuaXphdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeSgpIHtcbiAgICBpZiAodGhpcy5jbGVya2pzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGVya2pzLnRlbGVtZXRyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgZ2V0IF9fdW5zdGFibGVfX2Vudmlyb25tZW50KCkge1xuICAgIGlmICh0aGlzLmNsZXJranMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsZXJranMuX191bnN0YWJsZV9fZW52aXJvbm1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIF9fdW5zdGFibGVfX3NldEVudmlyb25tZW50KC4uLmFyZ3MpIHtcbiAgICBpZiAodGhpcy5jbGVya2pzICYmIFwiX191bnN0YWJsZV9fc2V0RW52aXJvbm1lbnRcIiBpbiB0aGlzLmNsZXJranMpIHtcbiAgICAgIHRoaXMuY2xlcmtqcy5fX3Vuc3RhYmxlX19zZXRFbnZpcm9ubWVudChhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5fbG9hZGVkID0gbmV3IFdlYWtNYXAoKTtcbl9kb21haW4gPSBuZXcgV2Vha01hcCgpO1xuX3Byb3h5VXJsID0gbmV3IFdlYWtNYXAoKTtcbl9wdWJsaXNoYWJsZUtleSA9IG5ldyBXZWFrTWFwKCk7XG5faW5zdGFuY2UgPSBuZXcgV2Vha01hcCgpO1xuX0lzb21vcnBoaWNDbGVya19pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpO1xud2FpdEZvckNsZXJrSlNfZm4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgdGhpcy5hZGRPbkxvYWRlZCgoKSA9PiByZXNvbHZlKHRoaXMuY2xlcmtqcykpO1xuICB9KTtcbn07XG5fX3ByaXZhdGVBZGQoX0lzb21vcnBoaWNDbGVyaywgX2luc3RhbmNlKTtcbnZhciBJc29tb3JwaGljQ2xlcmsgPSBfSXNvbW9ycGhpY0NsZXJrO1xuXG4vLyBzcmMvdXRpbHMvZGVyaXZlU3RhdGUudHNcbnZhciBkZXJpdmVTdGF0ZSA9IChjbGVya0xvYWRlZCwgc3RhdGUsIGluaXRpYWxTdGF0ZSkgPT4ge1xuICBpZiAoIWNsZXJrTG9hZGVkICYmIGluaXRpYWxTdGF0ZSkge1xuICAgIHJldHVybiBkZXJpdmVGcm9tU3NySW5pdGlhbFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIGRlcml2ZUZyb21DbGllbnRTaWRlU3RhdGUoc3RhdGUpO1xufTtcbnZhciBkZXJpdmVGcm9tU3NySW5pdGlhbFN0YXRlID0gKGluaXRpYWxTdGF0ZSkgPT4ge1xuICBjb25zdCB1c2VySWQgPSBpbml0aWFsU3RhdGUudXNlcklkO1xuICBjb25zdCB1c2VyID0gaW5pdGlhbFN0YXRlLnVzZXI7XG4gIGNvbnN0IHNlc3Npb25JZCA9IGluaXRpYWxTdGF0ZS5zZXNzaW9uSWQ7XG4gIGNvbnN0IHNlc3Npb24gPSBpbml0aWFsU3RhdGUuc2Vzc2lvbjtcbiAgY29uc3Qgb3JnYW5pemF0aW9uID0gaW5pdGlhbFN0YXRlLm9yZ2FuaXphdGlvbjtcbiAgY29uc3Qgb3JnSWQgPSBpbml0aWFsU3RhdGUub3JnSWQ7XG4gIGNvbnN0IG9yZ1JvbGUgPSBpbml0aWFsU3RhdGUub3JnUm9sZTtcbiAgY29uc3Qgb3JnUGVybWlzc2lvbnMgPSBpbml0aWFsU3RhdGUub3JnUGVybWlzc2lvbnM7XG4gIGNvbnN0IG9yZ1NsdWcgPSBpbml0aWFsU3RhdGUub3JnU2x1ZztcbiAgY29uc3QgYWN0b3IgPSBpbml0aWFsU3RhdGUuYWN0b3I7XG4gIGNvbnN0IF9fZXhwZXJpbWVudGFsX2ZhY3RvclZlcmlmaWNhdGlvbkFnZSA9IGluaXRpYWxTdGF0ZS5fX2V4cGVyaW1lbnRhbF9mYWN0b3JWZXJpZmljYXRpb25BZ2U7XG4gIHJldHVybiB7XG4gICAgdXNlcklkLFxuICAgIHVzZXIsXG4gICAgc2Vzc2lvbklkLFxuICAgIHNlc3Npb24sXG4gICAgb3JnYW5pemF0aW9uLFxuICAgIG9yZ0lkLFxuICAgIG9yZ1JvbGUsXG4gICAgb3JnUGVybWlzc2lvbnMsXG4gICAgb3JnU2x1ZyxcbiAgICBhY3RvcixcbiAgICBfX2V4cGVyaW1lbnRhbF9mYWN0b3JWZXJpZmljYXRpb25BZ2VcbiAgfTtcbn07XG52YXIgZGVyaXZlRnJvbUNsaWVudFNpZGVTdGF0ZSA9IChzdGF0ZSkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHVzZXJJZCA9IHN0YXRlLnVzZXIgPyBzdGF0ZS51c2VyLmlkIDogc3RhdGUudXNlcjtcbiAgY29uc3QgdXNlciA9IHN0YXRlLnVzZXI7XG4gIGNvbnN0IHNlc3Npb25JZCA9IHN0YXRlLnNlc3Npb24gPyBzdGF0ZS5zZXNzaW9uLmlkIDogc3RhdGUuc2Vzc2lvbjtcbiAgY29uc3Qgc2Vzc2lvbiA9IHN0YXRlLnNlc3Npb247XG4gIGNvbnN0IF9fZXhwZXJpbWVudGFsX2ZhY3RvclZlcmlmaWNhdGlvbkFnZSA9IHN0YXRlLnNlc3Npb24gPyBzdGF0ZS5zZXNzaW9uLl9fZXhwZXJpbWVudGFsX2ZhY3RvclZlcmlmaWNhdGlvbkFnZSA6IG51bGw7XG4gIGNvbnN0IGFjdG9yID0gc2Vzc2lvbiA9PSBudWxsID8gdm9pZCAwIDogc2Vzc2lvbi5hY3RvcjtcbiAgY29uc3Qgb3JnYW5pemF0aW9uID0gc3RhdGUub3JnYW5pemF0aW9uO1xuICBjb25zdCBvcmdJZCA9IHN0YXRlLm9yZ2FuaXphdGlvbiA/IHN0YXRlLm9yZ2FuaXphdGlvbi5pZCA6IHN0YXRlLm9yZ2FuaXphdGlvbjtcbiAgY29uc3Qgb3JnU2x1ZyA9IG9yZ2FuaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb3JnYW5pemF0aW9uLnNsdWc7XG4gIGNvbnN0IG1lbWJlcnNoaXAgPSBvcmdhbml6YXRpb24gPyAoX2EgPSB1c2VyID09IG51bGwgPyB2b2lkIDAgOiB1c2VyLm9yZ2FuaXphdGlvbk1lbWJlcnNoaXBzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmluZCgob20pID0+IG9tLm9yZ2FuaXphdGlvbi5pZCA9PT0gb3JnSWQpIDogb3JnYW5pemF0aW9uO1xuICBjb25zdCBvcmdQZXJtaXNzaW9ucyA9IG1lbWJlcnNoaXAgPyBtZW1iZXJzaGlwLnBlcm1pc3Npb25zIDogbWVtYmVyc2hpcDtcbiAgY29uc3Qgb3JnUm9sZSA9IG1lbWJlcnNoaXAgPyBtZW1iZXJzaGlwLnJvbGUgOiBtZW1iZXJzaGlwO1xuICByZXR1cm4ge1xuICAgIHVzZXJJZCxcbiAgICB1c2VyLFxuICAgIHNlc3Npb25JZCxcbiAgICBzZXNzaW9uLFxuICAgIG9yZ2FuaXphdGlvbixcbiAgICBvcmdJZCxcbiAgICBvcmdSb2xlLFxuICAgIG9yZ1NsdWcsXG4gICAgb3JnUGVybWlzc2lvbnMsXG4gICAgYWN0b3IsXG4gICAgX19leHBlcmltZW50YWxfZmFjdG9yVmVyaWZpY2F0aW9uQWdlXG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dHMvQ2xlcmtDb250ZXh0UHJvdmlkZXIudHN4XG5mdW5jdGlvbiBDbGVya0NvbnRleHRQcm92aWRlcihwcm9wcykge1xuICBjb25zdCB7IGlzb21vcnBoaWNDbGVya09wdGlvbnMsIGluaXRpYWxTdGF0ZSwgY2hpbGRyZW4gfSA9IHByb3BzO1xuICBjb25zdCB7IGlzb21vcnBoaWNDbGVyazogY2xlcmssIGxvYWRlZDogY2xlcmtMb2FkZWQgfSA9IHVzZUxvYWRlZElzb21vcnBoaWNDbGVyayhpc29tb3JwaGljQ2xlcmtPcHRpb25zKTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdDEyLnVzZVN0YXRlKHtcbiAgICBjbGllbnQ6IGNsZXJrLmNsaWVudCxcbiAgICBzZXNzaW9uOiBjbGVyay5zZXNzaW9uLFxuICAgIHVzZXI6IGNsZXJrLnVzZXIsXG4gICAgb3JnYW5pemF0aW9uOiBjbGVyay5vcmdhbml6YXRpb25cbiAgfSk7XG4gIFJlYWN0MTIudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gY2xlcmsuYWRkTGlzdGVuZXIoKGUpID0+IHNldFN0YXRlKHsgLi4uZSB9KSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZGVyaXZlZFN0YXRlID0gZGVyaXZlU3RhdGUoY2xlcmtMb2FkZWQsIHN0YXRlLCBpbml0aWFsU3RhdGUpO1xuICBjb25zdCBjbGVya0N0eCA9IFJlYWN0MTIudXNlTWVtbygoKSA9PiAoeyB2YWx1ZTogY2xlcmsgfSksIFtjbGVya0xvYWRlZF0pO1xuICBjb25zdCBjbGllbnRDdHggPSBSZWFjdDEyLnVzZU1lbW8oKCkgPT4gKHsgdmFsdWU6IHN0YXRlLmNsaWVudCB9KSwgW3N0YXRlLmNsaWVudF0pO1xuICBjb25zdCB7XG4gICAgc2Vzc2lvbklkLFxuICAgIHNlc3Npb24sXG4gICAgdXNlcklkLFxuICAgIHVzZXIsXG4gICAgb3JnSWQsXG4gICAgYWN0b3IsXG4gICAgb3JnYW5pemF0aW9uLFxuICAgIG9yZ1JvbGUsXG4gICAgb3JnU2x1ZyxcbiAgICBvcmdQZXJtaXNzaW9ucyxcbiAgICBfX2V4cGVyaW1lbnRhbF9mYWN0b3JWZXJpZmljYXRpb25BZ2VcbiAgfSA9IGRlcml2ZWRTdGF0ZTtcbiAgY29uc3QgYXV0aEN0eCA9IFJlYWN0MTIudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB7XG4gICAgICBzZXNzaW9uSWQsXG4gICAgICB1c2VySWQsXG4gICAgICBhY3RvcixcbiAgICAgIG9yZ0lkLFxuICAgICAgb3JnUm9sZSxcbiAgICAgIG9yZ1NsdWcsXG4gICAgICBvcmdQZXJtaXNzaW9ucyxcbiAgICAgIF9fZXhwZXJpbWVudGFsX2ZhY3RvclZlcmlmaWNhdGlvbkFnZVxuICAgIH07XG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfSwgW3Nlc3Npb25JZCwgdXNlcklkLCBhY3Rvciwgb3JnSWQsIG9yZ1JvbGUsIG9yZ1NsdWcsIF9fZXhwZXJpbWVudGFsX2ZhY3RvclZlcmlmaWNhdGlvbkFnZV0pO1xuICBjb25zdCBzZXNzaW9uQ3R4ID0gUmVhY3QxMi51c2VNZW1vKCgpID0+ICh7IHZhbHVlOiBzZXNzaW9uIH0pLCBbc2Vzc2lvbklkLCBzZXNzaW9uXSk7XG4gIGNvbnN0IHVzZXJDdHggPSBSZWFjdDEyLnVzZU1lbW8oKCkgPT4gKHsgdmFsdWU6IHVzZXIgfSksIFt1c2VySWQsIHVzZXJdKTtcbiAgY29uc3Qgb3JnYW5pemF0aW9uQ3R4ID0gUmVhY3QxMi51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgIG9yZ2FuaXphdGlvblxuICAgIH07XG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfSwgW29yZ0lkLCBvcmdhbml6YXRpb25dKTtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHZhbHVlIHBhc3NlZCBpcyBvZiB0eXBlIElzb21vcnBoaWNDbGVyayB3aGVyZSB0aGUgY29udGV4dCBleHBlY3RzIExvYWRlZENsZXJrXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChJc29tb3JwaGljQ2xlcmtDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjbGVya0N0eCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KENsaWVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNsaWVudEN0eCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFNlc3Npb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzZXNzaW9uQ3R4IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoT3JnYW5pemF0aW9uUHJvdmlkZXIsIHsgLi4ub3JnYW5pemF0aW9uQ3R4LnZhbHVlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoQXV0aENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGF1dGhDdHggfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChVc2VyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdXNlckN0eCB9LCBjaGlsZHJlbikpKSkpKVxuICApO1xufVxudmFyIHVzZUxvYWRlZElzb21vcnBoaWNDbGVyayA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IFtsb2FkZWQsIHNldExvYWRlZF0gPSBSZWFjdDEyLnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgaXNvbW9ycGhpY0NsZXJrID0gUmVhY3QxMi51c2VNZW1vKCgpID0+IElzb21vcnBoaWNDbGVyay5nZXRPckNyZWF0ZUluc3RhbmNlKG9wdGlvbnMpLCBbXSk7XG4gIFJlYWN0MTIudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2b2lkIGlzb21vcnBoaWNDbGVyay5fX3Vuc3RhYmxlX191cGRhdGVQcm9wcyh7IGFwcGVhcmFuY2U6IG9wdGlvbnMuYXBwZWFyYW5jZSB9KTtcbiAgfSwgW29wdGlvbnMuYXBwZWFyYW5jZV0pO1xuICBSZWFjdDEyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdm9pZCBpc29tb3JwaGljQ2xlcmsuX191bnN0YWJsZV9fdXBkYXRlUHJvcHMoeyBvcHRpb25zIH0pO1xuICB9LCBbb3B0aW9ucy5sb2NhbGl6YXRpb25dKTtcbiAgUmVhY3QxMi51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzb21vcnBoaWNDbGVyay5hZGRPbkxvYWRlZCgoKSA9PiBzZXRMb2FkZWQodHJ1ZSkpO1xuICB9LCBbXSk7XG4gIFJlYWN0MTIudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgSXNvbW9ycGhpY0NsZXJrLmNsZWFySW5zdGFuY2UoKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiB7IGlzb21vcnBoaWNDbGVyaywgbG9hZGVkIH07XG59O1xuXG4vLyBzcmMvY29udGV4dHMvQ2xlcmtQcm92aWRlci50c3hcbmZ1bmN0aW9uIENsZXJrUHJvdmlkZXJCYXNlKHByb3BzKSB7XG4gIGNvbnN0IHsgaW5pdGlhbFN0YXRlLCBjaGlsZHJlbiwgLi4ucmVzdElzb21vcnBoaWNDbGVya09wdGlvbnMgfSA9IHByb3BzO1xuICBjb25zdCB7IHB1Ymxpc2hhYmxlS2V5ID0gXCJcIiwgQ2xlcms6IHVzZXJJbml0aWFsaXNlZENsZXJrIH0gPSByZXN0SXNvbW9ycGhpY0NsZXJrT3B0aW9ucztcbiAgaWYgKCF1c2VySW5pdGlhbGlzZWRDbGVyaykge1xuICAgIGlmICghcHVibGlzaGFibGVLZXkpIHtcbiAgICAgIGVycm9yVGhyb3dlci50aHJvd01pc3NpbmdQdWJsaXNoYWJsZUtleUVycm9yKCk7XG4gICAgfSBlbHNlIGlmIChwdWJsaXNoYWJsZUtleSAmJiAhaXNQdWJsaXNoYWJsZUtleShwdWJsaXNoYWJsZUtleSkpIHtcbiAgICAgIGVycm9yVGhyb3dlci50aHJvd0ludmFsaWRQdWJsaXNoYWJsZUtleUVycm9yKHsga2V5OiBwdWJsaXNoYWJsZUtleSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoXG4gICAgQ2xlcmtDb250ZXh0UHJvdmlkZXIsXG4gICAge1xuICAgICAgaW5pdGlhbFN0YXRlLFxuICAgICAgaXNvbW9ycGhpY0NsZXJrT3B0aW9uczogcmVzdElzb21vcnBoaWNDbGVya09wdGlvbnNcbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG52YXIgQ2xlcmtQcm92aWRlciA9IHdpdGhNYXhBbGxvd2VkSW5zdGFuY2VzR3VhcmQoQ2xlcmtQcm92aWRlckJhc2UsIFwiQ2xlcmtQcm92aWRlclwiLCBtdWx0aXBsZUNsZXJrUHJvdmlkZXJzRXJyb3IpO1xuQ2xlcmtQcm92aWRlci5kaXNwbGF5TmFtZSA9IFwiQ2xlcmtQcm92aWRlclwiO1xuXG4vLyBzcmMvaW5kZXgudHNcbnNldEVycm9yVGhyb3dlck9wdGlvbnMoeyBwYWNrYWdlTmFtZTogXCJAY2xlcmsvY2xlcmstcmVhY3RcIiB9KTtcbnNldENsZXJrSnNMb2FkaW5nRXJyb3JQYWNrYWdlTmFtZShcIkBjbGVyay9jbGVyay1yZWFjdFwiKTtcbmV4cG9ydCB7XG4gIEF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdENhbGxiYWNrLFxuICBDbGVya0xvYWRlZCxcbiAgQ2xlcmtMb2FkaW5nLFxuICBDbGVya1Byb3ZpZGVyLFxuICBDcmVhdGVPcmdhbml6YXRpb24sXG4gIEdvb2dsZU9uZVRhcCxcbiAgT3JnYW5pemF0aW9uTGlzdCxcbiAgT3JnYW5pemF0aW9uUHJvZmlsZSxcbiAgT3JnYW5pemF0aW9uU3dpdGNoZXIsXG4gIFByb3RlY3QsXG4gIFJlZGlyZWN0VG9DcmVhdGVPcmdhbml6YXRpb24sXG4gIFJlZGlyZWN0VG9Pcmdhbml6YXRpb25Qcm9maWxlLFxuICBSZWRpcmVjdFRvU2lnbkluLFxuICBSZWRpcmVjdFRvU2lnblVwLFxuICBSZWRpcmVjdFRvVXNlclByb2ZpbGUsXG4gIFNpZ25JbixcbiAgU2lnbkluQnV0dG9uLFxuICBTaWduSW5XaXRoTWV0YW1hc2tCdXR0b24sXG4gIFNpZ25PdXRCdXR0b24sXG4gIFNpZ25VcCxcbiAgU2lnblVwQnV0dG9uLFxuICBTaWduZWRJbixcbiAgU2lnbmVkT3V0LFxuICBVc2VyQnV0dG9uLFxuICBVc2VyUHJvZmlsZSxcbiAgX19leHBlcmltZW50YWxfVXNlclZlcmlmaWNhdGlvbixcbiAgdXNlQXV0aCxcbiAgdXNlQ2xlcmssXG4gIHVzZUVtYWlsTGluayxcbiAgdXNlT3JnYW5pemF0aW9uLFxuICB1c2VPcmdhbml6YXRpb25MaXN0LFxuICB1c2VTZXNzaW9uLFxuICB1c2VTZXNzaW9uTGlzdCxcbiAgdXNlU2lnbkluLFxuICB1c2VTaWduVXAsXG4gIHVzZVVzZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/clerk-react/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/authorization.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/authorization.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCheckAuthorization: function() { return /* binding */ createCheckAuthorization; }\n/* harmony export */ });\n/* harmony import */ var _chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7ELT755Q.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs\");\n\n\n// src/authorization.ts\nvar MAX_AGE_TO_MINUTES = {\n  \"A1.10min\": 10,\n  \"A2.1hr\": 60,\n  \"A3.4hr\": 240,\n  //4 * 60\n  \"A4.1day\": 1440,\n  //24 * 60,\n  \"A5.1wk\": 10080\n  //7 * 24 * 60,\n};\nvar ALLOWED_MAX_AGES = new Set(\n  Object.keys(MAX_AGE_TO_MINUTES)\n);\nvar ALLOWED_LEVELS = /* @__PURE__ */ new Set([\n  \"L1.firstFactor\",\n  \"L2.secondFactor\",\n  \"L3.multiFactor\"\n]);\nvar isValidMaxAge = (maxAge) => ALLOWED_MAX_AGES.has(maxAge);\nvar isValidLevel = (level) => ALLOWED_LEVELS.has(level);\nvar checkOrgAuthorization = (params, options) => {\n  const { orgId, orgRole, orgPermissions } = options;\n  if (!params.role && !params.permission) {\n    return null;\n  }\n  if (!orgId || !orgRole || !orgPermissions) {\n    return null;\n  }\n  if (params.permission) {\n    return orgPermissions.includes(params.permission);\n  }\n  if (params.role) {\n    return orgRole === params.role;\n  }\n  return null;\n};\nvar checkStepUpAuthorization = (params, { __experimental_factorVerificationAge }) => {\n  if (!params.__experimental_assurance || !__experimental_factorVerificationAge) {\n    return null;\n  }\n  const { level, maxAge } = params.__experimental_assurance;\n  if (!isValidLevel(level) || !isValidMaxAge(maxAge)) {\n    return null;\n  }\n  const [factor1Age, factor2Age] = __experimental_factorVerificationAge;\n  const maxAgeInMinutes = MAX_AGE_TO_MINUTES[maxAge];\n  const isValidFactor1 = factor1Age !== -1 ? maxAgeInMinutes > factor1Age : null;\n  const isValidFactor2 = factor2Age !== -1 ? maxAgeInMinutes > factor2Age : null;\n  switch (level) {\n    case \"L1.firstFactor\":\n      return isValidFactor1;\n    case \"L2.secondFactor\":\n      return factor2Age !== -1 ? isValidFactor2 : isValidFactor1;\n    case \"L3.multiFactor\":\n      return factor2Age === -1 ? isValidFactor1 : isValidFactor1 && isValidFactor2;\n  }\n};\nvar createCheckAuthorization = (options) => {\n  return (params) => {\n    if (!options.userId) {\n      return false;\n    }\n    const orgAuthorization = checkOrgAuthorization(params, options);\n    const stepUpAuthorization = checkStepUpAuthorization(params, options);\n    if ([orgAuthorization, stepUpAuthorization].some((a) => a === null)) {\n      return [orgAuthorization, stepUpAuthorization].some((a) => a === true);\n    }\n    return [orgAuthorization, stepUpAuthorization].every((a) => a === true);\n  };\n};\n\n//# sourceMappingURL=authorization.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvYXV0aG9yaXphdGlvbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQ0FBc0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9hdXRob3JpemF0aW9uLm1qcz83NzZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4vY2h1bmstN0VMVDc1NVEubWpzXCI7XG5cbi8vIHNyYy9hdXRob3JpemF0aW9uLnRzXG52YXIgTUFYX0FHRV9UT19NSU5VVEVTID0ge1xuICBcIkExLjEwbWluXCI6IDEwLFxuICBcIkEyLjFoclwiOiA2MCxcbiAgXCJBMy40aHJcIjogMjQwLFxuICAvLzQgKiA2MFxuICBcIkE0LjFkYXlcIjogMTQ0MCxcbiAgLy8yNCAqIDYwLFxuICBcIkE1LjF3a1wiOiAxMDA4MFxuICAvLzcgKiAyNCAqIDYwLFxufTtcbnZhciBBTExPV0VEX01BWF9BR0VTID0gbmV3IFNldChcbiAgT2JqZWN0LmtleXMoTUFYX0FHRV9UT19NSU5VVEVTKVxuKTtcbnZhciBBTExPV0VEX0xFVkVMUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJMMS5maXJzdEZhY3RvclwiLFxuICBcIkwyLnNlY29uZEZhY3RvclwiLFxuICBcIkwzLm11bHRpRmFjdG9yXCJcbl0pO1xudmFyIGlzVmFsaWRNYXhBZ2UgPSAobWF4QWdlKSA9PiBBTExPV0VEX01BWF9BR0VTLmhhcyhtYXhBZ2UpO1xudmFyIGlzVmFsaWRMZXZlbCA9IChsZXZlbCkgPT4gQUxMT1dFRF9MRVZFTFMuaGFzKGxldmVsKTtcbnZhciBjaGVja09yZ0F1dGhvcml6YXRpb24gPSAocGFyYW1zLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHsgb3JnSWQsIG9yZ1JvbGUsIG9yZ1Blcm1pc3Npb25zIH0gPSBvcHRpb25zO1xuICBpZiAoIXBhcmFtcy5yb2xlICYmICFwYXJhbXMucGVybWlzc2lvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghb3JnSWQgfHwgIW9yZ1JvbGUgfHwgIW9yZ1Blcm1pc3Npb25zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBhcmFtcy5wZXJtaXNzaW9uKSB7XG4gICAgcmV0dXJuIG9yZ1Blcm1pc3Npb25zLmluY2x1ZGVzKHBhcmFtcy5wZXJtaXNzaW9uKTtcbiAgfVxuICBpZiAocGFyYW1zLnJvbGUpIHtcbiAgICByZXR1cm4gb3JnUm9sZSA9PT0gcGFyYW1zLnJvbGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIGNoZWNrU3RlcFVwQXV0aG9yaXphdGlvbiA9IChwYXJhbXMsIHsgX19leHBlcmltZW50YWxfZmFjdG9yVmVyaWZpY2F0aW9uQWdlIH0pID0+IHtcbiAgaWYgKCFwYXJhbXMuX19leHBlcmltZW50YWxfYXNzdXJhbmNlIHx8ICFfX2V4cGVyaW1lbnRhbF9mYWN0b3JWZXJpZmljYXRpb25BZ2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7IGxldmVsLCBtYXhBZ2UgfSA9IHBhcmFtcy5fX2V4cGVyaW1lbnRhbF9hc3N1cmFuY2U7XG4gIGlmICghaXNWYWxpZExldmVsKGxldmVsKSB8fCAhaXNWYWxpZE1heEFnZShtYXhBZ2UpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgW2ZhY3RvcjFBZ2UsIGZhY3RvcjJBZ2VdID0gX19leHBlcmltZW50YWxfZmFjdG9yVmVyaWZpY2F0aW9uQWdlO1xuICBjb25zdCBtYXhBZ2VJbk1pbnV0ZXMgPSBNQVhfQUdFX1RPX01JTlVURVNbbWF4QWdlXTtcbiAgY29uc3QgaXNWYWxpZEZhY3RvcjEgPSBmYWN0b3IxQWdlICE9PSAtMSA/IG1heEFnZUluTWludXRlcyA+IGZhY3RvcjFBZ2UgOiBudWxsO1xuICBjb25zdCBpc1ZhbGlkRmFjdG9yMiA9IGZhY3RvcjJBZ2UgIT09IC0xID8gbWF4QWdlSW5NaW51dGVzID4gZmFjdG9yMkFnZSA6IG51bGw7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIFwiTDEuZmlyc3RGYWN0b3JcIjpcbiAgICAgIHJldHVybiBpc1ZhbGlkRmFjdG9yMTtcbiAgICBjYXNlIFwiTDIuc2Vjb25kRmFjdG9yXCI6XG4gICAgICByZXR1cm4gZmFjdG9yMkFnZSAhPT0gLTEgPyBpc1ZhbGlkRmFjdG9yMiA6IGlzVmFsaWRGYWN0b3IxO1xuICAgIGNhc2UgXCJMMy5tdWx0aUZhY3RvclwiOlxuICAgICAgcmV0dXJuIGZhY3RvcjJBZ2UgPT09IC0xID8gaXNWYWxpZEZhY3RvcjEgOiBpc1ZhbGlkRmFjdG9yMSAmJiBpc1ZhbGlkRmFjdG9yMjtcbiAgfVxufTtcbnZhciBjcmVhdGVDaGVja0F1dGhvcml6YXRpb24gPSAob3B0aW9ucykgPT4ge1xuICByZXR1cm4gKHBhcmFtcykgPT4ge1xuICAgIGlmICghb3B0aW9ucy51c2VySWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb3JnQXV0aG9yaXphdGlvbiA9IGNoZWNrT3JnQXV0aG9yaXphdGlvbihwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHN0ZXBVcEF1dGhvcml6YXRpb24gPSBjaGVja1N0ZXBVcEF1dGhvcml6YXRpb24ocGFyYW1zLCBvcHRpb25zKTtcbiAgICBpZiAoW29yZ0F1dGhvcml6YXRpb24sIHN0ZXBVcEF1dGhvcml6YXRpb25dLnNvbWUoKGEpID0+IGEgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gW29yZ0F1dGhvcml6YXRpb24sIHN0ZXBVcEF1dGhvcml6YXRpb25dLnNvbWUoKGEpID0+IGEgPT09IHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gW29yZ0F1dGhvcml6YXRpb24sIHN0ZXBVcEF1dGhvcml6YXRpb25dLmV2ZXJ5KChhKSA9PiBhID09PSB0cnVlKTtcbiAgfTtcbn07XG5leHBvcnQge1xuICBjcmVhdGVDaGVja0F1dGhvcml6YXRpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRob3JpemF0aW9uLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/authorization.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/browser.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/browser.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   inBrowser: function() { return /* reexport safe */ _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_0__.inBrowser; },\n/* harmony export */   isBrowserOnline: function() { return /* reexport safe */ _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_0__.isBrowserOnline; },\n/* harmony export */   isValidBrowser: function() { return /* reexport safe */ _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_0__.isValidBrowser; },\n/* harmony export */   isValidBrowserOnline: function() { return /* reexport safe */ _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_0__.isValidBrowserOnline; },\n/* harmony export */   userAgentIsRobot: function() { return /* reexport safe */ _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_0__.userAgentIsRobot; }\n/* harmony export */ });\n/* harmony import */ var _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-LJ4R7M7R.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-LJ4R7M7R.mjs\");\n/* harmony import */ var _chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-7ELT755Q.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs\");\n\n\n\n//# sourceMappingURL=browser.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvYnJvd3Nlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQU04QjtBQUNBO0FBTzVCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9icm93c2VyLm1qcz80YzY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGluQnJvd3NlcixcbiAgaXNCcm93c2VyT25saW5lLFxuICBpc1ZhbGlkQnJvd3NlcixcbiAgaXNWYWxpZEJyb3dzZXJPbmxpbmUsXG4gIHVzZXJBZ2VudElzUm9ib3Rcbn0gZnJvbSBcIi4vY2h1bmstTEo0UjdNN1IubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLTdFTFQ3NTVRLm1qc1wiO1xuZXhwb3J0IHtcbiAgaW5Ccm93c2VyLFxuICBpc0Jyb3dzZXJPbmxpbmUsXG4gIGlzVmFsaWRCcm93c2VyLFxuICBpc1ZhbGlkQnJvd3Nlck9ubGluZSxcbiAgdXNlckFnZW50SXNSb2JvdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXIubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/browser.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-4LL2VPJL.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-4LL2VPJL.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fastDeepMergeAndKeep: function() { return /* binding */ fastDeepMergeAndKeep; },\n/* harmony export */   fastDeepMergeAndReplace: function() { return /* binding */ fastDeepMergeAndReplace; }\n/* harmony export */ });\n// src/fastDeepMerge.ts\nvar fastDeepMergeAndReplace = (source, target) => {\n  if (!source || !target) {\n    return;\n  }\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== null && typeof source[key] === `object`) {\n      if (target[key] === void 0) {\n        target[key] = new (Object.getPrototypeOf(source[key])).constructor();\n      }\n      fastDeepMergeAndReplace(source[key], target[key]);\n    } else if (Object.prototype.hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  }\n};\nvar fastDeepMergeAndKeep = (source, target) => {\n  if (!source || !target) {\n    return;\n  }\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== null && typeof source[key] === `object`) {\n      if (target[key] === void 0) {\n        target[key] = new (Object.getPrototypeOf(source[key])).constructor();\n      }\n      fastDeepMergeAndKeep(source[key], target[key]);\n    } else if (Object.prototype.hasOwnProperty.call(source, key) && target[key] === void 0) {\n      target[key] = source[key];\n    }\n  }\n};\n\n\n//# sourceMappingURL=chunk-4LL2VPJL.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNExMMlZQSkwubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUtFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay00TEwyVlBKTC5tanM/YjViMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZmFzdERlZXBNZXJnZS50c1xudmFyIGZhc3REZWVwTWVyZ2VBbmRSZXBsYWNlID0gKHNvdXJjZSwgdGFyZ2V0KSA9PiB7XG4gIGlmICghc291cmNlIHx8ICF0YXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkgJiYgc291cmNlW2tleV0gIT09IG51bGwgJiYgdHlwZW9mIHNvdXJjZVtrZXldID09PSBgb2JqZWN0YCkge1xuICAgICAgaWYgKHRhcmdldFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXcgKE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2Vba2V5XSkpLmNvbnN0cnVjdG9yKCk7XG4gICAgICB9XG4gICAgICBmYXN0RGVlcE1lcmdlQW5kUmVwbGFjZShzb3VyY2Vba2V5XSwgdGFyZ2V0W2tleV0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbn07XG52YXIgZmFzdERlZXBNZXJnZUFuZEtlZXAgPSAoc291cmNlLCB0YXJnZXQpID0+IHtcbiAgaWYgKCFzb3VyY2UgfHwgIXRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSAmJiBzb3VyY2Vba2V5XSAhPT0gbnVsbCAmJiB0eXBlb2Ygc291cmNlW2tleV0gPT09IGBvYmplY3RgKSB7XG4gICAgICBpZiAodGFyZ2V0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZVtrZXldKSkuY29uc3RydWN0b3IoKTtcbiAgICAgIH1cbiAgICAgIGZhc3REZWVwTWVyZ2VBbmRLZWVwKHNvdXJjZVtrZXldLCB0YXJnZXRba2V5XSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpICYmIHRhcmdldFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQge1xuICBmYXN0RGVlcE1lcmdlQW5kUmVwbGFjZSxcbiAgZmFzdERlZXBNZXJnZUFuZEtlZXBcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay00TEwyVlBKTC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-4LL2VPJL.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-4PW5MDZA.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-4PW5MDZA.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   callWithRetry: function() { return /* binding */ callWithRetry; }\n/* harmony export */ });\n// src/callWithRetry.ts\nfunction wait(ms) {\n  return new Promise((res) => setTimeout(res, ms));\n}\nvar MAX_NUMBER_OF_RETRIES = 5;\nasync function callWithRetry(fn, attempt = 1, maxAttempts = MAX_NUMBER_OF_RETRIES) {\n  try {\n    return await fn();\n  } catch (e) {\n    if (attempt >= maxAttempts) {\n      throw e;\n    }\n    await wait(2 ** attempt * 100);\n    return callWithRetry(fn, attempt + 1, maxAttempts);\n  }\n}\n\n\n//# sourceMappingURL=chunk-4PW5MDZA.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNFBXNU1EWkEubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay00UFc1TURaQS5tanM/ODQ0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY2FsbFdpdGhSZXRyeS50c1xuZnVuY3Rpb24gd2FpdChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIG1zKSk7XG59XG52YXIgTUFYX05VTUJFUl9PRl9SRVRSSUVTID0gNTtcbmFzeW5jIGZ1bmN0aW9uIGNhbGxXaXRoUmV0cnkoZm4sIGF0dGVtcHQgPSAxLCBtYXhBdHRlbXB0cyA9IE1BWF9OVU1CRVJfT0ZfUkVUUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGF0dGVtcHQgPj0gbWF4QXR0ZW1wdHMpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGF3YWl0IHdhaXQoMiAqKiBhdHRlbXB0ICogMTAwKTtcbiAgICByZXR1cm4gY2FsbFdpdGhSZXRyeShmbiwgYXR0ZW1wdCArIDEsIG1heEF0dGVtcHRzKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBjYWxsV2l0aFJldHJ5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstNFBXNU1EWkEubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-4PW5MDZA.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-5JU2E5TY.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-5JU2E5TY.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extension: function() { return /* binding */ extension; },\n/* harmony export */   readJSONFile: function() { return /* binding */ readJSONFile; }\n/* harmony export */ });\n// src/file.ts\nfunction readJSONFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener(\"load\", function() {\n      const result = JSON.parse(reader.result);\n      resolve(result);\n    });\n    reader.addEventListener(\"error\", reject);\n    reader.readAsText(file);\n  });\n}\nvar MimeTypeToExtensionMap = Object.freeze({\n  \"image/png\": \"png\",\n  \"image/jpeg\": \"jpg\",\n  \"image/gif\": \"gif\",\n  \"image/webp\": \"webp\",\n  \"image/x-icon\": \"ico\",\n  \"image/vnd.microsoft.icon\": \"ico\"\n});\nvar extension = (mimeType) => {\n  return MimeTypeToExtensionMap[mimeType];\n};\n\n\n//# sourceMappingURL=chunk-5JU2E5TY.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNUpVMkU1VFkubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFLRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNUpVMkU1VFkubWpzP2Q5M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2ZpbGUudHNcbmZ1bmN0aW9uIHJlYWRKU09ORmlsZShmaWxlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0pO1xuICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgfSk7XG59XG52YXIgTWltZVR5cGVUb0V4dGVuc2lvbk1hcCA9IE9iamVjdC5mcmVlemUoe1xuICBcImltYWdlL3BuZ1wiOiBcInBuZ1wiLFxuICBcImltYWdlL2pwZWdcIjogXCJqcGdcIixcbiAgXCJpbWFnZS9naWZcIjogXCJnaWZcIixcbiAgXCJpbWFnZS93ZWJwXCI6IFwid2VicFwiLFxuICBcImltYWdlL3gtaWNvblwiOiBcImljb1wiLFxuICBcImltYWdlL3ZuZC5taWNyb3NvZnQuaWNvblwiOiBcImljb1wiXG59KTtcbnZhciBleHRlbnNpb24gPSAobWltZVR5cGUpID0+IHtcbiAgcmV0dXJuIE1pbWVUeXBlVG9FeHRlbnNpb25NYXBbbWltZVR5cGVdO1xufTtcblxuZXhwb3J0IHtcbiAgcmVhZEpTT05GaWxlLFxuICBleHRlbnNpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay01SlUyRTVUWS5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-5JU2E5TY.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isHttpOrHttps: function() { return /* binding */ isHttpOrHttps; },\n/* harmony export */   isProxyUrlRelative: function() { return /* binding */ isProxyUrlRelative; },\n/* harmony export */   isValidProxyUrl: function() { return /* binding */ isValidProxyUrl; },\n/* harmony export */   proxyUrlToAbsoluteURL: function() { return /* binding */ proxyUrlToAbsoluteURL; }\n/* harmony export */ });\n// src/proxy.ts\nfunction isValidProxyUrl(key) {\n  if (!key) {\n    return true;\n  }\n  return isHttpOrHttps(key) || isProxyUrlRelative(key);\n}\nfunction isHttpOrHttps(key) {\n  return /^http(s)?:\\/\\//.test(key || \"\");\n}\nfunction isProxyUrlRelative(key) {\n  return key.startsWith(\"/\");\n}\nfunction proxyUrlToAbsoluteURL(url) {\n  if (!url) {\n    return \"\";\n  }\n  return isProxyUrlRelative(url) ? new URL(url, window.location.origin).toString() : url;\n}\n\n\n//# sourceMappingURL=chunk-6NDGN2IU.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNk5ER04ySVUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNk5ER04ySVUubWpzPzY5M2YiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3Byb3h5LnRzXG5mdW5jdGlvbiBpc1ZhbGlkUHJveHlVcmwoa2V5KSB7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzSHR0cE9ySHR0cHMoa2V5KSB8fCBpc1Byb3h5VXJsUmVsYXRpdmUoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzSHR0cE9ySHR0cHMoa2V5KSB7XG4gIHJldHVybiAvXmh0dHAocyk/OlxcL1xcLy8udGVzdChrZXkgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc1Byb3h5VXJsUmVsYXRpdmUoa2V5KSB7XG4gIHJldHVybiBrZXkuc3RhcnRzV2l0aChcIi9cIik7XG59XG5mdW5jdGlvbiBwcm94eVVybFRvQWJzb2x1dGVVUkwodXJsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIGlzUHJveHlVcmxSZWxhdGl2ZSh1cmwpID8gbmV3IFVSTCh1cmwsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLnRvU3RyaW5nKCkgOiB1cmw7XG59XG5cbmV4cG9ydCB7XG4gIGlzVmFsaWRQcm94eVVybCxcbiAgaXNIdHRwT3JIdHRwcyxcbiAgaXNQcm94eVVybFJlbGF0aXZlLFxuICBwcm94eVVybFRvQWJzb2x1dGVVUkxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay02TkRHTjJJVS5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NISCHKC.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-6NISCHKC.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deriveState: function() { return /* binding */ deriveState; }\n/* harmony export */ });\n// src/deriveState.ts\nvar deriveState = (clerkLoaded, state, initialState) => {\n  if (!clerkLoaded && initialState) {\n    return deriveFromSsrInitialState(initialState);\n  }\n  return deriveFromClientSideState(state);\n};\nvar deriveFromSsrInitialState = (initialState) => {\n  const userId = initialState.userId;\n  const user = initialState.user;\n  const sessionId = initialState.sessionId;\n  const session = initialState.session;\n  const organization = initialState.organization;\n  const orgId = initialState.orgId;\n  const orgRole = initialState.orgRole;\n  const orgPermissions = initialState.orgPermissions;\n  const orgSlug = initialState.orgSlug;\n  const actor = initialState.actor;\n  return {\n    userId,\n    user,\n    sessionId,\n    session,\n    organization,\n    orgId,\n    orgRole,\n    orgPermissions,\n    orgSlug,\n    actor\n  };\n};\nvar deriveFromClientSideState = (state) => {\n  var _a;\n  const userId = state.user ? state.user.id : state.user;\n  const user = state.user;\n  const sessionId = state.session ? state.session.id : state.session;\n  const session = state.session;\n  const actor = session == null ? void 0 : session.actor;\n  const organization = state.organization;\n  const orgId = state.organization ? state.organization.id : state.organization;\n  const orgSlug = organization == null ? void 0 : organization.slug;\n  const membership = organization ? (_a = user == null ? void 0 : user.organizationMemberships) == null ? void 0 : _a.find((om) => om.organization.id === orgId) : organization;\n  const orgPermissions = membership ? membership.permissions : membership;\n  const orgRole = membership ? membership.role : membership;\n  return {\n    userId,\n    user,\n    sessionId,\n    session,\n    organization,\n    orgId,\n    orgRole,\n    orgSlug,\n    orgPermissions,\n    actor\n  };\n};\n\n\n//# sourceMappingURL=chunk-6NISCHKC.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNk5JU0NIS0MubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLTZOSVNDSEtDLm1qcz9hMDQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kZXJpdmVTdGF0ZS50c1xudmFyIGRlcml2ZVN0YXRlID0gKGNsZXJrTG9hZGVkLCBzdGF0ZSwgaW5pdGlhbFN0YXRlKSA9PiB7XG4gIGlmICghY2xlcmtMb2FkZWQgJiYgaW5pdGlhbFN0YXRlKSB7XG4gICAgcmV0dXJuIGRlcml2ZUZyb21Tc3JJbml0aWFsU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgfVxuICByZXR1cm4gZGVyaXZlRnJvbUNsaWVudFNpZGVTdGF0ZShzdGF0ZSk7XG59O1xudmFyIGRlcml2ZUZyb21Tc3JJbml0aWFsU3RhdGUgPSAoaW5pdGlhbFN0YXRlKSA9PiB7XG4gIGNvbnN0IHVzZXJJZCA9IGluaXRpYWxTdGF0ZS51c2VySWQ7XG4gIGNvbnN0IHVzZXIgPSBpbml0aWFsU3RhdGUudXNlcjtcbiAgY29uc3Qgc2Vzc2lvbklkID0gaW5pdGlhbFN0YXRlLnNlc3Npb25JZDtcbiAgY29uc3Qgc2Vzc2lvbiA9IGluaXRpYWxTdGF0ZS5zZXNzaW9uO1xuICBjb25zdCBvcmdhbml6YXRpb24gPSBpbml0aWFsU3RhdGUub3JnYW5pemF0aW9uO1xuICBjb25zdCBvcmdJZCA9IGluaXRpYWxTdGF0ZS5vcmdJZDtcbiAgY29uc3Qgb3JnUm9sZSA9IGluaXRpYWxTdGF0ZS5vcmdSb2xlO1xuICBjb25zdCBvcmdQZXJtaXNzaW9ucyA9IGluaXRpYWxTdGF0ZS5vcmdQZXJtaXNzaW9ucztcbiAgY29uc3Qgb3JnU2x1ZyA9IGluaXRpYWxTdGF0ZS5vcmdTbHVnO1xuICBjb25zdCBhY3RvciA9IGluaXRpYWxTdGF0ZS5hY3RvcjtcbiAgcmV0dXJuIHtcbiAgICB1c2VySWQsXG4gICAgdXNlcixcbiAgICBzZXNzaW9uSWQsXG4gICAgc2Vzc2lvbixcbiAgICBvcmdhbml6YXRpb24sXG4gICAgb3JnSWQsXG4gICAgb3JnUm9sZSxcbiAgICBvcmdQZXJtaXNzaW9ucyxcbiAgICBvcmdTbHVnLFxuICAgIGFjdG9yXG4gIH07XG59O1xudmFyIGRlcml2ZUZyb21DbGllbnRTaWRlU3RhdGUgPSAoc3RhdGUpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB1c2VySWQgPSBzdGF0ZS51c2VyID8gc3RhdGUudXNlci5pZCA6IHN0YXRlLnVzZXI7XG4gIGNvbnN0IHVzZXIgPSBzdGF0ZS51c2VyO1xuICBjb25zdCBzZXNzaW9uSWQgPSBzdGF0ZS5zZXNzaW9uID8gc3RhdGUuc2Vzc2lvbi5pZCA6IHN0YXRlLnNlc3Npb247XG4gIGNvbnN0IHNlc3Npb24gPSBzdGF0ZS5zZXNzaW9uO1xuICBjb25zdCBhY3RvciA9IHNlc3Npb24gPT0gbnVsbCA/IHZvaWQgMCA6IHNlc3Npb24uYWN0b3I7XG4gIGNvbnN0IG9yZ2FuaXphdGlvbiA9IHN0YXRlLm9yZ2FuaXphdGlvbjtcbiAgY29uc3Qgb3JnSWQgPSBzdGF0ZS5vcmdhbml6YXRpb24gPyBzdGF0ZS5vcmdhbml6YXRpb24uaWQgOiBzdGF0ZS5vcmdhbml6YXRpb247XG4gIGNvbnN0IG9yZ1NsdWcgPSBvcmdhbml6YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IG9yZ2FuaXphdGlvbi5zbHVnO1xuICBjb25zdCBtZW1iZXJzaGlwID0gb3JnYW5pemF0aW9uID8gKF9hID0gdXNlciA9PSBudWxsID8gdm9pZCAwIDogdXNlci5vcmdhbml6YXRpb25NZW1iZXJzaGlwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZpbmQoKG9tKSA9PiBvbS5vcmdhbml6YXRpb24uaWQgPT09IG9yZ0lkKSA6IG9yZ2FuaXphdGlvbjtcbiAgY29uc3Qgb3JnUGVybWlzc2lvbnMgPSBtZW1iZXJzaGlwID8gbWVtYmVyc2hpcC5wZXJtaXNzaW9ucyA6IG1lbWJlcnNoaXA7XG4gIGNvbnN0IG9yZ1JvbGUgPSBtZW1iZXJzaGlwID8gbWVtYmVyc2hpcC5yb2xlIDogbWVtYmVyc2hpcDtcbiAgcmV0dXJuIHtcbiAgICB1c2VySWQsXG4gICAgdXNlcixcbiAgICBzZXNzaW9uSWQsXG4gICAgc2Vzc2lvbixcbiAgICBvcmdhbml6YXRpb24sXG4gICAgb3JnSWQsXG4gICAgb3JnUm9sZSxcbiAgICBvcmdTbHVnLFxuICAgIG9yZ1Blcm1pc3Npb25zLFxuICAgIGFjdG9yXG4gIH07XG59O1xuXG5leHBvcnQge1xuICBkZXJpdmVTdGF0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLTZOSVNDSEtDLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NISCHKC.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-752VSHHB.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-752VSHHB.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildClerkJsScriptAttributes: function() { return /* binding */ buildClerkJsScriptAttributes; },\n/* harmony export */   clerkJsScriptUrl: function() { return /* binding */ clerkJsScriptUrl; },\n/* harmony export */   loadClerkJsScript: function() { return /* binding */ loadClerkJsScript; },\n/* harmony export */   setClerkJsLoadingErrorPackageName: function() { return /* binding */ setClerkJsLoadingErrorPackageName; }\n/* harmony export */ });\n/* harmony import */ var _chunk_TVXNN3J6_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-TVXNN3J6.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TVXNN3J6.mjs\");\n/* harmony import */ var _chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-6NDGN2IU.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs\");\n/* harmony import */ var _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-Q2DOGLDC.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-Q2DOGLDC.mjs\");\n/* harmony import */ var _chunk_DSMUR7RM_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-DSMUR7RM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-DSMUR7RM.mjs\");\n/* harmony import */ var _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-IB6GRLVO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IB6GRLVO.mjs\");\n/* harmony import */ var _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-L2BNNARM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-L2BNNARM.mjs\");\n\n\n\n\n\n\n\n// src/loadClerkJsScript.ts\nvar FAILED_TO_LOAD_ERROR = \"Clerk: Failed to load Clerk\";\nvar { isDevOrStagingUrl } = (0,_chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_5__.createDevOrStagingUrlCache)();\nvar errorThrower = (0,_chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_4__.buildErrorThrower)({ packageName: \"@clerk/shared\" });\nfunction setClerkJsLoadingErrorPackageName(packageName) {\n  errorThrower.setPackageName({ packageName });\n}\nvar loadClerkJsScript = async (opts) => {\n  const existingScript = document.querySelector(\"script[data-clerk-js-script]\");\n  if (existingScript) {\n    return new Promise((resolve, reject) => {\n      existingScript.addEventListener(\"load\", () => {\n        resolve(existingScript);\n      });\n      existingScript.addEventListener(\"error\", () => {\n        reject(FAILED_TO_LOAD_ERROR);\n      });\n    });\n  }\n  if (!(opts == null ? void 0 : opts.publishableKey)) {\n    errorThrower.throwMissingPublishableKeyError();\n    return;\n  }\n  return (0,_chunk_DSMUR7RM_mjs__WEBPACK_IMPORTED_MODULE_3__.loadScript)(clerkJsScriptUrl(opts), {\n    async: true,\n    crossOrigin: \"anonymous\",\n    nonce: opts.nonce,\n    beforeLoad: applyClerkJsScriptAttributes(opts)\n  }).catch(() => {\n    throw new Error(FAILED_TO_LOAD_ERROR);\n  });\n};\nvar clerkJsScriptUrl = (opts) => {\n  var _a, _b;\n  const { clerkJSUrl, clerkJSVariant, clerkJSVersion, proxyUrl, domain, publishableKey } = opts;\n  if (clerkJSUrl) {\n    return clerkJSUrl;\n  }\n  let scriptHost = \"\";\n  if (!!proxyUrl && (0,_chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_1__.isValidProxyUrl)(proxyUrl)) {\n    scriptHost = (0,_chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_1__.proxyUrlToAbsoluteURL)(proxyUrl).replace(/http(s)?:\\/\\//, \"\");\n  } else if (domain && !isDevOrStagingUrl(((_a = (0,_chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_5__.parsePublishableKey)(publishableKey)) == null ? void 0 : _a.frontendApi) || \"\")) {\n    scriptHost = (0,_chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_2__.addClerkPrefix)(domain);\n  } else {\n    scriptHost = ((_b = (0,_chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_5__.parsePublishableKey)(publishableKey)) == null ? void 0 : _b.frontendApi) || \"\";\n  }\n  const variant = clerkJSVariant ? `${clerkJSVariant.replace(/\\.+$/, \"\")}.` : \"\";\n  const version = (0,_chunk_TVXNN3J6_mjs__WEBPACK_IMPORTED_MODULE_0__.versionSelector)(clerkJSVersion);\n  return `https://${scriptHost}/npm/@clerk/clerk-js@${version}/dist/clerk.${variant}browser.js`;\n};\nvar buildClerkJsScriptAttributes = (options) => {\n  const obj = {};\n  if (options.publishableKey) {\n    obj[\"data-clerk-publishable-key\"] = options.publishableKey;\n  }\n  if (options.proxyUrl) {\n    obj[\"data-clerk-proxy-url\"] = options.proxyUrl;\n  }\n  if (options.domain) {\n    obj[\"data-clerk-domain\"] = options.domain;\n  }\n  if (options.nonce) {\n    obj.nonce = options.nonce;\n  }\n  return obj;\n};\nvar applyClerkJsScriptAttributes = (options) => (script) => {\n  const attributes = buildClerkJsScriptAttributes(options);\n  for (const attribute in attributes) {\n    script.setAttribute(attribute, attributes[attribute]);\n  }\n};\n\n\n//# sourceMappingURL=chunk-752VSHHB.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstNzUyVlNISEIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFOEI7QUFJQTtBQUdBO0FBR0E7QUFHQTtBQUlBOztBQUU5QjtBQUNBO0FBQ0EsTUFBTSxvQkFBb0IsRUFBRSwrRUFBMEI7QUFDdEQsbUJBQW1CLHNFQUFpQixHQUFHLDhCQUE4QjtBQUNyRTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0VBQStFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9FQUFlO0FBQ25DLGlCQUFpQiwwRUFBcUI7QUFDdEMsSUFBSSw2Q0FBNkMsd0VBQW1CO0FBQ3BFLGlCQUFpQixtRUFBYztBQUMvQixJQUFJO0FBQ0osd0JBQXdCLHdFQUFtQjtBQUMzQztBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekUsa0JBQWtCLG9FQUFlO0FBQ2pDLG9CQUFvQixXQUFXLHVCQUF1QixRQUFRLGNBQWMsUUFBUTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay03NTJWU0hIQi5tanM/YTliYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICB2ZXJzaW9uU2VsZWN0b3Jcbn0gZnJvbSBcIi4vY2h1bmstVFZYTk4zSjYubWpzXCI7XG5pbXBvcnQge1xuICBpc1ZhbGlkUHJveHlVcmwsXG4gIHByb3h5VXJsVG9BYnNvbHV0ZVVSTFxufSBmcm9tIFwiLi9jaHVuay02TkRHTjJJVS5tanNcIjtcbmltcG9ydCB7XG4gIGFkZENsZXJrUHJlZml4XG59IGZyb20gXCIuL2NodW5rLVEyRE9HTERDLm1qc1wiO1xuaW1wb3J0IHtcbiAgbG9hZFNjcmlwdFxufSBmcm9tIFwiLi9jaHVuay1EU01VUjdSTS5tanNcIjtcbmltcG9ydCB7XG4gIGJ1aWxkRXJyb3JUaHJvd2VyXG59IGZyb20gXCIuL2NodW5rLUlCNkdSTFZPLm1qc1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlRGV2T3JTdGFnaW5nVXJsQ2FjaGUsXG4gIHBhcnNlUHVibGlzaGFibGVLZXlcbn0gZnJvbSBcIi4vY2h1bmstTDJCTk5BUk0ubWpzXCI7XG5cbi8vIHNyYy9sb2FkQ2xlcmtKc1NjcmlwdC50c1xudmFyIEZBSUxFRF9UT19MT0FEX0VSUk9SID0gXCJDbGVyazogRmFpbGVkIHRvIGxvYWQgQ2xlcmtcIjtcbnZhciB7IGlzRGV2T3JTdGFnaW5nVXJsIH0gPSBjcmVhdGVEZXZPclN0YWdpbmdVcmxDYWNoZSgpO1xudmFyIGVycm9yVGhyb3dlciA9IGJ1aWxkRXJyb3JUaHJvd2VyKHsgcGFja2FnZU5hbWU6IFwiQGNsZXJrL3NoYXJlZFwiIH0pO1xuZnVuY3Rpb24gc2V0Q2xlcmtKc0xvYWRpbmdFcnJvclBhY2thZ2VOYW1lKHBhY2thZ2VOYW1lKSB7XG4gIGVycm9yVGhyb3dlci5zZXRQYWNrYWdlTmFtZSh7IHBhY2thZ2VOYW1lIH0pO1xufVxudmFyIGxvYWRDbGVya0pzU2NyaXB0ID0gYXN5bmMgKG9wdHMpID0+IHtcbiAgY29uc3QgZXhpc3RpbmdTY3JpcHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic2NyaXB0W2RhdGEtY2xlcmstanMtc2NyaXB0XVwiKTtcbiAgaWYgKGV4aXN0aW5nU2NyaXB0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGV4aXN0aW5nU2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShleGlzdGluZ1NjcmlwdCk7XG4gICAgICB9KTtcbiAgICAgIGV4aXN0aW5nU2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgIHJlamVjdChGQUlMRURfVE9fTE9BRF9FUlJPUik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIShvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnB1Ymxpc2hhYmxlS2V5KSkge1xuICAgIGVycm9yVGhyb3dlci50aHJvd01pc3NpbmdQdWJsaXNoYWJsZUtleUVycm9yKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBsb2FkU2NyaXB0KGNsZXJrSnNTY3JpcHRVcmwob3B0cyksIHtcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBjcm9zc09yaWdpbjogXCJhbm9ueW1vdXNcIixcbiAgICBub25jZTogb3B0cy5ub25jZSxcbiAgICBiZWZvcmVMb2FkOiBhcHBseUNsZXJrSnNTY3JpcHRBdHRyaWJ1dGVzKG9wdHMpXG4gIH0pLmNhdGNoKCgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRkFJTEVEX1RPX0xPQURfRVJST1IpO1xuICB9KTtcbn07XG52YXIgY2xlcmtKc1NjcmlwdFVybCA9IChvcHRzKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHsgY2xlcmtKU1VybCwgY2xlcmtKU1ZhcmlhbnQsIGNsZXJrSlNWZXJzaW9uLCBwcm94eVVybCwgZG9tYWluLCBwdWJsaXNoYWJsZUtleSB9ID0gb3B0cztcbiAgaWYgKGNsZXJrSlNVcmwpIHtcbiAgICByZXR1cm4gY2xlcmtKU1VybDtcbiAgfVxuICBsZXQgc2NyaXB0SG9zdCA9IFwiXCI7XG4gIGlmICghIXByb3h5VXJsICYmIGlzVmFsaWRQcm94eVVybChwcm94eVVybCkpIHtcbiAgICBzY3JpcHRIb3N0ID0gcHJveHlVcmxUb0Fic29sdXRlVVJMKHByb3h5VXJsKS5yZXBsYWNlKC9odHRwKHMpPzpcXC9cXC8vLCBcIlwiKTtcbiAgfSBlbHNlIGlmIChkb21haW4gJiYgIWlzRGV2T3JTdGFnaW5nVXJsKCgoX2EgPSBwYXJzZVB1Ymxpc2hhYmxlS2V5KHB1Ymxpc2hhYmxlS2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZyb250ZW5kQXBpKSB8fCBcIlwiKSkge1xuICAgIHNjcmlwdEhvc3QgPSBhZGRDbGVya1ByZWZpeChkb21haW4pO1xuICB9IGVsc2Uge1xuICAgIHNjcmlwdEhvc3QgPSAoKF9iID0gcGFyc2VQdWJsaXNoYWJsZUtleShwdWJsaXNoYWJsZUtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mcm9udGVuZEFwaSkgfHwgXCJcIjtcbiAgfVxuICBjb25zdCB2YXJpYW50ID0gY2xlcmtKU1ZhcmlhbnQgPyBgJHtjbGVya0pTVmFyaWFudC5yZXBsYWNlKC9cXC4rJC8sIFwiXCIpfS5gIDogXCJcIjtcbiAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25TZWxlY3RvcihjbGVya0pTVmVyc2lvbik7XG4gIHJldHVybiBgaHR0cHM6Ly8ke3NjcmlwdEhvc3R9L25wbS9AY2xlcmsvY2xlcmstanNAJHt2ZXJzaW9ufS9kaXN0L2NsZXJrLiR7dmFyaWFudH1icm93c2VyLmpzYDtcbn07XG52YXIgYnVpbGRDbGVya0pzU2NyaXB0QXR0cmlidXRlcyA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBpZiAob3B0aW9ucy5wdWJsaXNoYWJsZUtleSkge1xuICAgIG9ialtcImRhdGEtY2xlcmstcHVibGlzaGFibGUta2V5XCJdID0gb3B0aW9ucy5wdWJsaXNoYWJsZUtleTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcm94eVVybCkge1xuICAgIG9ialtcImRhdGEtY2xlcmstcHJveHktdXJsXCJdID0gb3B0aW9ucy5wcm94eVVybDtcbiAgfVxuICBpZiAob3B0aW9ucy5kb21haW4pIHtcbiAgICBvYmpbXCJkYXRhLWNsZXJrLWRvbWFpblwiXSA9IG9wdGlvbnMuZG9tYWluO1xuICB9XG4gIGlmIChvcHRpb25zLm5vbmNlKSB7XG4gICAgb2JqLm5vbmNlID0gb3B0aW9ucy5ub25jZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcbnZhciBhcHBseUNsZXJrSnNTY3JpcHRBdHRyaWJ1dGVzID0gKG9wdGlvbnMpID0+IChzY3JpcHQpID0+IHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGJ1aWxkQ2xlcmtKc1NjcmlwdEF0dHJpYnV0ZXMob3B0aW9ucyk7XG4gIGZvciAoY29uc3QgYXR0cmlidXRlIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVdKTtcbiAgfVxufTtcblxuZXhwb3J0IHtcbiAgc2V0Q2xlcmtKc0xvYWRpbmdFcnJvclBhY2thZ2VOYW1lLFxuICBsb2FkQ2xlcmtKc1NjcmlwdCxcbiAgY2xlcmtKc1NjcmlwdFVybCxcbiAgYnVpbGRDbGVya0pzU2NyaXB0QXR0cmlidXRlc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLTc1MlZTSEhCLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-752VSHHB.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __export: function() { return /* binding */ __export; },\n/* harmony export */   __privateAdd: function() { return /* binding */ __privateAdd; },\n/* harmony export */   __privateGet: function() { return /* binding */ __privateGet; },\n/* harmony export */   __privateMethod: function() { return /* binding */ __privateMethod; },\n/* harmony export */   __privateSet: function() { return /* binding */ __privateSet; },\n/* harmony export */   __reExport: function() { return /* binding */ __reExport; }\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n\n//# sourceMappingURL=chunk-7ELT755Q.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstN0VMVDc1NVEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay03RUxUNzU1US5tanM/YjQ0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3R5cGVFcnJvciA9IChtc2cpID0+IHtcbiAgdGhyb3cgVHlwZUVycm9yKG1zZyk7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2QsIHNlY29uZFRhcmdldCkgPT4gKF9fY29weVByb3BzKHRhcmdldCwgbW9kLCBcImRlZmF1bHRcIiksIHNlY29uZFRhcmdldCAmJiBfX2NvcHlQcm9wcyhzZWNvbmRUYXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpKTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IG1lbWJlci5oYXMob2JqKSB8fCBfX3R5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKSwgdmFsdWUpO1xudmFyIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIiksIG1ldGhvZCk7XG5cbmV4cG9ydCB7XG4gIF9fZXhwb3J0LFxuICBfX3JlRXhwb3J0LFxuICBfX3ByaXZhdGVHZXQsXG4gIF9fcHJpdmF0ZUFkZCxcbiAgX19wcml2YXRlU2V0LFxuICBfX3ByaXZhdGVNZXRob2Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay03RUxUNzU1US5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-CFXQSUF6.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-CFXQSUF6.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyFunctionToObj: function() { return /* binding */ applyFunctionToObj; },\n/* harmony export */   filterProps: function() { return /* binding */ filterProps; },\n/* harmony export */   removeUndefined: function() { return /* binding */ removeUndefined; },\n/* harmony export */   without: function() { return /* binding */ without; }\n/* harmony export */ });\n// src/object.ts\nvar without = (obj, ...props) => {\n  const copy = { ...obj };\n  for (const prop of props) {\n    delete copy[prop];\n  }\n  return copy;\n};\nvar removeUndefined = (obj) => {\n  return Object.entries(obj).reduce((acc, [key, value]) => {\n    if (value !== void 0 && value !== null) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n};\nvar applyFunctionToObj = (obj, fn) => {\n  const result = {};\n  for (const key in obj) {\n    result[key] = fn(obj[key], key);\n  }\n  return result;\n};\nvar filterProps = (obj, filter) => {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] && filter(obj[key])) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n};\n\n\n//# sourceMappingURL=chunk-CFXQSUF6.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstQ0ZYUVNVRjYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1DRlhRU1VGNi5tanM/MDhiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvb2JqZWN0LnRzXG52YXIgd2l0aG91dCA9IChvYmosIC4uLnByb3BzKSA9PiB7XG4gIGNvbnN0IGNvcHkgPSB7IC4uLm9iaiB9O1xuICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICBkZWxldGUgY29weVtwcm9wXTtcbiAgfVxuICByZXR1cm4gY29weTtcbn07XG52YXIgcmVtb3ZlVW5kZWZpbmVkID0gKG9iaikgPT4ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07XG52YXIgYXBwbHlGdW5jdGlvblRvT2JqID0gKG9iaiwgZm4pID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJlc3VsdFtrZXldID0gZm4ob2JqW2tleV0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgZmlsdGVyUHJvcHMgPSAob2JqLCBmaWx0ZXIpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChvYmpba2V5XSAmJiBmaWx0ZXIob2JqW2tleV0pKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IHtcbiAgd2l0aG91dCxcbiAgcmVtb3ZlVW5kZWZpbmVkLFxuICBhcHBseUZ1bmN0aW9uVG9PYmosXG4gIGZpbHRlclByb3BzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstQ0ZYUVNVRjYubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-CFXQSUF6.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-CYDR2ZSA.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-CYDR2ZSA.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   logger: function() { return /* binding */ logger; }\n/* harmony export */ });\n// src/logger.ts\nvar loggedMessages = /* @__PURE__ */ new Set();\nvar logger = {\n  /**\n   * A custom logger that ensures messages are logged only once.\n   * Reduces noise and duplicated messages when logs are in a hot codepath.\n   */\n  warnOnce: (msg) => {\n    if (loggedMessages.has(msg)) {\n      return;\n    }\n    loggedMessages.add(msg);\n    console.warn(msg);\n  },\n  logOnce: (msg) => {\n    if (loggedMessages.has(msg)) {\n      return;\n    }\n    console.log(msg);\n    loggedMessages.add(msg);\n  }\n};\n\n\n//# sourceMappingURL=chunk-CYDR2ZSA.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstQ1lEUjJaU0EubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1DWURSMlpTQS5tanM/NDQyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbG9nZ2VyLnRzXG52YXIgbG9nZ2VkTWVzc2FnZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIGxvZ2dlciA9IHtcbiAgLyoqXG4gICAqIEEgY3VzdG9tIGxvZ2dlciB0aGF0IGVuc3VyZXMgbWVzc2FnZXMgYXJlIGxvZ2dlZCBvbmx5IG9uY2UuXG4gICAqIFJlZHVjZXMgbm9pc2UgYW5kIGR1cGxpY2F0ZWQgbWVzc2FnZXMgd2hlbiBsb2dzIGFyZSBpbiBhIGhvdCBjb2RlcGF0aC5cbiAgICovXG4gIHdhcm5PbmNlOiAobXNnKSA9PiB7XG4gICAgaWYgKGxvZ2dlZE1lc3NhZ2VzLmhhcyhtc2cpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlZE1lc3NhZ2VzLmFkZChtc2cpO1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICB9LFxuICBsb2dPbmNlOiAobXNnKSA9PiB7XG4gICAgaWYgKGxvZ2dlZE1lc3NhZ2VzLmhhcyhtc2cpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgbG9nZ2VkTWVzc2FnZXMuYWRkKG1zZyk7XG4gIH1cbn07XG5cbmV4cG9ydCB7XG4gIGxvZ2dlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUNZRFIyWlNBLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-CYDR2ZSA.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-DSMUR7RM.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-DSMUR7RM.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadScript: function() { return /* binding */ loadScript; }\n/* harmony export */ });\n// src/loadScript.ts\nvar NO_DOCUMENT_ERROR = \"loadScript cannot be called when document does not exist\";\nvar NO_SRC_ERROR = \"loadScript cannot be called without a src\";\nasync function loadScript(src = \"\", opts) {\n  const { async, defer, beforeLoad, crossOrigin, nonce } = opts || {};\n  return new Promise((resolve, reject) => {\n    if (!src) {\n      reject(NO_SRC_ERROR);\n    }\n    if (!document || !document.body) {\n      reject(NO_DOCUMENT_ERROR);\n    }\n    const script = document.createElement(\"script\");\n    crossOrigin && script.setAttribute(\"crossorigin\", crossOrigin);\n    script.async = async || false;\n    script.defer = defer || false;\n    script.addEventListener(\"load\", () => {\n      script.remove();\n      resolve(script);\n    });\n    script.addEventListener(\"error\", () => {\n      script.remove();\n      reject();\n    });\n    script.src = src;\n    script.nonce = nonce;\n    beforeLoad == null ? void 0 : beforeLoad(script);\n    document.body.appendChild(script);\n  });\n}\n\n\n//# sourceMappingURL=chunk-DSMUR7RM.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstRFNNVVI3Uk0ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1EU01VUjdSTS5tanM/MmNjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbG9hZFNjcmlwdC50c1xudmFyIE5PX0RPQ1VNRU5UX0VSUk9SID0gXCJsb2FkU2NyaXB0IGNhbm5vdCBiZSBjYWxsZWQgd2hlbiBkb2N1bWVudCBkb2VzIG5vdCBleGlzdFwiO1xudmFyIE5PX1NSQ19FUlJPUiA9IFwibG9hZFNjcmlwdCBjYW5ub3QgYmUgY2FsbGVkIHdpdGhvdXQgYSBzcmNcIjtcbmFzeW5jIGZ1bmN0aW9uIGxvYWRTY3JpcHQoc3JjID0gXCJcIiwgb3B0cykge1xuICBjb25zdCB7IGFzeW5jLCBkZWZlciwgYmVmb3JlTG9hZCwgY3Jvc3NPcmlnaW4sIG5vbmNlIH0gPSBvcHRzIHx8IHt9O1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICghc3JjKSB7XG4gICAgICByZWplY3QoTk9fU1JDX0VSUk9SKTtcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudCB8fCAhZG9jdW1lbnQuYm9keSkge1xuICAgICAgcmVqZWN0KE5PX0RPQ1VNRU5UX0VSUk9SKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBjcm9zc09yaWdpbiAmJiBzY3JpcHQuc2V0QXR0cmlidXRlKFwiY3Jvc3NvcmlnaW5cIiwgY3Jvc3NPcmlnaW4pO1xuICAgIHNjcmlwdC5hc3luYyA9IGFzeW5jIHx8IGZhbHNlO1xuICAgIHNjcmlwdC5kZWZlciA9IGRlZmVyIHx8IGZhbHNlO1xuICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICBzY3JpcHQucmVtb3ZlKCk7XG4gICAgICByZXNvbHZlKHNjcmlwdCk7XG4gICAgfSk7XG4gICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICBzY3JpcHQucmVtb3ZlKCk7XG4gICAgICByZWplY3QoKTtcbiAgICB9KTtcbiAgICBzY3JpcHQuc3JjID0gc3JjO1xuICAgIHNjcmlwdC5ub25jZSA9IG5vbmNlO1xuICAgIGJlZm9yZUxvYWQgPT0gbnVsbCA/IHZvaWQgMCA6IGJlZm9yZUxvYWQoc2NyaXB0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH0pO1xufVxuXG5leHBvcnQge1xuICBsb2FkU2NyaXB0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstRFNNVVI3Uk0ubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-DSMUR7RM.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-FSKKI4LG.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-FSKKI4LG.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addYears: function() { return /* binding */ addYears; },\n/* harmony export */   dateTo12HourTime: function() { return /* binding */ dateTo12HourTime; },\n/* harmony export */   differenceInCalendarDays: function() { return /* binding */ differenceInCalendarDays; },\n/* harmony export */   formatRelative: function() { return /* binding */ formatRelative; },\n/* harmony export */   normalizeDate: function() { return /* binding */ normalizeDate; }\n/* harmony export */ });\n// src/date.ts\nvar MILLISECONDS_IN_DAY = 864e5;\nfunction dateTo12HourTime(date) {\n  if (!date) {\n    return \"\";\n  }\n  return date.toLocaleString(\"en-US\", {\n    hour: \"2-digit\",\n    minute: \"numeric\",\n    hour12: true\n  });\n}\nfunction differenceInCalendarDays(a, b, { absolute = true } = {}) {\n  if (!a || !b) {\n    return 0;\n  }\n  const utcA = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());\n  const utcB = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());\n  const diff = Math.floor((utcB - utcA) / MILLISECONDS_IN_DAY);\n  return absolute ? Math.abs(diff) : diff;\n}\nfunction normalizeDate(d) {\n  try {\n    return new Date(d || /* @__PURE__ */ new Date());\n  } catch (e) {\n    return /* @__PURE__ */ new Date();\n  }\n}\nfunction formatRelative(props) {\n  const { date, relativeTo } = props;\n  if (!date || !relativeTo) {\n    return null;\n  }\n  const a = normalizeDate(date);\n  const b = normalizeDate(relativeTo);\n  const differenceInDays = differenceInCalendarDays(b, a, { absolute: false });\n  if (differenceInDays < -6) {\n    return { relativeDateCase: \"other\", date: a };\n  }\n  if (differenceInDays < -1) {\n    return { relativeDateCase: \"previous6Days\", date: a };\n  }\n  if (differenceInDays === -1) {\n    return { relativeDateCase: \"lastDay\", date: a };\n  }\n  if (differenceInDays === 0) {\n    return { relativeDateCase: \"sameDay\", date: a };\n  }\n  if (differenceInDays === 1) {\n    return { relativeDateCase: \"nextDay\", date: a };\n  }\n  if (differenceInDays < 7) {\n    return { relativeDateCase: \"next6Days\", date: a };\n  }\n  return { relativeDateCase: \"other\", date: a };\n}\nfunction addYears(initialDate, yearsToAdd) {\n  const date = normalizeDate(initialDate);\n  date.setFullYear(date.getFullYear() + yearsToAdd);\n  return date;\n}\n\n\n//# sourceMappingURL=chunk-FSKKI4LG.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstRlNLS0k0TEcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQ0FBMEMsa0JBQWtCLElBQUk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLUZTS0tJNExHLm1qcz81ZTU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kYXRlLnRzXG52YXIgTUlMTElTRUNPTkRTX0lOX0RBWSA9IDg2NGU1O1xuZnVuY3Rpb24gZGF0ZVRvMTJIb3VyVGltZShkYXRlKSB7XG4gIGlmICghZGF0ZSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHJldHVybiBkYXRlLnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIiwge1xuICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgIG1pbnV0ZTogXCJudW1lcmljXCIsXG4gICAgaG91cjEyOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKGEsIGIsIHsgYWJzb2x1dGUgPSB0cnVlIH0gPSB7fSkge1xuICBpZiAoIWEgfHwgIWIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCB1dGNBID0gRGF0ZS5VVEMoYS5nZXRGdWxsWWVhcigpLCBhLmdldE1vbnRoKCksIGEuZ2V0RGF0ZSgpKTtcbiAgY29uc3QgdXRjQiA9IERhdGUuVVRDKGIuZ2V0RnVsbFllYXIoKSwgYi5nZXRNb250aCgpLCBiLmdldERhdGUoKSk7XG4gIGNvbnN0IGRpZmYgPSBNYXRoLmZsb29yKCh1dGNCIC0gdXRjQSkgLyBNSUxMSVNFQ09ORFNfSU5fREFZKTtcbiAgcmV0dXJuIGFic29sdXRlID8gTWF0aC5hYnMoZGlmZikgOiBkaWZmO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRGF0ZShkKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGQgfHwgLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICB9XG59XG5mdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZShwcm9wcykge1xuICBjb25zdCB7IGRhdGUsIHJlbGF0aXZlVG8gfSA9IHByb3BzO1xuICBpZiAoIWRhdGUgfHwgIXJlbGF0aXZlVG8pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhID0gbm9ybWFsaXplRGF0ZShkYXRlKTtcbiAgY29uc3QgYiA9IG5vcm1hbGl6ZURhdGUocmVsYXRpdmVUbyk7XG4gIGNvbnN0IGRpZmZlcmVuY2VJbkRheXMgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoYiwgYSwgeyBhYnNvbHV0ZTogZmFsc2UgfSk7XG4gIGlmIChkaWZmZXJlbmNlSW5EYXlzIDwgLTYpIHtcbiAgICByZXR1cm4geyByZWxhdGl2ZURhdGVDYXNlOiBcIm90aGVyXCIsIGRhdGU6IGEgfTtcbiAgfVxuICBpZiAoZGlmZmVyZW5jZUluRGF5cyA8IC0xKSB7XG4gICAgcmV0dXJuIHsgcmVsYXRpdmVEYXRlQ2FzZTogXCJwcmV2aW91czZEYXlzXCIsIGRhdGU6IGEgfTtcbiAgfVxuICBpZiAoZGlmZmVyZW5jZUluRGF5cyA9PT0gLTEpIHtcbiAgICByZXR1cm4geyByZWxhdGl2ZURhdGVDYXNlOiBcImxhc3REYXlcIiwgZGF0ZTogYSB9O1xuICB9XG4gIGlmIChkaWZmZXJlbmNlSW5EYXlzID09PSAwKSB7XG4gICAgcmV0dXJuIHsgcmVsYXRpdmVEYXRlQ2FzZTogXCJzYW1lRGF5XCIsIGRhdGU6IGEgfTtcbiAgfVxuICBpZiAoZGlmZmVyZW5jZUluRGF5cyA9PT0gMSkge1xuICAgIHJldHVybiB7IHJlbGF0aXZlRGF0ZUNhc2U6IFwibmV4dERheVwiLCBkYXRlOiBhIH07XG4gIH1cbiAgaWYgKGRpZmZlcmVuY2VJbkRheXMgPCA3KSB7XG4gICAgcmV0dXJuIHsgcmVsYXRpdmVEYXRlQ2FzZTogXCJuZXh0NkRheXNcIiwgZGF0ZTogYSB9O1xuICB9XG4gIHJldHVybiB7IHJlbGF0aXZlRGF0ZUNhc2U6IFwib3RoZXJcIiwgZGF0ZTogYSB9O1xufVxuZnVuY3Rpb24gYWRkWWVhcnMoaW5pdGlhbERhdGUsIHllYXJzVG9BZGQpIHtcbiAgY29uc3QgZGF0ZSA9IG5vcm1hbGl6ZURhdGUoaW5pdGlhbERhdGUpO1xuICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHllYXJzVG9BZGQpO1xuICByZXR1cm4gZGF0ZTtcbn1cblxuZXhwb3J0IHtcbiAgZGF0ZVRvMTJIb3VyVGltZSxcbiAgZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzLFxuICBub3JtYWxpemVEYXRlLFxuICBmb3JtYXRSZWxhdGl2ZSxcbiAgYWRkWWVhcnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1GU0tLSTRMRy5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-FSKKI4LG.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURRENT_DEV_INSTANCE_SUFFIXES: function() { return /* binding */ CURRENT_DEV_INSTANCE_SUFFIXES; },\n/* harmony export */   DEV_OR_STAGING_SUFFIXES: function() { return /* binding */ DEV_OR_STAGING_SUFFIXES; },\n/* harmony export */   LEGACY_DEV_INSTANCE_SUFFIXES: function() { return /* binding */ LEGACY_DEV_INSTANCE_SUFFIXES; },\n/* harmony export */   LOCAL_API_URL: function() { return /* binding */ LOCAL_API_URL; },\n/* harmony export */   LOCAL_ENV_SUFFIXES: function() { return /* binding */ LOCAL_ENV_SUFFIXES; },\n/* harmony export */   PROD_API_URL: function() { return /* binding */ PROD_API_URL; },\n/* harmony export */   STAGING_API_URL: function() { return /* binding */ STAGING_API_URL; },\n/* harmony export */   STAGING_ENV_SUFFIXES: function() { return /* binding */ STAGING_ENV_SUFFIXES; },\n/* harmony export */   iconImageUrl: function() { return /* binding */ iconImageUrl; }\n/* harmony export */ });\n// src/constants.ts\nvar LEGACY_DEV_INSTANCE_SUFFIXES = [\".lcl.dev\", \".lclstage.dev\", \".lclclerk.com\"];\nvar CURRENT_DEV_INSTANCE_SUFFIXES = [\".accounts.dev\", \".accountsstage.dev\", \".accounts.lclclerk.com\"];\nvar DEV_OR_STAGING_SUFFIXES = [\n  \".lcl.dev\",\n  \".stg.dev\",\n  \".lclstage.dev\",\n  \".stgstage.dev\",\n  \".dev.lclclerk.com\",\n  \".stg.lclclerk.com\",\n  \".accounts.lclclerk.com\",\n  \"accountsstage.dev\",\n  \"accounts.dev\"\n];\nvar LOCAL_ENV_SUFFIXES = [\".lcl.dev\", \"lclstage.dev\", \".lclclerk.com\", \".accounts.lclclerk.com\"];\nvar STAGING_ENV_SUFFIXES = [\".accountsstage.dev\"];\nvar LOCAL_API_URL = \"https://api.lclclerk.com\";\nvar STAGING_API_URL = \"https://api.clerkstage.dev\";\nvar PROD_API_URL = \"https://api.clerk.com\";\nfunction iconImageUrl(id, format = \"svg\") {\n  return `https://img.clerk.com/static/${id}.${format}`;\n}\n\n\n//# sourceMappingURL=chunk-I6MTSTOF.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSTZNVFNUT0YubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRyxHQUFHLE9BQU87QUFDdEQ7O0FBWUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLUk2TVRTVE9GLm1qcz84ODZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBMRUdBQ1lfREVWX0lOU1RBTkNFX1NVRkZJWEVTID0gW1wiLmxjbC5kZXZcIiwgXCIubGNsc3RhZ2UuZGV2XCIsIFwiLmxjbGNsZXJrLmNvbVwiXTtcbnZhciBDVVJSRU5UX0RFVl9JTlNUQU5DRV9TVUZGSVhFUyA9IFtcIi5hY2NvdW50cy5kZXZcIiwgXCIuYWNjb3VudHNzdGFnZS5kZXZcIiwgXCIuYWNjb3VudHMubGNsY2xlcmsuY29tXCJdO1xudmFyIERFVl9PUl9TVEFHSU5HX1NVRkZJWEVTID0gW1xuICBcIi5sY2wuZGV2XCIsXG4gIFwiLnN0Zy5kZXZcIixcbiAgXCIubGNsc3RhZ2UuZGV2XCIsXG4gIFwiLnN0Z3N0YWdlLmRldlwiLFxuICBcIi5kZXYubGNsY2xlcmsuY29tXCIsXG4gIFwiLnN0Zy5sY2xjbGVyay5jb21cIixcbiAgXCIuYWNjb3VudHMubGNsY2xlcmsuY29tXCIsXG4gIFwiYWNjb3VudHNzdGFnZS5kZXZcIixcbiAgXCJhY2NvdW50cy5kZXZcIlxuXTtcbnZhciBMT0NBTF9FTlZfU1VGRklYRVMgPSBbXCIubGNsLmRldlwiLCBcImxjbHN0YWdlLmRldlwiLCBcIi5sY2xjbGVyay5jb21cIiwgXCIuYWNjb3VudHMubGNsY2xlcmsuY29tXCJdO1xudmFyIFNUQUdJTkdfRU5WX1NVRkZJWEVTID0gW1wiLmFjY291bnRzc3RhZ2UuZGV2XCJdO1xudmFyIExPQ0FMX0FQSV9VUkwgPSBcImh0dHBzOi8vYXBpLmxjbGNsZXJrLmNvbVwiO1xudmFyIFNUQUdJTkdfQVBJX1VSTCA9IFwiaHR0cHM6Ly9hcGkuY2xlcmtzdGFnZS5kZXZcIjtcbnZhciBQUk9EX0FQSV9VUkwgPSBcImh0dHBzOi8vYXBpLmNsZXJrLmNvbVwiO1xuZnVuY3Rpb24gaWNvbkltYWdlVXJsKGlkLCBmb3JtYXQgPSBcInN2Z1wiKSB7XG4gIHJldHVybiBgaHR0cHM6Ly9pbWcuY2xlcmsuY29tL3N0YXRpYy8ke2lkfS4ke2Zvcm1hdH1gO1xufVxuXG5leHBvcnQge1xuICBMRUdBQ1lfREVWX0lOU1RBTkNFX1NVRkZJWEVTLFxuICBDVVJSRU5UX0RFVl9JTlNUQU5DRV9TVUZGSVhFUyxcbiAgREVWX09SX1NUQUdJTkdfU1VGRklYRVMsXG4gIExPQ0FMX0VOVl9TVUZGSVhFUyxcbiAgU1RBR0lOR19FTlZfU1VGRklYRVMsXG4gIExPQ0FMX0FQSV9VUkwsXG4gIFNUQUdJTkdfQVBJX1VSTCxcbiAgUFJPRF9BUElfVVJMLFxuICBpY29uSW1hZ2VVcmxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1JNk1UU1RPRi5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IB6GRLVO.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-IB6GRLVO.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClerkAPIResponseError: function() { return /* binding */ ClerkAPIResponseError; },\n/* harmony export */   ClerkRuntimeError: function() { return /* binding */ ClerkRuntimeError; },\n/* harmony export */   EmailLinkError: function() { return /* binding */ EmailLinkError; },\n/* harmony export */   EmailLinkErrorCode: function() { return /* binding */ EmailLinkErrorCode; },\n/* harmony export */   buildErrorThrower: function() { return /* binding */ buildErrorThrower; },\n/* harmony export */   is4xxError: function() { return /* binding */ is4xxError; },\n/* harmony export */   isClerkAPIResponseError: function() { return /* binding */ isClerkAPIResponseError; },\n/* harmony export */   isClerkRuntimeError: function() { return /* binding */ isClerkRuntimeError; },\n/* harmony export */   isEmailLinkError: function() { return /* binding */ isEmailLinkError; },\n/* harmony export */   isKnownError: function() { return /* binding */ isKnownError; },\n/* harmony export */   isMetamaskError: function() { return /* binding */ isMetamaskError; },\n/* harmony export */   isNetworkError: function() { return /* binding */ isNetworkError; },\n/* harmony export */   isPasswordPwnedError: function() { return /* binding */ isPasswordPwnedError; },\n/* harmony export */   isUnauthorizedError: function() { return /* binding */ isUnauthorizedError; },\n/* harmony export */   isUserLockedError: function() { return /* binding */ isUserLockedError; },\n/* harmony export */   parseError: function() { return /* binding */ parseError; },\n/* harmony export */   parseErrors: function() { return /* binding */ parseErrors; }\n/* harmony export */ });\n// src/error.ts\nfunction isUnauthorizedError(e) {\n  var _a, _b;\n  const status = e == null ? void 0 : e.status;\n  const code = (_b = (_a = e == null ? void 0 : e.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.code;\n  return code === \"authentication_invalid\" && status === 401;\n}\nfunction is4xxError(e) {\n  const status = e == null ? void 0 : e.status;\n  return !!status && status >= 400 && status < 500;\n}\nfunction isNetworkError(e) {\n  const message = (`${e.message}${e.name}` || \"\").toLowerCase().replace(/\\s+/g, \"\");\n  return message.includes(\"networkerror\");\n}\nfunction isKnownError(error) {\n  return isClerkAPIResponseError(error) || isMetamaskError(error) || isClerkRuntimeError(error);\n}\nfunction isClerkAPIResponseError(err) {\n  return \"clerkError\" in err;\n}\nfunction isClerkRuntimeError(err) {\n  return \"clerkRuntimeError\" in err;\n}\nfunction isMetamaskError(err) {\n  return \"code\" in err && [4001, 32602, 32603].includes(err.code) && \"message\" in err;\n}\nfunction isUserLockedError(err) {\n  var _a, _b;\n  return isClerkAPIResponseError(err) && ((_b = (_a = err.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.code) === \"user_locked\";\n}\nfunction isPasswordPwnedError(err) {\n  var _a, _b;\n  return isClerkAPIResponseError(err) && ((_b = (_a = err.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.code) === \"form_password_pwned\";\n}\nfunction parseErrors(data = []) {\n  return data.length > 0 ? data.map(parseError) : [];\n}\nfunction parseError(error) {\n  var _a, _b, _c, _d, _e;\n  return {\n    code: error.code,\n    message: error.message,\n    longMessage: error.long_message,\n    meta: {\n      paramName: (_a = error == null ? void 0 : error.meta) == null ? void 0 : _a.param_name,\n      sessionId: (_b = error == null ? void 0 : error.meta) == null ? void 0 : _b.session_id,\n      emailAddresses: (_c = error == null ? void 0 : error.meta) == null ? void 0 : _c.email_addresses,\n      identifiers: (_d = error == null ? void 0 : error.meta) == null ? void 0 : _d.identifiers,\n      zxcvbn: (_e = error == null ? void 0 : error.meta) == null ? void 0 : _e.zxcvbn\n    }\n  };\n}\nvar ClerkAPIResponseError = class _ClerkAPIResponseError extends Error {\n  constructor(message, { data, status, clerkTraceId }) {\n    super(message);\n    this.toString = () => {\n      let message = `[${this.name}]\nMessage:${this.message}\nStatus:${this.status}\nSerialized errors: ${this.errors.map(\n        (e) => JSON.stringify(e)\n      )}`;\n      if (this.clerkTraceId) {\n        message += `\nClerk Trace ID: ${this.clerkTraceId}`;\n      }\n      return message;\n    };\n    Object.setPrototypeOf(this, _ClerkAPIResponseError.prototype);\n    this.status = status;\n    this.message = message;\n    this.clerkTraceId = clerkTraceId;\n    this.clerkError = true;\n    this.errors = parseErrors(data);\n  }\n};\nvar ClerkRuntimeError = class _ClerkRuntimeError extends Error {\n  constructor(message, { code }) {\n    super(message);\n    /**\n     * Returns a string representation of the error.\n     *\n     * @returns {string} A formatted string with the error name and message.\n     * @memberof ClerkRuntimeError\n     */\n    this.toString = () => {\n      return `[${this.name}]\nMessage:${this.message}`;\n    };\n    Object.setPrototypeOf(this, _ClerkRuntimeError.prototype);\n    this.code = code;\n    this.message = message;\n    this.clerkRuntimeError = true;\n  }\n};\nvar EmailLinkError = class _EmailLinkError extends Error {\n  constructor(code) {\n    super(code);\n    this.code = code;\n    Object.setPrototypeOf(this, _EmailLinkError.prototype);\n  }\n};\nfunction isEmailLinkError(err) {\n  return err instanceof EmailLinkError;\n}\nvar EmailLinkErrorCode = {\n  Expired: \"expired\",\n  Failed: \"failed\",\n  ClientMismatch: \"client_mismatch\"\n};\nvar DefaultMessages = Object.freeze({\n  InvalidProxyUrlErrorMessage: `The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})`,\n  InvalidPublishableKeyErrorMessage: `The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,\n  MissingPublishableKeyErrorMessage: `Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,\n  MissingSecretKeyErrorMessage: `Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,\n  MissingClerkProvider: `{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`\n});\nfunction buildErrorThrower({ packageName, customMessages }) {\n  let pkg = packageName;\n  const messages = {\n    ...DefaultMessages,\n    ...customMessages\n  };\n  function buildMessage(rawMessage, replacements) {\n    if (!replacements) {\n      return `${pkg}: ${rawMessage}`;\n    }\n    let msg = rawMessage;\n    const matches = rawMessage.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);\n    for (const match of matches) {\n      const replacement = (replacements[match[1]] || \"\").toString();\n      msg = msg.replace(`{{${match[1]}}}`, replacement);\n    }\n    return `${pkg}: ${msg}`;\n  }\n  return {\n    setPackageName({ packageName: packageName2 }) {\n      if (typeof packageName2 === \"string\") {\n        pkg = packageName2;\n      }\n      return this;\n    },\n    setMessages({ customMessages: customMessages2 }) {\n      Object.assign(messages, customMessages2 || {});\n      return this;\n    },\n    throwInvalidPublishableKeyError(params) {\n      throw new Error(buildMessage(messages.InvalidPublishableKeyErrorMessage, params));\n    },\n    throwInvalidProxyUrl(params) {\n      throw new Error(buildMessage(messages.InvalidProxyUrlErrorMessage, params));\n    },\n    throwMissingPublishableKeyError() {\n      throw new Error(buildMessage(messages.MissingPublishableKeyErrorMessage));\n    },\n    throwMissingSecretKeyError() {\n      throw new Error(buildMessage(messages.MissingSecretKeyErrorMessage));\n    },\n    throwMissingClerkProviderError(params) {\n      throw new Error(buildMessage(messages.MissingClerkProvider, params));\n    },\n    throw(message) {\n      throw new Error(buildMessage(message));\n    }\n  };\n}\n\n\n//# sourceMappingURL=chunk-IB6GRLVO.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSUI2R1JMVk8ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsRUFBRSxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyxVQUFVO0FBQ1YsU0FBUztBQUNULHFCQUFxQjtBQUNyQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEtBQTBLLEtBQUs7QUFDL0ssdUxBQXVMLEtBQUs7QUFDNUw7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDLENBQUM7QUFDRCw2QkFBNkIsNkJBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUksSUFBSSxXQUFXO0FBQ25DO0FBQ0E7QUFDQSwyQ0FBMkMsa0JBQWtCO0FBQzdEO0FBQ0E7QUFDQSwyQkFBMkIsRUFBRSxXQUFXO0FBQ3hDO0FBQ0EsY0FBYyxJQUFJLElBQUksSUFBSTtBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsaUNBQWlDO0FBQ25ELG1EQUFtRDtBQUNuRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFvQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLUlCNkdSTFZPLm1qcz9lNTZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvci50c1xuZnVuY3Rpb24gaXNVbmF1dGhvcml6ZWRFcnJvcihlKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHN0YXR1cyA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc3RhdHVzO1xuICBjb25zdCBjb2RlID0gKF9iID0gKF9hID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5lcnJvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvZGU7XG4gIHJldHVybiBjb2RlID09PSBcImF1dGhlbnRpY2F0aW9uX2ludmFsaWRcIiAmJiBzdGF0dXMgPT09IDQwMTtcbn1cbmZ1bmN0aW9uIGlzNHh4RXJyb3IoZSkge1xuICBjb25zdCBzdGF0dXMgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLnN0YXR1cztcbiAgcmV0dXJuICEhc3RhdHVzICYmIHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNTAwO1xufVxuZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IoZSkge1xuICBjb25zdCBtZXNzYWdlID0gKGAke2UubWVzc2FnZX0ke2UubmFtZX1gIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCBcIlwiKTtcbiAgcmV0dXJuIG1lc3NhZ2UuaW5jbHVkZXMoXCJuZXR3b3JrZXJyb3JcIik7XG59XG5mdW5jdGlvbiBpc0tub3duRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGlzQ2xlcmtBUElSZXNwb25zZUVycm9yKGVycm9yKSB8fCBpc01ldGFtYXNrRXJyb3IoZXJyb3IpIHx8IGlzQ2xlcmtSdW50aW1lRXJyb3IoZXJyb3IpO1xufVxuZnVuY3Rpb24gaXNDbGVya0FQSVJlc3BvbnNlRXJyb3IoZXJyKSB7XG4gIHJldHVybiBcImNsZXJrRXJyb3JcIiBpbiBlcnI7XG59XG5mdW5jdGlvbiBpc0NsZXJrUnVudGltZUVycm9yKGVycikge1xuICByZXR1cm4gXCJjbGVya1J1bnRpbWVFcnJvclwiIGluIGVycjtcbn1cbmZ1bmN0aW9uIGlzTWV0YW1hc2tFcnJvcihlcnIpIHtcbiAgcmV0dXJuIFwiY29kZVwiIGluIGVyciAmJiBbNDAwMSwgMzI2MDIsIDMyNjAzXS5pbmNsdWRlcyhlcnIuY29kZSkgJiYgXCJtZXNzYWdlXCIgaW4gZXJyO1xufVxuZnVuY3Rpb24gaXNVc2VyTG9ja2VkRXJyb3IoZXJyKSB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiBpc0NsZXJrQVBJUmVzcG9uc2VFcnJvcihlcnIpICYmICgoX2IgPSAoX2EgPSBlcnIuZXJyb3JzKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb2RlKSA9PT0gXCJ1c2VyX2xvY2tlZFwiO1xufVxuZnVuY3Rpb24gaXNQYXNzd29yZFB3bmVkRXJyb3IoZXJyKSB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiBpc0NsZXJrQVBJUmVzcG9uc2VFcnJvcihlcnIpICYmICgoX2IgPSAoX2EgPSBlcnIuZXJyb3JzKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb2RlKSA9PT0gXCJmb3JtX3Bhc3N3b3JkX3B3bmVkXCI7XG59XG5mdW5jdGlvbiBwYXJzZUVycm9ycyhkYXRhID0gW10pIHtcbiAgcmV0dXJuIGRhdGEubGVuZ3RoID4gMCA/IGRhdGEubWFwKHBhcnNlRXJyb3IpIDogW107XG59XG5mdW5jdGlvbiBwYXJzZUVycm9yKGVycm9yKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gIHJldHVybiB7XG4gICAgY29kZTogZXJyb3IuY29kZSxcbiAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgIGxvbmdNZXNzYWdlOiBlcnJvci5sb25nX21lc3NhZ2UsXG4gICAgbWV0YToge1xuICAgICAgcGFyYW1OYW1lOiAoX2EgPSBlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWV0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnBhcmFtX25hbWUsXG4gICAgICBzZXNzaW9uSWQ6IChfYiA9IGVycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5tZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc2Vzc2lvbl9pZCxcbiAgICAgIGVtYWlsQWRkcmVzc2VzOiAoX2MgPSBlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWV0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmVtYWlsX2FkZHJlc3NlcyxcbiAgICAgIGlkZW50aWZpZXJzOiAoX2QgPSBlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWV0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmlkZW50aWZpZXJzLFxuICAgICAgenhjdmJuOiAoX2UgPSBlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWV0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnp4Y3ZiblxuICAgIH1cbiAgfTtcbn1cbnZhciBDbGVya0FQSVJlc3BvbnNlRXJyb3IgPSBjbGFzcyBfQ2xlcmtBUElSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB7IGRhdGEsIHN0YXR1cywgY2xlcmtUcmFjZUlkIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4ge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgWyR7dGhpcy5uYW1lfV1cbk1lc3NhZ2U6JHt0aGlzLm1lc3NhZ2V9XG5TdGF0dXM6JHt0aGlzLnN0YXR1c31cblNlcmlhbGl6ZWQgZXJyb3JzOiAke3RoaXMuZXJyb3JzLm1hcChcbiAgICAgICAgKGUpID0+IEpTT04uc3RyaW5naWZ5KGUpXG4gICAgICApfWA7XG4gICAgICBpZiAodGhpcy5jbGVya1RyYWNlSWQpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgXG5DbGVyayBUcmFjZSBJRDogJHt0aGlzLmNsZXJrVHJhY2VJZH1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX0NsZXJrQVBJUmVzcG9uc2VFcnJvci5wcm90b3R5cGUpO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5jbGVya1RyYWNlSWQgPSBjbGVya1RyYWNlSWQ7XG4gICAgdGhpcy5jbGVya0Vycm9yID0gdHJ1ZTtcbiAgICB0aGlzLmVycm9ycyA9IHBhcnNlRXJyb3JzKGRhdGEpO1xuICB9XG59O1xudmFyIENsZXJrUnVudGltZUVycm9yID0gY2xhc3MgX0NsZXJrUnVudGltZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB7IGNvZGUgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBmb3JtYXR0ZWQgc3RyaW5nIHdpdGggdGhlIGVycm9yIG5hbWUgYW5kIG1lc3NhZ2UuXG4gICAgICogQG1lbWJlcm9mIENsZXJrUnVudGltZUVycm9yXG4gICAgICovXG4gICAgdGhpcy50b1N0cmluZyA9ICgpID0+IHtcbiAgICAgIHJldHVybiBgWyR7dGhpcy5uYW1lfV1cbk1lc3NhZ2U6JHt0aGlzLm1lc3NhZ2V9YDtcbiAgICB9O1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfQ2xlcmtSdW50aW1lRXJyb3IucHJvdG90eXBlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5jbGVya1J1bnRpbWVFcnJvciA9IHRydWU7XG4gIH1cbn07XG52YXIgRW1haWxMaW5rRXJyb3IgPSBjbGFzcyBfRW1haWxMaW5rRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICBzdXBlcihjb2RlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfRW1haWxMaW5rRXJyb3IucHJvdG90eXBlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzRW1haWxMaW5rRXJyb3IoZXJyKSB7XG4gIHJldHVybiBlcnIgaW5zdGFuY2VvZiBFbWFpbExpbmtFcnJvcjtcbn1cbnZhciBFbWFpbExpbmtFcnJvckNvZGUgPSB7XG4gIEV4cGlyZWQ6IFwiZXhwaXJlZFwiLFxuICBGYWlsZWQ6IFwiZmFpbGVkXCIsXG4gIENsaWVudE1pc21hdGNoOiBcImNsaWVudF9taXNtYXRjaFwiXG59O1xudmFyIERlZmF1bHRNZXNzYWdlcyA9IE9iamVjdC5mcmVlemUoe1xuICBJbnZhbGlkUHJveHlVcmxFcnJvck1lc3NhZ2U6IGBUaGUgcHJveHlVcmwgcGFzc2VkIHRvIENsZXJrIGlzIGludmFsaWQuIFRoZSBleHBlY3RlZCB2YWx1ZSBmb3IgcHJveHlVcmwgaXMgYW4gYWJzb2x1dGUgVVJMIG9yIGEgcmVsYXRpdmUgcGF0aCB3aXRoIGEgbGVhZGluZyAnLycuIChrZXk9e3t1cmx9fSlgLFxuICBJbnZhbGlkUHVibGlzaGFibGVLZXlFcnJvck1lc3NhZ2U6IGBUaGUgcHVibGlzaGFibGVLZXkgcGFzc2VkIHRvIENsZXJrIGlzIGludmFsaWQuIFlvdSBjYW4gZ2V0IHlvdXIgUHVibGlzaGFibGUga2V5IGF0IGh0dHBzOi8vZGFzaGJvYXJkLmNsZXJrLmNvbS9sYXN0LWFjdGl2ZT9wYXRoPWFwaS1rZXlzLiAoa2V5PXt7a2V5fX0pYCxcbiAgTWlzc2luZ1B1Ymxpc2hhYmxlS2V5RXJyb3JNZXNzYWdlOiBgTWlzc2luZyBwdWJsaXNoYWJsZUtleS4gWW91IGNhbiBnZXQgeW91ciBrZXkgYXQgaHR0cHM6Ly9kYXNoYm9hcmQuY2xlcmsuY29tL2xhc3QtYWN0aXZlP3BhdGg9YXBpLWtleXMuYCxcbiAgTWlzc2luZ1NlY3JldEtleUVycm9yTWVzc2FnZTogYE1pc3Npbmcgc2VjcmV0S2V5LiBZb3UgY2FuIGdldCB5b3VyIGtleSBhdCBodHRwczovL2Rhc2hib2FyZC5jbGVyay5jb20vbGFzdC1hY3RpdmU/cGF0aD1hcGkta2V5cy5gLFxuICBNaXNzaW5nQ2xlcmtQcm92aWRlcjogYHt7c291cmNlfX0gY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIDxDbGVya1Byb3ZpZGVyIC8+IGNvbXBvbmVudC4gTGVhcm4gbW9yZTogaHR0cHM6Ly9jbGVyay5jb20vZG9jcy9jb21wb25lbnRzL2NsZXJrLXByb3ZpZGVyYFxufSk7XG5mdW5jdGlvbiBidWlsZEVycm9yVGhyb3dlcih7IHBhY2thZ2VOYW1lLCBjdXN0b21NZXNzYWdlcyB9KSB7XG4gIGxldCBwa2cgPSBwYWNrYWdlTmFtZTtcbiAgY29uc3QgbWVzc2FnZXMgPSB7XG4gICAgLi4uRGVmYXVsdE1lc3NhZ2VzLFxuICAgIC4uLmN1c3RvbU1lc3NhZ2VzXG4gIH07XG4gIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShyYXdNZXNzYWdlLCByZXBsYWNlbWVudHMpIHtcbiAgICBpZiAoIXJlcGxhY2VtZW50cykge1xuICAgICAgcmV0dXJuIGAke3BrZ306ICR7cmF3TWVzc2FnZX1gO1xuICAgIH1cbiAgICBsZXQgbXNnID0gcmF3TWVzc2FnZTtcbiAgICBjb25zdCBtYXRjaGVzID0gcmF3TWVzc2FnZS5tYXRjaEFsbCgve3soW2EtekEtWjAtOS1fXSspfX0vZyk7XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IChyZXBsYWNlbWVudHNbbWF0Y2hbMV1dIHx8IFwiXCIpLnRvU3RyaW5nKCk7XG4gICAgICBtc2cgPSBtc2cucmVwbGFjZShge3ske21hdGNoWzFdfX19YCwgcmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cGtnfTogJHttc2d9YDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNldFBhY2thZ2VOYW1lKHsgcGFja2FnZU5hbWU6IHBhY2thZ2VOYW1lMiB9KSB7XG4gICAgICBpZiAodHlwZW9mIHBhY2thZ2VOYW1lMiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwa2cgPSBwYWNrYWdlTmFtZTI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNldE1lc3NhZ2VzKHsgY3VzdG9tTWVzc2FnZXM6IGN1c3RvbU1lc3NhZ2VzMiB9KSB7XG4gICAgICBPYmplY3QuYXNzaWduKG1lc3NhZ2VzLCBjdXN0b21NZXNzYWdlczIgfHwge30pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB0aHJvd0ludmFsaWRQdWJsaXNoYWJsZUtleUVycm9yKHBhcmFtcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGJ1aWxkTWVzc2FnZShtZXNzYWdlcy5JbnZhbGlkUHVibGlzaGFibGVLZXlFcnJvck1lc3NhZ2UsIHBhcmFtcykpO1xuICAgIH0sXG4gICAgdGhyb3dJbnZhbGlkUHJveHlVcmwocGFyYW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYnVpbGRNZXNzYWdlKG1lc3NhZ2VzLkludmFsaWRQcm94eVVybEVycm9yTWVzc2FnZSwgcGFyYW1zKSk7XG4gICAgfSxcbiAgICB0aHJvd01pc3NpbmdQdWJsaXNoYWJsZUtleUVycm9yKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGJ1aWxkTWVzc2FnZShtZXNzYWdlcy5NaXNzaW5nUHVibGlzaGFibGVLZXlFcnJvck1lc3NhZ2UpKTtcbiAgICB9LFxuICAgIHRocm93TWlzc2luZ1NlY3JldEtleUVycm9yKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGJ1aWxkTWVzc2FnZShtZXNzYWdlcy5NaXNzaW5nU2VjcmV0S2V5RXJyb3JNZXNzYWdlKSk7XG4gICAgfSxcbiAgICB0aHJvd01pc3NpbmdDbGVya1Byb3ZpZGVyRXJyb3IocGFyYW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYnVpbGRNZXNzYWdlKG1lc3NhZ2VzLk1pc3NpbmdDbGVya1Byb3ZpZGVyLCBwYXJhbXMpKTtcbiAgICB9LFxuICAgIHRocm93KG1lc3NhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihidWlsZE1lc3NhZ2UobWVzc2FnZSkpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHtcbiAgaXNVbmF1dGhvcml6ZWRFcnJvcixcbiAgaXM0eHhFcnJvcixcbiAgaXNOZXR3b3JrRXJyb3IsXG4gIGlzS25vd25FcnJvcixcbiAgaXNDbGVya0FQSVJlc3BvbnNlRXJyb3IsXG4gIGlzQ2xlcmtSdW50aW1lRXJyb3IsXG4gIGlzTWV0YW1hc2tFcnJvcixcbiAgaXNVc2VyTG9ja2VkRXJyb3IsXG4gIGlzUGFzc3dvcmRQd25lZEVycm9yLFxuICBwYXJzZUVycm9ycyxcbiAgcGFyc2VFcnJvcixcbiAgQ2xlcmtBUElSZXNwb25zZUVycm9yLFxuICBDbGVya1J1bnRpbWVFcnJvcixcbiAgRW1haWxMaW5rRXJyb3IsXG4gIGlzRW1haWxMaW5rRXJyb3IsXG4gIEVtYWlsTGlua0Vycm9yQ29kZSxcbiAgYnVpbGRFcnJvclRocm93ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1JQjZHUkxWTy5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IB6GRLVO.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IC4FGZI3.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-IC4FGZI3.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deprecated: function() { return /* binding */ deprecated; },\n/* harmony export */   deprecatedObjectProperty: function() { return /* binding */ deprecatedObjectProperty; },\n/* harmony export */   deprecatedProperty: function() { return /* binding */ deprecatedProperty; },\n/* harmony export */   isDevelopmentEnvironment: function() { return /* binding */ isDevelopmentEnvironment; },\n/* harmony export */   isProductionEnvironment: function() { return /* binding */ isProductionEnvironment; },\n/* harmony export */   isTestEnvironment: function() { return /* binding */ isTestEnvironment; }\n/* harmony export */ });\n// src/utils/runtimeEnvironment.ts\nvar isDevelopmentEnvironment = () => {\n  try {\n    return \"development\" === \"development\";\n  } catch (err) {\n  }\n  return false;\n};\nvar isTestEnvironment = () => {\n  try {\n    return \"development\" === \"test\";\n  } catch (err) {\n  }\n  return false;\n};\nvar isProductionEnvironment = () => {\n  try {\n    return \"development\" === \"production\";\n  } catch (err) {\n  }\n  return false;\n};\n\n// src/deprecated.ts\nvar displayedWarnings = /* @__PURE__ */ new Set();\nvar deprecated = (fnName, warning, key) => {\n  const hideWarning = isTestEnvironment() || isProductionEnvironment();\n  const messageId = key != null ? key : fnName;\n  if (displayedWarnings.has(messageId) || hideWarning) {\n    return;\n  }\n  displayedWarnings.add(messageId);\n  console.warn(\n    `Clerk - DEPRECATION WARNING: \"${fnName}\" is deprecated and will be removed in the next major release.\n${warning}`\n  );\n};\nvar deprecatedProperty = (cls, propName, warning, isStatic = false) => {\n  const target = isStatic ? cls : cls.prototype;\n  let value = target[propName];\n  Object.defineProperty(target, propName, {\n    get() {\n      deprecated(propName, warning, `${cls.name}:${propName}`);\n      return value;\n    },\n    set(v) {\n      value = v;\n    }\n  });\n};\nvar deprecatedObjectProperty = (obj, propName, warning, key) => {\n  let value = obj[propName];\n  Object.defineProperty(obj, propName, {\n    get() {\n      deprecated(propName, warning, key);\n      return value;\n    },\n    set(v) {\n      value = v;\n    }\n  });\n};\n\n\n//# sourceMappingURL=chunk-IC4FGZI3.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSUM0RkdaSTMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBb0I7QUFDL0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQW9CO0FBQy9CLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFvQjtBQUMvQixJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUMsRUFBRSxRQUFRO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUyxHQUFHLFNBQVM7QUFDNUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFTRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSUM0RkdaSTMubWpzP2MyMzMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL3J1bnRpbWVFbnZpcm9ubWVudC50c1xudmFyIGlzRGV2ZWxvcG1lbnRFbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBpc1Rlc3RFbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGlzUHJvZHVjdGlvbkVudmlyb25tZW50ID0gKCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy9kZXByZWNhdGVkLnRzXG52YXIgZGlzcGxheWVkV2FybmluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIGRlcHJlY2F0ZWQgPSAoZm5OYW1lLCB3YXJuaW5nLCBrZXkpID0+IHtcbiAgY29uc3QgaGlkZVdhcm5pbmcgPSBpc1Rlc3RFbnZpcm9ubWVudCgpIHx8IGlzUHJvZHVjdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IG1lc3NhZ2VJZCA9IGtleSAhPSBudWxsID8ga2V5IDogZm5OYW1lO1xuICBpZiAoZGlzcGxheWVkV2FybmluZ3MuaGFzKG1lc3NhZ2VJZCkgfHwgaGlkZVdhcm5pbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGlzcGxheWVkV2FybmluZ3MuYWRkKG1lc3NhZ2VJZCk7XG4gIGNvbnNvbGUud2FybihcbiAgICBgQ2xlcmsgLSBERVBSRUNBVElPTiBXQVJOSU5HOiBcIiR7Zm5OYW1lfVwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuJHt3YXJuaW5nfWBcbiAgKTtcbn07XG52YXIgZGVwcmVjYXRlZFByb3BlcnR5ID0gKGNscywgcHJvcE5hbWUsIHdhcm5pbmcsIGlzU3RhdGljID0gZmFsc2UpID0+IHtcbiAgY29uc3QgdGFyZ2V0ID0gaXNTdGF0aWMgPyBjbHMgOiBjbHMucHJvdG90eXBlO1xuICBsZXQgdmFsdWUgPSB0YXJnZXRbcHJvcE5hbWVdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wTmFtZSwge1xuICAgIGdldCgpIHtcbiAgICAgIGRlcHJlY2F0ZWQocHJvcE5hbWUsIHdhcm5pbmcsIGAke2Nscy5uYW1lfToke3Byb3BOYW1lfWApO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgIHZhbHVlID0gdjtcbiAgICB9XG4gIH0pO1xufTtcbnZhciBkZXByZWNhdGVkT2JqZWN0UHJvcGVydHkgPSAob2JqLCBwcm9wTmFtZSwgd2FybmluZywga2V5KSA9PiB7XG4gIGxldCB2YWx1ZSA9IG9ialtwcm9wTmFtZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BOYW1lLCB7XG4gICAgZ2V0KCkge1xuICAgICAgZGVwcmVjYXRlZChwcm9wTmFtZSwgd2FybmluZywga2V5KTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICB2YWx1ZSA9IHY7XG4gICAgfVxuICB9KTtcbn07XG5cbmV4cG9ydCB7XG4gIGlzRGV2ZWxvcG1lbnRFbnZpcm9ubWVudCxcbiAgaXNUZXN0RW52aXJvbm1lbnQsXG4gIGlzUHJvZHVjdGlvbkVudmlyb25tZW50LFxuICBkZXByZWNhdGVkLFxuICBkZXByZWNhdGVkUHJvcGVydHksXG4gIGRlcHJlY2F0ZWRPYmplY3RQcm9wZXJ0eVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUlDNEZHWkkzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IC4FGZI3.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-K64INQ4C.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-K64INQ4C.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEV_BROWSER_JWT_HEADER: function() { return /* binding */ DEV_BROWSER_JWT_HEADER; },\n/* harmony export */   DEV_BROWSER_JWT_KEY: function() { return /* binding */ DEV_BROWSER_JWT_KEY; },\n/* harmony export */   extractDevBrowserJWTFromURL: function() { return /* binding */ extractDevBrowserJWTFromURL; },\n/* harmony export */   setDevBrowserJWTInURL: function() { return /* binding */ setDevBrowserJWTInURL; }\n/* harmony export */ });\n// src/devBrowser.ts\nvar DEV_BROWSER_JWT_KEY = \"__clerk_db_jwt\";\nvar DEV_BROWSER_JWT_HEADER = \"Clerk-Db-Jwt\";\nfunction setDevBrowserJWTInURL(url, jwt) {\n  const resultURL = new URL(url);\n  const jwtFromSearch = resultURL.searchParams.get(DEV_BROWSER_JWT_KEY);\n  resultURL.searchParams.delete(DEV_BROWSER_JWT_KEY);\n  const jwtToSet = jwtFromSearch || jwt;\n  if (jwtToSet) {\n    resultURL.searchParams.set(DEV_BROWSER_JWT_KEY, jwtToSet);\n  }\n  return resultURL;\n}\nfunction extractDevBrowserJWTFromURL(url) {\n  const jwt = readDevBrowserJwtFromSearchParams(url);\n  const cleanUrl = removeDevBrowserJwt(url);\n  if (cleanUrl.href !== url.href && typeof globalThis.history !== \"undefined\") {\n    globalThis.history.replaceState(null, \"\", removeDevBrowserJwt(url));\n  }\n  return jwt;\n}\nvar readDevBrowserJwtFromSearchParams = (url) => {\n  return url.searchParams.get(DEV_BROWSER_JWT_KEY) || \"\";\n};\nvar removeDevBrowserJwt = (url) => {\n  return removeDevBrowserJwtFromURLSearchParams(removeLegacyDevBrowserJwt(url));\n};\nvar removeDevBrowserJwtFromURLSearchParams = (_url) => {\n  const url = new URL(_url);\n  url.searchParams.delete(DEV_BROWSER_JWT_KEY);\n  return url;\n};\nvar removeLegacyDevBrowserJwt = (_url) => {\n  const DEV_BROWSER_JWT_MARKER_REGEXP = /__clerk_db_jwt\\[(.*)\\]/;\n  const DEV_BROWSER_JWT_LEGACY_KEY = \"__dev_session\";\n  const url = new URL(_url);\n  url.searchParams.delete(DEV_BROWSER_JWT_LEGACY_KEY);\n  url.hash = decodeURI(url.hash).replace(DEV_BROWSER_JWT_MARKER_REGEXP, \"\");\n  if (url.href.endsWith(\"#\")) {\n    url.hash = \"\";\n  }\n  return url;\n};\n\n\n//# sourceMappingURL=chunk-K64INQ4C.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSzY0SU5RNEMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstSzY0SU5RNEMubWpzP2NmZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2RldkJyb3dzZXIudHNcbnZhciBERVZfQlJPV1NFUl9KV1RfS0VZID0gXCJfX2NsZXJrX2RiX2p3dFwiO1xudmFyIERFVl9CUk9XU0VSX0pXVF9IRUFERVIgPSBcIkNsZXJrLURiLUp3dFwiO1xuZnVuY3Rpb24gc2V0RGV2QnJvd3NlckpXVEluVVJMKHVybCwgand0KSB7XG4gIGNvbnN0IHJlc3VsdFVSTCA9IG5ldyBVUkwodXJsKTtcbiAgY29uc3Qgand0RnJvbVNlYXJjaCA9IHJlc3VsdFVSTC5zZWFyY2hQYXJhbXMuZ2V0KERFVl9CUk9XU0VSX0pXVF9LRVkpO1xuICByZXN1bHRVUkwuc2VhcmNoUGFyYW1zLmRlbGV0ZShERVZfQlJPV1NFUl9KV1RfS0VZKTtcbiAgY29uc3Qgand0VG9TZXQgPSBqd3RGcm9tU2VhcmNoIHx8IGp3dDtcbiAgaWYgKGp3dFRvU2V0KSB7XG4gICAgcmVzdWx0VVJMLnNlYXJjaFBhcmFtcy5zZXQoREVWX0JST1dTRVJfSldUX0tFWSwgand0VG9TZXQpO1xuICB9XG4gIHJldHVybiByZXN1bHRVUkw7XG59XG5mdW5jdGlvbiBleHRyYWN0RGV2QnJvd3NlckpXVEZyb21VUkwodXJsKSB7XG4gIGNvbnN0IGp3dCA9IHJlYWREZXZCcm93c2VySnd0RnJvbVNlYXJjaFBhcmFtcyh1cmwpO1xuICBjb25zdCBjbGVhblVybCA9IHJlbW92ZURldkJyb3dzZXJKd3QodXJsKTtcbiAgaWYgKGNsZWFuVXJsLmhyZWYgIT09IHVybC5ocmVmICYmIHR5cGVvZiBnbG9iYWxUaGlzLmhpc3RvcnkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBnbG9iYWxUaGlzLmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsIFwiXCIsIHJlbW92ZURldkJyb3dzZXJKd3QodXJsKSk7XG4gIH1cbiAgcmV0dXJuIGp3dDtcbn1cbnZhciByZWFkRGV2QnJvd3Nlckp3dEZyb21TZWFyY2hQYXJhbXMgPSAodXJsKSA9PiB7XG4gIHJldHVybiB1cmwuc2VhcmNoUGFyYW1zLmdldChERVZfQlJPV1NFUl9KV1RfS0VZKSB8fCBcIlwiO1xufTtcbnZhciByZW1vdmVEZXZCcm93c2VySnd0ID0gKHVybCkgPT4ge1xuICByZXR1cm4gcmVtb3ZlRGV2QnJvd3Nlckp3dEZyb21VUkxTZWFyY2hQYXJhbXMocmVtb3ZlTGVnYWN5RGV2QnJvd3Nlckp3dCh1cmwpKTtcbn07XG52YXIgcmVtb3ZlRGV2QnJvd3Nlckp3dEZyb21VUkxTZWFyY2hQYXJhbXMgPSAoX3VybCkgPT4ge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKF91cmwpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShERVZfQlJPV1NFUl9KV1RfS0VZKTtcbiAgcmV0dXJuIHVybDtcbn07XG52YXIgcmVtb3ZlTGVnYWN5RGV2QnJvd3Nlckp3dCA9IChfdXJsKSA9PiB7XG4gIGNvbnN0IERFVl9CUk9XU0VSX0pXVF9NQVJLRVJfUkVHRVhQID0gL19fY2xlcmtfZGJfand0XFxbKC4qKVxcXS87XG4gIGNvbnN0IERFVl9CUk9XU0VSX0pXVF9MRUdBQ1lfS0VZID0gXCJfX2Rldl9zZXNzaW9uXCI7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoX3VybCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKERFVl9CUk9XU0VSX0pXVF9MRUdBQ1lfS0VZKTtcbiAgdXJsLmhhc2ggPSBkZWNvZGVVUkkodXJsLmhhc2gpLnJlcGxhY2UoREVWX0JST1dTRVJfSldUX01BUktFUl9SRUdFWFAsIFwiXCIpO1xuICBpZiAodXJsLmhyZWYuZW5kc1dpdGgoXCIjXCIpKSB7XG4gICAgdXJsLmhhc2ggPSBcIlwiO1xuICB9XG4gIHJldHVybiB1cmw7XG59O1xuXG5leHBvcnQge1xuICBERVZfQlJPV1NFUl9KV1RfS0VZLFxuICBERVZfQlJPV1NFUl9KV1RfSEVBREVSLFxuICBzZXREZXZCcm93c2VySldUSW5VUkwsXG4gIGV4dHJhY3REZXZCcm93c2VySldURnJvbVVSTFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUs2NElOUTRDLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-K64INQ4C.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isomorphicBtoa: function() { return /* binding */ isomorphicBtoa; }\n/* harmony export */ });\n// src/isomorphicBtoa.ts\nvar isomorphicBtoa = (data) => {\n  if (typeof btoa !== \"undefined\" && typeof btoa === \"function\") {\n    return btoa(data);\n  } else if (typeof global !== \"undefined\" && global.Buffer) {\n    return new global.Buffer(data).toString(\"base64\");\n  }\n  return data;\n};\n\n\n//# sourceMappingURL=chunk-KOH7GTJO.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstS09IN0dUSk8ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstS09IN0dUSk8ubWpzPzk4NWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2lzb21vcnBoaWNCdG9hLnRzXG52YXIgaXNvbW9ycGhpY0J0b2EgPSAoZGF0YSkgPT4ge1xuICBpZiAodHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBidG9hKGRhdGEpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLkJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgZ2xvYmFsLkJ1ZmZlcihkYXRhKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn07XG5cbmV4cG9ydCB7XG4gIGlzb21vcnBoaWNCdG9hXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstS09IN0dUSk8ubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-L2BNNARM.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-L2BNNARM.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildPublishableKey: function() { return /* binding */ buildPublishableKey; },\n/* harmony export */   createDevOrStagingUrlCache: function() { return /* binding */ createDevOrStagingUrlCache; },\n/* harmony export */   getCookieSuffix: function() { return /* binding */ getCookieSuffix; },\n/* harmony export */   getSuffixedCookieName: function() { return /* binding */ getSuffixedCookieName; },\n/* harmony export */   isDevelopmentFromPublishableKey: function() { return /* binding */ isDevelopmentFromPublishableKey; },\n/* harmony export */   isDevelopmentFromSecretKey: function() { return /* binding */ isDevelopmentFromSecretKey; },\n/* harmony export */   isProductionFromPublishableKey: function() { return /* binding */ isProductionFromPublishableKey; },\n/* harmony export */   isProductionFromSecretKey: function() { return /* binding */ isProductionFromSecretKey; },\n/* harmony export */   isPublishableKey: function() { return /* binding */ isPublishableKey; },\n/* harmony export */   parsePublishableKey: function() { return /* binding */ parsePublishableKey; }\n/* harmony export */ });\n/* harmony import */ var _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-TETGTEI2.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\");\n/* harmony import */ var _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-KOH7GTJO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n\n\n\n\n// src/keys.ts\nvar PUBLISHABLE_KEY_LIVE_PREFIX = \"pk_live_\";\nvar PUBLISHABLE_KEY_TEST_PREFIX = \"pk_test_\";\nvar PUBLISHABLE_FRONTEND_API_DEV_REGEX = /^(([a-z]+)-){2}([0-9]{1,2})\\.clerk\\.accounts([a-z.]*)(dev|com)$/i;\nfunction buildPublishableKey(frontendApi) {\n  const isDevKey = PUBLISHABLE_FRONTEND_API_DEV_REGEX.test(frontendApi) || frontendApi.startsWith(\"clerk.\") && _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_2__.LEGACY_DEV_INSTANCE_SUFFIXES.some((s) => frontendApi.endsWith(s));\n  const keyPrefix = isDevKey ? PUBLISHABLE_KEY_TEST_PREFIX : PUBLISHABLE_KEY_LIVE_PREFIX;\n  return `${keyPrefix}${(0,_chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_1__.isomorphicBtoa)(`${frontendApi}$`)}`;\n}\nfunction parsePublishableKey(key, options = {}) {\n  key = key || \"\";\n  if (!key || !isPublishableKey(key)) {\n    if (options.fatal) {\n      throw new Error(\"Publishable key not valid.\");\n    }\n    return null;\n  }\n  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? \"production\" : \"development\";\n  let frontendApi = (0,_chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_0__.isomorphicAtob)(key.split(\"_\")[2]);\n  frontendApi = frontendApi.slice(0, -1);\n  if (options.proxyUrl) {\n    frontendApi = options.proxyUrl;\n  } else if (instanceType !== \"development\" && options.domain) {\n    frontendApi = `clerk.${options.domain}`;\n  }\n  return {\n    instanceType,\n    frontendApi\n  };\n}\nfunction isPublishableKey(key) {\n  key = key || \"\";\n  const hasValidPrefix = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX);\n  const hasValidFrontendApiPostfix = (0,_chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_0__.isomorphicAtob)(key.split(\"_\")[2] || \"\").endsWith(\"$\");\n  return hasValidPrefix && hasValidFrontendApiPostfix;\n}\nfunction createDevOrStagingUrlCache() {\n  const devOrStagingUrlCache = /* @__PURE__ */ new Map();\n  return {\n    isDevOrStagingUrl: (url) => {\n      if (!url) {\n        return false;\n      }\n      const hostname = typeof url === \"string\" ? url : url.hostname;\n      let res = devOrStagingUrlCache.get(hostname);\n      if (res === void 0) {\n        res = _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_2__.DEV_OR_STAGING_SUFFIXES.some((s) => hostname.endsWith(s));\n        devOrStagingUrlCache.set(hostname, res);\n      }\n      return res;\n    }\n  };\n}\nfunction isDevelopmentFromPublishableKey(apiKey) {\n  return apiKey.startsWith(\"test_\") || apiKey.startsWith(\"pk_test_\");\n}\nfunction isProductionFromPublishableKey(apiKey) {\n  return apiKey.startsWith(\"live_\") || apiKey.startsWith(\"pk_live_\");\n}\nfunction isDevelopmentFromSecretKey(apiKey) {\n  return apiKey.startsWith(\"test_\") || apiKey.startsWith(\"sk_test_\");\n}\nfunction isProductionFromSecretKey(apiKey) {\n  return apiKey.startsWith(\"live_\") || apiKey.startsWith(\"sk_live_\");\n}\nasync function getCookieSuffix(publishableKey, subtle = globalThis.crypto.subtle) {\n  const data = new TextEncoder().encode(publishableKey);\n  const digest = await subtle.digest(\"sha-1\", data);\n  const stringDigest = String.fromCharCode(...new Uint8Array(digest));\n  return (0,_chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_1__.isomorphicBtoa)(stringDigest).replace(/\\+/gi, \"-\").replace(/\\//gi, \"_\").substring(0, 8);\n}\nvar getSuffixedCookieName = (cookieName, cookieSuffix) => {\n  return `${cookieName}_${cookieSuffix}`;\n};\n\n\n//# sourceMappingURL=chunk-L2BNNARM.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstTDJCTk5BUk0ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFOEI7QUFHQTtBQUlBOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsRUFBRSxPQUFPLElBQUk7QUFDcEU7QUFDQSwrR0FBK0csNkVBQTRCO0FBQzNJO0FBQ0EsWUFBWSxVQUFVLEVBQUUsbUVBQWMsSUFBSSxZQUFZLElBQUk7QUFDMUQ7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1FQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0VBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtRUFBYztBQUN2QjtBQUNBO0FBQ0EsWUFBWSxXQUFXLEdBQUcsYUFBYTtBQUN2Qzs7QUFhRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstTDJCTk5BUk0ubWpzPzQ4ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaXNvbW9ycGhpY0F0b2Jcbn0gZnJvbSBcIi4vY2h1bmstVEVUR1RFSTIubWpzXCI7XG5pbXBvcnQge1xuICBpc29tb3JwaGljQnRvYVxufSBmcm9tIFwiLi9jaHVuay1LT0g3R1RKTy5tanNcIjtcbmltcG9ydCB7XG4gIERFVl9PUl9TVEFHSU5HX1NVRkZJWEVTLFxuICBMRUdBQ1lfREVWX0lOU1RBTkNFX1NVRkZJWEVTXG59IGZyb20gXCIuL2NodW5rLUk2TVRTVE9GLm1qc1wiO1xuXG4vLyBzcmMva2V5cy50c1xudmFyIFBVQkxJU0hBQkxFX0tFWV9MSVZFX1BSRUZJWCA9IFwicGtfbGl2ZV9cIjtcbnZhciBQVUJMSVNIQUJMRV9LRVlfVEVTVF9QUkVGSVggPSBcInBrX3Rlc3RfXCI7XG52YXIgUFVCTElTSEFCTEVfRlJPTlRFTkRfQVBJX0RFVl9SRUdFWCA9IC9eKChbYS16XSspLSl7Mn0oWzAtOV17MSwyfSlcXC5jbGVya1xcLmFjY291bnRzKFthLXouXSopKGRldnxjb20pJC9pO1xuZnVuY3Rpb24gYnVpbGRQdWJsaXNoYWJsZUtleShmcm9udGVuZEFwaSkge1xuICBjb25zdCBpc0RldktleSA9IFBVQkxJU0hBQkxFX0ZST05URU5EX0FQSV9ERVZfUkVHRVgudGVzdChmcm9udGVuZEFwaSkgfHwgZnJvbnRlbmRBcGkuc3RhcnRzV2l0aChcImNsZXJrLlwiKSAmJiBMRUdBQ1lfREVWX0lOU1RBTkNFX1NVRkZJWEVTLnNvbWUoKHMpID0+IGZyb250ZW5kQXBpLmVuZHNXaXRoKHMpKTtcbiAgY29uc3Qga2V5UHJlZml4ID0gaXNEZXZLZXkgPyBQVUJMSVNIQUJMRV9LRVlfVEVTVF9QUkVGSVggOiBQVUJMSVNIQUJMRV9LRVlfTElWRV9QUkVGSVg7XG4gIHJldHVybiBgJHtrZXlQcmVmaXh9JHtpc29tb3JwaGljQnRvYShgJHtmcm9udGVuZEFwaX0kYCl9YDtcbn1cbmZ1bmN0aW9uIHBhcnNlUHVibGlzaGFibGVLZXkoa2V5LCBvcHRpb25zID0ge30pIHtcbiAga2V5ID0ga2V5IHx8IFwiXCI7XG4gIGlmICgha2V5IHx8ICFpc1B1Ymxpc2hhYmxlS2V5KGtleSkpIHtcbiAgICBpZiAob3B0aW9ucy5mYXRhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHVibGlzaGFibGUga2V5IG5vdCB2YWxpZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlVHlwZSA9IGtleS5zdGFydHNXaXRoKFBVQkxJU0hBQkxFX0tFWV9MSVZFX1BSRUZJWCkgPyBcInByb2R1Y3Rpb25cIiA6IFwiZGV2ZWxvcG1lbnRcIjtcbiAgbGV0IGZyb250ZW5kQXBpID0gaXNvbW9ycGhpY0F0b2Ioa2V5LnNwbGl0KFwiX1wiKVsyXSk7XG4gIGZyb250ZW5kQXBpID0gZnJvbnRlbmRBcGkuc2xpY2UoMCwgLTEpO1xuICBpZiAob3B0aW9ucy5wcm94eVVybCkge1xuICAgIGZyb250ZW5kQXBpID0gb3B0aW9ucy5wcm94eVVybDtcbiAgfSBlbHNlIGlmIChpbnN0YW5jZVR5cGUgIT09IFwiZGV2ZWxvcG1lbnRcIiAmJiBvcHRpb25zLmRvbWFpbikge1xuICAgIGZyb250ZW5kQXBpID0gYGNsZXJrLiR7b3B0aW9ucy5kb21haW59YDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGluc3RhbmNlVHlwZSxcbiAgICBmcm9udGVuZEFwaVxuICB9O1xufVxuZnVuY3Rpb24gaXNQdWJsaXNoYWJsZUtleShrZXkpIHtcbiAga2V5ID0ga2V5IHx8IFwiXCI7XG4gIGNvbnN0IGhhc1ZhbGlkUHJlZml4ID0ga2V5LnN0YXJ0c1dpdGgoUFVCTElTSEFCTEVfS0VZX0xJVkVfUFJFRklYKSB8fCBrZXkuc3RhcnRzV2l0aChQVUJMSVNIQUJMRV9LRVlfVEVTVF9QUkVGSVgpO1xuICBjb25zdCBoYXNWYWxpZEZyb250ZW5kQXBpUG9zdGZpeCA9IGlzb21vcnBoaWNBdG9iKGtleS5zcGxpdChcIl9cIilbMl0gfHwgXCJcIikuZW5kc1dpdGgoXCIkXCIpO1xuICByZXR1cm4gaGFzVmFsaWRQcmVmaXggJiYgaGFzVmFsaWRGcm9udGVuZEFwaVBvc3RmaXg7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXZPclN0YWdpbmdVcmxDYWNoZSgpIHtcbiAgY29uc3QgZGV2T3JTdGFnaW5nVXJsQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIGlzRGV2T3JTdGFnaW5nVXJsOiAodXJsKSA9PiB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBob3N0bmFtZSA9IHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIgPyB1cmwgOiB1cmwuaG9zdG5hbWU7XG4gICAgICBsZXQgcmVzID0gZGV2T3JTdGFnaW5nVXJsQ2FjaGUuZ2V0KGhvc3RuYW1lKTtcbiAgICAgIGlmIChyZXMgPT09IHZvaWQgMCkge1xuICAgICAgICByZXMgPSBERVZfT1JfU1RBR0lOR19TVUZGSVhFUy5zb21lKChzKSA9PiBob3N0bmFtZS5lbmRzV2l0aChzKSk7XG4gICAgICAgIGRldk9yU3RhZ2luZ1VybENhY2hlLnNldChob3N0bmFtZSwgcmVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNEZXZlbG9wbWVudEZyb21QdWJsaXNoYWJsZUtleShhcGlLZXkpIHtcbiAgcmV0dXJuIGFwaUtleS5zdGFydHNXaXRoKFwidGVzdF9cIikgfHwgYXBpS2V5LnN0YXJ0c1dpdGgoXCJwa190ZXN0X1wiKTtcbn1cbmZ1bmN0aW9uIGlzUHJvZHVjdGlvbkZyb21QdWJsaXNoYWJsZUtleShhcGlLZXkpIHtcbiAgcmV0dXJuIGFwaUtleS5zdGFydHNXaXRoKFwibGl2ZV9cIikgfHwgYXBpS2V5LnN0YXJ0c1dpdGgoXCJwa19saXZlX1wiKTtcbn1cbmZ1bmN0aW9uIGlzRGV2ZWxvcG1lbnRGcm9tU2VjcmV0S2V5KGFwaUtleSkge1xuICByZXR1cm4gYXBpS2V5LnN0YXJ0c1dpdGgoXCJ0ZXN0X1wiKSB8fCBhcGlLZXkuc3RhcnRzV2l0aChcInNrX3Rlc3RfXCIpO1xufVxuZnVuY3Rpb24gaXNQcm9kdWN0aW9uRnJvbVNlY3JldEtleShhcGlLZXkpIHtcbiAgcmV0dXJuIGFwaUtleS5zdGFydHNXaXRoKFwibGl2ZV9cIikgfHwgYXBpS2V5LnN0YXJ0c1dpdGgoXCJza19saXZlX1wiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldENvb2tpZVN1ZmZpeChwdWJsaXNoYWJsZUtleSwgc3VidGxlID0gZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlKSB7XG4gIGNvbnN0IGRhdGEgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocHVibGlzaGFibGVLZXkpO1xuICBjb25zdCBkaWdlc3QgPSBhd2FpdCBzdWJ0bGUuZGlnZXN0KFwic2hhLTFcIiwgZGF0YSk7XG4gIGNvbnN0IHN0cmluZ0RpZ2VzdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoZGlnZXN0KSk7XG4gIHJldHVybiBpc29tb3JwaGljQnRvYShzdHJpbmdEaWdlc3QpLnJlcGxhY2UoL1xcKy9naSwgXCItXCIpLnJlcGxhY2UoL1xcLy9naSwgXCJfXCIpLnN1YnN0cmluZygwLCA4KTtcbn1cbnZhciBnZXRTdWZmaXhlZENvb2tpZU5hbWUgPSAoY29va2llTmFtZSwgY29va2llU3VmZml4KSA9PiB7XG4gIHJldHVybiBgJHtjb29raWVOYW1lfV8ke2Nvb2tpZVN1ZmZpeH1gO1xufTtcblxuZXhwb3J0IHtcbiAgYnVpbGRQdWJsaXNoYWJsZUtleSxcbiAgcGFyc2VQdWJsaXNoYWJsZUtleSxcbiAgaXNQdWJsaXNoYWJsZUtleSxcbiAgY3JlYXRlRGV2T3JTdGFnaW5nVXJsQ2FjaGUsXG4gIGlzRGV2ZWxvcG1lbnRGcm9tUHVibGlzaGFibGVLZXksXG4gIGlzUHJvZHVjdGlvbkZyb21QdWJsaXNoYWJsZUtleSxcbiAgaXNEZXZlbG9wbWVudEZyb21TZWNyZXRLZXksXG4gIGlzUHJvZHVjdGlvbkZyb21TZWNyZXRLZXksXG4gIGdldENvb2tpZVN1ZmZpeCxcbiAgZ2V0U3VmZml4ZWRDb29raWVOYW1lXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstTDJCTk5BUk0ubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-L2BNNARM.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-LJ4R7M7R.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-LJ4R7M7R.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   inBrowser: function() { return /* binding */ inBrowser; },\n/* harmony export */   isBrowserOnline: function() { return /* binding */ isBrowserOnline; },\n/* harmony export */   isValidBrowser: function() { return /* binding */ isValidBrowser; },\n/* harmony export */   isValidBrowserOnline: function() { return /* binding */ isValidBrowserOnline; },\n/* harmony export */   userAgentIsRobot: function() { return /* binding */ userAgentIsRobot; }\n/* harmony export */ });\n// src/browser.ts\nfunction inBrowser() {\n  return typeof window !== \"undefined\";\n}\nvar botAgents = [\n  \"bot\",\n  \"spider\",\n  \"crawl\",\n  \"APIs-Google\",\n  \"AdsBot\",\n  \"Googlebot\",\n  \"mediapartners\",\n  \"Google Favicon\",\n  \"FeedFetcher\",\n  \"Google-Read-Aloud\",\n  \"DuplexWeb-Google\",\n  \"googleweblight\",\n  \"bing\",\n  \"yandex\",\n  \"baidu\",\n  \"duckduck\",\n  \"yahoo\",\n  \"ecosia\",\n  \"ia_archiver\",\n  \"facebook\",\n  \"instagram\",\n  \"pinterest\",\n  \"reddit\",\n  \"slack\",\n  \"twitter\",\n  \"whatsapp\",\n  \"youtube\",\n  \"semrush\"\n];\nvar botAgentRegex = new RegExp(botAgents.join(\"|\"), \"i\");\nfunction userAgentIsRobot(userAgent) {\n  return !userAgent ? false : botAgentRegex.test(userAgent);\n}\nfunction isValidBrowser() {\n  const navigator = inBrowser() ? window == null ? void 0 : window.navigator : null;\n  if (!navigator) {\n    return false;\n  }\n  return !userAgentIsRobot(navigator == null ? void 0 : navigator.userAgent) && !(navigator == null ? void 0 : navigator.webdriver);\n}\nfunction isBrowserOnline() {\n  var _a, _b;\n  const navigator = inBrowser() ? window == null ? void 0 : window.navigator : null;\n  if (!navigator) {\n    return false;\n  }\n  const isNavigatorOnline = navigator == null ? void 0 : navigator.onLine;\n  const isExperimentalConnectionOnline = ((_a = navigator == null ? void 0 : navigator.connection) == null ? void 0 : _a.rtt) !== 0 && ((_b = navigator == null ? void 0 : navigator.connection) == null ? void 0 : _b.downlink) !== 0;\n  return isExperimentalConnectionOnline && isNavigatorOnline;\n}\nfunction isValidBrowserOnline() {\n  return isBrowserOnline() && isValidBrowser();\n}\n\n\n//# sourceMappingURL=chunk-LJ4R7M7R.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstTEo0UjdNN1IubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLUxKNFI3TTdSLm1qcz9lYWUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9icm93c2VyLnRzXG5mdW5jdGlvbiBpbkJyb3dzZXIoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufVxudmFyIGJvdEFnZW50cyA9IFtcbiAgXCJib3RcIixcbiAgXCJzcGlkZXJcIixcbiAgXCJjcmF3bFwiLFxuICBcIkFQSXMtR29vZ2xlXCIsXG4gIFwiQWRzQm90XCIsXG4gIFwiR29vZ2xlYm90XCIsXG4gIFwibWVkaWFwYXJ0bmVyc1wiLFxuICBcIkdvb2dsZSBGYXZpY29uXCIsXG4gIFwiRmVlZEZldGNoZXJcIixcbiAgXCJHb29nbGUtUmVhZC1BbG91ZFwiLFxuICBcIkR1cGxleFdlYi1Hb29nbGVcIixcbiAgXCJnb29nbGV3ZWJsaWdodFwiLFxuICBcImJpbmdcIixcbiAgXCJ5YW5kZXhcIixcbiAgXCJiYWlkdVwiLFxuICBcImR1Y2tkdWNrXCIsXG4gIFwieWFob29cIixcbiAgXCJlY29zaWFcIixcbiAgXCJpYV9hcmNoaXZlclwiLFxuICBcImZhY2Vib29rXCIsXG4gIFwiaW5zdGFncmFtXCIsXG4gIFwicGludGVyZXN0XCIsXG4gIFwicmVkZGl0XCIsXG4gIFwic2xhY2tcIixcbiAgXCJ0d2l0dGVyXCIsXG4gIFwid2hhdHNhcHBcIixcbiAgXCJ5b3V0dWJlXCIsXG4gIFwic2VtcnVzaFwiXG5dO1xudmFyIGJvdEFnZW50UmVnZXggPSBuZXcgUmVnRXhwKGJvdEFnZW50cy5qb2luKFwifFwiKSwgXCJpXCIpO1xuZnVuY3Rpb24gdXNlckFnZW50SXNSb2JvdCh1c2VyQWdlbnQpIHtcbiAgcmV0dXJuICF1c2VyQWdlbnQgPyBmYWxzZSA6IGJvdEFnZW50UmVnZXgudGVzdCh1c2VyQWdlbnQpO1xufVxuZnVuY3Rpb24gaXNWYWxpZEJyb3dzZXIoKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IGluQnJvd3NlcigpID8gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubmF2aWdhdG9yIDogbnVsbDtcbiAgaWYgKCFuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICF1c2VyQWdlbnRJc1JvYm90KG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIShuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci53ZWJkcml2ZXIpO1xufVxuZnVuY3Rpb24gaXNCcm93c2VyT25saW5lKCkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBuYXZpZ2F0b3IgPSBpbkJyb3dzZXIoKSA/IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93Lm5hdmlnYXRvciA6IG51bGw7XG4gIGlmICghbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlzTmF2aWdhdG9yT25saW5lID0gbmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3Iub25MaW5lO1xuICBjb25zdCBpc0V4cGVyaW1lbnRhbENvbm5lY3Rpb25PbmxpbmUgPSAoKF9hID0gbmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuY29ubmVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJ0dCkgIT09IDAgJiYgKChfYiA9IG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLmNvbm5lY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5kb3dubGluaykgIT09IDA7XG4gIHJldHVybiBpc0V4cGVyaW1lbnRhbENvbm5lY3Rpb25PbmxpbmUgJiYgaXNOYXZpZ2F0b3JPbmxpbmU7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQnJvd3Nlck9ubGluZSgpIHtcbiAgcmV0dXJuIGlzQnJvd3Nlck9ubGluZSgpICYmIGlzVmFsaWRCcm93c2VyKCk7XG59XG5cbmV4cG9ydCB7XG4gIGluQnJvd3NlcixcbiAgdXNlckFnZW50SXNSb2JvdCxcbiAgaXNWYWxpZEJyb3dzZXIsXG4gIGlzQnJvd3Nlck9ubGluZSxcbiAgaXNWYWxpZEJyb3dzZXJPbmxpbmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1MSjRSN003Ui5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-LJ4R7M7R.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-Q2DOGLDC.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-Q2DOGLDC.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClerkPrefix: function() { return /* binding */ addClerkPrefix; },\n/* harmony export */   cleanDoubleSlashes: function() { return /* binding */ cleanDoubleSlashes; },\n/* harmony export */   getClerkJsMajorVersionOrTag: function() { return /* binding */ getClerkJsMajorVersionOrTag; },\n/* harmony export */   getScriptUrl: function() { return /* binding */ getScriptUrl; },\n/* harmony export */   hasLeadingSlash: function() { return /* binding */ hasLeadingSlash; },\n/* harmony export */   hasTrailingSlash: function() { return /* binding */ hasTrailingSlash; },\n/* harmony export */   isAbsoluteUrl: function() { return /* binding */ isAbsoluteUrl; },\n/* harmony export */   isCurrentDevAccountPortalOrigin: function() { return /* binding */ isCurrentDevAccountPortalOrigin; },\n/* harmony export */   isLegacyDevAccountPortalOrigin: function() { return /* binding */ isLegacyDevAccountPortalOrigin; },\n/* harmony export */   isNonEmptyURL: function() { return /* binding */ isNonEmptyURL; },\n/* harmony export */   isStaging: function() { return /* binding */ isStaging; },\n/* harmony export */   joinURL: function() { return /* binding */ joinURL; },\n/* harmony export */   parseSearchParams: function() { return /* binding */ parseSearchParams; },\n/* harmony export */   stripScheme: function() { return /* binding */ stripScheme; },\n/* harmony export */   withLeadingSlash: function() { return /* binding */ withLeadingSlash; },\n/* harmony export */   withTrailingSlash: function() { return /* binding */ withTrailingSlash; },\n/* harmony export */   withoutLeadingSlash: function() { return /* binding */ withoutLeadingSlash; },\n/* harmony export */   withoutTrailingSlash: function() { return /* binding */ withoutTrailingSlash; }\n/* harmony export */ });\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n\n\n// src/utils/instance.ts\nfunction isStaging(frontendApi) {\n  return frontendApi.endsWith(\".lclstage.dev\") || frontendApi.endsWith(\".stgstage.dev\") || frontendApi.endsWith(\".clerkstage.dev\") || frontendApi.endsWith(\".accountsstage.dev\");\n}\n\n// src/url.ts\nfunction parseSearchParams(queryString = \"\") {\n  if (queryString.startsWith(\"?\")) {\n    queryString = queryString.slice(1);\n  }\n  return new URLSearchParams(queryString);\n}\nfunction stripScheme(url = \"\") {\n  return (url || \"\").replace(/^.+:\\/\\//, \"\");\n}\nfunction addClerkPrefix(str) {\n  if (!str) {\n    return \"\";\n  }\n  let regex;\n  if (str.match(/^(clerk\\.)+\\w*$/)) {\n    regex = /(clerk\\.)*(?=clerk\\.)/;\n  } else if (str.match(/\\.clerk.accounts/)) {\n    return str;\n  } else {\n    regex = /^(clerk\\.)*/gi;\n  }\n  const stripped = str.replace(regex, \"\");\n  return `clerk.${stripped}`;\n}\nvar getClerkJsMajorVersionOrTag = (frontendApi, version) => {\n  if (!version && isStaging(frontendApi)) {\n    return \"canary\";\n  }\n  if (!version) {\n    return \"latest\";\n  }\n  return version.split(\".\")[0] || \"latest\";\n};\nvar getScriptUrl = (frontendApi, { clerkJSVersion }) => {\n  const noSchemeFrontendApi = frontendApi.replace(/http(s)?:\\/\\//, \"\");\n  const major = getClerkJsMajorVersionOrTag(frontendApi, clerkJSVersion);\n  return `https://${noSchemeFrontendApi}/npm/@clerk/clerk-js@${clerkJSVersion || major}/dist/clerk.browser.js`;\n};\nfunction isLegacyDevAccountPortalOrigin(host) {\n  return _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_0__.LEGACY_DEV_INSTANCE_SUFFIXES.some((legacyDevSuffix) => {\n    return host.startsWith(\"accounts.\") && host.endsWith(legacyDevSuffix);\n  });\n}\nfunction isCurrentDevAccountPortalOrigin(host) {\n  return _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_0__.CURRENT_DEV_INSTANCE_SUFFIXES.some((currentDevSuffix) => {\n    return host.endsWith(currentDevSuffix) && !host.endsWith(\".clerk\" + currentDevSuffix);\n  });\n}\nvar TRAILING_SLASH_RE = /\\/$|\\/\\?|\\/#/;\nfunction hasTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n    if (!path) {\n      return fragment;\n    }\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction withoutTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nvar JOIN_LEADING_SLASH_RE = /^\\.?\\//;\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {\n    if (url) {\n      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, \"\");\n      url = withTrailingSlash(url) + _segment;\n    } else {\n      url = segment;\n    }\n  }\n  return url;\n}\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nvar isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);\n\n\n//# sourceMappingURL=chunk-Q2DOGLDC.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstUTJET0dMREMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CLHVCQUF1Qix3QkFBd0I7QUFDdkY7QUFDQTtBQUNBLFNBQVMsNkVBQTRCO0FBQ3JDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLDhFQUE2QjtBQUN0QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFxQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLVEyRE9HTERDLm1qcz83NjUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENVUlJFTlRfREVWX0lOU1RBTkNFX1NVRkZJWEVTLFxuICBMRUdBQ1lfREVWX0lOU1RBTkNFX1NVRkZJWEVTXG59IGZyb20gXCIuL2NodW5rLUk2TVRTVE9GLm1qc1wiO1xuXG4vLyBzcmMvdXRpbHMvaW5zdGFuY2UudHNcbmZ1bmN0aW9uIGlzU3RhZ2luZyhmcm9udGVuZEFwaSkge1xuICByZXR1cm4gZnJvbnRlbmRBcGkuZW5kc1dpdGgoXCIubGNsc3RhZ2UuZGV2XCIpIHx8IGZyb250ZW5kQXBpLmVuZHNXaXRoKFwiLnN0Z3N0YWdlLmRldlwiKSB8fCBmcm9udGVuZEFwaS5lbmRzV2l0aChcIi5jbGVya3N0YWdlLmRldlwiKSB8fCBmcm9udGVuZEFwaS5lbmRzV2l0aChcIi5hY2NvdW50c3N0YWdlLmRldlwiKTtcbn1cblxuLy8gc3JjL3VybC50c1xuZnVuY3Rpb24gcGFyc2VTZWFyY2hQYXJhbXMocXVlcnlTdHJpbmcgPSBcIlwiKSB7XG4gIGlmIChxdWVyeVN0cmluZy5zdGFydHNXaXRoKFwiP1wiKSkge1xuICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMocXVlcnlTdHJpbmcpO1xufVxuZnVuY3Rpb24gc3RyaXBTY2hlbWUodXJsID0gXCJcIikge1xuICByZXR1cm4gKHVybCB8fCBcIlwiKS5yZXBsYWNlKC9eLis6XFwvXFwvLywgXCJcIik7XG59XG5mdW5jdGlvbiBhZGRDbGVya1ByZWZpeChzdHIpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBsZXQgcmVnZXg7XG4gIGlmIChzdHIubWF0Y2goL14oY2xlcmtcXC4pK1xcdyokLykpIHtcbiAgICByZWdleCA9IC8oY2xlcmtcXC4pKig/PWNsZXJrXFwuKS87XG4gIH0gZWxzZSBpZiAoc3RyLm1hdGNoKC9cXC5jbGVyay5hY2NvdW50cy8pKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfSBlbHNlIHtcbiAgICByZWdleCA9IC9eKGNsZXJrXFwuKSovZ2k7XG4gIH1cbiAgY29uc3Qgc3RyaXBwZWQgPSBzdHIucmVwbGFjZShyZWdleCwgXCJcIik7XG4gIHJldHVybiBgY2xlcmsuJHtzdHJpcHBlZH1gO1xufVxudmFyIGdldENsZXJrSnNNYWpvclZlcnNpb25PclRhZyA9IChmcm9udGVuZEFwaSwgdmVyc2lvbikgPT4ge1xuICBpZiAoIXZlcnNpb24gJiYgaXNTdGFnaW5nKGZyb250ZW5kQXBpKSkge1xuICAgIHJldHVybiBcImNhbmFyeVwiO1xuICB9XG4gIGlmICghdmVyc2lvbikge1xuICAgIHJldHVybiBcImxhdGVzdFwiO1xuICB9XG4gIHJldHVybiB2ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSB8fCBcImxhdGVzdFwiO1xufTtcbnZhciBnZXRTY3JpcHRVcmwgPSAoZnJvbnRlbmRBcGksIHsgY2xlcmtKU1ZlcnNpb24gfSkgPT4ge1xuICBjb25zdCBub1NjaGVtZUZyb250ZW5kQXBpID0gZnJvbnRlbmRBcGkucmVwbGFjZSgvaHR0cChzKT86XFwvXFwvLywgXCJcIik7XG4gIGNvbnN0IG1ham9yID0gZ2V0Q2xlcmtKc01ham9yVmVyc2lvbk9yVGFnKGZyb250ZW5kQXBpLCBjbGVya0pTVmVyc2lvbik7XG4gIHJldHVybiBgaHR0cHM6Ly8ke25vU2NoZW1lRnJvbnRlbmRBcGl9L25wbS9AY2xlcmsvY2xlcmstanNAJHtjbGVya0pTVmVyc2lvbiB8fCBtYWpvcn0vZGlzdC9jbGVyay5icm93c2VyLmpzYDtcbn07XG5mdW5jdGlvbiBpc0xlZ2FjeURldkFjY291bnRQb3J0YWxPcmlnaW4oaG9zdCkge1xuICByZXR1cm4gTEVHQUNZX0RFVl9JTlNUQU5DRV9TVUZGSVhFUy5zb21lKChsZWdhY3lEZXZTdWZmaXgpID0+IHtcbiAgICByZXR1cm4gaG9zdC5zdGFydHNXaXRoKFwiYWNjb3VudHMuXCIpICYmIGhvc3QuZW5kc1dpdGgobGVnYWN5RGV2U3VmZml4KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0N1cnJlbnREZXZBY2NvdW50UG9ydGFsT3JpZ2luKGhvc3QpIHtcbiAgcmV0dXJuIENVUlJFTlRfREVWX0lOU1RBTkNFX1NVRkZJWEVTLnNvbWUoKGN1cnJlbnREZXZTdWZmaXgpID0+IHtcbiAgICByZXR1cm4gaG9zdC5lbmRzV2l0aChjdXJyZW50RGV2U3VmZml4KSAmJiAhaG9zdC5lbmRzV2l0aChcIi5jbGVya1wiICsgY3VycmVudERldlN1ZmZpeCk7XG4gIH0pO1xufVxudmFyIFRSQUlMSU5HX1NMQVNIX1JFID0gL1xcLyR8XFwvXFw/fFxcLyMvO1xuZnVuY3Rpb24gaGFzVHJhaWxpbmdTbGFzaChpbnB1dCA9IFwiXCIsIHJlc3BlY3RRdWVyeUFuZEZyYWdtZW50KSB7XG4gIGlmICghcmVzcGVjdFF1ZXJ5QW5kRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gaW5wdXQuZW5kc1dpdGgoXCIvXCIpO1xuICB9XG4gIHJldHVybiBUUkFJTElOR19TTEFTSF9SRS50ZXN0KGlucHV0KTtcbn1cbmZ1bmN0aW9uIHdpdGhUcmFpbGluZ1NsYXNoKGlucHV0ID0gXCJcIiwgcmVzcGVjdFF1ZXJ5QW5kRnJhZ21lbnQpIHtcbiAgaWYgKCFyZXNwZWN0UXVlcnlBbmRGcmFnbWVudCkge1xuICAgIHJldHVybiBpbnB1dC5lbmRzV2l0aChcIi9cIikgPyBpbnB1dCA6IGlucHV0ICsgXCIvXCI7XG4gIH1cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2goaW5wdXQsIHRydWUpKSB7XG4gICAgcmV0dXJuIGlucHV0IHx8IFwiL1wiO1xuICB9XG4gIGxldCBwYXRoID0gaW5wdXQ7XG4gIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gIGNvbnN0IGZyYWdtZW50SW5kZXggPSBpbnB1dC5pbmRleE9mKFwiI1wiKTtcbiAgaWYgKGZyYWdtZW50SW5kZXggPj0gMCkge1xuICAgIHBhdGggPSBpbnB1dC5zbGljZSgwLCBmcmFnbWVudEluZGV4KTtcbiAgICBmcmFnbWVudCA9IGlucHV0LnNsaWNlKGZyYWdtZW50SW5kZXgpO1xuICAgIGlmICghcGF0aCkge1xuICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCBbczAsIC4uLnNdID0gcGF0aC5zcGxpdChcIj9cIik7XG4gIHJldHVybiBzMCArIFwiL1wiICsgKHMubGVuZ3RoID4gMCA/IGA/JHtzLmpvaW4oXCI/XCIpfWAgOiBcIlwiKSArIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gd2l0aG91dFRyYWlsaW5nU2xhc2goaW5wdXQgPSBcIlwiLCByZXNwZWN0UXVlcnlBbmRGcmFnbWVudCkge1xuICBpZiAoIXJlc3BlY3RRdWVyeUFuZEZyYWdtZW50KSB7XG4gICAgcmV0dXJuIChoYXNUcmFpbGluZ1NsYXNoKGlucHV0KSA/IGlucHV0LnNsaWNlKDAsIC0xKSA6IGlucHV0KSB8fCBcIi9cIjtcbiAgfVxuICBpZiAoIWhhc1RyYWlsaW5nU2xhc2goaW5wdXQsIHRydWUpKSB7XG4gICAgcmV0dXJuIGlucHV0IHx8IFwiL1wiO1xuICB9XG4gIGxldCBwYXRoID0gaW5wdXQ7XG4gIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gIGNvbnN0IGZyYWdtZW50SW5kZXggPSBpbnB1dC5pbmRleE9mKFwiI1wiKTtcbiAgaWYgKGZyYWdtZW50SW5kZXggPj0gMCkge1xuICAgIHBhdGggPSBpbnB1dC5zbGljZSgwLCBmcmFnbWVudEluZGV4KTtcbiAgICBmcmFnbWVudCA9IGlucHV0LnNsaWNlKGZyYWdtZW50SW5kZXgpO1xuICB9XG4gIGNvbnN0IFtzMCwgLi4uc10gPSBwYXRoLnNwbGl0KFwiP1wiKTtcbiAgcmV0dXJuIChzMC5zbGljZSgwLCAtMSkgfHwgXCIvXCIpICsgKHMubGVuZ3RoID4gMCA/IGA/JHtzLmpvaW4oXCI/XCIpfWAgOiBcIlwiKSArIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gaGFzTGVhZGluZ1NsYXNoKGlucHV0ID0gXCJcIikge1xuICByZXR1cm4gaW5wdXQuc3RhcnRzV2l0aChcIi9cIik7XG59XG5mdW5jdGlvbiB3aXRob3V0TGVhZGluZ1NsYXNoKGlucHV0ID0gXCJcIikge1xuICByZXR1cm4gKGhhc0xlYWRpbmdTbGFzaChpbnB1dCkgPyBpbnB1dC5zbGljZSgxKSA6IGlucHV0KSB8fCBcIi9cIjtcbn1cbmZ1bmN0aW9uIHdpdGhMZWFkaW5nU2xhc2goaW5wdXQgPSBcIlwiKSB7XG4gIHJldHVybiBoYXNMZWFkaW5nU2xhc2goaW5wdXQpID8gaW5wdXQgOiBcIi9cIiArIGlucHV0O1xufVxuZnVuY3Rpb24gY2xlYW5Eb3VibGVTbGFzaGVzKGlucHV0ID0gXCJcIikge1xuICByZXR1cm4gaW5wdXQuc3BsaXQoXCI6Ly9cIikubWFwKChzdHJpbmdfKSA9PiBzdHJpbmdfLnJlcGxhY2UoL1xcL3syLH0vZywgXCIvXCIpKS5qb2luKFwiOi8vXCIpO1xufVxuZnVuY3Rpb24gaXNOb25FbXB0eVVSTCh1cmwpIHtcbiAgcmV0dXJuIHVybCAmJiB1cmwgIT09IFwiL1wiO1xufVxudmFyIEpPSU5fTEVBRElOR19TTEFTSF9SRSA9IC9eXFwuP1xcLy87XG5mdW5jdGlvbiBqb2luVVJMKGJhc2UsIC4uLmlucHV0KSB7XG4gIGxldCB1cmwgPSBiYXNlIHx8IFwiXCI7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBpbnB1dC5maWx0ZXIoKHVybDIpID0+IGlzTm9uRW1wdHlVUkwodXJsMikpKSB7XG4gICAgaWYgKHVybCkge1xuICAgICAgY29uc3QgX3NlZ21lbnQgPSBzZWdtZW50LnJlcGxhY2UoSk9JTl9MRUFESU5HX1NMQVNIX1JFLCBcIlwiKTtcbiAgICAgIHVybCA9IHdpdGhUcmFpbGluZ1NsYXNoKHVybCkgKyBfc2VnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsID0gc2VnbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbnZhciBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi87XG52YXIgaXNBYnNvbHV0ZVVybCA9ICh1cmwpID0+IEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KHVybCk7XG5cbmV4cG9ydCB7XG4gIGlzU3RhZ2luZyxcbiAgcGFyc2VTZWFyY2hQYXJhbXMsXG4gIHN0cmlwU2NoZW1lLFxuICBhZGRDbGVya1ByZWZpeCxcbiAgZ2V0Q2xlcmtKc01ham9yVmVyc2lvbk9yVGFnLFxuICBnZXRTY3JpcHRVcmwsXG4gIGlzTGVnYWN5RGV2QWNjb3VudFBvcnRhbE9yaWdpbixcbiAgaXNDdXJyZW50RGV2QWNjb3VudFBvcnRhbE9yaWdpbixcbiAgaGFzVHJhaWxpbmdTbGFzaCxcbiAgd2l0aFRyYWlsaW5nU2xhc2gsXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoLFxuICBoYXNMZWFkaW5nU2xhc2gsXG4gIHdpdGhvdXRMZWFkaW5nU2xhc2gsXG4gIHdpdGhMZWFkaW5nU2xhc2gsXG4gIGNsZWFuRG91YmxlU2xhc2hlcyxcbiAgaXNOb25FbXB0eVVSTCxcbiAgam9pblVSTCxcbiAgaXNBYnNvbHV0ZVVybFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVEyRE9HTERDLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-Q2DOGLDC.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-QE2A7CJI.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-QE2A7CJI.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   camelToSnake: function() { return /* binding */ camelToSnake; },\n/* harmony export */   deepCamelToSnake: function() { return /* binding */ deepCamelToSnake; },\n/* harmony export */   deepSnakeToCamel: function() { return /* binding */ deepSnakeToCamel; },\n/* harmony export */   getNonUndefinedValues: function() { return /* binding */ getNonUndefinedValues; },\n/* harmony export */   isIPV4Address: function() { return /* binding */ isIPV4Address; },\n/* harmony export */   isTruthy: function() { return /* binding */ isTruthy; },\n/* harmony export */   snakeToCamel: function() { return /* binding */ snakeToCamel; },\n/* harmony export */   titleize: function() { return /* binding */ titleize; },\n/* harmony export */   toSentence: function() { return /* binding */ toSentence; }\n/* harmony export */ });\n// src/underscore.ts\nvar toSentence = (items) => {\n  if (items.length == 0) {\n    return \"\";\n  }\n  if (items.length == 1) {\n    return items[0];\n  }\n  let sentence = items.slice(0, -1).join(\", \");\n  sentence += `, or ${items.slice(-1)}`;\n  return sentence;\n};\nvar IP_V4_ADDRESS_REGEX = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\nfunction isIPV4Address(str) {\n  return IP_V4_ADDRESS_REGEX.test(str || \"\");\n}\nfunction titleize(str) {\n  const s = str || \"\";\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\nfunction snakeToCamel(str) {\n  return str ? str.replace(/([-_][a-z])/g, (match) => match.toUpperCase().replace(/-|_/, \"\")) : \"\";\n}\nfunction camelToSnake(str) {\n  return str ? str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`) : \"\";\n}\nvar createDeepObjectTransformer = (transform) => {\n  const deepTransform = (obj) => {\n    if (!obj) {\n      return obj;\n    }\n    if (Array.isArray(obj)) {\n      return obj.map((el) => {\n        if (typeof el === \"object\" || Array.isArray(el)) {\n          return deepTransform(el);\n        }\n        return el;\n      });\n    }\n    const copy = { ...obj };\n    const keys = Object.keys(copy);\n    for (const oldName of keys) {\n      const newName = transform(oldName.toString());\n      if (newName !== oldName) {\n        copy[newName] = copy[oldName];\n        delete copy[oldName];\n      }\n      if (typeof copy[newName] === \"object\") {\n        copy[newName] = deepTransform(copy[newName]);\n      }\n    }\n    return copy;\n  };\n  return deepTransform;\n};\nvar deepCamelToSnake = createDeepObjectTransformer(camelToSnake);\nvar deepSnakeToCamel = createDeepObjectTransformer(snakeToCamel);\nfunction isTruthy(value) {\n  if (typeof value === `boolean`) {\n    return value;\n  }\n  if (value === void 0 || value === null) {\n    return false;\n  }\n  if (typeof value === `string`) {\n    if (value.toLowerCase() === `true`) {\n      return true;\n    }\n    if (value.toLowerCase() === `false`) {\n      return false;\n    }\n  }\n  const number = parseInt(value, 10);\n  if (isNaN(number)) {\n    return false;\n  }\n  if (number > 0) {\n    return true;\n  }\n  return false;\n}\nfunction getNonUndefinedValues(obj) {\n  return Object.entries(obj).reduce((acc, [key, value]) => {\n    if (value !== void 0) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n\n//# sourceMappingURL=chunk-QE2A7CJI.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstUUUyQTdDSkkubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxQkFBcUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFZRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstUUUyQTdDSkkubWpzPzQyYWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3VuZGVyc2NvcmUudHNcbnZhciB0b1NlbnRlbmNlID0gKGl0ZW1zKSA9PiB7XG4gIGlmIChpdGVtcy5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmIChpdGVtcy5sZW5ndGggPT0gMSkge1xuICAgIHJldHVybiBpdGVtc1swXTtcbiAgfVxuICBsZXQgc2VudGVuY2UgPSBpdGVtcy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpO1xuICBzZW50ZW5jZSArPSBgLCBvciAke2l0ZW1zLnNsaWNlKC0xKX1gO1xuICByZXR1cm4gc2VudGVuY2U7XG59O1xudmFyIElQX1Y0X0FERFJFU1NfUkVHRVggPSAvXigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pJC87XG5mdW5jdGlvbiBpc0lQVjRBZGRyZXNzKHN0cikge1xuICByZXR1cm4gSVBfVjRfQUREUkVTU19SRUdFWC50ZXN0KHN0ciB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHRpdGxlaXplKHN0cikge1xuICBjb25zdCBzID0gc3RyIHx8IFwiXCI7XG4gIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIHNuYWtlVG9DYW1lbChzdHIpIHtcbiAgcmV0dXJuIHN0ciA/IHN0ci5yZXBsYWNlKC8oWy1fXVthLXpdKS9nLCAobWF0Y2gpID0+IG1hdGNoLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvLXxfLywgXCJcIikpIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGNhbWVsVG9TbmFrZShzdHIpIHtcbiAgcmV0dXJuIHN0ciA/IHN0ci5yZXBsYWNlKC9bQS1aXS9nLCAobGV0dGVyKSA9PiBgXyR7bGV0dGVyLnRvTG93ZXJDYXNlKCl9YCkgOiBcIlwiO1xufVxudmFyIGNyZWF0ZURlZXBPYmplY3RUcmFuc2Zvcm1lciA9ICh0cmFuc2Zvcm0pID0+IHtcbiAgY29uc3QgZGVlcFRyYW5zZm9ybSA9IChvYmopID0+IHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuIG9iai5tYXAoKGVsKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZWwgPT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcFRyYW5zZm9ybShlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNvcHkgPSB7IC4uLm9iaiB9O1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjb3B5KTtcbiAgICBmb3IgKGNvbnN0IG9sZE5hbWUgb2Yga2V5cykge1xuICAgICAgY29uc3QgbmV3TmFtZSA9IHRyYW5zZm9ybShvbGROYW1lLnRvU3RyaW5nKCkpO1xuICAgICAgaWYgKG5ld05hbWUgIT09IG9sZE5hbWUpIHtcbiAgICAgICAgY29weVtuZXdOYW1lXSA9IGNvcHlbb2xkTmFtZV07XG4gICAgICAgIGRlbGV0ZSBjb3B5W29sZE5hbWVdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb3B5W25ld05hbWVdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvcHlbbmV3TmFtZV0gPSBkZWVwVHJhbnNmb3JtKGNvcHlbbmV3TmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfTtcbiAgcmV0dXJuIGRlZXBUcmFuc2Zvcm07XG59O1xudmFyIGRlZXBDYW1lbFRvU25ha2UgPSBjcmVhdGVEZWVwT2JqZWN0VHJhbnNmb3JtZXIoY2FtZWxUb1NuYWtlKTtcbnZhciBkZWVwU25ha2VUb0NhbWVsID0gY3JlYXRlRGVlcE9iamVjdFRyYW5zZm9ybWVyKHNuYWtlVG9DYW1lbCk7XG5mdW5jdGlvbiBpc1RydXRoeSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBgYm9vbGVhbmApIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gYHN0cmluZ2ApIHtcbiAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gYHRydWVgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGBmYWxzZWApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG51bWJlciA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXROb25VbmRlZmluZWRWYWx1ZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG5leHBvcnQge1xuICB0b1NlbnRlbmNlLFxuICBpc0lQVjRBZGRyZXNzLFxuICB0aXRsZWl6ZSxcbiAgc25ha2VUb0NhbWVsLFxuICBjYW1lbFRvU25ha2UsXG4gIGRlZXBDYW1lbFRvU25ha2UsXG4gIGRlZXBTbmFrZVRvQ2FtZWwsXG4gIGlzVHJ1dGh5LFxuICBnZXROb25VbmRlZmluZWRWYWx1ZXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1RRTJBN0NKSS5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-QE2A7CJI.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-QPSU45F4.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-QPSU45F4.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiUrlFromPublishableKey: function() { return /* binding */ apiUrlFromPublishableKey; }\n/* harmony export */ });\n/* harmony import */ var _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-L2BNNARM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-L2BNNARM.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n\n\n\n// src/apiUrlFromPublishableKey.ts\nvar apiUrlFromPublishableKey = (publishableKey) => {\n  var _a;\n  const frontendApi = (_a = (0,_chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.parsePublishableKey)(publishableKey)) == null ? void 0 : _a.frontendApi;\n  if ((frontendApi == null ? void 0 : frontendApi.startsWith(\"clerk.\")) && _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__.LEGACY_DEV_INSTANCE_SUFFIXES.some((suffix) => frontendApi == null ? void 0 : frontendApi.endsWith(suffix))) {\n    return _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__.PROD_API_URL;\n  }\n  if (_chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__.LOCAL_ENV_SUFFIXES.some((suffix) => frontendApi == null ? void 0 : frontendApi.endsWith(suffix))) {\n    return _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__.LOCAL_API_URL;\n  }\n  if (_chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__.STAGING_ENV_SUFFIXES.some((suffix) => frontendApi == null ? void 0 : frontendApi.endsWith(suffix))) {\n    return _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__.STAGING_API_URL;\n  }\n  return _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_1__.PROD_API_URL;\n};\n\n\n//# sourceMappingURL=chunk-QPSU45F4.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstUVBTVTQ1RjQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUU4QjtBQVFBOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0VBQW1CO0FBQy9DLDJFQUEyRSw2RUFBNEI7QUFDdkcsV0FBVyw2REFBWTtBQUN2QjtBQUNBLE1BQU0sbUVBQWtCO0FBQ3hCLFdBQVcsOERBQWE7QUFDeEI7QUFDQSxNQUFNLHFFQUFvQjtBQUMxQixXQUFXLGdFQUFlO0FBQzFCO0FBQ0EsU0FBUyw2REFBWTtBQUNyQjs7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstUVBTVTQ1RjQubWpzP2U3MDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgcGFyc2VQdWJsaXNoYWJsZUtleVxufSBmcm9tIFwiLi9jaHVuay1MMkJOTkFSTS5tanNcIjtcbmltcG9ydCB7XG4gIExFR0FDWV9ERVZfSU5TVEFOQ0VfU1VGRklYRVMsXG4gIExPQ0FMX0FQSV9VUkwsXG4gIExPQ0FMX0VOVl9TVUZGSVhFUyxcbiAgUFJPRF9BUElfVVJMLFxuICBTVEFHSU5HX0FQSV9VUkwsXG4gIFNUQUdJTkdfRU5WX1NVRkZJWEVTXG59IGZyb20gXCIuL2NodW5rLUk2TVRTVE9GLm1qc1wiO1xuXG4vLyBzcmMvYXBpVXJsRnJvbVB1Ymxpc2hhYmxlS2V5LnRzXG52YXIgYXBpVXJsRnJvbVB1Ymxpc2hhYmxlS2V5ID0gKHB1Ymxpc2hhYmxlS2V5KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgZnJvbnRlbmRBcGkgPSAoX2EgPSBwYXJzZVB1Ymxpc2hhYmxlS2V5KHB1Ymxpc2hhYmxlS2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZyb250ZW5kQXBpO1xuICBpZiAoKGZyb250ZW5kQXBpID09IG51bGwgPyB2b2lkIDAgOiBmcm9udGVuZEFwaS5zdGFydHNXaXRoKFwiY2xlcmsuXCIpKSAmJiBMRUdBQ1lfREVWX0lOU1RBTkNFX1NVRkZJWEVTLnNvbWUoKHN1ZmZpeCkgPT4gZnJvbnRlbmRBcGkgPT0gbnVsbCA/IHZvaWQgMCA6IGZyb250ZW5kQXBpLmVuZHNXaXRoKHN1ZmZpeCkpKSB7XG4gICAgcmV0dXJuIFBST0RfQVBJX1VSTDtcbiAgfVxuICBpZiAoTE9DQUxfRU5WX1NVRkZJWEVTLnNvbWUoKHN1ZmZpeCkgPT4gZnJvbnRlbmRBcGkgPT0gbnVsbCA/IHZvaWQgMCA6IGZyb250ZW5kQXBpLmVuZHNXaXRoKHN1ZmZpeCkpKSB7XG4gICAgcmV0dXJuIExPQ0FMX0FQSV9VUkw7XG4gIH1cbiAgaWYgKFNUQUdJTkdfRU5WX1NVRkZJWEVTLnNvbWUoKHN1ZmZpeCkgPT4gZnJvbnRlbmRBcGkgPT0gbnVsbCA/IHZvaWQgMCA6IGZyb250ZW5kQXBpLmVuZHNXaXRoKHN1ZmZpeCkpKSB7XG4gICAgcmV0dXJuIFNUQUdJTkdfQVBJX1VSTDtcbiAgfVxuICByZXR1cm4gUFJPRF9BUElfVVJMO1xufTtcblxuZXhwb3J0IHtcbiAgYXBpVXJsRnJvbVB1Ymxpc2hhYmxlS2V5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstUVBTVTQ1RjQubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-QPSU45F4.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-RSOCGYTF.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-RSOCGYTF.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalStorageBroadcastChannel: function() { return /* binding */ LocalStorageBroadcastChannel; }\n/* harmony export */ });\n// src/localStorageBroadcastChannel.ts\nvar KEY_PREFIX = \"__lsbc__\";\nvar LocalStorageBroadcastChannel = class {\n  constructor(name) {\n    this.eventTarget = window;\n    this.postMessage = (data) => {\n      if (typeof window === \"undefined\") {\n        return;\n      }\n      try {\n        window.localStorage.setItem(this.channelKey, JSON.stringify(data));\n        window.localStorage.removeItem(this.channelKey);\n      } catch (e) {\n      }\n    };\n    this.addEventListener = (eventName, listener) => {\n      this.eventTarget.addEventListener(this.prefixEventName(eventName), (e) => {\n        listener(e);\n      });\n    };\n    this.setupLocalStorageListener = () => {\n      const notifyListeners = (e) => {\n        if (e.key !== this.channelKey || !e.newValue) {\n          return;\n        }\n        try {\n          const data = JSON.parse(e.newValue || \"\");\n          const event = new MessageEvent(this.prefixEventName(\"message\"), {\n            data\n          });\n          this.eventTarget.dispatchEvent(event);\n        } catch (e2) {\n        }\n      };\n      window.addEventListener(\"storage\", notifyListeners);\n    };\n    this.channelKey = KEY_PREFIX + name;\n    this.setupLocalStorageListener();\n  }\n  prefixEventName(eventName) {\n    return this.channelKey + eventName;\n  }\n};\n\n\n//# sourceMappingURL=chunk-RSOCGYTF.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstUlNPQ0dZVEYubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1SU09DR1lURi5tanM/NDVlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbG9jYWxTdG9yYWdlQnJvYWRjYXN0Q2hhbm5lbC50c1xudmFyIEtFWV9QUkVGSVggPSBcIl9fbHNiY19fXCI7XG52YXIgTG9jYWxTdG9yYWdlQnJvYWRjYXN0Q2hhbm5lbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHRoaXMuZXZlbnRUYXJnZXQgPSB3aW5kb3c7XG4gICAgdGhpcy5wb3N0TWVzc2FnZSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5jaGFubmVsS2V5LCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmNoYW5uZWxLZXkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gKGV2ZW50TmFtZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLnByZWZpeEV2ZW50TmFtZShldmVudE5hbWUpLCAoZSkgPT4ge1xuICAgICAgICBsaXN0ZW5lcihlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5zZXR1cExvY2FsU3RvcmFnZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUua2V5ICE9PSB0aGlzLmNoYW5uZWxLZXkgfHwgIWUubmV3VmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShlLm5ld1ZhbHVlIHx8IFwiXCIpO1xuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudCh0aGlzLnByZWZpeEV2ZW50TmFtZShcIm1lc3NhZ2VcIiksIHtcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzdG9yYWdlXCIsIG5vdGlmeUxpc3RlbmVycyk7XG4gICAgfTtcbiAgICB0aGlzLmNoYW5uZWxLZXkgPSBLRVlfUFJFRklYICsgbmFtZTtcbiAgICB0aGlzLnNldHVwTG9jYWxTdG9yYWdlTGlzdGVuZXIoKTtcbiAgfVxuICBwcmVmaXhFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbEtleSArIGV2ZW50TmFtZTtcbiAgfVxufTtcblxuZXhwb3J0IHtcbiAgTG9jYWxTdG9yYWdlQnJvYWRjYXN0Q2hhbm5lbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVJTT0NHWVRGLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-RSOCGYTF.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isomorphicAtob: function() { return /* binding */ isomorphicAtob; }\n/* harmony export */ });\n// src/isomorphicAtob.ts\nvar isomorphicAtob = (data) => {\n  if (typeof atob !== \"undefined\" && typeof atob === \"function\") {\n    return atob(data);\n  } else if (typeof global !== \"undefined\" && global.Buffer) {\n    return new global.Buffer(data, \"base64\").toString();\n  }\n  return data;\n};\n\n\n//# sourceMappingURL=chunk-TETGTEI2.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstVEVUR1RFSTIubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstVEVUR1RFSTIubWpzP2MyZWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2lzb21vcnBoaWNBdG9iLnRzXG52YXIgaXNvbW9ycGhpY0F0b2IgPSAoZGF0YSkgPT4ge1xuICBpZiAodHlwZW9mIGF0b2IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGF0b2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBhdG9iKGRhdGEpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLkJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgZ2xvYmFsLkJ1ZmZlcihkYXRhLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufTtcblxuZXhwb3J0IHtcbiAgaXNvbW9ycGhpY0F0b2Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1URVRHVEVJMi5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TRWMHODU.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-TRWMHODU.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handleValueOrFn: function() { return /* binding */ handleValueOrFn; }\n/* harmony export */ });\n// src/handleValueOrFn.ts\nfunction handleValueOrFn(value, url, defaultValue) {\n  if (typeof value === \"function\") {\n    return value(url);\n  }\n  if (typeof value !== \"undefined\") {\n    return value;\n  }\n  if (typeof defaultValue !== \"undefined\") {\n    return defaultValue;\n  }\n  return void 0;\n}\n\n\n//# sourceMappingURL=chunk-TRWMHODU.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstVFJXTUhPRFUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstVFJXTUhPRFUubWpzP2VkOWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2hhbmRsZVZhbHVlT3JGbi50c1xuZnVuY3Rpb24gaGFuZGxlVmFsdWVPckZuKHZhbHVlLCB1cmwsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdmFsdWUodXJsKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG5leHBvcnQge1xuICBoYW5kbGVWYWx1ZU9yRm5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1UUldNSE9EVS5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TRWMHODU.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TUVJ3GI6.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-TUVJ3GI6.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventMethodCalled: function() { return /* binding */ eventMethodCalled; }\n/* harmony export */ });\n// src/telemetry/events/method-called.ts\nvar EVENT_METHOD_CALLED = \"METHOD_CALLED\";\nfunction eventMethodCalled(method, payload) {\n  return {\n    event: EVENT_METHOD_CALLED,\n    payload: {\n      method,\n      ...payload\n    }\n  };\n}\n\n\n//# sourceMappingURL=chunk-TUVJ3GI6.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstVFVWSjNHSTYubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9jaHVuay1UVVZKM0dJNi5tanM/MTBjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdGVsZW1ldHJ5L2V2ZW50cy9tZXRob2QtY2FsbGVkLnRzXG52YXIgRVZFTlRfTUVUSE9EX0NBTExFRCA9IFwiTUVUSE9EX0NBTExFRFwiO1xuZnVuY3Rpb24gZXZlbnRNZXRob2RDYWxsZWQobWV0aG9kLCBwYXlsb2FkKSB7XG4gIHJldHVybiB7XG4gICAgZXZlbnQ6IEVWRU5UX01FVEhPRF9DQUxMRUQsXG4gICAgcGF5bG9hZDoge1xuICAgICAgbWV0aG9kLFxuICAgICAgLi4ucGF5bG9hZFxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHtcbiAgZXZlbnRNZXRob2RDYWxsZWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1UVVZKM0dJNi5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TUVJ3GI6.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TVXNN3J6.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-TVXNN3J6.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMajorVersion: function() { return /* binding */ getMajorVersion; },\n/* harmony export */   versionSelector: function() { return /* binding */ versionSelector; }\n/* harmony export */ });\n// src/versionSelector.ts\nvar versionSelector = (clerkJSVersion, packageVersion = \"5.24.0\") => {\n  if (clerkJSVersion) {\n    return clerkJSVersion;\n  }\n  const prereleaseTag = getPrereleaseTag(packageVersion);\n  if (prereleaseTag) {\n    if (prereleaseTag === \"snapshot\") {\n      return \"5.24.0\";\n    }\n    return prereleaseTag;\n  }\n  return getMajorVersion(packageVersion);\n};\nvar getPrereleaseTag = (packageVersion) => {\n  var _a;\n  return (_a = packageVersion.trim().replace(/^v/, \"\").match(/-(.+?)(\\.|$)/)) == null ? void 0 : _a[1];\n};\nvar getMajorVersion = (packageVersion) => packageVersion.trim().replace(/^v/, \"\").split(\".\")[0];\n\n\n//# sourceMappingURL=chunk-TVXNN3J6.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstVFZYTk4zSjYubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLVRWWE5OM0o2Lm1qcz83NGU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy92ZXJzaW9uU2VsZWN0b3IudHNcbnZhciB2ZXJzaW9uU2VsZWN0b3IgPSAoY2xlcmtKU1ZlcnNpb24sIHBhY2thZ2VWZXJzaW9uID0gXCI1LjI0LjBcIikgPT4ge1xuICBpZiAoY2xlcmtKU1ZlcnNpb24pIHtcbiAgICByZXR1cm4gY2xlcmtKU1ZlcnNpb247XG4gIH1cbiAgY29uc3QgcHJlcmVsZWFzZVRhZyA9IGdldFByZXJlbGVhc2VUYWcocGFja2FnZVZlcnNpb24pO1xuICBpZiAocHJlcmVsZWFzZVRhZykge1xuICAgIGlmIChwcmVyZWxlYXNlVGFnID09PSBcInNuYXBzaG90XCIpIHtcbiAgICAgIHJldHVybiBcIjUuMjQuMFwiO1xuICAgIH1cbiAgICByZXR1cm4gcHJlcmVsZWFzZVRhZztcbiAgfVxuICByZXR1cm4gZ2V0TWFqb3JWZXJzaW9uKHBhY2thZ2VWZXJzaW9uKTtcbn07XG52YXIgZ2V0UHJlcmVsZWFzZVRhZyA9IChwYWNrYWdlVmVyc2lvbikgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBwYWNrYWdlVmVyc2lvbi50cmltKCkucmVwbGFjZSgvXnYvLCBcIlwiKS5tYXRjaCgvLSguKz8pKFxcLnwkKS8pKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMV07XG59O1xudmFyIGdldE1ham9yVmVyc2lvbiA9IChwYWNrYWdlVmVyc2lvbikgPT4gcGFja2FnZVZlcnNpb24udHJpbSgpLnJlcGxhY2UoL152LywgXCJcIikuc3BsaXQoXCIuXCIpWzBdO1xuXG5leHBvcnQge1xuICB2ZXJzaW9uU2VsZWN0b3IsXG4gIGdldE1ham9yVmVyc2lvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVRWWE5OM0o2Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TVXNN3J6.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-X6NLIF7Y.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-X6NLIF7Y.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorToSameTypeString: function() { return /* binding */ colorToSameTypeString; },\n/* harmony export */   hasAlpha: function() { return /* binding */ hasAlpha; },\n/* harmony export */   hexStringToRgbaColor: function() { return /* binding */ hexStringToRgbaColor; },\n/* harmony export */   isHSLColor: function() { return /* binding */ isHSLColor; },\n/* harmony export */   isRGBColor: function() { return /* binding */ isRGBColor; },\n/* harmony export */   isTransparent: function() { return /* binding */ isTransparent; },\n/* harmony export */   isValidHexString: function() { return /* binding */ isValidHexString; },\n/* harmony export */   isValidHslaString: function() { return /* binding */ isValidHslaString; },\n/* harmony export */   isValidRgbaString: function() { return /* binding */ isValidRgbaString; },\n/* harmony export */   stringToHslaColor: function() { return /* binding */ stringToHslaColor; },\n/* harmony export */   stringToSameTypeColor: function() { return /* binding */ stringToSameTypeColor; }\n/* harmony export */ });\n// src/color.ts\nvar IS_HEX_COLOR_REGEX = /^#?([A-F0-9]{6}|[A-F0-9]{3})$/i;\nvar IS_RGB_COLOR_REGEX = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/i;\nvar IS_RGBA_COLOR_REGEX = /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+)(,\\s*\\d+(\\.\\d+)?)\\)$/i;\nvar IS_HSL_COLOR_REGEX = /^hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)$/i;\nvar IS_HSLA_COLOR_REGEX = /^hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%(,\\s*\\d+(\\.\\d+)?)*\\)$/i;\nvar isValidHexString = (s) => {\n  return !!s.match(IS_HEX_COLOR_REGEX);\n};\nvar isValidRgbaString = (s) => {\n  return !!(s.match(IS_RGB_COLOR_REGEX) || s.match(IS_RGBA_COLOR_REGEX));\n};\nvar isValidHslaString = (s) => {\n  return !!s.match(IS_HSL_COLOR_REGEX) || !!s.match(IS_HSLA_COLOR_REGEX);\n};\nvar isRGBColor = (c) => {\n  return typeof c !== \"string\" && \"r\" in c;\n};\nvar isHSLColor = (c) => {\n  return typeof c !== \"string\" && \"h\" in c;\n};\nvar isTransparent = (c) => {\n  return c === \"transparent\";\n};\nvar hasAlpha = (color) => {\n  return typeof color !== \"string\" && color.a != void 0 && color.a < 1;\n};\nvar CLEAN_HSLA_REGEX = /[hsla()]/g;\nvar CLEAN_RGBA_REGEX = /[rgba()]/g;\nvar stringToHslaColor = (value) => {\n  if (value === \"transparent\") {\n    return { h: 0, s: 0, l: 0, a: 0 };\n  }\n  if (isValidHexString(value)) {\n    return hexStringToHslaColor(value);\n  }\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n  if (isValidRgbaString(value)) {\n    return rgbaStringToHslaColor(value);\n  }\n  return null;\n};\nvar stringToSameTypeColor = (value) => {\n  value = value.trim();\n  if (isValidHexString(value)) {\n    return value.startsWith(\"#\") ? value : `#${value}`;\n  }\n  if (isValidRgbaString(value)) {\n    return parseRgbaString(value);\n  }\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n  if (isTransparent(value)) {\n    return value;\n  }\n  return \"\";\n};\nvar colorToSameTypeString = (color) => {\n  if (typeof color === \"string\" && (isValidHexString(color) || isTransparent(color))) {\n    return color;\n  }\n  if (isRGBColor(color)) {\n    return rgbaColorToRgbaString(color);\n  }\n  if (isHSLColor(color)) {\n    return hslaColorToHslaString(color);\n  }\n  return \"\";\n};\nvar hexStringToRgbaColor = (hex) => {\n  hex = hex.replace(\"#\", \"\");\n  const r = parseInt(hex.substring(0, 2), 16);\n  const g = parseInt(hex.substring(2, 4), 16);\n  const b = parseInt(hex.substring(4, 6), 16);\n  return { r, g, b };\n};\nvar rgbaColorToRgbaString = (color) => {\n  const { a, b, g, r } = color;\n  return color.a === 0 ? \"transparent\" : color.a != void 0 ? `rgba(${r},${g},${b},${a})` : `rgb(${r},${g},${b})`;\n};\nvar hslaColorToHslaString = (color) => {\n  const { h, s, l, a } = color;\n  const sPerc = Math.round(s * 100);\n  const lPerc = Math.round(l * 100);\n  return color.a === 0 ? \"transparent\" : color.a != void 0 ? `hsla(${h},${sPerc}%,${lPerc}%,${a})` : `hsl(${h},${sPerc}%,${lPerc}%)`;\n};\nvar hexStringToHslaColor = (hex) => {\n  const rgbaString = colorToSameTypeString(hexStringToRgbaColor(hex));\n  return rgbaStringToHslaColor(rgbaString);\n};\nvar rgbaStringToHslaColor = (rgba) => {\n  const rgbaColor = parseRgbaString(rgba);\n  const r = rgbaColor.r / 255;\n  const g = rgbaColor.g / 255;\n  const b = rgbaColor.b / 255;\n  const max = Math.max(r, g, b), min = Math.min(r, g, b);\n  let h, s;\n  const l = (max + min) / 2;\n  if (max == min) {\n    h = s = 0;\n  } else {\n    const d = max - min;\n    s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d * 60;\n        break;\n      case g:\n        h = ((b - r) / d + 2) * 60;\n        break;\n      default:\n        h = ((r - g) / d + 4) * 60;\n        break;\n    }\n  }\n  const res = { h: Math.round(h), s, l };\n  const a = rgbaColor.a;\n  if (a != void 0) {\n    res.a = a;\n  }\n  return res;\n};\nvar parseRgbaString = (str) => {\n  const [r, g, b, a] = str.replace(CLEAN_RGBA_REGEX, \"\").split(\",\").map((c) => Number.parseFloat(c));\n  return { r, g, b, a };\n};\nvar parseHslaString = (str) => {\n  const [h, s, l, a] = str.replace(CLEAN_HSLA_REGEX, \"\").split(\",\").map((c) => Number.parseFloat(c));\n  return { h, s: s / 100, l: l / 100, a };\n};\n\n\n//# sourceMappingURL=chunk-X6NLIF7Y.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstWDZOTElGN1kubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSx1Q0FBdUMsRUFBRSxVQUFVLEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkIscUVBQXFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDOUc7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0EscUVBQXFFLEVBQUUsR0FBRyxNQUFNLElBQUksTUFBTSxJQUFJLEVBQUUsWUFBWSxFQUFFLEdBQUcsTUFBTSxJQUFJLE1BQU07QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBY0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLVg2TkxJRjdZLm1qcz8xZTM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb2xvci50c1xudmFyIElTX0hFWF9DT0xPUl9SRUdFWCA9IC9eIz8oW0EtRjAtOV17Nn18W0EtRjAtOV17M30pJC9pO1xudmFyIElTX1JHQl9DT0xPUl9SRUdFWCA9IC9ecmdiXFwoKFxcZCspLFxccyooXFxkKyksXFxzKihcXGQrKVxcKSQvaTtcbnZhciBJU19SR0JBX0NPTE9SX1JFR0VYID0gL15yZ2JhXFwoKFxcZCspLFxccyooXFxkKyksXFxzKihcXGQrKSgsXFxzKlxcZCsoXFwuXFxkKyk/KVxcKSQvaTtcbnZhciBJU19IU0xfQ09MT1JfUkVHRVggPSAvXmhzbFxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJVxcKSQvaTtcbnZhciBJU19IU0xBX0NPTE9SX1JFR0VYID0gL15oc2xhXFwoKFxcZCspLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKyklKCxcXHMqXFxkKyhcXC5cXGQrKT8pKlxcKSQvaTtcbnZhciBpc1ZhbGlkSGV4U3RyaW5nID0gKHMpID0+IHtcbiAgcmV0dXJuICEhcy5tYXRjaChJU19IRVhfQ09MT1JfUkVHRVgpO1xufTtcbnZhciBpc1ZhbGlkUmdiYVN0cmluZyA9IChzKSA9PiB7XG4gIHJldHVybiAhIShzLm1hdGNoKElTX1JHQl9DT0xPUl9SRUdFWCkgfHwgcy5tYXRjaChJU19SR0JBX0NPTE9SX1JFR0VYKSk7XG59O1xudmFyIGlzVmFsaWRIc2xhU3RyaW5nID0gKHMpID0+IHtcbiAgcmV0dXJuICEhcy5tYXRjaChJU19IU0xfQ09MT1JfUkVHRVgpIHx8ICEhcy5tYXRjaChJU19IU0xBX0NPTE9SX1JFR0VYKTtcbn07XG52YXIgaXNSR0JDb2xvciA9IChjKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgYyAhPT0gXCJzdHJpbmdcIiAmJiBcInJcIiBpbiBjO1xufTtcbnZhciBpc0hTTENvbG9yID0gKGMpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBjICE9PSBcInN0cmluZ1wiICYmIFwiaFwiIGluIGM7XG59O1xudmFyIGlzVHJhbnNwYXJlbnQgPSAoYykgPT4ge1xuICByZXR1cm4gYyA9PT0gXCJ0cmFuc3BhcmVudFwiO1xufTtcbnZhciBoYXNBbHBoYSA9IChjb2xvcikgPT4ge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yICE9PSBcInN0cmluZ1wiICYmIGNvbG9yLmEgIT0gdm9pZCAwICYmIGNvbG9yLmEgPCAxO1xufTtcbnZhciBDTEVBTl9IU0xBX1JFR0VYID0gL1toc2xhKCldL2c7XG52YXIgQ0xFQU5fUkdCQV9SRUdFWCA9IC9bcmdiYSgpXS9nO1xudmFyIHN0cmluZ1RvSHNsYUNvbG9yID0gKHZhbHVlKSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gXCJ0cmFuc3BhcmVudFwiKSB7XG4gICAgcmV0dXJuIHsgaDogMCwgczogMCwgbDogMCwgYTogMCB9O1xuICB9XG4gIGlmIChpc1ZhbGlkSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBoZXhTdHJpbmdUb0hzbGFDb2xvcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGlzVmFsaWRIc2xhU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBwYXJzZUhzbGFTdHJpbmcodmFsdWUpO1xuICB9XG4gIGlmIChpc1ZhbGlkUmdiYVN0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmdiYVN0cmluZ1RvSHNsYUNvbG9yKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgc3RyaW5nVG9TYW1lVHlwZUNvbG9yID0gKHZhbHVlKSA9PiB7XG4gIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICBpZiAoaXNWYWxpZEhleFN0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuc3RhcnRzV2l0aChcIiNcIikgPyB2YWx1ZSA6IGAjJHt2YWx1ZX1gO1xuICB9XG4gIGlmIChpc1ZhbGlkUmdiYVN0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gcGFyc2VSZ2JhU3RyaW5nKHZhbHVlKTtcbiAgfVxuICBpZiAoaXNWYWxpZEhzbGFTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHBhcnNlSHNsYVN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgaWYgKGlzVHJhbnNwYXJlbnQodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBcIlwiO1xufTtcbnZhciBjb2xvclRvU2FtZVR5cGVTdHJpbmcgPSAoY29sb3IpID0+IHtcbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gXCJzdHJpbmdcIiAmJiAoaXNWYWxpZEhleFN0cmluZyhjb2xvcikgfHwgaXNUcmFuc3BhcmVudChjb2xvcikpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIGlmIChpc1JHQkNvbG9yKGNvbG9yKSkge1xuICAgIHJldHVybiByZ2JhQ29sb3JUb1JnYmFTdHJpbmcoY29sb3IpO1xuICB9XG4gIGlmIChpc0hTTENvbG9yKGNvbG9yKSkge1xuICAgIHJldHVybiBoc2xhQ29sb3JUb0hzbGFTdHJpbmcoY29sb3IpO1xuICB9XG4gIHJldHVybiBcIlwiO1xufTtcbnZhciBoZXhTdHJpbmdUb1JnYmFDb2xvciA9IChoZXgpID0+IHtcbiAgaGV4ID0gaGV4LnJlcGxhY2UoXCIjXCIsIFwiXCIpO1xuICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygwLCAyKSwgMTYpO1xuICBjb25zdCBnID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygyLCA0KSwgMTYpO1xuICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyg0LCA2KSwgMTYpO1xuICByZXR1cm4geyByLCBnLCBiIH07XG59O1xudmFyIHJnYmFDb2xvclRvUmdiYVN0cmluZyA9IChjb2xvcikgPT4ge1xuICBjb25zdCB7IGEsIGIsIGcsIHIgfSA9IGNvbG9yO1xuICByZXR1cm4gY29sb3IuYSA9PT0gMCA/IFwidHJhbnNwYXJlbnRcIiA6IGNvbG9yLmEgIT0gdm9pZCAwID8gYHJnYmEoJHtyfSwke2d9LCR7Yn0sJHthfSlgIDogYHJnYigke3J9LCR7Z30sJHtifSlgO1xufTtcbnZhciBoc2xhQ29sb3JUb0hzbGFTdHJpbmcgPSAoY29sb3IpID0+IHtcbiAgY29uc3QgeyBoLCBzLCBsLCBhIH0gPSBjb2xvcjtcbiAgY29uc3Qgc1BlcmMgPSBNYXRoLnJvdW5kKHMgKiAxMDApO1xuICBjb25zdCBsUGVyYyA9IE1hdGgucm91bmQobCAqIDEwMCk7XG4gIHJldHVybiBjb2xvci5hID09PSAwID8gXCJ0cmFuc3BhcmVudFwiIDogY29sb3IuYSAhPSB2b2lkIDAgPyBgaHNsYSgke2h9LCR7c1BlcmN9JSwke2xQZXJjfSUsJHthfSlgIDogYGhzbCgke2h9LCR7c1BlcmN9JSwke2xQZXJjfSUpYDtcbn07XG52YXIgaGV4U3RyaW5nVG9Ic2xhQ29sb3IgPSAoaGV4KSA9PiB7XG4gIGNvbnN0IHJnYmFTdHJpbmcgPSBjb2xvclRvU2FtZVR5cGVTdHJpbmcoaGV4U3RyaW5nVG9SZ2JhQ29sb3IoaGV4KSk7XG4gIHJldHVybiByZ2JhU3RyaW5nVG9Ic2xhQ29sb3IocmdiYVN0cmluZyk7XG59O1xudmFyIHJnYmFTdHJpbmdUb0hzbGFDb2xvciA9IChyZ2JhKSA9PiB7XG4gIGNvbnN0IHJnYmFDb2xvciA9IHBhcnNlUmdiYVN0cmluZyhyZ2JhKTtcbiAgY29uc3QgciA9IHJnYmFDb2xvci5yIC8gMjU1O1xuICBjb25zdCBnID0gcmdiYUNvbG9yLmcgLyAyNTU7XG4gIGNvbnN0IGIgPSByZ2JhQ29sb3IuYiAvIDI1NTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBsZXQgaCwgcztcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKG1heCA9PSBtaW4pIHtcbiAgICBoID0gcyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbCA+PSAwLjUgPyBkIC8gKDIgLSAobWF4ICsgbWluKSkgOiBkIC8gKG1heCArIG1pbik7XG4gICAgc3dpdGNoIChtYXgpIHtcbiAgICAgIGNhc2UgcjpcbiAgICAgICAgaCA9IChnIC0gYikgLyBkICogNjA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnOlxuICAgICAgICBoID0gKChiIC0gcikgLyBkICsgMikgKiA2MDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBoID0gKChyIC0gZykgLyBkICsgNCkgKiA2MDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlcyA9IHsgaDogTWF0aC5yb3VuZChoKSwgcywgbCB9O1xuICBjb25zdCBhID0gcmdiYUNvbG9yLmE7XG4gIGlmIChhICE9IHZvaWQgMCkge1xuICAgIHJlcy5hID0gYTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbnZhciBwYXJzZVJnYmFTdHJpbmcgPSAoc3RyKSA9PiB7XG4gIGNvbnN0IFtyLCBnLCBiLCBhXSA9IHN0ci5yZXBsYWNlKENMRUFOX1JHQkFfUkVHRVgsIFwiXCIpLnNwbGl0KFwiLFwiKS5tYXAoKGMpID0+IE51bWJlci5wYXJzZUZsb2F0KGMpKTtcbiAgcmV0dXJuIHsgciwgZywgYiwgYSB9O1xufTtcbnZhciBwYXJzZUhzbGFTdHJpbmcgPSAoc3RyKSA9PiB7XG4gIGNvbnN0IFtoLCBzLCBsLCBhXSA9IHN0ci5yZXBsYWNlKENMRUFOX0hTTEFfUkVHRVgsIFwiXCIpLnNwbGl0KFwiLFwiKS5tYXAoKGMpID0+IE51bWJlci5wYXJzZUZsb2F0KGMpKTtcbiAgcmV0dXJuIHsgaCwgczogcyAvIDEwMCwgbDogbCAvIDEwMCwgYSB9O1xufTtcblxuZXhwb3J0IHtcbiAgaXNWYWxpZEhleFN0cmluZyxcbiAgaXNWYWxpZFJnYmFTdHJpbmcsXG4gIGlzVmFsaWRIc2xhU3RyaW5nLFxuICBpc1JHQkNvbG9yLFxuICBpc0hTTENvbG9yLFxuICBpc1RyYW5zcGFyZW50LFxuICBoYXNBbHBoYSxcbiAgc3RyaW5nVG9Ic2xhQ29sb3IsXG4gIHN0cmluZ1RvU2FtZVR5cGVDb2xvcixcbiAgY29sb3JUb1NhbWVUeXBlU3RyaW5nLFxuICBoZXhTdHJpbmdUb1JnYmFDb2xvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVg2TkxJRjdZLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-X6NLIF7Y.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-XPYJQUM7.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/chunk-XPYJQUM7.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Poller: function() { return /* binding */ Poller; },\n/* harmony export */   createWorkerTimers: function() { return /* binding */ createWorkerTimers; },\n/* harmony export */   noop: function() { return /* binding */ noop; }\n/* harmony export */ });\n// src/utils/noop.ts\nvar noop = (..._args) => {\n};\n\n// src/workerTimers/workerTimers.worker.ts\nvar workerTimers_worker_default = 'const respond=r=>{self.postMessage(r)},workerToTabIds={};self.addEventListener(\"message\",r=>{const e=r.data;switch(e.type){case\"setTimeout\":workerToTabIds[e.id]=setTimeout(()=>{respond({id:e.id})},e.ms);break;case\"clearTimeout\":workerToTabIds[e.id]&&(clearTimeout(workerToTabIds[e.id]),delete workerToTabIds[e.id]);break;case\"setInterval\":workerToTabIds[e.id]=setInterval(()=>{respond({id:e.id})},e.ms);break;case\"clearInterval\":workerToTabIds[e.id]&&(clearInterval(workerToTabIds[e.id]),delete workerToTabIds[e.id]);break}});\\n';\n\n// src/workerTimers/createWorkerTimers.ts\nvar createWebWorker = (source, opts = {}) => {\n  if (typeof Worker === \"undefined\") {\n    return null;\n  }\n  try {\n    const blob = new Blob([source], { type: \"application/javascript; charset=utf-8\" });\n    const workerScript = globalThis.URL.createObjectURL(blob);\n    return new Worker(workerScript, opts);\n  } catch (e) {\n    console.warn(\"Clerk: Cannot create worker from blob. Consider adding worker-src blob:; to your CSP\");\n    return null;\n  }\n};\nvar fallbackTimers = () => {\n  const setTimeout = globalThis.setTimeout.bind(globalThis);\n  const setInterval = globalThis.setInterval.bind(globalThis);\n  const clearTimeout = globalThis.clearTimeout.bind(globalThis);\n  const clearInterval = globalThis.clearInterval.bind(globalThis);\n  return { setTimeout, setInterval, clearTimeout, clearInterval, cleanup: noop };\n};\nvar createWorkerTimers = () => {\n  let id = 0;\n  const generateId = () => id++;\n  const callbacks = /* @__PURE__ */ new Map();\n  const post = (w, p) => w == null ? void 0 : w.postMessage(p);\n  const handleMessage = (e) => {\n    var _a;\n    (_a = callbacks.get(e.data.id)) == null ? void 0 : _a();\n  };\n  let worker = createWebWorker(workerTimers_worker_default, { name: \"clerk-timers\" });\n  worker == null ? void 0 : worker.addEventListener(\"message\", handleMessage);\n  if (!worker) {\n    return fallbackTimers();\n  }\n  const init = () => {\n    if (!worker) {\n      worker = createWebWorker(workerTimers_worker_default, { name: \"clerk-timers\" });\n      worker == null ? void 0 : worker.addEventListener(\"message\", handleMessage);\n    }\n  };\n  const cleanup = () => {\n    if (worker) {\n      worker.terminate();\n      worker = null;\n      callbacks.clear();\n    }\n  };\n  const setTimeout = (cb, ms) => {\n    init();\n    const id2 = generateId();\n    callbacks.set(id2, cb);\n    post(worker, { type: \"setTimeout\", id: id2, ms });\n    return id2;\n  };\n  const setInterval = (cb, ms) => {\n    init();\n    const id2 = generateId();\n    callbacks.set(id2, cb);\n    post(worker, { type: \"setInterval\", id: id2, ms });\n    return id2;\n  };\n  const clearTimeout = (id2) => {\n    init();\n    callbacks.delete(id2);\n    post(worker, { type: \"clearTimeout\", id: id2 });\n  };\n  const clearInterval = (id2) => {\n    init();\n    callbacks.delete(id2);\n    post(worker, { type: \"clearInterval\", id: id2 });\n  };\n  return { setTimeout, setInterval, clearTimeout, clearInterval, cleanup };\n};\n\n// src/poller.ts\nfunction Poller({ delayInMs } = { delayInMs: 1e3 }) {\n  const workerTimers = createWorkerTimers();\n  let timerId;\n  let stopped = false;\n  const stop = () => {\n    if (timerId) {\n      workerTimers.clearTimeout(timerId);\n      workerTimers.cleanup();\n    }\n    stopped = true;\n  };\n  const run = async (cb) => {\n    stopped = false;\n    await cb(stop);\n    if (stopped) {\n      return;\n    }\n    timerId = workerTimers.setTimeout(() => {\n      void run(cb);\n    }, delayInMs);\n  };\n  return { run, stop };\n}\n\n\n//# sourceMappingURL=chunk-XPYJQUM7.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvY2h1bmstWFBZSlFVTTcubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxvQkFBb0IsbUJBQW1CLG9DQUFvQyxlQUFlLGVBQWUsc0RBQXNELFNBQVMsUUFBUSxFQUFFLE9BQU8sTUFBTSwwR0FBMEcsTUFBTSx3REFBd0QsU0FBUyxRQUFRLEVBQUUsT0FBTyxNQUFNLDRHQUE0RyxPQUFPLEVBQUU7O0FBRWpqQjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQkFBK0IsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsc0JBQXNCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxzQkFBc0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtCQUErQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxrQkFBa0IsWUFBWSxJQUFJLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXO0FBQ1g7O0FBTUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2NodW5rLVhQWUpRVU03Lm1qcz83YjRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9ub29wLnRzXG52YXIgbm9vcCA9ICguLi5fYXJncykgPT4ge1xufTtcblxuLy8gc3JjL3dvcmtlclRpbWVycy93b3JrZXJUaW1lcnMud29ya2VyLnRzXG52YXIgd29ya2VyVGltZXJzX3dvcmtlcl9kZWZhdWx0ID0gJ2NvbnN0IHJlc3BvbmQ9cj0+e3NlbGYucG9zdE1lc3NhZ2Uocil9LHdvcmtlclRvVGFiSWRzPXt9O3NlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixyPT57Y29uc3QgZT1yLmRhdGE7c3dpdGNoKGUudHlwZSl7Y2FzZVwic2V0VGltZW91dFwiOndvcmtlclRvVGFiSWRzW2UuaWRdPXNldFRpbWVvdXQoKCk9PntyZXNwb25kKHtpZDplLmlkfSl9LGUubXMpO2JyZWFrO2Nhc2VcImNsZWFyVGltZW91dFwiOndvcmtlclRvVGFiSWRzW2UuaWRdJiYoY2xlYXJUaW1lb3V0KHdvcmtlclRvVGFiSWRzW2UuaWRdKSxkZWxldGUgd29ya2VyVG9UYWJJZHNbZS5pZF0pO2JyZWFrO2Nhc2VcInNldEludGVydmFsXCI6d29ya2VyVG9UYWJJZHNbZS5pZF09c2V0SW50ZXJ2YWwoKCk9PntyZXNwb25kKHtpZDplLmlkfSl9LGUubXMpO2JyZWFrO2Nhc2VcImNsZWFySW50ZXJ2YWxcIjp3b3JrZXJUb1RhYklkc1tlLmlkXSYmKGNsZWFySW50ZXJ2YWwod29ya2VyVG9UYWJJZHNbZS5pZF0pLGRlbGV0ZSB3b3JrZXJUb1RhYklkc1tlLmlkXSk7YnJlYWt9fSk7XFxuJztcblxuLy8gc3JjL3dvcmtlclRpbWVycy9jcmVhdGVXb3JrZXJUaW1lcnMudHNcbnZhciBjcmVhdGVXZWJXb3JrZXIgPSAoc291cmNlLCBvcHRzID0ge30pID0+IHtcbiAgaWYgKHR5cGVvZiBXb3JrZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbc291cmNlXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHQ7IGNoYXJzZXQ9dXRmLThcIiB9KTtcbiAgICBjb25zdCB3b3JrZXJTY3JpcHQgPSBnbG9iYWxUaGlzLlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgcmV0dXJuIG5ldyBXb3JrZXIod29ya2VyU2NyaXB0LCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybihcIkNsZXJrOiBDYW5ub3QgY3JlYXRlIHdvcmtlciBmcm9tIGJsb2IuIENvbnNpZGVyIGFkZGluZyB3b3JrZXItc3JjIGJsb2I6OyB0byB5b3VyIENTUFwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbnZhciBmYWxsYmFja1RpbWVycyA9ICgpID0+IHtcbiAgY29uc3Qgc2V0VGltZW91dCA9IGdsb2JhbFRoaXMuc2V0VGltZW91dC5iaW5kKGdsb2JhbFRoaXMpO1xuICBjb25zdCBzZXRJbnRlcnZhbCA9IGdsb2JhbFRoaXMuc2V0SW50ZXJ2YWwuYmluZChnbG9iYWxUaGlzKTtcbiAgY29uc3QgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsVGhpcy5jbGVhclRpbWVvdXQuYmluZChnbG9iYWxUaGlzKTtcbiAgY29uc3QgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbFRoaXMuY2xlYXJJbnRlcnZhbC5iaW5kKGdsb2JhbFRoaXMpO1xuICByZXR1cm4geyBzZXRUaW1lb3V0LCBzZXRJbnRlcnZhbCwgY2xlYXJUaW1lb3V0LCBjbGVhckludGVydmFsLCBjbGVhbnVwOiBub29wIH07XG59O1xudmFyIGNyZWF0ZVdvcmtlclRpbWVycyA9ICgpID0+IHtcbiAgbGV0IGlkID0gMDtcbiAgY29uc3QgZ2VuZXJhdGVJZCA9ICgpID0+IGlkKys7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHBvc3QgPSAodywgcCkgPT4gdyA9PSBudWxsID8gdm9pZCAwIDogdy5wb3N0TWVzc2FnZShwKTtcbiAgY29uc3QgaGFuZGxlTWVzc2FnZSA9IChlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IGNhbGxiYWNrcy5nZXQoZS5kYXRhLmlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hKCk7XG4gIH07XG4gIGxldCB3b3JrZXIgPSBjcmVhdGVXZWJXb3JrZXIod29ya2VyVGltZXJzX3dvcmtlcl9kZWZhdWx0LCB7IG5hbWU6IFwiY2xlcmstdGltZXJzXCIgfSk7XG4gIHdvcmtlciA9PSBudWxsID8gdm9pZCAwIDogd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZU1lc3NhZ2UpO1xuICBpZiAoIXdvcmtlcikge1xuICAgIHJldHVybiBmYWxsYmFja1RpbWVycygpO1xuICB9XG4gIGNvbnN0IGluaXQgPSAoKSA9PiB7XG4gICAgaWYgKCF3b3JrZXIpIHtcbiAgICAgIHdvcmtlciA9IGNyZWF0ZVdlYldvcmtlcih3b3JrZXJUaW1lcnNfd29ya2VyX2RlZmF1bHQsIHsgbmFtZTogXCJjbGVyay10aW1lcnNcIiB9KTtcbiAgICAgIHdvcmtlciA9PSBudWxsID8gdm9pZCAwIDogd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZU1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBpZiAod29ya2VyKSB7XG4gICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICB3b3JrZXIgPSBudWxsO1xuICAgICAgY2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRUaW1lb3V0ID0gKGNiLCBtcykgPT4ge1xuICAgIGluaXQoKTtcbiAgICBjb25zdCBpZDIgPSBnZW5lcmF0ZUlkKCk7XG4gICAgY2FsbGJhY2tzLnNldChpZDIsIGNiKTtcbiAgICBwb3N0KHdvcmtlciwgeyB0eXBlOiBcInNldFRpbWVvdXRcIiwgaWQ6IGlkMiwgbXMgfSk7XG4gICAgcmV0dXJuIGlkMjtcbiAgfTtcbiAgY29uc3Qgc2V0SW50ZXJ2YWwgPSAoY2IsIG1zKSA9PiB7XG4gICAgaW5pdCgpO1xuICAgIGNvbnN0IGlkMiA9IGdlbmVyYXRlSWQoKTtcbiAgICBjYWxsYmFja3Muc2V0KGlkMiwgY2IpO1xuICAgIHBvc3Qod29ya2VyLCB7IHR5cGU6IFwic2V0SW50ZXJ2YWxcIiwgaWQ6IGlkMiwgbXMgfSk7XG4gICAgcmV0dXJuIGlkMjtcbiAgfTtcbiAgY29uc3QgY2xlYXJUaW1lb3V0ID0gKGlkMikgPT4ge1xuICAgIGluaXQoKTtcbiAgICBjYWxsYmFja3MuZGVsZXRlKGlkMik7XG4gICAgcG9zdCh3b3JrZXIsIHsgdHlwZTogXCJjbGVhclRpbWVvdXRcIiwgaWQ6IGlkMiB9KTtcbiAgfTtcbiAgY29uc3QgY2xlYXJJbnRlcnZhbCA9IChpZDIpID0+IHtcbiAgICBpbml0KCk7XG4gICAgY2FsbGJhY2tzLmRlbGV0ZShpZDIpO1xuICAgIHBvc3Qod29ya2VyLCB7IHR5cGU6IFwiY2xlYXJJbnRlcnZhbFwiLCBpZDogaWQyIH0pO1xuICB9O1xuICByZXR1cm4geyBzZXRUaW1lb3V0LCBzZXRJbnRlcnZhbCwgY2xlYXJUaW1lb3V0LCBjbGVhckludGVydmFsLCBjbGVhbnVwIH07XG59O1xuXG4vLyBzcmMvcG9sbGVyLnRzXG5mdW5jdGlvbiBQb2xsZXIoeyBkZWxheUluTXMgfSA9IHsgZGVsYXlJbk1zOiAxZTMgfSkge1xuICBjb25zdCB3b3JrZXJUaW1lcnMgPSBjcmVhdGVXb3JrZXJUaW1lcnMoKTtcbiAgbGV0IHRpbWVySWQ7XG4gIGxldCBzdG9wcGVkID0gZmFsc2U7XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgaWYgKHRpbWVySWQpIHtcbiAgICAgIHdvcmtlclRpbWVycy5jbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICB3b3JrZXJUaW1lcnMuY2xlYW51cCgpO1xuICAgIH1cbiAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgcnVuID0gYXN5bmMgKGNiKSA9PiB7XG4gICAgc3RvcHBlZCA9IGZhbHNlO1xuICAgIGF3YWl0IGNiKHN0b3ApO1xuICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRpbWVySWQgPSB3b3JrZXJUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB2b2lkIHJ1bihjYik7XG4gICAgfSwgZGVsYXlJbk1zKTtcbiAgfTtcbiAgcmV0dXJuIHsgcnVuLCBzdG9wIH07XG59XG5cbmV4cG9ydCB7XG4gIG5vb3AsXG4gIGNyZWF0ZVdvcmtlclRpbWVycyxcbiAgUG9sbGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstWFBZSlFVTTcubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-XPYJQUM7.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/error.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/error.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClerkAPIResponseError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkAPIResponseError; },\n/* harmony export */   ClerkRuntimeError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.ClerkRuntimeError; },\n/* harmony export */   EmailLinkError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.EmailLinkError; },\n/* harmony export */   EmailLinkErrorCode: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.EmailLinkErrorCode; },\n/* harmony export */   buildErrorThrower: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.buildErrorThrower; },\n/* harmony export */   is4xxError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.is4xxError; },\n/* harmony export */   isClerkAPIResponseError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.isClerkAPIResponseError; },\n/* harmony export */   isClerkRuntimeError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.isClerkRuntimeError; },\n/* harmony export */   isEmailLinkError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmailLinkError; },\n/* harmony export */   isKnownError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.isKnownError; },\n/* harmony export */   isMetamaskError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.isMetamaskError; },\n/* harmony export */   isNetworkError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.isNetworkError; },\n/* harmony export */   isPasswordPwnedError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.isPasswordPwnedError; },\n/* harmony export */   isUnauthorizedError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.isUnauthorizedError; },\n/* harmony export */   isUserLockedError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.isUserLockedError; },\n/* harmony export */   parseError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.parseError; },\n/* harmony export */   parseErrors: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__.parseErrors; }\n/* harmony export */ });\n/* harmony import */ var _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-IB6GRLVO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IB6GRLVO.mjs\");\n/* harmony import */ var _chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-7ELT755Q.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs\");\n\n\n\n//# sourceMappingURL=error.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvZXJyb3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQjhCO0FBQ0E7QUFtQjVCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9lcnJvci5tanM/ZTE3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDbGVya0FQSVJlc3BvbnNlRXJyb3IsXG4gIENsZXJrUnVudGltZUVycm9yLFxuICBFbWFpbExpbmtFcnJvcixcbiAgRW1haWxMaW5rRXJyb3JDb2RlLFxuICBidWlsZEVycm9yVGhyb3dlcixcbiAgaXM0eHhFcnJvcixcbiAgaXNDbGVya0FQSVJlc3BvbnNlRXJyb3IsXG4gIGlzQ2xlcmtSdW50aW1lRXJyb3IsXG4gIGlzRW1haWxMaW5rRXJyb3IsXG4gIGlzS25vd25FcnJvcixcbiAgaXNNZXRhbWFza0Vycm9yLFxuICBpc05ldHdvcmtFcnJvcixcbiAgaXNQYXNzd29yZFB3bmVkRXJyb3IsXG4gIGlzVW5hdXRob3JpemVkRXJyb3IsXG4gIGlzVXNlckxvY2tlZEVycm9yLFxuICBwYXJzZUVycm9yLFxuICBwYXJzZUVycm9yc1xufSBmcm9tIFwiLi9jaHVuay1JQjZHUkxWTy5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstN0VMVDc1NVEubWpzXCI7XG5leHBvcnQge1xuICBDbGVya0FQSVJlc3BvbnNlRXJyb3IsXG4gIENsZXJrUnVudGltZUVycm9yLFxuICBFbWFpbExpbmtFcnJvcixcbiAgRW1haWxMaW5rRXJyb3JDb2RlLFxuICBidWlsZEVycm9yVGhyb3dlcixcbiAgaXM0eHhFcnJvcixcbiAgaXNDbGVya0FQSVJlc3BvbnNlRXJyb3IsXG4gIGlzQ2xlcmtSdW50aW1lRXJyb3IsXG4gIGlzRW1haWxMaW5rRXJyb3IsXG4gIGlzS25vd25FcnJvcixcbiAgaXNNZXRhbWFza0Vycm9yLFxuICBpc05ldHdvcmtFcnJvcixcbiAgaXNQYXNzd29yZFB3bmVkRXJyb3IsXG4gIGlzVW5hdXRob3JpemVkRXJyb3IsXG4gIGlzVXNlckxvY2tlZEVycm9yLFxuICBwYXJzZUVycm9yLFxuICBwYXJzZUVycm9yc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/error.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/handleValueOrFn.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/handleValueOrFn.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handleValueOrFn: function() { return /* reexport safe */ _chunk_TRWMHODU_mjs__WEBPACK_IMPORTED_MODULE_0__.handleValueOrFn; }\n/* harmony export */ });\n/* harmony import */ var _chunk_TRWMHODU_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-TRWMHODU.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TRWMHODU.mjs\");\n/* harmony import */ var _chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-7ELT755Q.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs\");\n\n\n\n//# sourceMappingURL=handleValueOrFn.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvaGFuZGxlVmFsdWVPckZuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFFOEI7QUFDQTtBQUc1QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvaGFuZGxlVmFsdWVPckZuLm1qcz8xNDJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGhhbmRsZVZhbHVlT3JGblxufSBmcm9tIFwiLi9jaHVuay1UUldNSE9EVS5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstN0VMVDc1NVEubWpzXCI7XG5leHBvcnQge1xuICBoYW5kbGVWYWx1ZU9yRm5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYW5kbGVWYWx1ZU9yRm4ubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/handleValueOrFn.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/index.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURRENT_DEV_INSTANCE_SUFFIXES: function() { return /* reexport safe */ _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_24__.CURRENT_DEV_INSTANCE_SUFFIXES; },\n/* harmony export */   ClerkAPIResponseError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.ClerkAPIResponseError; },\n/* harmony export */   ClerkRuntimeError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.ClerkRuntimeError; },\n/* harmony export */   DEV_BROWSER_JWT_KEY: function() { return /* reexport safe */ _chunk_K64INQ4C_mjs__WEBPACK_IMPORTED_MODULE_12__.DEV_BROWSER_JWT_KEY; },\n/* harmony export */   DEV_OR_STAGING_SUFFIXES: function() { return /* reexport safe */ _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_24__.DEV_OR_STAGING_SUFFIXES; },\n/* harmony export */   EmailLinkError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.EmailLinkError; },\n/* harmony export */   EmailLinkErrorCode: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.EmailLinkErrorCode; },\n/* harmony export */   LEGACY_DEV_INSTANCE_SUFFIXES: function() { return /* reexport safe */ _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_24__.LEGACY_DEV_INSTANCE_SUFFIXES; },\n/* harmony export */   LOCAL_API_URL: function() { return /* reexport safe */ _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_24__.LOCAL_API_URL; },\n/* harmony export */   LOCAL_ENV_SUFFIXES: function() { return /* reexport safe */ _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_24__.LOCAL_ENV_SUFFIXES; },\n/* harmony export */   LocalStorageBroadcastChannel: function() { return /* reexport safe */ _chunk_RSOCGYTF_mjs__WEBPACK_IMPORTED_MODULE_8__.LocalStorageBroadcastChannel; },\n/* harmony export */   PROD_API_URL: function() { return /* reexport safe */ _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_24__.PROD_API_URL; },\n/* harmony export */   Poller: function() { return /* reexport safe */ _chunk_XPYJQUM7_mjs__WEBPACK_IMPORTED_MODULE_1__.Poller; },\n/* harmony export */   STAGING_API_URL: function() { return /* reexport safe */ _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_24__.STAGING_API_URL; },\n/* harmony export */   STAGING_ENV_SUFFIXES: function() { return /* reexport safe */ _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_24__.STAGING_ENV_SUFFIXES; },\n/* harmony export */   addClerkPrefix: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.addClerkPrefix; },\n/* harmony export */   addYears: function() { return /* reexport safe */ _chunk_FSKKI4LG_mjs__WEBPACK_IMPORTED_MODULE_25__.addYears; },\n/* harmony export */   apiUrlFromPublishableKey: function() { return /* reexport safe */ _chunk_QPSU45F4_mjs__WEBPACK_IMPORTED_MODULE_17__.apiUrlFromPublishableKey; },\n/* harmony export */   applyFunctionToObj: function() { return /* reexport safe */ _chunk_CFXQSUF6_mjs__WEBPACK_IMPORTED_MODULE_0__.applyFunctionToObj; },\n/* harmony export */   buildClerkJsScriptAttributes: function() { return /* reexport safe */ _chunk_752VSHHB_mjs__WEBPACK_IMPORTED_MODULE_3__.buildClerkJsScriptAttributes; },\n/* harmony export */   buildErrorThrower: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.buildErrorThrower; },\n/* harmony export */   buildPublishableKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__.buildPublishableKey; },\n/* harmony export */   callWithRetry: function() { return /* reexport safe */ _chunk_4PW5MDZA_mjs__WEBPACK_IMPORTED_MODULE_22__.callWithRetry; },\n/* harmony export */   camelToSnake: function() { return /* reexport safe */ _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_2__.camelToSnake; },\n/* harmony export */   cleanDoubleSlashes: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.cleanDoubleSlashes; },\n/* harmony export */   clerkJsScriptUrl: function() { return /* reexport safe */ _chunk_752VSHHB_mjs__WEBPACK_IMPORTED_MODULE_3__.clerkJsScriptUrl; },\n/* harmony export */   colorToSameTypeString: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.colorToSameTypeString; },\n/* harmony export */   createDeferredPromise: function() { return /* binding */ createDeferredPromise; },\n/* harmony export */   createDevOrStagingUrlCache: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__.createDevOrStagingUrlCache; },\n/* harmony export */   createWorkerTimers: function() { return /* reexport safe */ _chunk_XPYJQUM7_mjs__WEBPACK_IMPORTED_MODULE_1__.createWorkerTimers; },\n/* harmony export */   dateTo12HourTime: function() { return /* reexport safe */ _chunk_FSKKI4LG_mjs__WEBPACK_IMPORTED_MODULE_25__.dateTo12HourTime; },\n/* harmony export */   deepCamelToSnake: function() { return /* reexport safe */ _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_2__.deepCamelToSnake; },\n/* harmony export */   deepSnakeToCamel: function() { return /* reexport safe */ _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_2__.deepSnakeToCamel; },\n/* harmony export */   deprecated: function() { return /* reexport safe */ _chunk_IC4FGZI3_mjs__WEBPACK_IMPORTED_MODULE_10__.deprecated; },\n/* harmony export */   deprecatedObjectProperty: function() { return /* reexport safe */ _chunk_IC4FGZI3_mjs__WEBPACK_IMPORTED_MODULE_10__.deprecatedObjectProperty; },\n/* harmony export */   deprecatedProperty: function() { return /* reexport safe */ _chunk_IC4FGZI3_mjs__WEBPACK_IMPORTED_MODULE_10__.deprecatedProperty; },\n/* harmony export */   deriveState: function() { return /* reexport safe */ _chunk_6NISCHKC_mjs__WEBPACK_IMPORTED_MODULE_11__.deriveState; },\n/* harmony export */   differenceInCalendarDays: function() { return /* reexport safe */ _chunk_FSKKI4LG_mjs__WEBPACK_IMPORTED_MODULE_25__.differenceInCalendarDays; },\n/* harmony export */   extension: function() { return /* reexport safe */ _chunk_5JU2E5TY_mjs__WEBPACK_IMPORTED_MODULE_15__.extension; },\n/* harmony export */   extractDevBrowserJWTFromURL: function() { return /* reexport safe */ _chunk_K64INQ4C_mjs__WEBPACK_IMPORTED_MODULE_12__.extractDevBrowserJWTFromURL; },\n/* harmony export */   fastDeepMergeAndKeep: function() { return /* reexport safe */ _chunk_4LL2VPJL_mjs__WEBPACK_IMPORTED_MODULE_14__.fastDeepMergeAndKeep; },\n/* harmony export */   fastDeepMergeAndReplace: function() { return /* reexport safe */ _chunk_4LL2VPJL_mjs__WEBPACK_IMPORTED_MODULE_14__.fastDeepMergeAndReplace; },\n/* harmony export */   filterProps: function() { return /* reexport safe */ _chunk_CFXQSUF6_mjs__WEBPACK_IMPORTED_MODULE_0__.filterProps; },\n/* harmony export */   formatRelative: function() { return /* reexport safe */ _chunk_FSKKI4LG_mjs__WEBPACK_IMPORTED_MODULE_25__.formatRelative; },\n/* harmony export */   getClerkJsMajorVersionOrTag: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.getClerkJsMajorVersionOrTag; },\n/* harmony export */   getCookieSuffix: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__.getCookieSuffix; },\n/* harmony export */   getNonUndefinedValues: function() { return /* reexport safe */ _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_2__.getNonUndefinedValues; },\n/* harmony export */   getScriptUrl: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.getScriptUrl; },\n/* harmony export */   getSuffixedCookieName: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__.getSuffixedCookieName; },\n/* harmony export */   handleValueOrFn: function() { return /* reexport safe */ _chunk_TRWMHODU_mjs__WEBPACK_IMPORTED_MODULE_16__.handleValueOrFn; },\n/* harmony export */   hasAlpha: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.hasAlpha; },\n/* harmony export */   hasLeadingSlash: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.hasLeadingSlash; },\n/* harmony export */   hasTrailingSlash: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.hasTrailingSlash; },\n/* harmony export */   hexStringToRgbaColor: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.hexStringToRgbaColor; },\n/* harmony export */   iconImageUrl: function() { return /* reexport safe */ _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_24__.iconImageUrl; },\n/* harmony export */   inBrowser: function() { return /* reexport safe */ _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_21__.inBrowser; },\n/* harmony export */   is4xxError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.is4xxError; },\n/* harmony export */   isAbsoluteUrl: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.isAbsoluteUrl; },\n/* harmony export */   isBrowserOnline: function() { return /* reexport safe */ _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_21__.isBrowserOnline; },\n/* harmony export */   isClerkAPIResponseError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.isClerkAPIResponseError; },\n/* harmony export */   isClerkRuntimeError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.isClerkRuntimeError; },\n/* harmony export */   isCurrentDevAccountPortalOrigin: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.isCurrentDevAccountPortalOrigin; },\n/* harmony export */   isDevelopmentEnvironment: function() { return /* reexport safe */ _chunk_IC4FGZI3_mjs__WEBPACK_IMPORTED_MODULE_10__.isDevelopmentEnvironment; },\n/* harmony export */   isDevelopmentFromPublishableKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__.isDevelopmentFromPublishableKey; },\n/* harmony export */   isDevelopmentFromSecretKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__.isDevelopmentFromSecretKey; },\n/* harmony export */   isEmailLinkError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.isEmailLinkError; },\n/* harmony export */   isHSLColor: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.isHSLColor; },\n/* harmony export */   isHttpOrHttps: function() { return /* reexport safe */ _chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_5__.isHttpOrHttps; },\n/* harmony export */   isIPV4Address: function() { return /* reexport safe */ _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_2__.isIPV4Address; },\n/* harmony export */   isKnownError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.isKnownError; },\n/* harmony export */   isLegacyDevAccountPortalOrigin: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.isLegacyDevAccountPortalOrigin; },\n/* harmony export */   isMetamaskError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.isMetamaskError; },\n/* harmony export */   isNetworkError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.isNetworkError; },\n/* harmony export */   isNonEmptyURL: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.isNonEmptyURL; },\n/* harmony export */   isPasswordPwnedError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.isPasswordPwnedError; },\n/* harmony export */   isProductionEnvironment: function() { return /* reexport safe */ _chunk_IC4FGZI3_mjs__WEBPACK_IMPORTED_MODULE_10__.isProductionEnvironment; },\n/* harmony export */   isProductionFromPublishableKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__.isProductionFromPublishableKey; },\n/* harmony export */   isProductionFromSecretKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__.isProductionFromSecretKey; },\n/* harmony export */   isProxyUrlRelative: function() { return /* reexport safe */ _chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_5__.isProxyUrlRelative; },\n/* harmony export */   isPublishableKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__.isPublishableKey; },\n/* harmony export */   isRGBColor: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.isRGBColor; },\n/* harmony export */   isStaging: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.isStaging; },\n/* harmony export */   isTestEnvironment: function() { return /* reexport safe */ _chunk_IC4FGZI3_mjs__WEBPACK_IMPORTED_MODULE_10__.isTestEnvironment; },\n/* harmony export */   isTransparent: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.isTransparent; },\n/* harmony export */   isTruthy: function() { return /* reexport safe */ _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_2__.isTruthy; },\n/* harmony export */   isUnauthorizedError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.isUnauthorizedError; },\n/* harmony export */   isUserLockedError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.isUserLockedError; },\n/* harmony export */   isValidBrowser: function() { return /* reexport safe */ _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_21__.isValidBrowser; },\n/* harmony export */   isValidBrowserOnline: function() { return /* reexport safe */ _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_21__.isValidBrowserOnline; },\n/* harmony export */   isValidHexString: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.isValidHexString; },\n/* harmony export */   isValidHslaString: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.isValidHslaString; },\n/* harmony export */   isValidProxyUrl: function() { return /* reexport safe */ _chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_5__.isValidProxyUrl; },\n/* harmony export */   isValidRgbaString: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.isValidRgbaString; },\n/* harmony export */   isomorphicAtob: function() { return /* reexport safe */ _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_19__.isomorphicAtob; },\n/* harmony export */   isomorphicBtoa: function() { return /* reexport safe */ _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_20__.isomorphicBtoa; },\n/* harmony export */   joinURL: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.joinURL; },\n/* harmony export */   loadClerkJsScript: function() { return /* reexport safe */ _chunk_752VSHHB_mjs__WEBPACK_IMPORTED_MODULE_3__.loadClerkJsScript; },\n/* harmony export */   loadScript: function() { return /* reexport safe */ _chunk_DSMUR7RM_mjs__WEBPACK_IMPORTED_MODULE_7__.loadScript; },\n/* harmony export */   logErrorInDevMode: function() { return /* binding */ logErrorInDevMode; },\n/* harmony export */   logger: function() { return /* reexport safe */ _chunk_CYDR2ZSA_mjs__WEBPACK_IMPORTED_MODULE_9__.logger; },\n/* harmony export */   noop: function() { return /* reexport safe */ _chunk_XPYJQUM7_mjs__WEBPACK_IMPORTED_MODULE_1__.noop; },\n/* harmony export */   normalizeDate: function() { return /* reexport safe */ _chunk_FSKKI4LG_mjs__WEBPACK_IMPORTED_MODULE_25__.normalizeDate; },\n/* harmony export */   parseError: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.parseError; },\n/* harmony export */   parseErrors: function() { return /* reexport safe */ _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__.parseErrors; },\n/* harmony export */   parsePublishableKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__.parsePublishableKey; },\n/* harmony export */   parseSearchParams: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.parseSearchParams; },\n/* harmony export */   proxyUrlToAbsoluteURL: function() { return /* reexport safe */ _chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_5__.proxyUrlToAbsoluteURL; },\n/* harmony export */   readJSONFile: function() { return /* reexport safe */ _chunk_5JU2E5TY_mjs__WEBPACK_IMPORTED_MODULE_15__.readJSONFile; },\n/* harmony export */   removeUndefined: function() { return /* reexport safe */ _chunk_CFXQSUF6_mjs__WEBPACK_IMPORTED_MODULE_0__.removeUndefined; },\n/* harmony export */   runWithExponentialBackOff: function() { return /* binding */ runWithExponentialBackOff; },\n/* harmony export */   setClerkJsLoadingErrorPackageName: function() { return /* reexport safe */ _chunk_752VSHHB_mjs__WEBPACK_IMPORTED_MODULE_3__.setClerkJsLoadingErrorPackageName; },\n/* harmony export */   setDevBrowserJWTInURL: function() { return /* reexport safe */ _chunk_K64INQ4C_mjs__WEBPACK_IMPORTED_MODULE_12__.setDevBrowserJWTInURL; },\n/* harmony export */   snakeToCamel: function() { return /* reexport safe */ _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_2__.snakeToCamel; },\n/* harmony export */   stringToHslaColor: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.stringToHslaColor; },\n/* harmony export */   stringToSameTypeColor: function() { return /* reexport safe */ _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__.stringToSameTypeColor; },\n/* harmony export */   stripScheme: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.stripScheme; },\n/* harmony export */   titleize: function() { return /* reexport safe */ _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_2__.titleize; },\n/* harmony export */   toSentence: function() { return /* reexport safe */ _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_2__.toSentence; },\n/* harmony export */   userAgentIsRobot: function() { return /* reexport safe */ _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_21__.userAgentIsRobot; },\n/* harmony export */   versionSelector: function() { return /* reexport safe */ _chunk_TVXNN3J6_mjs__WEBPACK_IMPORTED_MODULE_4__.versionSelector; },\n/* harmony export */   withLeadingSlash: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.withLeadingSlash; },\n/* harmony export */   withTrailingSlash: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.withTrailingSlash; },\n/* harmony export */   without: function() { return /* reexport safe */ _chunk_CFXQSUF6_mjs__WEBPACK_IMPORTED_MODULE_0__.without; },\n/* harmony export */   withoutLeadingSlash: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.withoutLeadingSlash; },\n/* harmony export */   withoutTrailingSlash: function() { return /* reexport safe */ _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__.withoutTrailingSlash; }\n/* harmony export */ });\n/* harmony import */ var _chunk_CFXQSUF6_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-CFXQSUF6.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-CFXQSUF6.mjs\");\n/* harmony import */ var _chunk_XPYJQUM7_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-XPYJQUM7.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-XPYJQUM7.mjs\");\n/* harmony import */ var _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-QE2A7CJI.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-QE2A7CJI.mjs\");\n/* harmony import */ var _chunk_752VSHHB_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-752VSHHB.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-752VSHHB.mjs\");\n/* harmony import */ var _chunk_TVXNN3J6_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-TVXNN3J6.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TVXNN3J6.mjs\");\n/* harmony import */ var _chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-6NDGN2IU.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs\");\n/* harmony import */ var _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunk-Q2DOGLDC.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-Q2DOGLDC.mjs\");\n/* harmony import */ var _chunk_DSMUR7RM_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chunk-DSMUR7RM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-DSMUR7RM.mjs\");\n/* harmony import */ var _chunk_RSOCGYTF_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chunk-RSOCGYTF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-RSOCGYTF.mjs\");\n/* harmony import */ var _chunk_CYDR2ZSA_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chunk-CYDR2ZSA.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-CYDR2ZSA.mjs\");\n/* harmony import */ var _chunk_IC4FGZI3_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./chunk-IC4FGZI3.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IC4FGZI3.mjs\");\n/* harmony import */ var _chunk_6NISCHKC_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./chunk-6NISCHKC.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NISCHKC.mjs\");\n/* harmony import */ var _chunk_K64INQ4C_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./chunk-K64INQ4C.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-K64INQ4C.mjs\");\n/* harmony import */ var _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./chunk-IB6GRLVO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IB6GRLVO.mjs\");\n/* harmony import */ var _chunk_4LL2VPJL_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./chunk-4LL2VPJL.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-4LL2VPJL.mjs\");\n/* harmony import */ var _chunk_5JU2E5TY_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./chunk-5JU2E5TY.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-5JU2E5TY.mjs\");\n/* harmony import */ var _chunk_TRWMHODU_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./chunk-TRWMHODU.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TRWMHODU.mjs\");\n/* harmony import */ var _chunk_QPSU45F4_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./chunk-QPSU45F4.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-QPSU45F4.mjs\");\n/* harmony import */ var _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./chunk-L2BNNARM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-L2BNNARM.mjs\");\n/* harmony import */ var _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./chunk-TETGTEI2.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\");\n/* harmony import */ var _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./chunk-KOH7GTJO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\");\n/* harmony import */ var _chunk_LJ4R7M7R_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./chunk-LJ4R7M7R.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-LJ4R7M7R.mjs\");\n/* harmony import */ var _chunk_4PW5MDZA_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./chunk-4PW5MDZA.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-4PW5MDZA.mjs\");\n/* harmony import */ var _chunk_X6NLIF7Y_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./chunk-X6NLIF7Y.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-X6NLIF7Y.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n/* harmony import */ var _chunk_FSKKI4LG_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./chunk-FSKKI4LG.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-FSKKI4LG.mjs\");\n/* harmony import */ var _chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./chunk-7ELT755Q.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// src/utils/createDeferredPromise.ts\nvar createDeferredPromise = () => {\n  let resolve = _chunk_XPYJQUM7_mjs__WEBPACK_IMPORTED_MODULE_1__.noop;\n  let reject = _chunk_XPYJQUM7_mjs__WEBPACK_IMPORTED_MODULE_1__.noop;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n};\n\n// src/utils/logErrorInDevMode.ts\nvar logErrorInDevMode = (message) => {\n  if ((0,_chunk_IC4FGZI3_mjs__WEBPACK_IMPORTED_MODULE_10__.isDevelopmentEnvironment)()) {\n    console.error(`Clerk: ${message}`);\n  }\n};\n\n// src/utils/runWithExponentialBackOff.ts\nvar defaultOptions = {\n  firstDelay: 125,\n  maxDelay: 0,\n  timeMultiple: 2,\n  shouldRetry: () => true\n};\nvar sleep = async (ms) => new Promise((s) => setTimeout(s, ms));\nvar createExponentialDelayAsyncFn = (opts) => {\n  let timesCalled = 0;\n  const calculateDelayInMs = () => {\n    const constant = opts.firstDelay;\n    const base = opts.timeMultiple;\n    const delay = constant * Math.pow(base, timesCalled);\n    return Math.min(opts.maxDelay || delay, delay);\n  };\n  return async () => {\n    await sleep(calculateDelayInMs());\n    timesCalled++;\n  };\n};\nvar runWithExponentialBackOff = async (callback, options = {}) => {\n  let iterationsCount = 0;\n  const { shouldRetry, firstDelay, maxDelay, timeMultiple } = {\n    ...defaultOptions,\n    ...options\n  };\n  const delay = createExponentialDelayAsyncFn({ firstDelay, maxDelay, timeMultiple });\n  while (true) {\n    try {\n      return await callback();\n    } catch (e) {\n      iterationsCount++;\n      if (!shouldRetry(e, iterationsCount)) {\n        throw e;\n      }\n      await delay();\n    }\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSzhCO0FBS0E7QUFXQTtBQU1BO0FBR0E7QUFNQTtBQW9CQTtBQUdBO0FBR0E7QUFHQTtBQVFBO0FBR0E7QUFLQTtBQW1CQTtBQUlBO0FBSUE7QUFHQTtBQUdBO0FBWUE7QUFHQTtBQUdBO0FBT0E7QUFHQTtBQWFBO0FBV0E7QUFPQTtBQUNBOztBQUU5QjtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFJO0FBQ3BCLGVBQWUscURBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsTUFBTSw4RUFBd0I7QUFDOUIsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxVQUFVLGtEQUFrRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsb0NBQW9DO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBK0hFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9pbmRleC5tanM/ZjYyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBhcHBseUZ1bmN0aW9uVG9PYmosXG4gIGZpbHRlclByb3BzLFxuICByZW1vdmVVbmRlZmluZWQsXG4gIHdpdGhvdXRcbn0gZnJvbSBcIi4vY2h1bmstQ0ZYUVNVRjYubWpzXCI7XG5pbXBvcnQge1xuICBQb2xsZXIsXG4gIGNyZWF0ZVdvcmtlclRpbWVycyxcbiAgbm9vcFxufSBmcm9tIFwiLi9jaHVuay1YUFlKUVVNNy5tanNcIjtcbmltcG9ydCB7XG4gIGNhbWVsVG9TbmFrZSxcbiAgZGVlcENhbWVsVG9TbmFrZSxcbiAgZGVlcFNuYWtlVG9DYW1lbCxcbiAgZ2V0Tm9uVW5kZWZpbmVkVmFsdWVzLFxuICBpc0lQVjRBZGRyZXNzLFxuICBpc1RydXRoeSxcbiAgc25ha2VUb0NhbWVsLFxuICB0aXRsZWl6ZSxcbiAgdG9TZW50ZW5jZVxufSBmcm9tIFwiLi9jaHVuay1RRTJBN0NKSS5tanNcIjtcbmltcG9ydCB7XG4gIGJ1aWxkQ2xlcmtKc1NjcmlwdEF0dHJpYnV0ZXMsXG4gIGNsZXJrSnNTY3JpcHRVcmwsXG4gIGxvYWRDbGVya0pzU2NyaXB0LFxuICBzZXRDbGVya0pzTG9hZGluZ0Vycm9yUGFja2FnZU5hbWVcbn0gZnJvbSBcIi4vY2h1bmstNzUyVlNISEIubWpzXCI7XG5pbXBvcnQge1xuICB2ZXJzaW9uU2VsZWN0b3Jcbn0gZnJvbSBcIi4vY2h1bmstVFZYTk4zSjYubWpzXCI7XG5pbXBvcnQge1xuICBpc0h0dHBPckh0dHBzLFxuICBpc1Byb3h5VXJsUmVsYXRpdmUsXG4gIGlzVmFsaWRQcm94eVVybCxcbiAgcHJveHlVcmxUb0Fic29sdXRlVVJMXG59IGZyb20gXCIuL2NodW5rLTZOREdOMklVLm1qc1wiO1xuaW1wb3J0IHtcbiAgYWRkQ2xlcmtQcmVmaXgsXG4gIGNsZWFuRG91YmxlU2xhc2hlcyxcbiAgZ2V0Q2xlcmtKc01ham9yVmVyc2lvbk9yVGFnLFxuICBnZXRTY3JpcHRVcmwsXG4gIGhhc0xlYWRpbmdTbGFzaCxcbiAgaGFzVHJhaWxpbmdTbGFzaCxcbiAgaXNBYnNvbHV0ZVVybCxcbiAgaXNDdXJyZW50RGV2QWNjb3VudFBvcnRhbE9yaWdpbixcbiAgaXNMZWdhY3lEZXZBY2NvdW50UG9ydGFsT3JpZ2luLFxuICBpc05vbkVtcHR5VVJMLFxuICBpc1N0YWdpbmcsXG4gIGpvaW5VUkwsXG4gIHBhcnNlU2VhcmNoUGFyYW1zLFxuICBzdHJpcFNjaGVtZSxcbiAgd2l0aExlYWRpbmdTbGFzaCxcbiAgd2l0aFRyYWlsaW5nU2xhc2gsXG4gIHdpdGhvdXRMZWFkaW5nU2xhc2gsXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoXG59IGZyb20gXCIuL2NodW5rLVEyRE9HTERDLm1qc1wiO1xuaW1wb3J0IHtcbiAgbG9hZFNjcmlwdFxufSBmcm9tIFwiLi9jaHVuay1EU01VUjdSTS5tanNcIjtcbmltcG9ydCB7XG4gIExvY2FsU3RvcmFnZUJyb2FkY2FzdENoYW5uZWxcbn0gZnJvbSBcIi4vY2h1bmstUlNPQ0dZVEYubWpzXCI7XG5pbXBvcnQge1xuICBsb2dnZXJcbn0gZnJvbSBcIi4vY2h1bmstQ1lEUjJaU0EubWpzXCI7XG5pbXBvcnQge1xuICBkZXByZWNhdGVkLFxuICBkZXByZWNhdGVkT2JqZWN0UHJvcGVydHksXG4gIGRlcHJlY2F0ZWRQcm9wZXJ0eSxcbiAgaXNEZXZlbG9wbWVudEVudmlyb25tZW50LFxuICBpc1Byb2R1Y3Rpb25FbnZpcm9ubWVudCxcbiAgaXNUZXN0RW52aXJvbm1lbnRcbn0gZnJvbSBcIi4vY2h1bmstSUM0RkdaSTMubWpzXCI7XG5pbXBvcnQge1xuICBkZXJpdmVTdGF0ZVxufSBmcm9tIFwiLi9jaHVuay02TklTQ0hLQy5tanNcIjtcbmltcG9ydCB7XG4gIERFVl9CUk9XU0VSX0pXVF9LRVksXG4gIGV4dHJhY3REZXZCcm93c2VySldURnJvbVVSTCxcbiAgc2V0RGV2QnJvd3NlckpXVEluVVJMXG59IGZyb20gXCIuL2NodW5rLUs2NElOUTRDLm1qc1wiO1xuaW1wb3J0IHtcbiAgQ2xlcmtBUElSZXNwb25zZUVycm9yLFxuICBDbGVya1J1bnRpbWVFcnJvcixcbiAgRW1haWxMaW5rRXJyb3IsXG4gIEVtYWlsTGlua0Vycm9yQ29kZSxcbiAgYnVpbGRFcnJvclRocm93ZXIsXG4gIGlzNHh4RXJyb3IsXG4gIGlzQ2xlcmtBUElSZXNwb25zZUVycm9yLFxuICBpc0NsZXJrUnVudGltZUVycm9yLFxuICBpc0VtYWlsTGlua0Vycm9yLFxuICBpc0tub3duRXJyb3IsXG4gIGlzTWV0YW1hc2tFcnJvcixcbiAgaXNOZXR3b3JrRXJyb3IsXG4gIGlzUGFzc3dvcmRQd25lZEVycm9yLFxuICBpc1VuYXV0aG9yaXplZEVycm9yLFxuICBpc1VzZXJMb2NrZWRFcnJvcixcbiAgcGFyc2VFcnJvcixcbiAgcGFyc2VFcnJvcnNcbn0gZnJvbSBcIi4vY2h1bmstSUI2R1JMVk8ubWpzXCI7XG5pbXBvcnQge1xuICBmYXN0RGVlcE1lcmdlQW5kS2VlcCxcbiAgZmFzdERlZXBNZXJnZUFuZFJlcGxhY2Vcbn0gZnJvbSBcIi4vY2h1bmstNExMMlZQSkwubWpzXCI7XG5pbXBvcnQge1xuICBleHRlbnNpb24sXG4gIHJlYWRKU09ORmlsZVxufSBmcm9tIFwiLi9jaHVuay01SlUyRTVUWS5tanNcIjtcbmltcG9ydCB7XG4gIGhhbmRsZVZhbHVlT3JGblxufSBmcm9tIFwiLi9jaHVuay1UUldNSE9EVS5tanNcIjtcbmltcG9ydCB7XG4gIGFwaVVybEZyb21QdWJsaXNoYWJsZUtleVxufSBmcm9tIFwiLi9jaHVuay1RUFNVNDVGNC5tanNcIjtcbmltcG9ydCB7XG4gIGJ1aWxkUHVibGlzaGFibGVLZXksXG4gIGNyZWF0ZURldk9yU3RhZ2luZ1VybENhY2hlLFxuICBnZXRDb29raWVTdWZmaXgsXG4gIGdldFN1ZmZpeGVkQ29va2llTmFtZSxcbiAgaXNEZXZlbG9wbWVudEZyb21QdWJsaXNoYWJsZUtleSxcbiAgaXNEZXZlbG9wbWVudEZyb21TZWNyZXRLZXksXG4gIGlzUHJvZHVjdGlvbkZyb21QdWJsaXNoYWJsZUtleSxcbiAgaXNQcm9kdWN0aW9uRnJvbVNlY3JldEtleSxcbiAgaXNQdWJsaXNoYWJsZUtleSxcbiAgcGFyc2VQdWJsaXNoYWJsZUtleVxufSBmcm9tIFwiLi9jaHVuay1MMkJOTkFSTS5tanNcIjtcbmltcG9ydCB7XG4gIGlzb21vcnBoaWNBdG9iXG59IGZyb20gXCIuL2NodW5rLVRFVEdURUkyLm1qc1wiO1xuaW1wb3J0IHtcbiAgaXNvbW9ycGhpY0J0b2Fcbn0gZnJvbSBcIi4vY2h1bmstS09IN0dUSk8ubWpzXCI7XG5pbXBvcnQge1xuICBpbkJyb3dzZXIsXG4gIGlzQnJvd3Nlck9ubGluZSxcbiAgaXNWYWxpZEJyb3dzZXIsXG4gIGlzVmFsaWRCcm93c2VyT25saW5lLFxuICB1c2VyQWdlbnRJc1JvYm90XG59IGZyb20gXCIuL2NodW5rLUxKNFI3TTdSLm1qc1wiO1xuaW1wb3J0IHtcbiAgY2FsbFdpdGhSZXRyeVxufSBmcm9tIFwiLi9jaHVuay00UFc1TURaQS5tanNcIjtcbmltcG9ydCB7XG4gIGNvbG9yVG9TYW1lVHlwZVN0cmluZyxcbiAgaGFzQWxwaGEsXG4gIGhleFN0cmluZ1RvUmdiYUNvbG9yLFxuICBpc0hTTENvbG9yLFxuICBpc1JHQkNvbG9yLFxuICBpc1RyYW5zcGFyZW50LFxuICBpc1ZhbGlkSGV4U3RyaW5nLFxuICBpc1ZhbGlkSHNsYVN0cmluZyxcbiAgaXNWYWxpZFJnYmFTdHJpbmcsXG4gIHN0cmluZ1RvSHNsYUNvbG9yLFxuICBzdHJpbmdUb1NhbWVUeXBlQ29sb3Jcbn0gZnJvbSBcIi4vY2h1bmstWDZOTElGN1kubWpzXCI7XG5pbXBvcnQge1xuICBDVVJSRU5UX0RFVl9JTlNUQU5DRV9TVUZGSVhFUyxcbiAgREVWX09SX1NUQUdJTkdfU1VGRklYRVMsXG4gIExFR0FDWV9ERVZfSU5TVEFOQ0VfU1VGRklYRVMsXG4gIExPQ0FMX0FQSV9VUkwsXG4gIExPQ0FMX0VOVl9TVUZGSVhFUyxcbiAgUFJPRF9BUElfVVJMLFxuICBTVEFHSU5HX0FQSV9VUkwsXG4gIFNUQUdJTkdfRU5WX1NVRkZJWEVTLFxuICBpY29uSW1hZ2VVcmxcbn0gZnJvbSBcIi4vY2h1bmstSTZNVFNUT0YubWpzXCI7XG5pbXBvcnQge1xuICBhZGRZZWFycyxcbiAgZGF0ZVRvMTJIb3VyVGltZSxcbiAgZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzLFxuICBmb3JtYXRSZWxhdGl2ZSxcbiAgbm9ybWFsaXplRGF0ZVxufSBmcm9tIFwiLi9jaHVuay1GU0tLSTRMRy5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstN0VMVDc1NVEubWpzXCI7XG5cbi8vIHNyYy91dGlscy9jcmVhdGVEZWZlcnJlZFByb21pc2UudHNcbnZhciBjcmVhdGVEZWZlcnJlZFByb21pc2UgPSAoKSA9PiB7XG4gIGxldCByZXNvbHZlID0gbm9vcDtcbiAgbGV0IHJlamVjdCA9IG5vb3A7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufTtcblxuLy8gc3JjL3V0aWxzL2xvZ0Vycm9ySW5EZXZNb2RlLnRzXG52YXIgbG9nRXJyb3JJbkRldk1vZGUgPSAobWVzc2FnZSkgPT4ge1xuICBpZiAoaXNEZXZlbG9wbWVudEVudmlyb25tZW50KCkpIHtcbiAgICBjb25zb2xlLmVycm9yKGBDbGVyazogJHttZXNzYWdlfWApO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvcnVuV2l0aEV4cG9uZW50aWFsQmFja09mZi50c1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBmaXJzdERlbGF5OiAxMjUsXG4gIG1heERlbGF5OiAwLFxuICB0aW1lTXVsdGlwbGU6IDIsXG4gIHNob3VsZFJldHJ5OiAoKSA9PiB0cnVlXG59O1xudmFyIHNsZWVwID0gYXN5bmMgKG1zKSA9PiBuZXcgUHJvbWlzZSgocykgPT4gc2V0VGltZW91dChzLCBtcykpO1xudmFyIGNyZWF0ZUV4cG9uZW50aWFsRGVsYXlBc3luY0ZuID0gKG9wdHMpID0+IHtcbiAgbGV0IHRpbWVzQ2FsbGVkID0gMDtcbiAgY29uc3QgY2FsY3VsYXRlRGVsYXlJbk1zID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gb3B0cy5maXJzdERlbGF5O1xuICAgIGNvbnN0IGJhc2UgPSBvcHRzLnRpbWVNdWx0aXBsZTtcbiAgICBjb25zdCBkZWxheSA9IGNvbnN0YW50ICogTWF0aC5wb3coYmFzZSwgdGltZXNDYWxsZWQpO1xuICAgIHJldHVybiBNYXRoLm1pbihvcHRzLm1heERlbGF5IHx8IGRlbGF5LCBkZWxheSk7XG4gIH07XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgc2xlZXAoY2FsY3VsYXRlRGVsYXlJbk1zKCkpO1xuICAgIHRpbWVzQ2FsbGVkKys7XG4gIH07XG59O1xudmFyIHJ1bldpdGhFeHBvbmVudGlhbEJhY2tPZmYgPSBhc3luYyAoY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBsZXQgaXRlcmF0aW9uc0NvdW50ID0gMDtcbiAgY29uc3QgeyBzaG91bGRSZXRyeSwgZmlyc3REZWxheSwgbWF4RGVsYXksIHRpbWVNdWx0aXBsZSB9ID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgZGVsYXkgPSBjcmVhdGVFeHBvbmVudGlhbERlbGF5QXN5bmNGbih7IGZpcnN0RGVsYXksIG1heERlbGF5LCB0aW1lTXVsdGlwbGUgfSk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsYmFjaygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGl0ZXJhdGlvbnNDb3VudCsrO1xuICAgICAgaWYgKCFzaG91bGRSZXRyeShlLCBpdGVyYXRpb25zQ291bnQpKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBhd2FpdCBkZWxheSgpO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCB7XG4gIENVUlJFTlRfREVWX0lOU1RBTkNFX1NVRkZJWEVTLFxuICBDbGVya0FQSVJlc3BvbnNlRXJyb3IsXG4gIENsZXJrUnVudGltZUVycm9yLFxuICBERVZfQlJPV1NFUl9KV1RfS0VZLFxuICBERVZfT1JfU1RBR0lOR19TVUZGSVhFUyxcbiAgRW1haWxMaW5rRXJyb3IsXG4gIEVtYWlsTGlua0Vycm9yQ29kZSxcbiAgTEVHQUNZX0RFVl9JTlNUQU5DRV9TVUZGSVhFUyxcbiAgTE9DQUxfQVBJX1VSTCxcbiAgTE9DQUxfRU5WX1NVRkZJWEVTLFxuICBMb2NhbFN0b3JhZ2VCcm9hZGNhc3RDaGFubmVsLFxuICBQUk9EX0FQSV9VUkwsXG4gIFBvbGxlcixcbiAgU1RBR0lOR19BUElfVVJMLFxuICBTVEFHSU5HX0VOVl9TVUZGSVhFUyxcbiAgYWRkQ2xlcmtQcmVmaXgsXG4gIGFkZFllYXJzLFxuICBhcGlVcmxGcm9tUHVibGlzaGFibGVLZXksXG4gIGFwcGx5RnVuY3Rpb25Ub09iaixcbiAgYnVpbGRDbGVya0pzU2NyaXB0QXR0cmlidXRlcyxcbiAgYnVpbGRFcnJvclRocm93ZXIsXG4gIGJ1aWxkUHVibGlzaGFibGVLZXksXG4gIGNhbGxXaXRoUmV0cnksXG4gIGNhbWVsVG9TbmFrZSxcbiAgY2xlYW5Eb3VibGVTbGFzaGVzLFxuICBjbGVya0pzU2NyaXB0VXJsLFxuICBjb2xvclRvU2FtZVR5cGVTdHJpbmcsXG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZSxcbiAgY3JlYXRlRGV2T3JTdGFnaW5nVXJsQ2FjaGUsXG4gIGNyZWF0ZVdvcmtlclRpbWVycyxcbiAgZGF0ZVRvMTJIb3VyVGltZSxcbiAgZGVlcENhbWVsVG9TbmFrZSxcbiAgZGVlcFNuYWtlVG9DYW1lbCxcbiAgZGVwcmVjYXRlZCxcbiAgZGVwcmVjYXRlZE9iamVjdFByb3BlcnR5LFxuICBkZXByZWNhdGVkUHJvcGVydHksXG4gIGRlcml2ZVN0YXRlLFxuICBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMsXG4gIGV4dGVuc2lvbixcbiAgZXh0cmFjdERldkJyb3dzZXJKV1RGcm9tVVJMLFxuICBmYXN0RGVlcE1lcmdlQW5kS2VlcCxcbiAgZmFzdERlZXBNZXJnZUFuZFJlcGxhY2UsXG4gIGZpbHRlclByb3BzLFxuICBmb3JtYXRSZWxhdGl2ZSxcbiAgZ2V0Q2xlcmtKc01ham9yVmVyc2lvbk9yVGFnLFxuICBnZXRDb29raWVTdWZmaXgsXG4gIGdldE5vblVuZGVmaW5lZFZhbHVlcyxcbiAgZ2V0U2NyaXB0VXJsLFxuICBnZXRTdWZmaXhlZENvb2tpZU5hbWUsXG4gIGhhbmRsZVZhbHVlT3JGbixcbiAgaGFzQWxwaGEsXG4gIGhhc0xlYWRpbmdTbGFzaCxcbiAgaGFzVHJhaWxpbmdTbGFzaCxcbiAgaGV4U3RyaW5nVG9SZ2JhQ29sb3IsXG4gIGljb25JbWFnZVVybCxcbiAgaW5Ccm93c2VyLFxuICBpczR4eEVycm9yLFxuICBpc0Fic29sdXRlVXJsLFxuICBpc0Jyb3dzZXJPbmxpbmUsXG4gIGlzQ2xlcmtBUElSZXNwb25zZUVycm9yLFxuICBpc0NsZXJrUnVudGltZUVycm9yLFxuICBpc0N1cnJlbnREZXZBY2NvdW50UG9ydGFsT3JpZ2luLFxuICBpc0RldmVsb3BtZW50RW52aXJvbm1lbnQsXG4gIGlzRGV2ZWxvcG1lbnRGcm9tUHVibGlzaGFibGVLZXksXG4gIGlzRGV2ZWxvcG1lbnRGcm9tU2VjcmV0S2V5LFxuICBpc0VtYWlsTGlua0Vycm9yLFxuICBpc0hTTENvbG9yLFxuICBpc0h0dHBPckh0dHBzLFxuICBpc0lQVjRBZGRyZXNzLFxuICBpc0tub3duRXJyb3IsXG4gIGlzTGVnYWN5RGV2QWNjb3VudFBvcnRhbE9yaWdpbixcbiAgaXNNZXRhbWFza0Vycm9yLFxuICBpc05ldHdvcmtFcnJvcixcbiAgaXNOb25FbXB0eVVSTCxcbiAgaXNQYXNzd29yZFB3bmVkRXJyb3IsXG4gIGlzUHJvZHVjdGlvbkVudmlyb25tZW50LFxuICBpc1Byb2R1Y3Rpb25Gcm9tUHVibGlzaGFibGVLZXksXG4gIGlzUHJvZHVjdGlvbkZyb21TZWNyZXRLZXksXG4gIGlzUHJveHlVcmxSZWxhdGl2ZSxcbiAgaXNQdWJsaXNoYWJsZUtleSxcbiAgaXNSR0JDb2xvcixcbiAgaXNTdGFnaW5nLFxuICBpc1Rlc3RFbnZpcm9ubWVudCxcbiAgaXNUcmFuc3BhcmVudCxcbiAgaXNUcnV0aHksXG4gIGlzVW5hdXRob3JpemVkRXJyb3IsXG4gIGlzVXNlckxvY2tlZEVycm9yLFxuICBpc1ZhbGlkQnJvd3NlcixcbiAgaXNWYWxpZEJyb3dzZXJPbmxpbmUsXG4gIGlzVmFsaWRIZXhTdHJpbmcsXG4gIGlzVmFsaWRIc2xhU3RyaW5nLFxuICBpc1ZhbGlkUHJveHlVcmwsXG4gIGlzVmFsaWRSZ2JhU3RyaW5nLFxuICBpc29tb3JwaGljQXRvYixcbiAgaXNvbW9ycGhpY0J0b2EsXG4gIGpvaW5VUkwsXG4gIGxvYWRDbGVya0pzU2NyaXB0LFxuICBsb2FkU2NyaXB0LFxuICBsb2dFcnJvckluRGV2TW9kZSxcbiAgbG9nZ2VyLFxuICBub29wLFxuICBub3JtYWxpemVEYXRlLFxuICBwYXJzZUVycm9yLFxuICBwYXJzZUVycm9ycyxcbiAgcGFyc2VQdWJsaXNoYWJsZUtleSxcbiAgcGFyc2VTZWFyY2hQYXJhbXMsXG4gIHByb3h5VXJsVG9BYnNvbHV0ZVVSTCxcbiAgcmVhZEpTT05GaWxlLFxuICByZW1vdmVVbmRlZmluZWQsXG4gIHJ1bldpdGhFeHBvbmVudGlhbEJhY2tPZmYsXG4gIHNldENsZXJrSnNMb2FkaW5nRXJyb3JQYWNrYWdlTmFtZSxcbiAgc2V0RGV2QnJvd3NlckpXVEluVVJMLFxuICBzbmFrZVRvQ2FtZWwsXG4gIHN0cmluZ1RvSHNsYUNvbG9yLFxuICBzdHJpbmdUb1NhbWVUeXBlQ29sb3IsXG4gIHN0cmlwU2NoZW1lLFxuICB0aXRsZWl6ZSxcbiAgdG9TZW50ZW5jZSxcbiAgdXNlckFnZW50SXNSb2JvdCxcbiAgdmVyc2lvblNlbGVjdG9yLFxuICB3aXRoTGVhZGluZ1NsYXNoLFxuICB3aXRoVHJhaWxpbmdTbGFzaCxcbiAgd2l0aG91dCxcbiAgd2l0aG91dExlYWRpbmdTbGFzaCxcbiAgd2l0aG91dFRyYWlsaW5nU2xhc2hcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/keys.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/keys.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildPublishableKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.buildPublishableKey; },\n/* harmony export */   createDevOrStagingUrlCache: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.createDevOrStagingUrlCache; },\n/* harmony export */   getCookieSuffix: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.getCookieSuffix; },\n/* harmony export */   getSuffixedCookieName: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.getSuffixedCookieName; },\n/* harmony export */   isDevelopmentFromPublishableKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.isDevelopmentFromPublishableKey; },\n/* harmony export */   isDevelopmentFromSecretKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.isDevelopmentFromSecretKey; },\n/* harmony export */   isProductionFromPublishableKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.isProductionFromPublishableKey; },\n/* harmony export */   isProductionFromSecretKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.isProductionFromSecretKey; },\n/* harmony export */   isPublishableKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.isPublishableKey; },\n/* harmony export */   parsePublishableKey: function() { return /* reexport safe */ _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__.parsePublishableKey; }\n/* harmony export */ });\n/* harmony import */ var _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-L2BNNARM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-L2BNNARM.mjs\");\n/* harmony import */ var _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-TETGTEI2.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\");\n/* harmony import */ var _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-KOH7GTJO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n/* harmony import */ var _chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-7ELT755Q.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs\");\n\n\n\n\n\n\n//# sourceMappingURL=keys.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3Qva2V5cy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVzhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFZNUI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNsZXJrL3NoYXJlZC9kaXN0L2tleXMubWpzPzIzMTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgYnVpbGRQdWJsaXNoYWJsZUtleSxcbiAgY3JlYXRlRGV2T3JTdGFnaW5nVXJsQ2FjaGUsXG4gIGdldENvb2tpZVN1ZmZpeCxcbiAgZ2V0U3VmZml4ZWRDb29raWVOYW1lLFxuICBpc0RldmVsb3BtZW50RnJvbVB1Ymxpc2hhYmxlS2V5LFxuICBpc0RldmVsb3BtZW50RnJvbVNlY3JldEtleSxcbiAgaXNQcm9kdWN0aW9uRnJvbVB1Ymxpc2hhYmxlS2V5LFxuICBpc1Byb2R1Y3Rpb25Gcm9tU2VjcmV0S2V5LFxuICBpc1B1Ymxpc2hhYmxlS2V5LFxuICBwYXJzZVB1Ymxpc2hhYmxlS2V5XG59IGZyb20gXCIuL2NodW5rLUwyQk5OQVJNLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1URVRHVEVJMi5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstS09IN0dUSk8ubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLUk2TVRTVE9GLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay03RUxUNzU1US5tanNcIjtcbmV4cG9ydCB7XG4gIGJ1aWxkUHVibGlzaGFibGVLZXksXG4gIGNyZWF0ZURldk9yU3RhZ2luZ1VybENhY2hlLFxuICBnZXRDb29raWVTdWZmaXgsXG4gIGdldFN1ZmZpeGVkQ29va2llTmFtZSxcbiAgaXNEZXZlbG9wbWVudEZyb21QdWJsaXNoYWJsZUtleSxcbiAgaXNEZXZlbG9wbWVudEZyb21TZWNyZXRLZXksXG4gIGlzUHJvZHVjdGlvbkZyb21QdWJsaXNoYWJsZUtleSxcbiAgaXNQcm9kdWN0aW9uRnJvbVNlY3JldEtleSxcbiAgaXNQdWJsaXNoYWJsZUtleSxcbiAgcGFyc2VQdWJsaXNoYWJsZUtleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/keys.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/loadClerkJsScript.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/loadClerkJsScript.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildClerkJsScriptAttributes: function() { return /* reexport safe */ _chunk_752VSHHB_mjs__WEBPACK_IMPORTED_MODULE_0__.buildClerkJsScriptAttributes; },\n/* harmony export */   clerkJsScriptUrl: function() { return /* reexport safe */ _chunk_752VSHHB_mjs__WEBPACK_IMPORTED_MODULE_0__.clerkJsScriptUrl; },\n/* harmony export */   loadClerkJsScript: function() { return /* reexport safe */ _chunk_752VSHHB_mjs__WEBPACK_IMPORTED_MODULE_0__.loadClerkJsScript; },\n/* harmony export */   setClerkJsLoadingErrorPackageName: function() { return /* reexport safe */ _chunk_752VSHHB_mjs__WEBPACK_IMPORTED_MODULE_0__.setClerkJsLoadingErrorPackageName; }\n/* harmony export */ });\n/* harmony import */ var _chunk_752VSHHB_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-752VSHHB.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-752VSHHB.mjs\");\n/* harmony import */ var _chunk_TVXNN3J6_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-TVXNN3J6.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TVXNN3J6.mjs\");\n/* harmony import */ var _chunk_6NDGN2IU_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-6NDGN2IU.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs\");\n/* harmony import */ var _chunk_Q2DOGLDC_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-Q2DOGLDC.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-Q2DOGLDC.mjs\");\n/* harmony import */ var _chunk_DSMUR7RM_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-DSMUR7RM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-DSMUR7RM.mjs\");\n/* harmony import */ var _chunk_IB6GRLVO_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-IB6GRLVO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-IB6GRLVO.mjs\");\n/* harmony import */ var _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunk-L2BNNARM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-L2BNNARM.mjs\");\n/* harmony import */ var _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chunk-TETGTEI2.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\");\n/* harmony import */ var _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chunk-KOH7GTJO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n/* harmony import */ var _chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./chunk-7ELT755Q.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=loadClerkJsScript.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvbG9hZENsZXJrSnNTY3JpcHQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUs4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTTVCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC9sb2FkQ2xlcmtKc1NjcmlwdC5tanM/ZDliMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBidWlsZENsZXJrSnNTY3JpcHRBdHRyaWJ1dGVzLFxuICBjbGVya0pzU2NyaXB0VXJsLFxuICBsb2FkQ2xlcmtKc1NjcmlwdCxcbiAgc2V0Q2xlcmtKc0xvYWRpbmdFcnJvclBhY2thZ2VOYW1lXG59IGZyb20gXCIuL2NodW5rLTc1MlZTSEhCLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1UVlhOTjNKNi5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstNk5ER04ySVUubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLVEyRE9HTERDLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1EU01VUjdSTS5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstSUI2R1JMVk8ubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLUwyQk5OQVJNLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1URVRHVEVJMi5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstS09IN0dUSk8ubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLUk2TVRTVE9GLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay03RUxUNzU1US5tanNcIjtcbmV4cG9ydCB7XG4gIGJ1aWxkQ2xlcmtKc1NjcmlwdEF0dHJpYnV0ZXMsXG4gIGNsZXJrSnNTY3JpcHRVcmwsXG4gIGxvYWRDbGVya0pzU2NyaXB0LFxuICBzZXRDbGVya0pzTG9hZGluZ0Vycm9yUGFja2FnZU5hbWVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkQ2xlcmtKc1NjcmlwdC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/loadClerkJsScript.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/react/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/react/index.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClerkInstanceContext: function() { return /* binding */ ClerkInstanceContext; },\n/* harmony export */   ClientContext: function() { return /* binding */ ClientContext; },\n/* harmony export */   OptionsContext: function() { return /* binding */ OptionsContext; },\n/* harmony export */   OrganizationProvider: function() { return /* binding */ OrganizationProvider; },\n/* harmony export */   SessionContext: function() { return /* binding */ SessionContext; },\n/* harmony export */   UserContext: function() { return /* binding */ UserContext; },\n/* harmony export */   assertContextExists: function() { return /* binding */ assertContextExists; },\n/* harmony export */   createContextAndHook: function() { return /* binding */ createContextAndHook; },\n/* harmony export */   isDeeplyEqual: function() { return /* binding */ isDeeplyEqual; },\n/* harmony export */   useAssertWrappedByClerkProvider: function() { return /* binding */ useAssertWrappedByClerkProvider; },\n/* harmony export */   useClerk: function() { return /* binding */ useClerk; },\n/* harmony export */   useClerkInstanceContext: function() { return /* binding */ useClerkInstanceContext; },\n/* harmony export */   useClientContext: function() { return /* binding */ useClientContext; },\n/* harmony export */   useDeepEqualMemo: function() { return /* binding */ useDeepEqualMemo; },\n/* harmony export */   useOptionsContext: function() { return /* binding */ useOptionsContext; },\n/* harmony export */   useOrganization: function() { return /* binding */ useOrganization; },\n/* harmony export */   useOrganizationContext: function() { return /* binding */ useOrganizationContext; },\n/* harmony export */   useOrganizationList: function() { return /* binding */ useOrganizationList; },\n/* harmony export */   useSafeLayoutEffect: function() { return /* binding */ useSafeLayoutEffect; },\n/* harmony export */   useSession: function() { return /* binding */ useSession; },\n/* harmony export */   useSessionContext: function() { return /* binding */ useSessionContext; },\n/* harmony export */   useSessionList: function() { return /* binding */ useSessionList; },\n/* harmony export */   useUser: function() { return /* binding */ useUser; },\n/* harmony export */   useUserContext: function() { return /* binding */ useUserContext; }\n/* harmony export */ });\n/* harmony import */ var _chunk_TUVJ3GI6_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunk-TUVJ3GI6.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TUVJ3GI6.mjs\");\n/* harmony import */ var _chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chunk-7ELT755Q.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/core/index.mjs\");\n/* harmony import */ var swr_infinite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! swr/infinite */ \"(app-pages-browser)/./node_modules/swr/dist/infinite/index.mjs\");\n\n\n\n// src/react/hooks/createContextAndHook.ts\n\nfunction assertContextExists(contextVal, msgOrCtx) {\n  if (!contextVal) {\n    throw typeof msgOrCtx === \"string\" ? new Error(msgOrCtx) : new Error(`${msgOrCtx.displayName} not found`);\n  }\n}\nvar createContextAndHook = (displayName, options) => {\n  const { assertCtxFn = assertContextExists } = options || {};\n  const Ctx = react__WEBPACK_IMPORTED_MODULE_2__.createContext(void 0);\n  Ctx.displayName = displayName;\n  const useCtx = () => {\n    const ctx = react__WEBPACK_IMPORTED_MODULE_2__.useContext(Ctx);\n    assertCtxFn(ctx, `${displayName} not found`);\n    return ctx.value;\n  };\n  const useCtxWithoutGuarantee = () => {\n    const ctx = react__WEBPACK_IMPORTED_MODULE_2__.useContext(Ctx);\n    return ctx ? ctx.value : {};\n  };\n  return [Ctx, useCtx, useCtxWithoutGuarantee];\n};\n\n// src/react/contexts.tsx\n\n\n// src/react/clerk-swr.ts\nvar clerk_swr_exports = {};\n(0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_1__.__export)(clerk_swr_exports, {\n  SWRConfig: () => swr__WEBPACK_IMPORTED_MODULE_3__.SWRConfig,\n  useSWR: () => swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  useSWRInfinite: () => swr_infinite__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n});\n(0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_1__.__reExport)(clerk_swr_exports, swr__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n// src/react/contexts.tsx\nvar [ClerkInstanceContext, useClerkInstanceContext] = createContextAndHook(\"ClerkInstanceContext\");\nvar [UserContext, useUserContext] = createContextAndHook(\"UserContext\");\nvar [ClientContext, useClientContext] = createContextAndHook(\"ClientContext\");\nvar [SessionContext, useSessionContext] = createContextAndHook(\n  \"SessionContext\"\n);\nvar OptionsContext = react__WEBPACK_IMPORTED_MODULE_2__.createContext({});\nfunction useOptionsContext() {\n  const context = react__WEBPACK_IMPORTED_MODULE_2__.useContext(OptionsContext);\n  if (context === void 0) {\n    throw new Error(\"useOptions must be used within an OptionsContext\");\n  }\n  return context;\n}\nvar [OrganizationContextInternal, useOrganizationContext] = createContextAndHook(\"OrganizationContext\");\nvar OrganizationProvider = ({\n  children,\n  organization,\n  swrConfig\n}) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(swr__WEBPACK_IMPORTED_MODULE_3__.SWRConfig, { value: swrConfig }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\n    OrganizationContextInternal.Provider,\n    {\n      value: {\n        value: { organization }\n      }\n    },\n    children\n  ));\n};\nfunction useAssertWrappedByClerkProvider(displayNameOrFn) {\n  const ctx = react__WEBPACK_IMPORTED_MODULE_2__.useContext(ClerkInstanceContext);\n  if (!ctx) {\n    if (typeof displayNameOrFn === \"function\") {\n      displayNameOrFn();\n      return;\n    }\n    throw new Error(\n      `${displayNameOrFn} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`\n    );\n  }\n}\n\n// src/react/hooks/usePagesOrInfinite.ts\n\nfunction getDifferentKeys(obj1, obj2) {\n  const keysSet = new Set(Object.keys(obj2));\n  const differentKeysObject = {};\n  for (const key1 of Object.keys(obj1)) {\n    if (!keysSet.has(key1)) {\n      differentKeysObject[key1] = obj1[key1];\n    }\n  }\n  return differentKeysObject;\n}\nvar useWithSafeValues = (params, defaultValues) => {\n  var _a, _b, _c;\n  const shouldUseDefaults = typeof params === \"boolean\" && params;\n  const initialPageRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(\n    shouldUseDefaults ? defaultValues.initialPage : (_a = params == null ? void 0 : params.initialPage) != null ? _a : defaultValues.initialPage\n  );\n  const pageSizeRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(shouldUseDefaults ? defaultValues.pageSize : (_b = params == null ? void 0 : params.pageSize) != null ? _b : defaultValues.pageSize);\n  const newObj = {};\n  for (const key of Object.keys(defaultValues)) {\n    newObj[key] = shouldUseDefaults ? defaultValues[key] : (_c = params == null ? void 0 : params[key]) != null ? _c : defaultValues[key];\n  }\n  return {\n    ...newObj,\n    initialPage: initialPageRef.current,\n    pageSize: pageSizeRef.current\n  };\n};\nvar cachingSWROptions = {\n  dedupingInterval: 1e3 * 60,\n  focusThrottleInterval: 1e3 * 60 * 2\n};\nvar usePagesOrInfinite = (params, fetcher, config, cacheKeys) => {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const [paginatedPage, setPaginatedPage] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)((_a = params.initialPage) != null ? _a : 1);\n  const initialPageRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)((_b = params.initialPage) != null ? _b : 1);\n  const pageSizeRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)((_c = params.pageSize) != null ? _c : 10);\n  const enabled = (_d = config.enabled) != null ? _d : true;\n  const triggerInfinite = (_e = config.infinite) != null ? _e : false;\n  const keepPreviousData = (_f = config.keepPreviousData) != null ? _f : false;\n  const pagesCacheKey = {\n    ...cacheKeys,\n    ...params,\n    initialPage: paginatedPage,\n    pageSize: pageSizeRef.current\n  };\n  const {\n    data: swrData,\n    isValidating: swrIsValidating,\n    isLoading: swrIsLoading,\n    error: swrError,\n    mutate: swrMutate\n  } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n    !triggerInfinite && !!fetcher && enabled ? pagesCacheKey : null,\n    (cacheKeyParams) => {\n      const requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);\n      return fetcher == null ? void 0 : fetcher(requestParams);\n    },\n    { keepPreviousData, ...cachingSWROptions }\n  );\n  const {\n    data: swrInfiniteData,\n    isLoading: swrInfiniteIsLoading,\n    isValidating: swrInfiniteIsValidating,\n    error: swrInfiniteError,\n    size,\n    setSize,\n    mutate: swrInfiniteMutate\n  } = (0,swr_infinite__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(\n    (pageIndex) => {\n      if (!triggerInfinite || !enabled) {\n        return null;\n      }\n      return {\n        ...params,\n        ...cacheKeys,\n        initialPage: initialPageRef.current + pageIndex,\n        pageSize: pageSizeRef.current\n      };\n    },\n    (cacheKeyParams) => {\n      const requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);\n      return fetcher == null ? void 0 : fetcher(requestParams);\n    },\n    cachingSWROptions\n  );\n  const page = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(() => {\n    if (triggerInfinite) {\n      return size;\n    }\n    return paginatedPage;\n  }, [triggerInfinite, size, paginatedPage]);\n  const fetchPage = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(\n    (numberOrgFn) => {\n      if (triggerInfinite) {\n        void setSize(numberOrgFn);\n        return;\n      }\n      return setPaginatedPage(numberOrgFn);\n    },\n    [setSize]\n  );\n  const data = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(() => {\n    var _a2, _b2;\n    if (triggerInfinite) {\n      return (_a2 = swrInfiniteData == null ? void 0 : swrInfiniteData.map((a) => a == null ? void 0 : a.data).flat()) != null ? _a2 : [];\n    }\n    return (_b2 = swrData == null ? void 0 : swrData.data) != null ? _b2 : [];\n  }, [triggerInfinite, swrData, swrInfiniteData]);\n  const count = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(() => {\n    var _a2, _b2;\n    if (triggerInfinite) {\n      return ((_a2 = swrInfiniteData == null ? void 0 : swrInfiniteData[(swrInfiniteData == null ? void 0 : swrInfiniteData.length) - 1]) == null ? void 0 : _a2.total_count) || 0;\n    }\n    return (_b2 = swrData == null ? void 0 : swrData.total_count) != null ? _b2 : 0;\n  }, [triggerInfinite, swrData, swrInfiniteData]);\n  const isLoading = triggerInfinite ? swrInfiniteIsLoading : swrIsLoading;\n  const isFetching = triggerInfinite ? swrInfiniteIsValidating : swrIsValidating;\n  const error = (_g = triggerInfinite ? swrInfiniteError : swrError) != null ? _g : null;\n  const isError = !!error;\n  const fetchNext = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(() => {\n    fetchPage((n) => Math.max(0, n + 1));\n  }, [fetchPage]);\n  const fetchPrevious = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(() => {\n    fetchPage((n) => Math.max(0, n - 1));\n  }, [fetchPage]);\n  const offsetCount = (initialPageRef.current - 1) * pageSizeRef.current;\n  const pageCount = Math.ceil((count - offsetCount) / pageSizeRef.current);\n  const hasNextPage = count - offsetCount * pageSizeRef.current > page * pageSizeRef.current;\n  const hasPreviousPage = (page - 1) * pageSizeRef.current > offsetCount * pageSizeRef.current;\n  const setData = triggerInfinite ? (value) => swrInfiniteMutate(value, {\n    revalidate: false\n  }) : (value) => swrMutate(value, {\n    revalidate: false\n  });\n  const revalidate = triggerInfinite ? () => swrInfiniteMutate() : () => swrMutate();\n  return {\n    data,\n    count,\n    error,\n    isLoading,\n    isFetching,\n    isError,\n    page,\n    pageCount,\n    fetchPage,\n    fetchNext,\n    fetchPrevious,\n    hasNextPage,\n    hasPreviousPage,\n    // Let the hook return type define this type\n    revalidate,\n    // Let the hook return type define this type\n    setData\n  };\n};\n\n// src/react/hooks/useOrganization.tsx\nvar undefinedPaginatedResource = {\n  data: void 0,\n  count: void 0,\n  error: void 0,\n  isLoading: false,\n  isFetching: false,\n  isError: false,\n  page: void 0,\n  pageCount: void 0,\n  fetchPage: void 0,\n  fetchNext: void 0,\n  fetchPrevious: void 0,\n  hasNextPage: false,\n  hasPreviousPage: false,\n  revalidate: void 0,\n  setData: void 0\n};\nvar useOrganization = (params) => {\n  var _a;\n  const {\n    domains: domainListParams,\n    membershipRequests: membershipRequestsListParams,\n    memberships: membersListParams,\n    invitations: invitationsListParams\n  } = params || {};\n  useAssertWrappedByClerkProvider(\"useOrganization\");\n  const { organization } = useOrganizationContext();\n  const session = useSessionContext();\n  const domainSafeValues = useWithSafeValues(domainListParams, {\n    initialPage: 1,\n    pageSize: 10,\n    keepPreviousData: false,\n    infinite: false,\n    enrollmentMode: void 0\n  });\n  const membershipRequestSafeValues = useWithSafeValues(membershipRequestsListParams, {\n    initialPage: 1,\n    pageSize: 10,\n    status: \"pending\",\n    keepPreviousData: false,\n    infinite: false\n  });\n  const membersSafeValues = useWithSafeValues(membersListParams, {\n    initialPage: 1,\n    pageSize: 10,\n    role: void 0,\n    keepPreviousData: false,\n    infinite: false\n  });\n  const invitationsSafeValues = useWithSafeValues(invitationsListParams, {\n    initialPage: 1,\n    pageSize: 10,\n    status: [\"pending\"],\n    keepPreviousData: false,\n    infinite: false\n  });\n  const clerk = useClerkInstanceContext();\n  (_a = clerk.telemetry) == null ? void 0 : _a.record((0,_chunk_TUVJ3GI6_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled)(\"useOrganization\"));\n  const domainParams = typeof domainListParams === \"undefined\" ? void 0 : {\n    initialPage: domainSafeValues.initialPage,\n    pageSize: domainSafeValues.pageSize,\n    enrollmentMode: domainSafeValues.enrollmentMode\n  };\n  const membershipRequestParams = typeof membershipRequestsListParams === \"undefined\" ? void 0 : {\n    initialPage: membershipRequestSafeValues.initialPage,\n    pageSize: membershipRequestSafeValues.pageSize,\n    status: membershipRequestSafeValues.status\n  };\n  const membersParams = typeof membersListParams === \"undefined\" ? void 0 : {\n    initialPage: membersSafeValues.initialPage,\n    pageSize: membersSafeValues.pageSize,\n    role: membersSafeValues.role\n  };\n  const invitationsParams = typeof invitationsListParams === \"undefined\" ? void 0 : {\n    initialPage: invitationsSafeValues.initialPage,\n    pageSize: invitationsSafeValues.pageSize,\n    status: invitationsSafeValues.status\n  };\n  const domains = usePagesOrInfinite(\n    {\n      ...domainParams\n    },\n    organization == null ? void 0 : organization.getDomains,\n    {\n      keepPreviousData: domainSafeValues.keepPreviousData,\n      infinite: domainSafeValues.infinite,\n      enabled: !!domainParams\n    },\n    {\n      type: \"domains\",\n      organizationId: organization == null ? void 0 : organization.id\n    }\n  );\n  const membershipRequests = usePagesOrInfinite(\n    {\n      ...membershipRequestParams\n    },\n    organization == null ? void 0 : organization.getMembershipRequests,\n    {\n      keepPreviousData: membershipRequestSafeValues.keepPreviousData,\n      infinite: membershipRequestSafeValues.infinite,\n      enabled: !!membershipRequestParams\n    },\n    {\n      type: \"membershipRequests\",\n      organizationId: organization == null ? void 0 : organization.id\n    }\n  );\n  const memberships = usePagesOrInfinite(\n    membersParams || {},\n    organization == null ? void 0 : organization.getMemberships,\n    {\n      keepPreviousData: membersSafeValues.keepPreviousData,\n      infinite: membersSafeValues.infinite,\n      enabled: !!membersParams\n    },\n    {\n      type: \"members\",\n      organizationId: organization == null ? void 0 : organization.id\n    }\n  );\n  const invitations = usePagesOrInfinite(\n    {\n      ...invitationsParams\n    },\n    organization == null ? void 0 : organization.getInvitations,\n    {\n      keepPreviousData: invitationsSafeValues.keepPreviousData,\n      infinite: invitationsSafeValues.infinite,\n      enabled: !!invitationsParams\n    },\n    {\n      type: \"invitations\",\n      organizationId: organization == null ? void 0 : organization.id\n    }\n  );\n  if (organization === void 0) {\n    return {\n      isLoaded: false,\n      organization: void 0,\n      membership: void 0,\n      domains: undefinedPaginatedResource,\n      membershipRequests: undefinedPaginatedResource,\n      memberships: undefinedPaginatedResource,\n      invitations: undefinedPaginatedResource\n    };\n  }\n  if (organization === null) {\n    return {\n      isLoaded: true,\n      organization: null,\n      membership: null,\n      domains: null,\n      membershipRequests: null,\n      memberships: null,\n      invitations: null\n    };\n  }\n  if (!clerk.loaded && organization) {\n    return {\n      isLoaded: true,\n      organization,\n      membership: void 0,\n      domains: undefinedPaginatedResource,\n      membershipRequests: undefinedPaginatedResource,\n      memberships: undefinedPaginatedResource,\n      invitations: undefinedPaginatedResource\n    };\n  }\n  return {\n    isLoaded: clerk.loaded,\n    organization,\n    membership: getCurrentOrganizationMembership(session.user.organizationMemberships, organization.id),\n    // your membership in the current org\n    domains,\n    membershipRequests,\n    memberships,\n    invitations\n  };\n};\nfunction getCurrentOrganizationMembership(organizationMemberships, activeOrganizationId) {\n  return organizationMemberships.find(\n    (organizationMembership) => organizationMembership.organization.id === activeOrganizationId\n  );\n}\n\n// src/react/hooks/useOrganizationList.tsx\nvar undefinedPaginatedResource2 = {\n  data: void 0,\n  count: void 0,\n  error: void 0,\n  isLoading: false,\n  isFetching: false,\n  isError: false,\n  page: void 0,\n  pageCount: void 0,\n  fetchPage: void 0,\n  fetchNext: void 0,\n  fetchPrevious: void 0,\n  hasNextPage: false,\n  hasPreviousPage: false,\n  revalidate: void 0,\n  setData: void 0\n};\nvar useOrganizationList = (params) => {\n  var _a;\n  const { userMemberships, userInvitations, userSuggestions } = params || {};\n  useAssertWrappedByClerkProvider(\"useOrganizationList\");\n  const userMembershipsSafeValues = useWithSafeValues(userMemberships, {\n    initialPage: 1,\n    pageSize: 10,\n    keepPreviousData: false,\n    infinite: false\n  });\n  const userInvitationsSafeValues = useWithSafeValues(userInvitations, {\n    initialPage: 1,\n    pageSize: 10,\n    status: \"pending\",\n    keepPreviousData: false,\n    infinite: false\n  });\n  const userSuggestionsSafeValues = useWithSafeValues(userSuggestions, {\n    initialPage: 1,\n    pageSize: 10,\n    status: \"pending\",\n    keepPreviousData: false,\n    infinite: false\n  });\n  const clerk = useClerkInstanceContext();\n  const user = useUserContext();\n  (_a = clerk.telemetry) == null ? void 0 : _a.record((0,_chunk_TUVJ3GI6_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled)(\"useOrganizationList\"));\n  const userMembershipsParams = typeof userMemberships === \"undefined\" ? void 0 : {\n    initialPage: userMembershipsSafeValues.initialPage,\n    pageSize: userMembershipsSafeValues.pageSize\n  };\n  const userInvitationsParams = typeof userInvitations === \"undefined\" ? void 0 : {\n    initialPage: userInvitationsSafeValues.initialPage,\n    pageSize: userInvitationsSafeValues.pageSize,\n    status: userInvitationsSafeValues.status\n  };\n  const userSuggestionsParams = typeof userSuggestions === \"undefined\" ? void 0 : {\n    initialPage: userSuggestionsSafeValues.initialPage,\n    pageSize: userSuggestionsSafeValues.pageSize,\n    status: userSuggestionsSafeValues.status\n  };\n  const isClerkLoaded = !!(clerk.loaded && user);\n  const memberships = usePagesOrInfinite(\n    userMembershipsParams || {},\n    user == null ? void 0 : user.getOrganizationMemberships,\n    {\n      keepPreviousData: userMembershipsSafeValues.keepPreviousData,\n      infinite: userMembershipsSafeValues.infinite,\n      enabled: !!userMembershipsParams\n    },\n    {\n      type: \"userMemberships\",\n      userId: user == null ? void 0 : user.id\n    }\n  );\n  const invitations = usePagesOrInfinite(\n    {\n      ...userInvitationsParams\n    },\n    user == null ? void 0 : user.getOrganizationInvitations,\n    {\n      keepPreviousData: userInvitationsSafeValues.keepPreviousData,\n      infinite: userInvitationsSafeValues.infinite,\n      enabled: !!userInvitationsParams\n    },\n    {\n      type: \"userInvitations\",\n      userId: user == null ? void 0 : user.id\n    }\n  );\n  const suggestions = usePagesOrInfinite(\n    {\n      ...userSuggestionsParams\n    },\n    user == null ? void 0 : user.getOrganizationSuggestions,\n    {\n      keepPreviousData: userSuggestionsSafeValues.keepPreviousData,\n      infinite: userSuggestionsSafeValues.infinite,\n      enabled: !!userSuggestionsParams\n    },\n    {\n      type: \"userSuggestions\",\n      userId: user == null ? void 0 : user.id\n    }\n  );\n  if (!isClerkLoaded) {\n    return {\n      isLoaded: false,\n      createOrganization: void 0,\n      setActive: void 0,\n      userMemberships: undefinedPaginatedResource2,\n      userInvitations: undefinedPaginatedResource2,\n      userSuggestions: undefinedPaginatedResource2\n    };\n  }\n  return {\n    isLoaded: isClerkLoaded,\n    setActive: clerk.setActive,\n    createOrganization: clerk.createOrganization,\n    userMemberships: memberships,\n    userInvitations: invitations,\n    userSuggestions: suggestions\n  };\n};\n\n// src/react/hooks/useSafeLayoutEffect.tsx\n\nvar useSafeLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_2__.useEffect;\n\n// src/react/hooks/useSession.ts\nvar useSession = () => {\n  useAssertWrappedByClerkProvider(\"useSession\");\n  const session = useSessionContext();\n  if (session === void 0) {\n    return { isLoaded: false, isSignedIn: void 0, session: void 0 };\n  }\n  if (session === null) {\n    return { isLoaded: true, isSignedIn: false, session: null };\n  }\n  return { isLoaded: true, isSignedIn: true, session };\n};\n\n// src/react/hooks/useSessionList.ts\nvar useSessionList = () => {\n  useAssertWrappedByClerkProvider(\"useSessionList\");\n  const isomorphicClerk = useClerkInstanceContext();\n  const client = useClientContext();\n  if (!client) {\n    return { isLoaded: false, sessions: void 0, setActive: void 0 };\n  }\n  return {\n    isLoaded: true,\n    sessions: client.sessions,\n    setActive: isomorphicClerk.setActive\n  };\n};\n\n// src/react/hooks/useUser.ts\nfunction useUser() {\n  useAssertWrappedByClerkProvider(\"useUser\");\n  const user = useUserContext();\n  if (user === void 0) {\n    return { isLoaded: false, isSignedIn: void 0, user: void 0 };\n  }\n  if (user === null) {\n    return { isLoaded: true, isSignedIn: false, user: null };\n  }\n  return { isLoaded: true, isSignedIn: true, user };\n}\n\n// src/react/hooks/useClerk.ts\nvar useClerk = () => {\n  useAssertWrappedByClerkProvider(\"useClerk\");\n  return useClerkInstanceContext();\n};\n\n// ../../node_modules/dequal/dist/index.mjs\nvar has = Object.prototype.hasOwnProperty;\nfunction find(iter, tar, key) {\n  for (key of iter.keys()) {\n    if (dequal(key, tar)) return key;\n  }\n}\nfunction dequal(foo, bar) {\n  var ctor, len, tmp;\n  if (foo === bar) return true;\n  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {\n    if (ctor === Date) return foo.getTime() === bar.getTime();\n    if (ctor === RegExp) return foo.toString() === bar.toString();\n    if (ctor === Array) {\n      if ((len = foo.length) === bar.length) {\n        while (len-- && dequal(foo[len], bar[len])) ;\n      }\n      return len === -1;\n    }\n    if (ctor === Set) {\n      if (foo.size !== bar.size) {\n        return false;\n      }\n      for (len of foo) {\n        tmp = len;\n        if (tmp && typeof tmp === \"object\") {\n          tmp = find(bar, tmp);\n          if (!tmp) return false;\n        }\n        if (!bar.has(tmp)) return false;\n      }\n      return true;\n    }\n    if (ctor === Map) {\n      if (foo.size !== bar.size) {\n        return false;\n      }\n      for (len of foo) {\n        tmp = len[0];\n        if (tmp && typeof tmp === \"object\") {\n          tmp = find(bar, tmp);\n          if (!tmp) return false;\n        }\n        if (!dequal(len[1], bar.get(tmp))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (ctor === ArrayBuffer) {\n      foo = new Uint8Array(foo);\n      bar = new Uint8Array(bar);\n    } else if (ctor === DataView) {\n      if ((len = foo.byteLength) === bar.byteLength) {\n        while (len-- && foo.getInt8(len) === bar.getInt8(len)) ;\n      }\n      return len === -1;\n    }\n    if (ArrayBuffer.isView(foo)) {\n      if ((len = foo.byteLength) === bar.byteLength) {\n        while (len-- && foo[len] === bar[len]) ;\n      }\n      return len === -1;\n    }\n    if (!ctor || typeof foo === \"object\") {\n      len = 0;\n      for (ctor in foo) {\n        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n      }\n      return Object.keys(bar).length === len;\n    }\n  }\n  return foo !== foo && bar !== bar;\n}\n\n// src/react/hooks/useDeepEqualMemo.ts\n\nvar useDeepEqualMemoize = (value) => {\n  const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(value);\n  if (!dequal(value, ref.current)) {\n    ref.current = value;\n  }\n  return react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ref.current, [ref.current]);\n};\nvar useDeepEqualMemo = (factory, dependencyArray) => {\n  return react__WEBPACK_IMPORTED_MODULE_2__.useMemo(factory, useDeepEqualMemoize(dependencyArray));\n};\nvar isDeeplyEqual = dequal;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvcmVhY3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRStCO0FBSUE7O0FBRS9CO0FBQzBCO0FBQzFCO0FBQ0E7QUFDQSw0RUFBNEUsc0JBQXNCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0NBQW9DO0FBQzlDLGNBQWMsZ0RBQW1CO0FBQ2pDO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQWdCO0FBQ2hDLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkI7O0FBRTNCO0FBQ0E7QUFDQSw2REFBUTtBQUNSLG1CQUFtQiwwQ0FBUztBQUM1QixnQkFBZ0IsMkNBQVE7QUFDeEIsd0JBQXdCLG9EQUFRO0FBQ2hDLENBQUM7QUFDRCwrREFBVSxvQkFBb0IsZ0NBQVE7QUFDTjtBQUNxQjtBQUNGOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnREFBb0IsR0FBRztBQUM1QztBQUNBLGtCQUFrQiw2Q0FBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCLGdEQUFvQixDQUFDLDBDQUFTLElBQUksa0JBQWtCLGtCQUFrQixnREFBb0I7QUFDbkg7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2Q0FBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQytEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZDQUFNO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsK0NBQVE7QUFDcEQseUJBQXlCLDZDQUFNO0FBQy9CLHNCQUFzQiw2Q0FBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsK0NBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLHdEQUFRO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLDhDQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9CQUFvQixrREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsOENBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQkFBZ0IsOENBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBVztBQUMvQjtBQUNBLEdBQUc7QUFDSCx3QkFBd0Isa0RBQVc7QUFDbkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNEQUFzRCxzRUFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFvRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0RBQXNELHNFQUFpQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCLDBEQUEwRCxrREFBc0IsR0FBRyw0Q0FBZ0I7O0FBRW5HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQSxjQUFjLHlDQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMENBQWM7QUFDdkI7QUFDQTtBQUNBLFNBQVMsMENBQWM7QUFDdkI7QUFDQTtBQTBCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvcmVhY3QvaW5kZXgubWpzPzdkN2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZXZlbnRNZXRob2RDYWxsZWRcbn0gZnJvbSBcIi4uL2NodW5rLVRVVkozR0k2Lm1qc1wiO1xuaW1wb3J0IHtcbiAgX19leHBvcnQsXG4gIF9fcmVFeHBvcnRcbn0gZnJvbSBcIi4uL2NodW5rLTdFTFQ3NTVRLm1qc1wiO1xuXG4vLyBzcmMvcmVhY3QvaG9va3MvY3JlYXRlQ29udGV4dEFuZEhvb2sudHNcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIGFzc2VydENvbnRleHRFeGlzdHMoY29udGV4dFZhbCwgbXNnT3JDdHgpIHtcbiAgaWYgKCFjb250ZXh0VmFsKSB7XG4gICAgdGhyb3cgdHlwZW9mIG1zZ09yQ3R4ID09PSBcInN0cmluZ1wiID8gbmV3IEVycm9yKG1zZ09yQ3R4KSA6IG5ldyBFcnJvcihgJHttc2dPckN0eC5kaXNwbGF5TmFtZX0gbm90IGZvdW5kYCk7XG4gIH1cbn1cbnZhciBjcmVhdGVDb250ZXh0QW5kSG9vayA9IChkaXNwbGF5TmFtZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7IGFzc2VydEN0eEZuID0gYXNzZXJ0Q29udGV4dEV4aXN0cyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgQ3R4ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuICBDdHguZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgY29uc3QgdXNlQ3R4ID0gKCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ3R4KTtcbiAgICBhc3NlcnRDdHhGbihjdHgsIGAke2Rpc3BsYXlOYW1lfSBub3QgZm91bmRgKTtcbiAgICByZXR1cm4gY3R4LnZhbHVlO1xuICB9O1xuICBjb25zdCB1c2VDdHhXaXRob3V0R3VhcmFudGVlID0gKCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ3R4KTtcbiAgICByZXR1cm4gY3R4ID8gY3R4LnZhbHVlIDoge307XG4gIH07XG4gIHJldHVybiBbQ3R4LCB1c2VDdHgsIHVzZUN0eFdpdGhvdXRHdWFyYW50ZWVdO1xufTtcblxuLy8gc3JjL3JlYWN0L2NvbnRleHRzLnRzeFxuaW1wb3J0IFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3JlYWN0L2NsZXJrLXN3ci50c1xudmFyIGNsZXJrX3N3cl9leHBvcnRzID0ge307XG5fX2V4cG9ydChjbGVya19zd3JfZXhwb3J0cywge1xuICBTV1JDb25maWc6ICgpID0+IFNXUkNvbmZpZyxcbiAgdXNlU1dSOiAoKSA9PiBkZWZhdWx0MixcbiAgdXNlU1dSSW5maW5pdGU6ICgpID0+IGRlZmF1bHQzXG59KTtcbl9fcmVFeHBvcnQoY2xlcmtfc3dyX2V4cG9ydHMsIHN3cl9zdGFyKTtcbmltcG9ydCAqIGFzIHN3cl9zdGFyIGZyb20gXCJzd3JcIjtcbmltcG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdDIsIFNXUkNvbmZpZyB9IGZyb20gXCJzd3JcIjtcbmltcG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdDMgfSBmcm9tIFwic3dyL2luZmluaXRlXCI7XG5cbi8vIHNyYy9yZWFjdC9jb250ZXh0cy50c3hcbnZhciBbQ2xlcmtJbnN0YW5jZUNvbnRleHQsIHVzZUNsZXJrSW5zdGFuY2VDb250ZXh0XSA9IGNyZWF0ZUNvbnRleHRBbmRIb29rKFwiQ2xlcmtJbnN0YW5jZUNvbnRleHRcIik7XG52YXIgW1VzZXJDb250ZXh0LCB1c2VVc2VyQ29udGV4dF0gPSBjcmVhdGVDb250ZXh0QW5kSG9vayhcIlVzZXJDb250ZXh0XCIpO1xudmFyIFtDbGllbnRDb250ZXh0LCB1c2VDbGllbnRDb250ZXh0XSA9IGNyZWF0ZUNvbnRleHRBbmRIb29rKFwiQ2xpZW50Q29udGV4dFwiKTtcbnZhciBbU2Vzc2lvbkNvbnRleHQsIHVzZVNlc3Npb25Db250ZXh0XSA9IGNyZWF0ZUNvbnRleHRBbmRIb29rKFxuICBcIlNlc3Npb25Db250ZXh0XCJcbik7XG52YXIgT3B0aW9uc0NvbnRleHQgPSBSZWFjdDIuY3JlYXRlQ29udGV4dCh7fSk7XG5mdW5jdGlvbiB1c2VPcHRpb25zQ29udGV4dCgpIHtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0Mi51c2VDb250ZXh0KE9wdGlvbnNDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZU9wdGlvbnMgbXVzdCBiZSB1c2VkIHdpdGhpbiBhbiBPcHRpb25zQ29udGV4dFwiKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbnZhciBbT3JnYW5pemF0aW9uQ29udGV4dEludGVybmFsLCB1c2VPcmdhbml6YXRpb25Db250ZXh0XSA9IGNyZWF0ZUNvbnRleHRBbmRIb29rKFwiT3JnYW5pemF0aW9uQ29udGV4dFwiKTtcbnZhciBPcmdhbml6YXRpb25Qcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBvcmdhbml6YXRpb24sXG4gIHN3ckNvbmZpZ1xufSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFNXUkNvbmZpZywgeyB2YWx1ZTogc3dyQ29uZmlnIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICBPcmdhbml6YXRpb25Db250ZXh0SW50ZXJuYWwuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdmFsdWU6IHsgb3JnYW5pemF0aW9uIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICkpO1xufTtcbmZ1bmN0aW9uIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoZGlzcGxheU5hbWVPckZuKSB7XG4gIGNvbnN0IGN0eCA9IFJlYWN0Mi51c2VDb250ZXh0KENsZXJrSW5zdGFuY2VDb250ZXh0KTtcbiAgaWYgKCFjdHgpIHtcbiAgICBpZiAodHlwZW9mIGRpc3BsYXlOYW1lT3JGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBkaXNwbGF5TmFtZU9yRm4oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCR7ZGlzcGxheU5hbWVPckZufSBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgPENsZXJrUHJvdmlkZXIgLz4gY29tcG9uZW50LiBMZWFybiBtb3JlOiBodHRwczovL2NsZXJrLmNvbS9kb2NzL2NvbXBvbmVudHMvY2xlcmstcHJvdmlkZXJgXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvcmVhY3QvaG9va3MvdXNlUGFnZXNPckluZmluaXRlLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gZ2V0RGlmZmVyZW50S2V5cyhvYmoxLCBvYmoyKSB7XG4gIGNvbnN0IGtleXNTZXQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKG9iajIpKTtcbiAgY29uc3QgZGlmZmVyZW50S2V5c09iamVjdCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleTEgb2YgT2JqZWN0LmtleXMob2JqMSkpIHtcbiAgICBpZiAoIWtleXNTZXQuaGFzKGtleTEpKSB7XG4gICAgICBkaWZmZXJlbnRLZXlzT2JqZWN0W2tleTFdID0gb2JqMVtrZXkxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmZlcmVudEtleXNPYmplY3Q7XG59XG52YXIgdXNlV2l0aFNhZmVWYWx1ZXMgPSAocGFyYW1zLCBkZWZhdWx0VmFsdWVzKSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBzaG91bGRVc2VEZWZhdWx0cyA9IHR5cGVvZiBwYXJhbXMgPT09IFwiYm9vbGVhblwiICYmIHBhcmFtcztcbiAgY29uc3QgaW5pdGlhbFBhZ2VSZWYgPSB1c2VSZWYoXG4gICAgc2hvdWxkVXNlRGVmYXVsdHMgPyBkZWZhdWx0VmFsdWVzLmluaXRpYWxQYWdlIDogKF9hID0gcGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMuaW5pdGlhbFBhZ2UpICE9IG51bGwgPyBfYSA6IGRlZmF1bHRWYWx1ZXMuaW5pdGlhbFBhZ2VcbiAgKTtcbiAgY29uc3QgcGFnZVNpemVSZWYgPSB1c2VSZWYoc2hvdWxkVXNlRGVmYXVsdHMgPyBkZWZhdWx0VmFsdWVzLnBhZ2VTaXplIDogKF9iID0gcGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMucGFnZVNpemUpICE9IG51bGwgPyBfYiA6IGRlZmF1bHRWYWx1ZXMucGFnZVNpemUpO1xuICBjb25zdCBuZXdPYmogPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZGVmYXVsdFZhbHVlcykpIHtcbiAgICBuZXdPYmpba2V5XSA9IHNob3VsZFVzZURlZmF1bHRzID8gZGVmYXVsdFZhbHVlc1trZXldIDogKF9jID0gcGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXNba2V5XSkgIT0gbnVsbCA/IF9jIDogZGVmYXVsdFZhbHVlc1trZXldO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4ubmV3T2JqLFxuICAgIGluaXRpYWxQYWdlOiBpbml0aWFsUGFnZVJlZi5jdXJyZW50LFxuICAgIHBhZ2VTaXplOiBwYWdlU2l6ZVJlZi5jdXJyZW50XG4gIH07XG59O1xudmFyIGNhY2hpbmdTV1JPcHRpb25zID0ge1xuICBkZWR1cGluZ0ludGVydmFsOiAxZTMgKiA2MCxcbiAgZm9jdXNUaHJvdHRsZUludGVydmFsOiAxZTMgKiA2MCAqIDJcbn07XG52YXIgdXNlUGFnZXNPckluZmluaXRlID0gKHBhcmFtcywgZmV0Y2hlciwgY29uZmlnLCBjYWNoZUtleXMpID0+IHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICBjb25zdCBbcGFnaW5hdGVkUGFnZSwgc2V0UGFnaW5hdGVkUGFnZV0gPSB1c2VTdGF0ZSgoX2EgPSBwYXJhbXMuaW5pdGlhbFBhZ2UpICE9IG51bGwgPyBfYSA6IDEpO1xuICBjb25zdCBpbml0aWFsUGFnZVJlZiA9IHVzZVJlZigoX2IgPSBwYXJhbXMuaW5pdGlhbFBhZ2UpICE9IG51bGwgPyBfYiA6IDEpO1xuICBjb25zdCBwYWdlU2l6ZVJlZiA9IHVzZVJlZigoX2MgPSBwYXJhbXMucGFnZVNpemUpICE9IG51bGwgPyBfYyA6IDEwKTtcbiAgY29uc3QgZW5hYmxlZCA9IChfZCA9IGNvbmZpZy5lbmFibGVkKSAhPSBudWxsID8gX2QgOiB0cnVlO1xuICBjb25zdCB0cmlnZ2VySW5maW5pdGUgPSAoX2UgPSBjb25maWcuaW5maW5pdGUpICE9IG51bGwgPyBfZSA6IGZhbHNlO1xuICBjb25zdCBrZWVwUHJldmlvdXNEYXRhID0gKF9mID0gY29uZmlnLmtlZXBQcmV2aW91c0RhdGEpICE9IG51bGwgPyBfZiA6IGZhbHNlO1xuICBjb25zdCBwYWdlc0NhY2hlS2V5ID0ge1xuICAgIC4uLmNhY2hlS2V5cyxcbiAgICAuLi5wYXJhbXMsXG4gICAgaW5pdGlhbFBhZ2U6IHBhZ2luYXRlZFBhZ2UsXG4gICAgcGFnZVNpemU6IHBhZ2VTaXplUmVmLmN1cnJlbnRcbiAgfTtcbiAgY29uc3Qge1xuICAgIGRhdGE6IHN3ckRhdGEsXG4gICAgaXNWYWxpZGF0aW5nOiBzd3JJc1ZhbGlkYXRpbmcsXG4gICAgaXNMb2FkaW5nOiBzd3JJc0xvYWRpbmcsXG4gICAgZXJyb3I6IHN3ckVycm9yLFxuICAgIG11dGF0ZTogc3dyTXV0YXRlXG4gIH0gPSBkZWZhdWx0MihcbiAgICAhdHJpZ2dlckluZmluaXRlICYmICEhZmV0Y2hlciAmJiBlbmFibGVkID8gcGFnZXNDYWNoZUtleSA6IG51bGwsXG4gICAgKGNhY2hlS2V5UGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gZ2V0RGlmZmVyZW50S2V5cyhjYWNoZUtleVBhcmFtcywgY2FjaGVLZXlzKTtcbiAgICAgIHJldHVybiBmZXRjaGVyID09IG51bGwgPyB2b2lkIDAgOiBmZXRjaGVyKHJlcXVlc3RQYXJhbXMpO1xuICAgIH0sXG4gICAgeyBrZWVwUHJldmlvdXNEYXRhLCAuLi5jYWNoaW5nU1dST3B0aW9ucyB9XG4gICk7XG4gIGNvbnN0IHtcbiAgICBkYXRhOiBzd3JJbmZpbml0ZURhdGEsXG4gICAgaXNMb2FkaW5nOiBzd3JJbmZpbml0ZUlzTG9hZGluZyxcbiAgICBpc1ZhbGlkYXRpbmc6IHN3ckluZmluaXRlSXNWYWxpZGF0aW5nLFxuICAgIGVycm9yOiBzd3JJbmZpbml0ZUVycm9yLFxuICAgIHNpemUsXG4gICAgc2V0U2l6ZSxcbiAgICBtdXRhdGU6IHN3ckluZmluaXRlTXV0YXRlXG4gIH0gPSBkZWZhdWx0MyhcbiAgICAocGFnZUluZGV4KSA9PiB7XG4gICAgICBpZiAoIXRyaWdnZXJJbmZpbml0ZSB8fCAhZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgLi4uY2FjaGVLZXlzLFxuICAgICAgICBpbml0aWFsUGFnZTogaW5pdGlhbFBhZ2VSZWYuY3VycmVudCArIHBhZ2VJbmRleCxcbiAgICAgICAgcGFnZVNpemU6IHBhZ2VTaXplUmVmLmN1cnJlbnRcbiAgICAgIH07XG4gICAgfSxcbiAgICAoY2FjaGVLZXlQYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBnZXREaWZmZXJlbnRLZXlzKGNhY2hlS2V5UGFyYW1zLCBjYWNoZUtleXMpO1xuICAgICAgcmV0dXJuIGZldGNoZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGZldGNoZXIocmVxdWVzdFBhcmFtcyk7XG4gICAgfSxcbiAgICBjYWNoaW5nU1dST3B0aW9uc1xuICApO1xuICBjb25zdCBwYWdlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHRyaWdnZXJJbmZpbml0ZSkge1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIHJldHVybiBwYWdpbmF0ZWRQYWdlO1xuICB9LCBbdHJpZ2dlckluZmluaXRlLCBzaXplLCBwYWdpbmF0ZWRQYWdlXSk7XG4gIGNvbnN0IGZldGNoUGFnZSA9IHVzZUNhbGxiYWNrKFxuICAgIChudW1iZXJPcmdGbikgPT4ge1xuICAgICAgaWYgKHRyaWdnZXJJbmZpbml0ZSkge1xuICAgICAgICB2b2lkIHNldFNpemUobnVtYmVyT3JnRm4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0UGFnaW5hdGVkUGFnZShudW1iZXJPcmdGbik7XG4gICAgfSxcbiAgICBbc2V0U2l6ZV1cbiAgKTtcbiAgY29uc3QgZGF0YSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfYTIsIF9iMjtcbiAgICBpZiAodHJpZ2dlckluZmluaXRlKSB7XG4gICAgICByZXR1cm4gKF9hMiA9IHN3ckluZmluaXRlRGF0YSA9PSBudWxsID8gdm9pZCAwIDogc3dySW5maW5pdGVEYXRhLm1hcCgoYSkgPT4gYSA9PSBudWxsID8gdm9pZCAwIDogYS5kYXRhKS5mbGF0KCkpICE9IG51bGwgPyBfYTIgOiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIChfYjIgPSBzd3JEYXRhID09IG51bGwgPyB2b2lkIDAgOiBzd3JEYXRhLmRhdGEpICE9IG51bGwgPyBfYjIgOiBbXTtcbiAgfSwgW3RyaWdnZXJJbmZpbml0ZSwgc3dyRGF0YSwgc3dySW5maW5pdGVEYXRhXSk7XG4gIGNvbnN0IGNvdW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9hMiwgX2IyO1xuICAgIGlmICh0cmlnZ2VySW5maW5pdGUpIHtcbiAgICAgIHJldHVybiAoKF9hMiA9IHN3ckluZmluaXRlRGF0YSA9PSBudWxsID8gdm9pZCAwIDogc3dySW5maW5pdGVEYXRhWyhzd3JJbmZpbml0ZURhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHN3ckluZmluaXRlRGF0YS5sZW5ndGgpIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG90YWxfY291bnQpIHx8IDA7XG4gICAgfVxuICAgIHJldHVybiAoX2IyID0gc3dyRGF0YSA9PSBudWxsID8gdm9pZCAwIDogc3dyRGF0YS50b3RhbF9jb3VudCkgIT0gbnVsbCA/IF9iMiA6IDA7XG4gIH0sIFt0cmlnZ2VySW5maW5pdGUsIHN3ckRhdGEsIHN3ckluZmluaXRlRGF0YV0pO1xuICBjb25zdCBpc0xvYWRpbmcgPSB0cmlnZ2VySW5maW5pdGUgPyBzd3JJbmZpbml0ZUlzTG9hZGluZyA6IHN3cklzTG9hZGluZztcbiAgY29uc3QgaXNGZXRjaGluZyA9IHRyaWdnZXJJbmZpbml0ZSA/IHN3ckluZmluaXRlSXNWYWxpZGF0aW5nIDogc3dySXNWYWxpZGF0aW5nO1xuICBjb25zdCBlcnJvciA9IChfZyA9IHRyaWdnZXJJbmZpbml0ZSA/IHN3ckluZmluaXRlRXJyb3IgOiBzd3JFcnJvcikgIT0gbnVsbCA/IF9nIDogbnVsbDtcbiAgY29uc3QgaXNFcnJvciA9ICEhZXJyb3I7XG4gIGNvbnN0IGZldGNoTmV4dCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBmZXRjaFBhZ2UoKG4pID0+IE1hdGgubWF4KDAsIG4gKyAxKSk7XG4gIH0sIFtmZXRjaFBhZ2VdKTtcbiAgY29uc3QgZmV0Y2hQcmV2aW91cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBmZXRjaFBhZ2UoKG4pID0+IE1hdGgubWF4KDAsIG4gLSAxKSk7XG4gIH0sIFtmZXRjaFBhZ2VdKTtcbiAgY29uc3Qgb2Zmc2V0Q291bnQgPSAoaW5pdGlhbFBhZ2VSZWYuY3VycmVudCAtIDEpICogcGFnZVNpemVSZWYuY3VycmVudDtcbiAgY29uc3QgcGFnZUNvdW50ID0gTWF0aC5jZWlsKChjb3VudCAtIG9mZnNldENvdW50KSAvIHBhZ2VTaXplUmVmLmN1cnJlbnQpO1xuICBjb25zdCBoYXNOZXh0UGFnZSA9IGNvdW50IC0gb2Zmc2V0Q291bnQgKiBwYWdlU2l6ZVJlZi5jdXJyZW50ID4gcGFnZSAqIHBhZ2VTaXplUmVmLmN1cnJlbnQ7XG4gIGNvbnN0IGhhc1ByZXZpb3VzUGFnZSA9IChwYWdlIC0gMSkgKiBwYWdlU2l6ZVJlZi5jdXJyZW50ID4gb2Zmc2V0Q291bnQgKiBwYWdlU2l6ZVJlZi5jdXJyZW50O1xuICBjb25zdCBzZXREYXRhID0gdHJpZ2dlckluZmluaXRlID8gKHZhbHVlKSA9PiBzd3JJbmZpbml0ZU11dGF0ZSh2YWx1ZSwge1xuICAgIHJldmFsaWRhdGU6IGZhbHNlXG4gIH0pIDogKHZhbHVlKSA9PiBzd3JNdXRhdGUodmFsdWUsIHtcbiAgICByZXZhbGlkYXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgcmV2YWxpZGF0ZSA9IHRyaWdnZXJJbmZpbml0ZSA/ICgpID0+IHN3ckluZmluaXRlTXV0YXRlKCkgOiAoKSA9PiBzd3JNdXRhdGUoKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIGNvdW50LFxuICAgIGVycm9yLFxuICAgIGlzTG9hZGluZyxcbiAgICBpc0ZldGNoaW5nLFxuICAgIGlzRXJyb3IsXG4gICAgcGFnZSxcbiAgICBwYWdlQ291bnQsXG4gICAgZmV0Y2hQYWdlLFxuICAgIGZldGNoTmV4dCxcbiAgICBmZXRjaFByZXZpb3VzLFxuICAgIGhhc05leHRQYWdlLFxuICAgIGhhc1ByZXZpb3VzUGFnZSxcbiAgICAvLyBMZXQgdGhlIGhvb2sgcmV0dXJuIHR5cGUgZGVmaW5lIHRoaXMgdHlwZVxuICAgIHJldmFsaWRhdGUsXG4gICAgLy8gTGV0IHRoZSBob29rIHJldHVybiB0eXBlIGRlZmluZSB0aGlzIHR5cGVcbiAgICBzZXREYXRhXG4gIH07XG59O1xuXG4vLyBzcmMvcmVhY3QvaG9va3MvdXNlT3JnYW5pemF0aW9uLnRzeFxudmFyIHVuZGVmaW5lZFBhZ2luYXRlZFJlc291cmNlID0ge1xuICBkYXRhOiB2b2lkIDAsXG4gIGNvdW50OiB2b2lkIDAsXG4gIGVycm9yOiB2b2lkIDAsXG4gIGlzTG9hZGluZzogZmFsc2UsXG4gIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICBpc0Vycm9yOiBmYWxzZSxcbiAgcGFnZTogdm9pZCAwLFxuICBwYWdlQ291bnQ6IHZvaWQgMCxcbiAgZmV0Y2hQYWdlOiB2b2lkIDAsXG4gIGZldGNoTmV4dDogdm9pZCAwLFxuICBmZXRjaFByZXZpb3VzOiB2b2lkIDAsXG4gIGhhc05leHRQYWdlOiBmYWxzZSxcbiAgaGFzUHJldmlvdXNQYWdlOiBmYWxzZSxcbiAgcmV2YWxpZGF0ZTogdm9pZCAwLFxuICBzZXREYXRhOiB2b2lkIDBcbn07XG52YXIgdXNlT3JnYW5pemF0aW9uID0gKHBhcmFtcykgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBkb21haW5zOiBkb21haW5MaXN0UGFyYW1zLFxuICAgIG1lbWJlcnNoaXBSZXF1ZXN0czogbWVtYmVyc2hpcFJlcXVlc3RzTGlzdFBhcmFtcyxcbiAgICBtZW1iZXJzaGlwczogbWVtYmVyc0xpc3RQYXJhbXMsXG4gICAgaW52aXRhdGlvbnM6IGludml0YXRpb25zTGlzdFBhcmFtc1xuICB9ID0gcGFyYW1zIHx8IHt9O1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKFwidXNlT3JnYW5pemF0aW9uXCIpO1xuICBjb25zdCB7IG9yZ2FuaXphdGlvbiB9ID0gdXNlT3JnYW5pemF0aW9uQ29udGV4dCgpO1xuICBjb25zdCBzZXNzaW9uID0gdXNlU2Vzc2lvbkNvbnRleHQoKTtcbiAgY29uc3QgZG9tYWluU2FmZVZhbHVlcyA9IHVzZVdpdGhTYWZlVmFsdWVzKGRvbWFpbkxpc3RQYXJhbXMsIHtcbiAgICBpbml0aWFsUGFnZTogMSxcbiAgICBwYWdlU2l6ZTogMTAsXG4gICAga2VlcFByZXZpb3VzRGF0YTogZmFsc2UsXG4gICAgaW5maW5pdGU6IGZhbHNlLFxuICAgIGVucm9sbG1lbnRNb2RlOiB2b2lkIDBcbiAgfSk7XG4gIGNvbnN0IG1lbWJlcnNoaXBSZXF1ZXN0U2FmZVZhbHVlcyA9IHVzZVdpdGhTYWZlVmFsdWVzKG1lbWJlcnNoaXBSZXF1ZXN0c0xpc3RQYXJhbXMsIHtcbiAgICBpbml0aWFsUGFnZTogMSxcbiAgICBwYWdlU2l6ZTogMTAsXG4gICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICBrZWVwUHJldmlvdXNEYXRhOiBmYWxzZSxcbiAgICBpbmZpbml0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IG1lbWJlcnNTYWZlVmFsdWVzID0gdXNlV2l0aFNhZmVWYWx1ZXMobWVtYmVyc0xpc3RQYXJhbXMsIHtcbiAgICBpbml0aWFsUGFnZTogMSxcbiAgICBwYWdlU2l6ZTogMTAsXG4gICAgcm9sZTogdm9pZCAwLFxuICAgIGtlZXBQcmV2aW91c0RhdGE6IGZhbHNlLFxuICAgIGluZmluaXRlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgaW52aXRhdGlvbnNTYWZlVmFsdWVzID0gdXNlV2l0aFNhZmVWYWx1ZXMoaW52aXRhdGlvbnNMaXN0UGFyYW1zLCB7XG4gICAgaW5pdGlhbFBhZ2U6IDEsXG4gICAgcGFnZVNpemU6IDEwLFxuICAgIHN0YXR1czogW1wicGVuZGluZ1wiXSxcbiAgICBrZWVwUHJldmlvdXNEYXRhOiBmYWxzZSxcbiAgICBpbmZpbml0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGNsZXJrID0gdXNlQ2xlcmtJbnN0YW5jZUNvbnRleHQoKTtcbiAgKF9hID0gY2xlcmsudGVsZW1ldHJ5KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVjb3JkKGV2ZW50TWV0aG9kQ2FsbGVkKFwidXNlT3JnYW5pemF0aW9uXCIpKTtcbiAgY29uc3QgZG9tYWluUGFyYW1zID0gdHlwZW9mIGRvbWFpbkxpc3RQYXJhbXMgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiB7XG4gICAgaW5pdGlhbFBhZ2U6IGRvbWFpblNhZmVWYWx1ZXMuaW5pdGlhbFBhZ2UsXG4gICAgcGFnZVNpemU6IGRvbWFpblNhZmVWYWx1ZXMucGFnZVNpemUsXG4gICAgZW5yb2xsbWVudE1vZGU6IGRvbWFpblNhZmVWYWx1ZXMuZW5yb2xsbWVudE1vZGVcbiAgfTtcbiAgY29uc3QgbWVtYmVyc2hpcFJlcXVlc3RQYXJhbXMgPSB0eXBlb2YgbWVtYmVyc2hpcFJlcXVlc3RzTGlzdFBhcmFtcyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHtcbiAgICBpbml0aWFsUGFnZTogbWVtYmVyc2hpcFJlcXVlc3RTYWZlVmFsdWVzLmluaXRpYWxQYWdlLFxuICAgIHBhZ2VTaXplOiBtZW1iZXJzaGlwUmVxdWVzdFNhZmVWYWx1ZXMucGFnZVNpemUsXG4gICAgc3RhdHVzOiBtZW1iZXJzaGlwUmVxdWVzdFNhZmVWYWx1ZXMuc3RhdHVzXG4gIH07XG4gIGNvbnN0IG1lbWJlcnNQYXJhbXMgPSB0eXBlb2YgbWVtYmVyc0xpc3RQYXJhbXMgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiB7XG4gICAgaW5pdGlhbFBhZ2U6IG1lbWJlcnNTYWZlVmFsdWVzLmluaXRpYWxQYWdlLFxuICAgIHBhZ2VTaXplOiBtZW1iZXJzU2FmZVZhbHVlcy5wYWdlU2l6ZSxcbiAgICByb2xlOiBtZW1iZXJzU2FmZVZhbHVlcy5yb2xlXG4gIH07XG4gIGNvbnN0IGludml0YXRpb25zUGFyYW1zID0gdHlwZW9mIGludml0YXRpb25zTGlzdFBhcmFtcyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHtcbiAgICBpbml0aWFsUGFnZTogaW52aXRhdGlvbnNTYWZlVmFsdWVzLmluaXRpYWxQYWdlLFxuICAgIHBhZ2VTaXplOiBpbnZpdGF0aW9uc1NhZmVWYWx1ZXMucGFnZVNpemUsXG4gICAgc3RhdHVzOiBpbnZpdGF0aW9uc1NhZmVWYWx1ZXMuc3RhdHVzXG4gIH07XG4gIGNvbnN0IGRvbWFpbnMgPSB1c2VQYWdlc09ySW5maW5pdGUoXG4gICAge1xuICAgICAgLi4uZG9tYWluUGFyYW1zXG4gICAgfSxcbiAgICBvcmdhbml6YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IG9yZ2FuaXphdGlvbi5nZXREb21haW5zLFxuICAgIHtcbiAgICAgIGtlZXBQcmV2aW91c0RhdGE6IGRvbWFpblNhZmVWYWx1ZXMua2VlcFByZXZpb3VzRGF0YSxcbiAgICAgIGluZmluaXRlOiBkb21haW5TYWZlVmFsdWVzLmluZmluaXRlLFxuICAgICAgZW5hYmxlZDogISFkb21haW5QYXJhbXNcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiZG9tYWluc1wiLFxuICAgICAgb3JnYW5pemF0aW9uSWQ6IG9yZ2FuaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb3JnYW5pemF0aW9uLmlkXG4gICAgfVxuICApO1xuICBjb25zdCBtZW1iZXJzaGlwUmVxdWVzdHMgPSB1c2VQYWdlc09ySW5maW5pdGUoXG4gICAge1xuICAgICAgLi4ubWVtYmVyc2hpcFJlcXVlc3RQYXJhbXNcbiAgICB9LFxuICAgIG9yZ2FuaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb3JnYW5pemF0aW9uLmdldE1lbWJlcnNoaXBSZXF1ZXN0cyxcbiAgICB7XG4gICAgICBrZWVwUHJldmlvdXNEYXRhOiBtZW1iZXJzaGlwUmVxdWVzdFNhZmVWYWx1ZXMua2VlcFByZXZpb3VzRGF0YSxcbiAgICAgIGluZmluaXRlOiBtZW1iZXJzaGlwUmVxdWVzdFNhZmVWYWx1ZXMuaW5maW5pdGUsXG4gICAgICBlbmFibGVkOiAhIW1lbWJlcnNoaXBSZXF1ZXN0UGFyYW1zXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcIm1lbWJlcnNoaXBSZXF1ZXN0c1wiLFxuICAgICAgb3JnYW5pemF0aW9uSWQ6IG9yZ2FuaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb3JnYW5pemF0aW9uLmlkXG4gICAgfVxuICApO1xuICBjb25zdCBtZW1iZXJzaGlwcyA9IHVzZVBhZ2VzT3JJbmZpbml0ZShcbiAgICBtZW1iZXJzUGFyYW1zIHx8IHt9LFxuICAgIG9yZ2FuaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb3JnYW5pemF0aW9uLmdldE1lbWJlcnNoaXBzLFxuICAgIHtcbiAgICAgIGtlZXBQcmV2aW91c0RhdGE6IG1lbWJlcnNTYWZlVmFsdWVzLmtlZXBQcmV2aW91c0RhdGEsXG4gICAgICBpbmZpbml0ZTogbWVtYmVyc1NhZmVWYWx1ZXMuaW5maW5pdGUsXG4gICAgICBlbmFibGVkOiAhIW1lbWJlcnNQYXJhbXNcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwibWVtYmVyc1wiLFxuICAgICAgb3JnYW5pemF0aW9uSWQ6IG9yZ2FuaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb3JnYW5pemF0aW9uLmlkXG4gICAgfVxuICApO1xuICBjb25zdCBpbnZpdGF0aW9ucyA9IHVzZVBhZ2VzT3JJbmZpbml0ZShcbiAgICB7XG4gICAgICAuLi5pbnZpdGF0aW9uc1BhcmFtc1xuICAgIH0sXG4gICAgb3JnYW5pemF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvcmdhbml6YXRpb24uZ2V0SW52aXRhdGlvbnMsXG4gICAge1xuICAgICAga2VlcFByZXZpb3VzRGF0YTogaW52aXRhdGlvbnNTYWZlVmFsdWVzLmtlZXBQcmV2aW91c0RhdGEsXG4gICAgICBpbmZpbml0ZTogaW52aXRhdGlvbnNTYWZlVmFsdWVzLmluZmluaXRlLFxuICAgICAgZW5hYmxlZDogISFpbnZpdGF0aW9uc1BhcmFtc1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJpbnZpdGF0aW9uc1wiLFxuICAgICAgb3JnYW5pemF0aW9uSWQ6IG9yZ2FuaXphdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb3JnYW5pemF0aW9uLmlkXG4gICAgfVxuICApO1xuICBpZiAob3JnYW5pemF0aW9uID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkZWQ6IGZhbHNlLFxuICAgICAgb3JnYW5pemF0aW9uOiB2b2lkIDAsXG4gICAgICBtZW1iZXJzaGlwOiB2b2lkIDAsXG4gICAgICBkb21haW5zOiB1bmRlZmluZWRQYWdpbmF0ZWRSZXNvdXJjZSxcbiAgICAgIG1lbWJlcnNoaXBSZXF1ZXN0czogdW5kZWZpbmVkUGFnaW5hdGVkUmVzb3VyY2UsXG4gICAgICBtZW1iZXJzaGlwczogdW5kZWZpbmVkUGFnaW5hdGVkUmVzb3VyY2UsXG4gICAgICBpbnZpdGF0aW9uczogdW5kZWZpbmVkUGFnaW5hdGVkUmVzb3VyY2VcbiAgICB9O1xuICB9XG4gIGlmIChvcmdhbml6YXRpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkZWQ6IHRydWUsXG4gICAgICBvcmdhbml6YXRpb246IG51bGwsXG4gICAgICBtZW1iZXJzaGlwOiBudWxsLFxuICAgICAgZG9tYWluczogbnVsbCxcbiAgICAgIG1lbWJlcnNoaXBSZXF1ZXN0czogbnVsbCxcbiAgICAgIG1lbWJlcnNoaXBzOiBudWxsLFxuICAgICAgaW52aXRhdGlvbnM6IG51bGxcbiAgICB9O1xuICB9XG4gIGlmICghY2xlcmsubG9hZGVkICYmIG9yZ2FuaXphdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRlZDogdHJ1ZSxcbiAgICAgIG9yZ2FuaXphdGlvbixcbiAgICAgIG1lbWJlcnNoaXA6IHZvaWQgMCxcbiAgICAgIGRvbWFpbnM6IHVuZGVmaW5lZFBhZ2luYXRlZFJlc291cmNlLFxuICAgICAgbWVtYmVyc2hpcFJlcXVlc3RzOiB1bmRlZmluZWRQYWdpbmF0ZWRSZXNvdXJjZSxcbiAgICAgIG1lbWJlcnNoaXBzOiB1bmRlZmluZWRQYWdpbmF0ZWRSZXNvdXJjZSxcbiAgICAgIGludml0YXRpb25zOiB1bmRlZmluZWRQYWdpbmF0ZWRSZXNvdXJjZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRlZDogY2xlcmsubG9hZGVkLFxuICAgIG9yZ2FuaXphdGlvbixcbiAgICBtZW1iZXJzaGlwOiBnZXRDdXJyZW50T3JnYW5pemF0aW9uTWVtYmVyc2hpcChzZXNzaW9uLnVzZXIub3JnYW5pemF0aW9uTWVtYmVyc2hpcHMsIG9yZ2FuaXphdGlvbi5pZCksXG4gICAgLy8geW91ciBtZW1iZXJzaGlwIGluIHRoZSBjdXJyZW50IG9yZ1xuICAgIGRvbWFpbnMsXG4gICAgbWVtYmVyc2hpcFJlcXVlc3RzLFxuICAgIG1lbWJlcnNoaXBzLFxuICAgIGludml0YXRpb25zXG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0Q3VycmVudE9yZ2FuaXphdGlvbk1lbWJlcnNoaXAob3JnYW5pemF0aW9uTWVtYmVyc2hpcHMsIGFjdGl2ZU9yZ2FuaXphdGlvbklkKSB7XG4gIHJldHVybiBvcmdhbml6YXRpb25NZW1iZXJzaGlwcy5maW5kKFxuICAgIChvcmdhbml6YXRpb25NZW1iZXJzaGlwKSA9PiBvcmdhbml6YXRpb25NZW1iZXJzaGlwLm9yZ2FuaXphdGlvbi5pZCA9PT0gYWN0aXZlT3JnYW5pemF0aW9uSWRcbiAgKTtcbn1cblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZU9yZ2FuaXphdGlvbkxpc3QudHN4XG52YXIgdW5kZWZpbmVkUGFnaW5hdGVkUmVzb3VyY2UyID0ge1xuICBkYXRhOiB2b2lkIDAsXG4gIGNvdW50OiB2b2lkIDAsXG4gIGVycm9yOiB2b2lkIDAsXG4gIGlzTG9hZGluZzogZmFsc2UsXG4gIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICBpc0Vycm9yOiBmYWxzZSxcbiAgcGFnZTogdm9pZCAwLFxuICBwYWdlQ291bnQ6IHZvaWQgMCxcbiAgZmV0Y2hQYWdlOiB2b2lkIDAsXG4gIGZldGNoTmV4dDogdm9pZCAwLFxuICBmZXRjaFByZXZpb3VzOiB2b2lkIDAsXG4gIGhhc05leHRQYWdlOiBmYWxzZSxcbiAgaGFzUHJldmlvdXNQYWdlOiBmYWxzZSxcbiAgcmV2YWxpZGF0ZTogdm9pZCAwLFxuICBzZXREYXRhOiB2b2lkIDBcbn07XG52YXIgdXNlT3JnYW5pemF0aW9uTGlzdCA9IChwYXJhbXMpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IHVzZXJNZW1iZXJzaGlwcywgdXNlckludml0YXRpb25zLCB1c2VyU3VnZ2VzdGlvbnMgfSA9IHBhcmFtcyB8fCB7fTtcbiAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihcInVzZU9yZ2FuaXphdGlvbkxpc3RcIik7XG4gIGNvbnN0IHVzZXJNZW1iZXJzaGlwc1NhZmVWYWx1ZXMgPSB1c2VXaXRoU2FmZVZhbHVlcyh1c2VyTWVtYmVyc2hpcHMsIHtcbiAgICBpbml0aWFsUGFnZTogMSxcbiAgICBwYWdlU2l6ZTogMTAsXG4gICAga2VlcFByZXZpb3VzRGF0YTogZmFsc2UsXG4gICAgaW5maW5pdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCB1c2VySW52aXRhdGlvbnNTYWZlVmFsdWVzID0gdXNlV2l0aFNhZmVWYWx1ZXModXNlckludml0YXRpb25zLCB7XG4gICAgaW5pdGlhbFBhZ2U6IDEsXG4gICAgcGFnZVNpemU6IDEwLFxuICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAga2VlcFByZXZpb3VzRGF0YTogZmFsc2UsXG4gICAgaW5maW5pdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCB1c2VyU3VnZ2VzdGlvbnNTYWZlVmFsdWVzID0gdXNlV2l0aFNhZmVWYWx1ZXModXNlclN1Z2dlc3Rpb25zLCB7XG4gICAgaW5pdGlhbFBhZ2U6IDEsXG4gICAgcGFnZVNpemU6IDEwLFxuICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAga2VlcFByZXZpb3VzRGF0YTogZmFsc2UsXG4gICAgaW5maW5pdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBjbGVyayA9IHVzZUNsZXJrSW5zdGFuY2VDb250ZXh0KCk7XG4gIGNvbnN0IHVzZXIgPSB1c2VVc2VyQ29udGV4dCgpO1xuICAoX2EgPSBjbGVyay50ZWxlbWV0cnkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWNvcmQoZXZlbnRNZXRob2RDYWxsZWQoXCJ1c2VPcmdhbml6YXRpb25MaXN0XCIpKTtcbiAgY29uc3QgdXNlck1lbWJlcnNoaXBzUGFyYW1zID0gdHlwZW9mIHVzZXJNZW1iZXJzaGlwcyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHtcbiAgICBpbml0aWFsUGFnZTogdXNlck1lbWJlcnNoaXBzU2FmZVZhbHVlcy5pbml0aWFsUGFnZSxcbiAgICBwYWdlU2l6ZTogdXNlck1lbWJlcnNoaXBzU2FmZVZhbHVlcy5wYWdlU2l6ZVxuICB9O1xuICBjb25zdCB1c2VySW52aXRhdGlvbnNQYXJhbXMgPSB0eXBlb2YgdXNlckludml0YXRpb25zID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDoge1xuICAgIGluaXRpYWxQYWdlOiB1c2VySW52aXRhdGlvbnNTYWZlVmFsdWVzLmluaXRpYWxQYWdlLFxuICAgIHBhZ2VTaXplOiB1c2VySW52aXRhdGlvbnNTYWZlVmFsdWVzLnBhZ2VTaXplLFxuICAgIHN0YXR1czogdXNlckludml0YXRpb25zU2FmZVZhbHVlcy5zdGF0dXNcbiAgfTtcbiAgY29uc3QgdXNlclN1Z2dlc3Rpb25zUGFyYW1zID0gdHlwZW9mIHVzZXJTdWdnZXN0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHtcbiAgICBpbml0aWFsUGFnZTogdXNlclN1Z2dlc3Rpb25zU2FmZVZhbHVlcy5pbml0aWFsUGFnZSxcbiAgICBwYWdlU2l6ZTogdXNlclN1Z2dlc3Rpb25zU2FmZVZhbHVlcy5wYWdlU2l6ZSxcbiAgICBzdGF0dXM6IHVzZXJTdWdnZXN0aW9uc1NhZmVWYWx1ZXMuc3RhdHVzXG4gIH07XG4gIGNvbnN0IGlzQ2xlcmtMb2FkZWQgPSAhIShjbGVyay5sb2FkZWQgJiYgdXNlcik7XG4gIGNvbnN0IG1lbWJlcnNoaXBzID0gdXNlUGFnZXNPckluZmluaXRlKFxuICAgIHVzZXJNZW1iZXJzaGlwc1BhcmFtcyB8fCB7fSxcbiAgICB1c2VyID09IG51bGwgPyB2b2lkIDAgOiB1c2VyLmdldE9yZ2FuaXphdGlvbk1lbWJlcnNoaXBzLFxuICAgIHtcbiAgICAgIGtlZXBQcmV2aW91c0RhdGE6IHVzZXJNZW1iZXJzaGlwc1NhZmVWYWx1ZXMua2VlcFByZXZpb3VzRGF0YSxcbiAgICAgIGluZmluaXRlOiB1c2VyTWVtYmVyc2hpcHNTYWZlVmFsdWVzLmluZmluaXRlLFxuICAgICAgZW5hYmxlZDogISF1c2VyTWVtYmVyc2hpcHNQYXJhbXNcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwidXNlck1lbWJlcnNoaXBzXCIsXG4gICAgICB1c2VySWQ6IHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIuaWRcbiAgICB9XG4gICk7XG4gIGNvbnN0IGludml0YXRpb25zID0gdXNlUGFnZXNPckluZmluaXRlKFxuICAgIHtcbiAgICAgIC4uLnVzZXJJbnZpdGF0aW9uc1BhcmFtc1xuICAgIH0sXG4gICAgdXNlciA9PSBudWxsID8gdm9pZCAwIDogdXNlci5nZXRPcmdhbml6YXRpb25JbnZpdGF0aW9ucyxcbiAgICB7XG4gICAgICBrZWVwUHJldmlvdXNEYXRhOiB1c2VySW52aXRhdGlvbnNTYWZlVmFsdWVzLmtlZXBQcmV2aW91c0RhdGEsXG4gICAgICBpbmZpbml0ZTogdXNlckludml0YXRpb25zU2FmZVZhbHVlcy5pbmZpbml0ZSxcbiAgICAgIGVuYWJsZWQ6ICEhdXNlckludml0YXRpb25zUGFyYW1zXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcInVzZXJJbnZpdGF0aW9uc1wiLFxuICAgICAgdXNlcklkOiB1c2VyID09IG51bGwgPyB2b2lkIDAgOiB1c2VyLmlkXG4gICAgfVxuICApO1xuICBjb25zdCBzdWdnZXN0aW9ucyA9IHVzZVBhZ2VzT3JJbmZpbml0ZShcbiAgICB7XG4gICAgICAuLi51c2VyU3VnZ2VzdGlvbnNQYXJhbXNcbiAgICB9LFxuICAgIHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIuZ2V0T3JnYW5pemF0aW9uU3VnZ2VzdGlvbnMsXG4gICAge1xuICAgICAga2VlcFByZXZpb3VzRGF0YTogdXNlclN1Z2dlc3Rpb25zU2FmZVZhbHVlcy5rZWVwUHJldmlvdXNEYXRhLFxuICAgICAgaW5maW5pdGU6IHVzZXJTdWdnZXN0aW9uc1NhZmVWYWx1ZXMuaW5maW5pdGUsXG4gICAgICBlbmFibGVkOiAhIXVzZXJTdWdnZXN0aW9uc1BhcmFtc1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJ1c2VyU3VnZ2VzdGlvbnNcIixcbiAgICAgIHVzZXJJZDogdXNlciA9PSBudWxsID8gdm9pZCAwIDogdXNlci5pZFxuICAgIH1cbiAgKTtcbiAgaWYgKCFpc0NsZXJrTG9hZGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGVkOiBmYWxzZSxcbiAgICAgIGNyZWF0ZU9yZ2FuaXphdGlvbjogdm9pZCAwLFxuICAgICAgc2V0QWN0aXZlOiB2b2lkIDAsXG4gICAgICB1c2VyTWVtYmVyc2hpcHM6IHVuZGVmaW5lZFBhZ2luYXRlZFJlc291cmNlMixcbiAgICAgIHVzZXJJbnZpdGF0aW9uczogdW5kZWZpbmVkUGFnaW5hdGVkUmVzb3VyY2UyLFxuICAgICAgdXNlclN1Z2dlc3Rpb25zOiB1bmRlZmluZWRQYWdpbmF0ZWRSZXNvdXJjZTJcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkZWQ6IGlzQ2xlcmtMb2FkZWQsXG4gICAgc2V0QWN0aXZlOiBjbGVyay5zZXRBY3RpdmUsXG4gICAgY3JlYXRlT3JnYW5pemF0aW9uOiBjbGVyay5jcmVhdGVPcmdhbml6YXRpb24sXG4gICAgdXNlck1lbWJlcnNoaXBzOiBtZW1iZXJzaGlwcyxcbiAgICB1c2VySW52aXRhdGlvbnM6IGludml0YXRpb25zLFxuICAgIHVzZXJTdWdnZXN0aW9uczogc3VnZ2VzdGlvbnNcbiAgfTtcbn07XG5cbi8vIHNyYy9yZWFjdC9ob29rcy91c2VTYWZlTGF5b3V0RWZmZWN0LnRzeFxuaW1wb3J0IFJlYWN0MyBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VTYWZlTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IFJlYWN0My51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdDMudXNlRWZmZWN0O1xuXG4vLyBzcmMvcmVhY3QvaG9va3MvdXNlU2Vzc2lvbi50c1xudmFyIHVzZVNlc3Npb24gPSAoKSA9PiB7XG4gIHVzZUFzc2VydFdyYXBwZWRCeUNsZXJrUHJvdmlkZXIoXCJ1c2VTZXNzaW9uXCIpO1xuICBjb25zdCBzZXNzaW9uID0gdXNlU2Vzc2lvbkNvbnRleHQoKTtcbiAgaWYgKHNlc3Npb24gPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IGlzTG9hZGVkOiBmYWxzZSwgaXNTaWduZWRJbjogdm9pZCAwLCBzZXNzaW9uOiB2b2lkIDAgfTtcbiAgfVxuICBpZiAoc2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7IGlzTG9hZGVkOiB0cnVlLCBpc1NpZ25lZEluOiBmYWxzZSwgc2Vzc2lvbjogbnVsbCB9O1xuICB9XG4gIHJldHVybiB7IGlzTG9hZGVkOiB0cnVlLCBpc1NpZ25lZEluOiB0cnVlLCBzZXNzaW9uIH07XG59O1xuXG4vLyBzcmMvcmVhY3QvaG9va3MvdXNlU2Vzc2lvbkxpc3QudHNcbnZhciB1c2VTZXNzaW9uTGlzdCA9ICgpID0+IHtcbiAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihcInVzZVNlc3Npb25MaXN0XCIpO1xuICBjb25zdCBpc29tb3JwaGljQ2xlcmsgPSB1c2VDbGVya0luc3RhbmNlQ29udGV4dCgpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnRDb250ZXh0KCk7XG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuIHsgaXNMb2FkZWQ6IGZhbHNlLCBzZXNzaW9uczogdm9pZCAwLCBzZXRBY3RpdmU6IHZvaWQgMCB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkZWQ6IHRydWUsXG4gICAgc2Vzc2lvbnM6IGNsaWVudC5zZXNzaW9ucyxcbiAgICBzZXRBY3RpdmU6IGlzb21vcnBoaWNDbGVyay5zZXRBY3RpdmVcbiAgfTtcbn07XG5cbi8vIHNyYy9yZWFjdC9ob29rcy91c2VVc2VyLnRzXG5mdW5jdGlvbiB1c2VVc2VyKCkge1xuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyKFwidXNlVXNlclwiKTtcbiAgY29uc3QgdXNlciA9IHVzZVVzZXJDb250ZXh0KCk7XG4gIGlmICh1c2VyID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4geyBpc0xvYWRlZDogZmFsc2UsIGlzU2lnbmVkSW46IHZvaWQgMCwgdXNlcjogdm9pZCAwIH07XG4gIH1cbiAgaWYgKHVzZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4geyBpc0xvYWRlZDogdHJ1ZSwgaXNTaWduZWRJbjogZmFsc2UsIHVzZXI6IG51bGwgfTtcbiAgfVxuICByZXR1cm4geyBpc0xvYWRlZDogdHJ1ZSwgaXNTaWduZWRJbjogdHJ1ZSwgdXNlciB9O1xufVxuXG4vLyBzcmMvcmVhY3QvaG9va3MvdXNlQ2xlcmsudHNcbnZhciB1c2VDbGVyayA9ICgpID0+IHtcbiAgdXNlQXNzZXJ0V3JhcHBlZEJ5Q2xlcmtQcm92aWRlcihcInVzZUNsZXJrXCIpO1xuICByZXR1cm4gdXNlQ2xlcmtJbnN0YW5jZUNvbnRleHQoKTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9kZXF1YWwvZGlzdC9pbmRleC5tanNcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gZmluZChpdGVyLCB0YXIsIGtleSkge1xuICBmb3IgKGtleSBvZiBpdGVyLmtleXMoKSkge1xuICAgIGlmIChkZXF1YWwoa2V5LCB0YXIpKSByZXR1cm4ga2V5O1xuICB9XG59XG5mdW5jdGlvbiBkZXF1YWwoZm9vLCBiYXIpIHtcbiAgdmFyIGN0b3IsIGxlbiwgdG1wO1xuICBpZiAoZm9vID09PSBiYXIpIHJldHVybiB0cnVlO1xuICBpZiAoZm9vICYmIGJhciAmJiAoY3RvciA9IGZvby5jb25zdHJ1Y3RvcikgPT09IGJhci5jb25zdHJ1Y3Rvcikge1xuICAgIGlmIChjdG9yID09PSBEYXRlKSByZXR1cm4gZm9vLmdldFRpbWUoKSA9PT0gYmFyLmdldFRpbWUoKTtcbiAgICBpZiAoY3RvciA9PT0gUmVnRXhwKSByZXR1cm4gZm9vLnRvU3RyaW5nKCkgPT09IGJhci50b1N0cmluZygpO1xuICAgIGlmIChjdG9yID09PSBBcnJheSkge1xuICAgICAgaWYgKChsZW4gPSBmb28ubGVuZ3RoKSA9PT0gYmFyLmxlbmd0aCkge1xuICAgICAgICB3aGlsZSAobGVuLS0gJiYgZGVxdWFsKGZvb1tsZW5dLCBiYXJbbGVuXSkpIDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW4gPT09IC0xO1xuICAgIH1cbiAgICBpZiAoY3RvciA9PT0gU2V0KSB7XG4gICAgICBpZiAoZm9vLnNpemUgIT09IGJhci5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGVuIG9mIGZvbykge1xuICAgICAgICB0bXAgPSBsZW47XG4gICAgICAgIGlmICh0bXAgJiYgdHlwZW9mIHRtcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRtcCA9IGZpbmQoYmFyLCB0bXApO1xuICAgICAgICAgIGlmICghdG1wKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiYXIuaGFzKHRtcCkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3RvciA9PT0gTWFwKSB7XG4gICAgICBpZiAoZm9vLnNpemUgIT09IGJhci5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGVuIG9mIGZvbykge1xuICAgICAgICB0bXAgPSBsZW5bMF07XG4gICAgICAgIGlmICh0bXAgJiYgdHlwZW9mIHRtcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRtcCA9IGZpbmQoYmFyLCB0bXApO1xuICAgICAgICAgIGlmICghdG1wKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXF1YWwobGVuWzFdLCBiYXIuZ2V0KHRtcCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICBmb28gPSBuZXcgVWludDhBcnJheShmb28pO1xuICAgICAgYmFyID0gbmV3IFVpbnQ4QXJyYXkoYmFyKTtcbiAgICB9IGVsc2UgaWYgKGN0b3IgPT09IERhdGFWaWV3KSB7XG4gICAgICBpZiAoKGxlbiA9IGZvby5ieXRlTGVuZ3RoKSA9PT0gYmFyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKGxlbi0tICYmIGZvby5nZXRJbnQ4KGxlbikgPT09IGJhci5nZXRJbnQ4KGxlbikpIDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW4gPT09IC0xO1xuICAgIH1cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGZvbykpIHtcbiAgICAgIGlmICgobGVuID0gZm9vLmJ5dGVMZW5ndGgpID09PSBiYXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICB3aGlsZSAobGVuLS0gJiYgZm9vW2xlbl0gPT09IGJhcltsZW5dKSA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuID09PSAtMTtcbiAgICB9XG4gICAgaWYgKCFjdG9yIHx8IHR5cGVvZiBmb28gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGxlbiA9IDA7XG4gICAgICBmb3IgKGN0b3IgaW4gZm9vKSB7XG4gICAgICAgIGlmIChoYXMuY2FsbChmb28sIGN0b3IpICYmICsrbGVuICYmICFoYXMuY2FsbChiYXIsIGN0b3IpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghKGN0b3IgaW4gYmFyKSB8fCAhZGVxdWFsKGZvb1tjdG9yXSwgYmFyW2N0b3JdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGJhcikubGVuZ3RoID09PSBsZW47XG4gICAgfVxuICB9XG4gIHJldHVybiBmb28gIT09IGZvbyAmJiBiYXIgIT09IGJhcjtcbn1cblxuLy8gc3JjL3JlYWN0L2hvb2tzL3VzZURlZXBFcXVhbE1lbW8udHNcbmltcG9ydCBSZWFjdDQgZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlRGVlcEVxdWFsTWVtb2l6ZSA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCByZWYgPSBSZWFjdDQudXNlUmVmKHZhbHVlKTtcbiAgaWYgKCFkZXF1YWwodmFsdWUsIHJlZi5jdXJyZW50KSkge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIFJlYWN0NC51c2VNZW1vKCgpID0+IHJlZi5jdXJyZW50LCBbcmVmLmN1cnJlbnRdKTtcbn07XG52YXIgdXNlRGVlcEVxdWFsTWVtbyA9IChmYWN0b3J5LCBkZXBlbmRlbmN5QXJyYXkpID0+IHtcbiAgcmV0dXJuIFJlYWN0NC51c2VNZW1vKGZhY3RvcnksIHVzZURlZXBFcXVhbE1lbW9pemUoZGVwZW5kZW5jeUFycmF5KSk7XG59O1xudmFyIGlzRGVlcGx5RXF1YWwgPSBkZXF1YWw7XG5leHBvcnQge1xuICBDbGVya0luc3RhbmNlQ29udGV4dCxcbiAgQ2xpZW50Q29udGV4dCxcbiAgT3B0aW9uc0NvbnRleHQsXG4gIE9yZ2FuaXphdGlvblByb3ZpZGVyLFxuICBTZXNzaW9uQ29udGV4dCxcbiAgVXNlckNvbnRleHQsXG4gIGFzc2VydENvbnRleHRFeGlzdHMsXG4gIGNyZWF0ZUNvbnRleHRBbmRIb29rLFxuICBpc0RlZXBseUVxdWFsLFxuICB1c2VBc3NlcnRXcmFwcGVkQnlDbGVya1Byb3ZpZGVyLFxuICB1c2VDbGVyayxcbiAgdXNlQ2xlcmtJbnN0YW5jZUNvbnRleHQsXG4gIHVzZUNsaWVudENvbnRleHQsXG4gIHVzZURlZXBFcXVhbE1lbW8sXG4gIHVzZU9wdGlvbnNDb250ZXh0LFxuICB1c2VPcmdhbml6YXRpb24sXG4gIHVzZU9yZ2FuaXphdGlvbkNvbnRleHQsXG4gIHVzZU9yZ2FuaXphdGlvbkxpc3QsXG4gIHVzZVNhZmVMYXlvdXRFZmZlY3QsXG4gIHVzZVNlc3Npb24sXG4gIHVzZVNlc3Npb25Db250ZXh0LFxuICB1c2VTZXNzaW9uTGlzdCxcbiAgdXNlVXNlcixcbiAgdXNlVXNlckNvbnRleHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/react/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@clerk/shared/dist/telemetry.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@clerk/shared/dist/telemetry.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TelemetryCollector: function() { return /* binding */ TelemetryCollector; },\n/* harmony export */   eventComponentMounted: function() { return /* binding */ eventComponentMounted; },\n/* harmony export */   eventMethodCalled: function() { return /* reexport safe */ _chunk_TUVJ3GI6_mjs__WEBPACK_IMPORTED_MODULE_0__.eventMethodCalled; },\n/* harmony export */   eventPrebuiltComponentMounted: function() { return /* binding */ eventPrebuiltComponentMounted; }\n/* harmony export */ });\n/* harmony import */ var _chunk_TUVJ3GI6_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-TUVJ3GI6.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TUVJ3GI6.mjs\");\n/* harmony import */ var _chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-QE2A7CJI.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-QE2A7CJI.mjs\");\n/* harmony import */ var _chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-L2BNNARM.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-L2BNNARM.mjs\");\n/* harmony import */ var _chunk_TETGTEI2_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-TETGTEI2.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs\");\n/* harmony import */ var _chunk_KOH7GTJO_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-KOH7GTJO.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs\");\n/* harmony import */ var _chunk_I6MTSTOF_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-I6MTSTOF.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs\");\n/* harmony import */ var _chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunk-7ELT755Q.mjs */ \"(app-pages-browser)/./node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n\n\n\n\n\n// src/telemetry/throttler.ts\nvar DEFAULT_CACHE_TTL_MS = 864e5;\nvar _storageKey, _cacheTtl, _TelemetryEventThrottler_instances, generateKey_fn, cache_get, isValidBrowser_get;\nvar TelemetryEventThrottler = class {\n  constructor() {\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateAdd)(this, _TelemetryEventThrottler_instances);\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateAdd)(this, _storageKey, \"clerk_telemetry_throttler\");\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateAdd)(this, _cacheTtl, DEFAULT_CACHE_TTL_MS);\n  }\n  isEventThrottled(payload) {\n    var _a;\n    if (!(0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _TelemetryEventThrottler_instances, isValidBrowser_get)) {\n      return false;\n    }\n    const now = Date.now();\n    const key = (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryEventThrottler_instances, generateKey_fn).call(this, payload);\n    const entry = (_a = (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _TelemetryEventThrottler_instances, cache_get)) == null ? void 0 : _a[key];\n    if (!entry) {\n      const updatedCache = {\n        ...(0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _TelemetryEventThrottler_instances, cache_get),\n        [key]: now\n      };\n      localStorage.setItem((0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _storageKey), JSON.stringify(updatedCache));\n    }\n    const shouldInvalidate = entry && now - entry > (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _cacheTtl);\n    if (shouldInvalidate) {\n      const updatedCache = (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _TelemetryEventThrottler_instances, cache_get);\n      delete updatedCache[key];\n      localStorage.setItem((0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _storageKey), JSON.stringify(updatedCache));\n    }\n    return !!entry;\n  }\n};\n_storageKey = new WeakMap();\n_cacheTtl = new WeakMap();\n_TelemetryEventThrottler_instances = new WeakSet();\n/**\n * Generates a consistent unique key for telemetry events by sorting payload properties.\n * This ensures that payloads with identical content in different orders produce the same key.\n */\ngenerateKey_fn = function(event) {\n  const { sk: _sk, pk: _pk, payload, ...rest } = event;\n  const sanitizedEvent = {\n    ...payload,\n    ...rest\n  };\n  return JSON.stringify(\n    Object.keys({\n      ...payload,\n      ...rest\n    }).sort().map((key) => sanitizedEvent[key])\n  );\n};\ncache_get = function() {\n  const cacheString = localStorage.getItem((0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _storageKey));\n  if (!cacheString) {\n    return {};\n  }\n  return JSON.parse(cacheString);\n};\nisValidBrowser_get = function() {\n  if (typeof window === \"undefined\") {\n    return false;\n  }\n  const storage = window.localStorage;\n  if (!storage) {\n    return false;\n  }\n  try {\n    const testKey = \"test\";\n    storage.setItem(testKey, testKey);\n    storage.removeItem(testKey);\n    return true;\n  } catch (err) {\n    const isQuotaExceededError = err instanceof DOMException && // Check error names for different browsers\n    (err.name === \"QuotaExceededError\" || err.name === \"NS_ERROR_DOM_QUOTA_REACHED\");\n    if (isQuotaExceededError && storage.length > 0) {\n      storage.removeItem((0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _storageKey));\n    }\n    return false;\n  }\n};\n\n// src/telemetry/collector.ts\nvar DEFAULT_CONFIG = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: \"https://clerk-telemetry.com\"\n};\nvar _config, _eventThrottler, _metadata, _buffer, _pendingFlush, _TelemetryCollector_instances, shouldRecord_fn, shouldBeSampled_fn, scheduleFlush_fn, flush_fn, logEvent_fn, getSDKMetadata_fn, preparePayload_fn;\nvar TelemetryCollector = class {\n  constructor(options) {\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateAdd)(this, _TelemetryCollector_instances);\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateAdd)(this, _config);\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateAdd)(this, _eventThrottler);\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateAdd)(this, _metadata, {});\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateAdd)(this, _buffer, []);\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateAdd)(this, _pendingFlush);\n    var _a, _b, _c, _d, _e, _f;\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateSet)(this, _config, {\n      maxBufferSize: (_a = options.maxBufferSize) != null ? _a : DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: (_b = options.samplingRate) != null ? _b : DEFAULT_CONFIG.samplingRate,\n      disabled: (_c = options.disabled) != null ? _c : false,\n      debug: (_d = options.debug) != null ? _d : false,\n      endpoint: DEFAULT_CONFIG.endpoint\n    });\n    if (!options.clerkVersion && typeof window === \"undefined\") {\n      (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).clerkVersion = \"\";\n    } else {\n      (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).clerkVersion = (_e = options.clerkVersion) != null ? _e : \"\";\n    }\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).sdk = options.sdk;\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).sdkVersion = options.sdkVersion;\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).publishableKey = (_f = options.publishableKey) != null ? _f : \"\";\n    const parsedKey = (0,_chunk_L2BNNARM_mjs__WEBPACK_IMPORTED_MODULE_2__.parsePublishableKey)(options.publishableKey);\n    if (parsedKey) {\n      (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).instanceType = parsedKey.instanceType;\n    }\n    if (options.secretKey) {\n      (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).secretKey = options.secretKey.substring(0, 16);\n    }\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateSet)(this, _eventThrottler, new TelemetryEventThrottler());\n  }\n  get isEnabled() {\n    var _a;\n    if ((0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).instanceType !== \"development\") {\n      return false;\n    }\n    if ((0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _config).disabled || typeof process !== \"undefined\" && (0,_chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_1__.isTruthy)(process.env.CLERK_TELEMETRY_DISABLED)) {\n      return false;\n    }\n    if (typeof window !== \"undefined\" && !!((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.webdriver)) {\n      return false;\n    }\n    return true;\n  }\n  get isDebug() {\n    return (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _config).debug || typeof process !== \"undefined\" && (0,_chunk_QE2A7CJI_mjs__WEBPACK_IMPORTED_MODULE_1__.isTruthy)(process.env.CLERK_TELEMETRY_DEBUG);\n  }\n  record(event) {\n    const preparedPayload = (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryCollector_instances, preparePayload_fn).call(this, event.event, event.payload);\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryCollector_instances, logEvent_fn).call(this, preparedPayload.event, preparedPayload);\n    if (!(0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryCollector_instances, shouldRecord_fn).call(this, preparedPayload, event.eventSamplingRate)) {\n      return;\n    }\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _buffer).push(preparedPayload);\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryCollector_instances, scheduleFlush_fn).call(this);\n  }\n};\n_config = new WeakMap();\n_eventThrottler = new WeakMap();\n_metadata = new WeakMap();\n_buffer = new WeakMap();\n_pendingFlush = new WeakMap();\n_TelemetryCollector_instances = new WeakSet();\nshouldRecord_fn = function(preparedPayload, eventSamplingRate) {\n  return this.isEnabled && !this.isDebug && (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryCollector_instances, shouldBeSampled_fn).call(this, preparedPayload, eventSamplingRate);\n};\nshouldBeSampled_fn = function(preparedPayload, eventSamplingRate) {\n  const randomSeed = Math.random();\n  if ((0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _eventThrottler).isEventThrottled(preparedPayload)) {\n    return false;\n  }\n  return randomSeed <= (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _config).samplingRate && (typeof eventSamplingRate === \"undefined\" || randomSeed <= eventSamplingRate);\n};\nscheduleFlush_fn = function() {\n  if (typeof window === \"undefined\") {\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryCollector_instances, flush_fn).call(this);\n    return;\n  }\n  const isBufferFull = (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _buffer).length >= (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _config).maxBufferSize;\n  if (isBufferFull) {\n    if ((0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _pendingFlush)) {\n      const cancel = typeof cancelIdleCallback !== \"undefined\" ? cancelIdleCallback : clearTimeout;\n      cancel((0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _pendingFlush));\n    }\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryCollector_instances, flush_fn).call(this);\n    return;\n  }\n  if ((0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _pendingFlush)) {\n    return;\n  }\n  if (\"requestIdleCallback\" in window) {\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateSet)(this, _pendingFlush, requestIdleCallback(() => {\n      (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryCollector_instances, flush_fn).call(this);\n    }));\n  } else {\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateSet)(this, _pendingFlush, setTimeout(() => {\n      (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryCollector_instances, flush_fn).call(this);\n    }, 0));\n  }\n};\nflush_fn = function() {\n  fetch(new URL(\"/v1/event\", (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _config).endpoint), {\n    method: \"POST\",\n    // TODO: We send an array here with that idea that we can eventually send multiple events.\n    body: JSON.stringify({\n      events: (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _buffer)\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  }).catch(() => void 0).then(() => {\n    (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateSet)(this, _buffer, []);\n  }).catch(() => void 0);\n};\n/**\n * If running in debug mode, log the event and its payload to the console.\n */\nlogEvent_fn = function(event, payload) {\n  if (!this.isDebug) {\n    return;\n  }\n  if (typeof console.groupCollapsed !== \"undefined\") {\n    console.groupCollapsed(\"[clerk/telemetry]\", event);\n    console.log(payload);\n    console.groupEnd();\n  } else {\n    console.log(\"[clerk/telemetry]\", event, payload);\n  }\n};\n/**\n * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n *\n * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n */\ngetSDKMetadata_fn = function() {\n  let sdkMetadata = {\n    name: (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).sdk,\n    version: (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).sdkVersion\n  };\n  if (typeof window !== \"undefined\" && window.Clerk) {\n    sdkMetadata = { ...sdkMetadata, ...window.Clerk.constructor.sdkMetadata };\n  }\n  return sdkMetadata;\n};\n/**\n * Append relevant metadata from the Clerk singleton to the event payload.\n */\npreparePayload_fn = function(event, payload) {\n  var _a, _b;\n  const sdkMetadata = (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateMethod)(this, _TelemetryCollector_instances, getSDKMetadata_fn).call(this);\n  return {\n    event,\n    cv: (_a = (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).clerkVersion) != null ? _a : \"\",\n    it: (_b = (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).instanceType) != null ? _b : \"\",\n    sdk: sdkMetadata.name,\n    sdkv: sdkMetadata.version,\n    ...(0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).publishableKey ? { pk: (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).publishableKey } : {},\n    ...(0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).secretKey ? { sk: (0,_chunk_7ELT755Q_mjs__WEBPACK_IMPORTED_MODULE_6__.__privateGet)(this, _metadata).secretKey } : {},\n    payload\n  };\n};\n\n// src/telemetry/events/component-mounted.ts\nvar EVENT_COMPONENT_MOUNTED = \"COMPONENT_MOUNTED\";\nvar EVENT_SAMPLING_RATE = 0.1;\nfunction eventPrebuiltComponentMounted(component, props) {\n  var _a, _b, _c;\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      component,\n      appearanceProp: Boolean(props == null ? void 0 : props.appearance),\n      baseTheme: Boolean((_a = props == null ? void 0 : props.appearance) == null ? void 0 : _a.baseTheme),\n      elements: Boolean((_b = props == null ? void 0 : props.appearance) == null ? void 0 : _b.elements),\n      variables: Boolean((_c = props == null ? void 0 : props.appearance) == null ? void 0 : _c.variables)\n    }\n  };\n}\nfunction eventComponentMounted(component, props = {}) {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      component,\n      ...props\n    }\n  };\n}\n\n//# sourceMappingURL=telemetry.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2xlcmsvc2hhcmVkL2Rpc3QvdGVsZW1ldHJ5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFOEI7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFZO0FBQ2hCLElBQUksaUVBQVk7QUFDaEIsSUFBSSxpRUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlFQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBZTtBQUMvQix3QkFBd0IsaUVBQVk7QUFDcEM7QUFDQTtBQUNBLFdBQVcsaUVBQVk7QUFDdkI7QUFDQTtBQUNBLDJCQUEyQixpRUFBWTtBQUN2QztBQUNBLG9EQUFvRCxpRUFBWTtBQUNoRTtBQUNBLDJCQUEyQixpRUFBWTtBQUN2QztBQUNBLDJCQUEyQixpRUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFDQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpRUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlFQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQVk7QUFDaEIsSUFBSSxpRUFBWTtBQUNoQixJQUFJLGlFQUFZO0FBQ2hCLElBQUksaUVBQVksb0JBQW9CO0FBQ3BDLElBQUksaUVBQVk7QUFDaEIsSUFBSSxpRUFBWTtBQUNoQjtBQUNBLElBQUksaUVBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU0saUVBQVk7QUFDbEIsTUFBTTtBQUNOLE1BQU0saUVBQVk7QUFDbEI7QUFDQSxJQUFJLGlFQUFZO0FBQ2hCLElBQUksaUVBQVk7QUFDaEIsSUFBSSxpRUFBWTtBQUNoQixzQkFBc0Isd0VBQW1CO0FBQ3pDO0FBQ0EsTUFBTSxpRUFBWTtBQUNsQjtBQUNBO0FBQ0EsTUFBTSxpRUFBWTtBQUNsQjtBQUNBLElBQUksaUVBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBWTtBQUNwQjtBQUNBO0FBQ0EsUUFBUSxpRUFBWSxtQ0FBbUMsT0FBTyxvQkFBb0IsNkRBQVEsQ0FBQyxPQUFPO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlFQUFZLGdDQUFnQyxPQUFPLG9CQUFvQiw2REFBUSxDQUFDLE9BQU87QUFDbEc7QUFDQTtBQUNBLDRCQUE0QixvRUFBZTtBQUMzQyxJQUFJLG9FQUFlO0FBQ25CLFNBQVMsb0VBQWU7QUFDeEI7QUFDQTtBQUNBLElBQUksaUVBQVk7QUFDaEIsSUFBSSxvRUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsb0VBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpRUFBWTtBQUNsQjtBQUNBO0FBQ0EsdUJBQXVCLGlFQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLElBQUksb0VBQWU7QUFDbkI7QUFDQTtBQUNBLHVCQUF1QixpRUFBWSwwQkFBMEIsaUVBQVk7QUFDekU7QUFDQSxRQUFRLGlFQUFZO0FBQ3BCO0FBQ0EsYUFBYSxpRUFBWTtBQUN6QjtBQUNBLElBQUksb0VBQWU7QUFDbkI7QUFDQTtBQUNBLE1BQU0saUVBQVk7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBWTtBQUNoQixNQUFNLG9FQUFlO0FBQ3JCLEtBQUs7QUFDTCxJQUFJO0FBQ0osSUFBSSxpRUFBWTtBQUNoQixNQUFNLG9FQUFlO0FBQ3JCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBWTtBQUMxQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUksaUVBQVk7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUVBQVk7QUFDdEIsYUFBYSxpRUFBWTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0VBQWU7QUFDckM7QUFDQTtBQUNBLGNBQWMsaUVBQVk7QUFDMUIsY0FBYyxpRUFBWTtBQUMxQjtBQUNBO0FBQ0EsT0FBTyxpRUFBWSxxQ0FBcUMsSUFBSSxpRUFBWSxtQ0FBbUMsSUFBSTtBQUMvRyxPQUFPLGlFQUFZLGdDQUFnQyxJQUFJLGlFQUFZLDhCQUE4QixJQUFJO0FBQ3JHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjbGVyay9zaGFyZWQvZGlzdC90ZWxlbWV0cnkubWpzPzIwOWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZXZlbnRNZXRob2RDYWxsZWRcbn0gZnJvbSBcIi4vY2h1bmstVFVWSjNHSTYubWpzXCI7XG5pbXBvcnQge1xuICBpc1RydXRoeVxufSBmcm9tIFwiLi9jaHVuay1RRTJBN0NKSS5tanNcIjtcbmltcG9ydCB7XG4gIHBhcnNlUHVibGlzaGFibGVLZXlcbn0gZnJvbSBcIi4vY2h1bmstTDJCTk5BUk0ubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLVRFVEdURUkyLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1LT0g3R1RKTy5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstSTZNVFNUT0YubWpzXCI7XG5pbXBvcnQge1xuICBfX3ByaXZhdGVBZGQsXG4gIF9fcHJpdmF0ZUdldCxcbiAgX19wcml2YXRlTWV0aG9kLFxuICBfX3ByaXZhdGVTZXRcbn0gZnJvbSBcIi4vY2h1bmstN0VMVDc1NVEubWpzXCI7XG5cbi8vIHNyYy90ZWxlbWV0cnkvdGhyb3R0bGVyLnRzXG52YXIgREVGQVVMVF9DQUNIRV9UVExfTVMgPSA4NjRlNTtcbnZhciBfc3RvcmFnZUtleSwgX2NhY2hlVHRsLCBfVGVsZW1ldHJ5RXZlbnRUaHJvdHRsZXJfaW5zdGFuY2VzLCBnZW5lcmF0ZUtleV9mbiwgY2FjaGVfZ2V0LCBpc1ZhbGlkQnJvd3Nlcl9nZXQ7XG52YXIgVGVsZW1ldHJ5RXZlbnRUaHJvdHRsZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfVGVsZW1ldHJ5RXZlbnRUaHJvdHRsZXJfaW5zdGFuY2VzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3N0b3JhZ2VLZXksIFwiY2xlcmtfdGVsZW1ldHJ5X3Rocm90dGxlclwiKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NhY2hlVHRsLCBERUZBVUxUX0NBQ0hFX1RUTF9NUyk7XG4gIH1cbiAgaXNFdmVudFRocm90dGxlZChwYXlsb2FkKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9UZWxlbWV0cnlFdmVudFRocm90dGxlcl9pbnN0YW5jZXMsIGlzVmFsaWRCcm93c2VyX2dldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBrZXkgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX1RlbGVtZXRyeUV2ZW50VGhyb3R0bGVyX2luc3RhbmNlcywgZ2VuZXJhdGVLZXlfZm4pLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgY29uc3QgZW50cnkgPSAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX1RlbGVtZXRyeUV2ZW50VGhyb3R0bGVyX2luc3RhbmNlcywgY2FjaGVfZ2V0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2tleV07XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgY29uc3QgdXBkYXRlZENhY2hlID0ge1xuICAgICAgICAuLi5fX3ByaXZhdGVHZXQodGhpcywgX1RlbGVtZXRyeUV2ZW50VGhyb3R0bGVyX2luc3RhbmNlcywgY2FjaGVfZ2V0KSxcbiAgICAgICAgW2tleV06IG5vd1xuICAgICAgfTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKF9fcHJpdmF0ZUdldCh0aGlzLCBfc3RvcmFnZUtleSksIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRDYWNoZSkpO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRJbnZhbGlkYXRlID0gZW50cnkgJiYgbm93IC0gZW50cnkgPiBfX3ByaXZhdGVHZXQodGhpcywgX2NhY2hlVHRsKTtcbiAgICBpZiAoc2hvdWxkSW52YWxpZGF0ZSkge1xuICAgICAgY29uc3QgdXBkYXRlZENhY2hlID0gX19wcml2YXRlR2V0KHRoaXMsIF9UZWxlbWV0cnlFdmVudFRocm90dGxlcl9pbnN0YW5jZXMsIGNhY2hlX2dldCk7XG4gICAgICBkZWxldGUgdXBkYXRlZENhY2hlW2tleV07XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShfX3ByaXZhdGVHZXQodGhpcywgX3N0b3JhZ2VLZXkpLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkQ2FjaGUpKTtcbiAgICB9XG4gICAgcmV0dXJuICEhZW50cnk7XG4gIH1cbn07XG5fc3RvcmFnZUtleSA9IG5ldyBXZWFrTWFwKCk7XG5fY2FjaGVUdGwgPSBuZXcgV2Vha01hcCgpO1xuX1RlbGVtZXRyeUV2ZW50VGhyb3R0bGVyX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCk7XG4vKipcbiAqIEdlbmVyYXRlcyBhIGNvbnNpc3RlbnQgdW5pcXVlIGtleSBmb3IgdGVsZW1ldHJ5IGV2ZW50cyBieSBzb3J0aW5nIHBheWxvYWQgcHJvcGVydGllcy5cbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHBheWxvYWRzIHdpdGggaWRlbnRpY2FsIGNvbnRlbnQgaW4gZGlmZmVyZW50IG9yZGVycyBwcm9kdWNlIHRoZSBzYW1lIGtleS5cbiAqL1xuZ2VuZXJhdGVLZXlfZm4gPSBmdW5jdGlvbihldmVudCkge1xuICBjb25zdCB7IHNrOiBfc2ssIHBrOiBfcGssIHBheWxvYWQsIC4uLnJlc3QgfSA9IGV2ZW50O1xuICBjb25zdCBzYW5pdGl6ZWRFdmVudCA9IHtcbiAgICAuLi5wYXlsb2FkLFxuICAgIC4uLnJlc3RcbiAgfTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgIE9iamVjdC5rZXlzKHtcbiAgICAgIC4uLnBheWxvYWQsXG4gICAgICAuLi5yZXN0XG4gICAgfSkuc29ydCgpLm1hcCgoa2V5KSA9PiBzYW5pdGl6ZWRFdmVudFtrZXldKVxuICApO1xufTtcbmNhY2hlX2dldCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBjYWNoZVN0cmluZyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKF9fcHJpdmF0ZUdldCh0aGlzLCBfc3RvcmFnZUtleSkpO1xuICBpZiAoIWNhY2hlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBKU09OLnBhcnNlKGNhY2hlU3RyaW5nKTtcbn07XG5pc1ZhbGlkQnJvd3Nlcl9nZXQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIGlmICghc3RvcmFnZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHRlc3RLZXkgPSBcInRlc3RcIjtcbiAgICBzdG9yYWdlLnNldEl0ZW0odGVzdEtleSwgdGVzdEtleSk7XG4gICAgc3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RLZXkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCBpc1F1b3RhRXhjZWVkZWRFcnJvciA9IGVyciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiAvLyBDaGVjayBlcnJvciBuYW1lcyBmb3IgZGlmZmVyZW50IGJyb3dzZXJzXG4gICAgKGVyci5uYW1lID09PSBcIlF1b3RhRXhjZWVkZWRFcnJvclwiIHx8IGVyci5uYW1lID09PSBcIk5TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEXCIpO1xuICAgIGlmIChpc1F1b3RhRXhjZWVkZWRFcnJvciAmJiBzdG9yYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShfX3ByaXZhdGVHZXQodGhpcywgX3N0b3JhZ2VLZXkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBzcmMvdGVsZW1ldHJ5L2NvbGxlY3Rvci50c1xudmFyIERFRkFVTFRfQ09ORklHID0ge1xuICBzYW1wbGluZ1JhdGU6IDEsXG4gIG1heEJ1ZmZlclNpemU6IDUsXG4gIC8vIFByb2R1Y3Rpb24gZW5kcG9pbnQ6IGh0dHBzOi8vY2xlcmstdGVsZW1ldHJ5LmNvbVxuICAvLyBTdGFnaW5nIGVuZHBvaW50OiBodHRwczovL3N0YWdpbmcuY2xlcmstdGVsZW1ldHJ5LmNvbVxuICAvLyBMb2NhbDogaHR0cDovL2xvY2FsaG9zdDo4Nzg3XG4gIGVuZHBvaW50OiBcImh0dHBzOi8vY2xlcmstdGVsZW1ldHJ5LmNvbVwiXG59O1xudmFyIF9jb25maWcsIF9ldmVudFRocm90dGxlciwgX21ldGFkYXRhLCBfYnVmZmVyLCBfcGVuZGluZ0ZsdXNoLCBfVGVsZW1ldHJ5Q29sbGVjdG9yX2luc3RhbmNlcywgc2hvdWxkUmVjb3JkX2ZuLCBzaG91bGRCZVNhbXBsZWRfZm4sIHNjaGVkdWxlRmx1c2hfZm4sIGZsdXNoX2ZuLCBsb2dFdmVudF9mbiwgZ2V0U0RLTWV0YWRhdGFfZm4sIHByZXBhcmVQYXlsb2FkX2ZuO1xudmFyIFRlbGVtZXRyeUNvbGxlY3RvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfVGVsZW1ldHJ5Q29sbGVjdG9yX2luc3RhbmNlcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9jb25maWcpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZXZlbnRUaHJvdHRsZXIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWV0YWRhdGEsIHt9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2J1ZmZlciwgW10pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcGVuZGluZ0ZsdXNoKTtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NvbmZpZywge1xuICAgICAgbWF4QnVmZmVyU2l6ZTogKF9hID0gb3B0aW9ucy5tYXhCdWZmZXJTaXplKSAhPSBudWxsID8gX2EgOiBERUZBVUxUX0NPTkZJRy5tYXhCdWZmZXJTaXplLFxuICAgICAgc2FtcGxpbmdSYXRlOiAoX2IgPSBvcHRpb25zLnNhbXBsaW5nUmF0ZSkgIT0gbnVsbCA/IF9iIDogREVGQVVMVF9DT05GSUcuc2FtcGxpbmdSYXRlLFxuICAgICAgZGlzYWJsZWQ6IChfYyA9IG9wdGlvbnMuZGlzYWJsZWQpICE9IG51bGwgPyBfYyA6IGZhbHNlLFxuICAgICAgZGVidWc6IChfZCA9IG9wdGlvbnMuZGVidWcpICE9IG51bGwgPyBfZCA6IGZhbHNlLFxuICAgICAgZW5kcG9pbnQ6IERFRkFVTFRfQ09ORklHLmVuZHBvaW50XG4gICAgfSk7XG4gICAgaWYgKCFvcHRpb25zLmNsZXJrVmVyc2lvbiAmJiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX21ldGFkYXRhKS5jbGVya1ZlcnNpb24gPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX21ldGFkYXRhKS5jbGVya1ZlcnNpb24gPSAoX2UgPSBvcHRpb25zLmNsZXJrVmVyc2lvbikgIT0gbnVsbCA/IF9lIDogXCJcIjtcbiAgICB9XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9tZXRhZGF0YSkuc2RrID0gb3B0aW9ucy5zZGs7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9tZXRhZGF0YSkuc2RrVmVyc2lvbiA9IG9wdGlvbnMuc2RrVmVyc2lvbjtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX21ldGFkYXRhKS5wdWJsaXNoYWJsZUtleSA9IChfZiA9IG9wdGlvbnMucHVibGlzaGFibGVLZXkpICE9IG51bGwgPyBfZiA6IFwiXCI7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gcGFyc2VQdWJsaXNoYWJsZUtleShvcHRpb25zLnB1Ymxpc2hhYmxlS2V5KTtcbiAgICBpZiAocGFyc2VkS2V5KSB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX21ldGFkYXRhKS5pbnN0YW5jZVR5cGUgPSBwYXJzZWRLZXkuaW5zdGFuY2VUeXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZWNyZXRLZXkpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWV0YWRhdGEpLnNlY3JldEtleSA9IG9wdGlvbnMuc2VjcmV0S2V5LnN1YnN0cmluZygwLCAxNik7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZXZlbnRUaHJvdHRsZXIsIG5ldyBUZWxlbWV0cnlFdmVudFRocm90dGxlcigpKTtcbiAgfVxuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9tZXRhZGF0YSkuaW5zdGFuY2VUeXBlICE9PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfY29uZmlnKS5kaXNhYmxlZCB8fCB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc1RydXRoeShwcm9jZXNzLmVudi5DTEVSS19URUxFTUVUUllfRElTQUJMRUQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICEhKChfYSA9IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLndlYmRyaXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IGlzRGVidWcoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfY29uZmlnKS5kZWJ1ZyB8fCB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc1RydXRoeShwcm9jZXNzLmVudi5DTEVSS19URUxFTUVUUllfREVCVUcpO1xuICB9XG4gIHJlY29yZChldmVudCkge1xuICAgIGNvbnN0IHByZXBhcmVkUGF5bG9hZCA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGVsZW1ldHJ5Q29sbGVjdG9yX2luc3RhbmNlcywgcHJlcGFyZVBheWxvYWRfZm4pLmNhbGwodGhpcywgZXZlbnQuZXZlbnQsIGV2ZW50LnBheWxvYWQpO1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGVsZW1ldHJ5Q29sbGVjdG9yX2luc3RhbmNlcywgbG9nRXZlbnRfZm4pLmNhbGwodGhpcywgcHJlcGFyZWRQYXlsb2FkLmV2ZW50LCBwcmVwYXJlZFBheWxvYWQpO1xuICAgIGlmICghX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UZWxlbWV0cnlDb2xsZWN0b3JfaW5zdGFuY2VzLCBzaG91bGRSZWNvcmRfZm4pLmNhbGwodGhpcywgcHJlcGFyZWRQYXlsb2FkLCBldmVudC5ldmVudFNhbXBsaW5nUmF0ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9idWZmZXIpLnB1c2gocHJlcGFyZWRQYXlsb2FkKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1RlbGVtZXRyeUNvbGxlY3Rvcl9pbnN0YW5jZXMsIHNjaGVkdWxlRmx1c2hfZm4pLmNhbGwodGhpcyk7XG4gIH1cbn07XG5fY29uZmlnID0gbmV3IFdlYWtNYXAoKTtcbl9ldmVudFRocm90dGxlciA9IG5ldyBXZWFrTWFwKCk7XG5fbWV0YWRhdGEgPSBuZXcgV2Vha01hcCgpO1xuX2J1ZmZlciA9IG5ldyBXZWFrTWFwKCk7XG5fcGVuZGluZ0ZsdXNoID0gbmV3IFdlYWtNYXAoKTtcbl9UZWxlbWV0cnlDb2xsZWN0b3JfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKTtcbnNob3VsZFJlY29yZF9mbiA9IGZ1bmN0aW9uKHByZXBhcmVkUGF5bG9hZCwgZXZlbnRTYW1wbGluZ1JhdGUpIHtcbiAgcmV0dXJuIHRoaXMuaXNFbmFibGVkICYmICF0aGlzLmlzRGVidWcgJiYgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UZWxlbWV0cnlDb2xsZWN0b3JfaW5zdGFuY2VzLCBzaG91bGRCZVNhbXBsZWRfZm4pLmNhbGwodGhpcywgcHJlcGFyZWRQYXlsb2FkLCBldmVudFNhbXBsaW5nUmF0ZSk7XG59O1xuc2hvdWxkQmVTYW1wbGVkX2ZuID0gZnVuY3Rpb24ocHJlcGFyZWRQYXlsb2FkLCBldmVudFNhbXBsaW5nUmF0ZSkge1xuICBjb25zdCByYW5kb21TZWVkID0gTWF0aC5yYW5kb20oKTtcbiAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfZXZlbnRUaHJvdHRsZXIpLmlzRXZlbnRUaHJvdHRsZWQocHJlcGFyZWRQYXlsb2FkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcmFuZG9tU2VlZCA8PSBfX3ByaXZhdGVHZXQodGhpcywgX2NvbmZpZykuc2FtcGxpbmdSYXRlICYmICh0eXBlb2YgZXZlbnRTYW1wbGluZ1JhdGUgPT09IFwidW5kZWZpbmVkXCIgfHwgcmFuZG9tU2VlZCA8PSBldmVudFNhbXBsaW5nUmF0ZSk7XG59O1xuc2NoZWR1bGVGbHVzaF9mbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGVsZW1ldHJ5Q29sbGVjdG9yX2luc3RhbmNlcywgZmx1c2hfZm4pLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlzQnVmZmVyRnVsbCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYnVmZmVyKS5sZW5ndGggPj0gX19wcml2YXRlR2V0KHRoaXMsIF9jb25maWcpLm1heEJ1ZmZlclNpemU7XG4gIGlmIChpc0J1ZmZlckZ1bGwpIHtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9wZW5kaW5nRmx1c2gpKSB7XG4gICAgICBjb25zdCBjYW5jZWwgPSB0eXBlb2YgY2FuY2VsSWRsZUNhbGxiYWNrICE9PSBcInVuZGVmaW5lZFwiID8gY2FuY2VsSWRsZUNhbGxiYWNrIDogY2xlYXJUaW1lb3V0O1xuICAgICAgY2FuY2VsKF9fcHJpdmF0ZUdldCh0aGlzLCBfcGVuZGluZ0ZsdXNoKSk7XG4gICAgfVxuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGVsZW1ldHJ5Q29sbGVjdG9yX2luc3RhbmNlcywgZmx1c2hfZm4pLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX3BlbmRpbmdGbHVzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKFwicmVxdWVzdElkbGVDYWxsYmFja1wiIGluIHdpbmRvdykge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcGVuZGluZ0ZsdXNoLCByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGVsZW1ldHJ5Q29sbGVjdG9yX2luc3RhbmNlcywgZmx1c2hfZm4pLmNhbGwodGhpcyk7XG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcGVuZGluZ0ZsdXNoLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVGVsZW1ldHJ5Q29sbGVjdG9yX2luc3RhbmNlcywgZmx1c2hfZm4pLmNhbGwodGhpcyk7XG4gICAgfSwgMCkpO1xuICB9XG59O1xuZmx1c2hfZm4gPSBmdW5jdGlvbigpIHtcbiAgZmV0Y2gobmV3IFVSTChcIi92MS9ldmVudFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2NvbmZpZykuZW5kcG9pbnQpLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAvLyBUT0RPOiBXZSBzZW5kIGFuIGFycmF5IGhlcmUgd2l0aCB0aGF0IGlkZWEgdGhhdCB3ZSBjYW4gZXZlbnR1YWxseSBzZW5kIG11bHRpcGxlIGV2ZW50cy5cbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBldmVudHM6IF9fcHJpdmF0ZUdldCh0aGlzLCBfYnVmZmVyKVxuICAgIH0pLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfVxuICB9KS5jYXRjaCgoKSA9PiB2b2lkIDApLnRoZW4oKCkgPT4ge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYnVmZmVyLCBbXSk7XG4gIH0pLmNhdGNoKCgpID0+IHZvaWQgMCk7XG59O1xuLyoqXG4gKiBJZiBydW5uaW5nIGluIGRlYnVnIG1vZGUsIGxvZyB0aGUgZXZlbnQgYW5kIGl0cyBwYXlsb2FkIHRvIHRoZSBjb25zb2xlLlxuICovXG5sb2dFdmVudF9mbiA9IGZ1bmN0aW9uKGV2ZW50LCBwYXlsb2FkKSB7XG4gIGlmICghdGhpcy5pc0RlYnVnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgY29uc29sZS5ncm91cENvbGxhcHNlZCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJbY2xlcmsvdGVsZW1ldHJ5XVwiLCBldmVudCk7XG4gICAgY29uc29sZS5sb2cocGF5bG9hZCk7XG4gICAgY29uc29sZS5ncm91cEVuZCgpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKFwiW2NsZXJrL3RlbGVtZXRyeV1cIiwgZXZlbnQsIHBheWxvYWQpO1xuICB9XG59O1xuLyoqXG4gKiBJZiBpbiBicm93c2VyLCBhdHRlbXB0IHRvIGxhemlseSBncmFiIHRoZSBTREsgbWV0YWRhdGEgZnJvbSB0aGUgQ2xlcmsgc2luZ2xldG9uLCBvdGhlcndpc2UgZmFsbGJhY2sgdG8gdGhlIGluaXRpYWxseSBwYXNzZWQgaW4gdmFsdWVzLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIHNka01ldGFkYXRhIGNhbiBiZSBzZXQgYnkgdGhlIGhvc3QgU0RLIGFmdGVyIHRoZSBUZWxlbWV0cnlDb2xsZWN0b3IgaXMgaW5zdGFudGlhdGVkLlxuICovXG5nZXRTREtNZXRhZGF0YV9mbiA9IGZ1bmN0aW9uKCkge1xuICBsZXQgc2RrTWV0YWRhdGEgPSB7XG4gICAgbmFtZTogX19wcml2YXRlR2V0KHRoaXMsIF9tZXRhZGF0YSkuc2RrLFxuICAgIHZlcnNpb246IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWV0YWRhdGEpLnNka1ZlcnNpb25cbiAgfTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LkNsZXJrKSB7XG4gICAgc2RrTWV0YWRhdGEgPSB7IC4uLnNka01ldGFkYXRhLCAuLi53aW5kb3cuQ2xlcmsuY29uc3RydWN0b3Iuc2RrTWV0YWRhdGEgfTtcbiAgfVxuICByZXR1cm4gc2RrTWV0YWRhdGE7XG59O1xuLyoqXG4gKiBBcHBlbmQgcmVsZXZhbnQgbWV0YWRhdGEgZnJvbSB0aGUgQ2xlcmsgc2luZ2xldG9uIHRvIHRoZSBldmVudCBwYXlsb2FkLlxuICovXG5wcmVwYXJlUGF5bG9hZF9mbiA9IGZ1bmN0aW9uKGV2ZW50LCBwYXlsb2FkKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHNka01ldGFkYXRhID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UZWxlbWV0cnlDb2xsZWN0b3JfaW5zdGFuY2VzLCBnZXRTREtNZXRhZGF0YV9mbikuY2FsbCh0aGlzKTtcbiAgcmV0dXJuIHtcbiAgICBldmVudCxcbiAgICBjdjogKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9tZXRhZGF0YSkuY2xlcmtWZXJzaW9uKSAhPSBudWxsID8gX2EgOiBcIlwiLFxuICAgIGl0OiAoX2IgPSBfX3ByaXZhdGVHZXQodGhpcywgX21ldGFkYXRhKS5pbnN0YW5jZVR5cGUpICE9IG51bGwgPyBfYiA6IFwiXCIsXG4gICAgc2RrOiBzZGtNZXRhZGF0YS5uYW1lLFxuICAgIHNka3Y6IHNka01ldGFkYXRhLnZlcnNpb24sXG4gICAgLi4uX19wcml2YXRlR2V0KHRoaXMsIF9tZXRhZGF0YSkucHVibGlzaGFibGVLZXkgPyB7IHBrOiBfX3ByaXZhdGVHZXQodGhpcywgX21ldGFkYXRhKS5wdWJsaXNoYWJsZUtleSB9IDoge30sXG4gICAgLi4uX19wcml2YXRlR2V0KHRoaXMsIF9tZXRhZGF0YSkuc2VjcmV0S2V5ID8geyBzazogX19wcml2YXRlR2V0KHRoaXMsIF9tZXRhZGF0YSkuc2VjcmV0S2V5IH0gOiB7fSxcbiAgICBwYXlsb2FkXG4gIH07XG59O1xuXG4vLyBzcmMvdGVsZW1ldHJ5L2V2ZW50cy9jb21wb25lbnQtbW91bnRlZC50c1xudmFyIEVWRU5UX0NPTVBPTkVOVF9NT1VOVEVEID0gXCJDT01QT05FTlRfTU9VTlRFRFwiO1xudmFyIEVWRU5UX1NBTVBMSU5HX1JBVEUgPSAwLjE7XG5mdW5jdGlvbiBldmVudFByZWJ1aWx0Q29tcG9uZW50TW91bnRlZChjb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICByZXR1cm4ge1xuICAgIGV2ZW50OiBFVkVOVF9DT01QT05FTlRfTU9VTlRFRCxcbiAgICBldmVudFNhbXBsaW5nUmF0ZTogRVZFTlRfU0FNUExJTkdfUkFURSxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBjb21wb25lbnQsXG4gICAgICBhcHBlYXJhbmNlUHJvcDogQm9vbGVhbihwcm9wcyA9PSBudWxsID8gdm9pZCAwIDogcHJvcHMuYXBwZWFyYW5jZSksXG4gICAgICBiYXNlVGhlbWU6IEJvb2xlYW4oKF9hID0gcHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3BzLmFwcGVhcmFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5iYXNlVGhlbWUpLFxuICAgICAgZWxlbWVudHM6IEJvb2xlYW4oKF9iID0gcHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3BzLmFwcGVhcmFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYi5lbGVtZW50cyksXG4gICAgICB2YXJpYWJsZXM6IEJvb2xlYW4oKF9jID0gcHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3BzLmFwcGVhcmFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy52YXJpYWJsZXMpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZXZlbnRDb21wb25lbnRNb3VudGVkKGNvbXBvbmVudCwgcHJvcHMgPSB7fSkge1xuICByZXR1cm4ge1xuICAgIGV2ZW50OiBFVkVOVF9DT01QT05FTlRfTU9VTlRFRCxcbiAgICBldmVudFNhbXBsaW5nUmF0ZTogRVZFTlRfU0FNUExJTkdfUkFURSxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBjb21wb25lbnQsXG4gICAgICAuLi5wcm9wc1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIFRlbGVtZXRyeUNvbGxlY3RvcixcbiAgZXZlbnRDb21wb25lbnRNb3VudGVkLFxuICBldmVudE1ldGhvZENhbGxlZCxcbiAgZXZlbnRQcmVidWlsdENvbXBvbmVudE1vdW50ZWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZWxlbWV0cnkubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@clerk/shared/dist/telemetry.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-avatar/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@radix-ui/react-avatar/dist/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Avatar: function() { return /* binding */ Avatar; },\n/* harmony export */   AvatarFallback: function() { return /* binding */ AvatarFallback; },\n/* harmony export */   AvatarImage: function() { return /* binding */ AvatarImage; },\n/* harmony export */   Fallback: function() { return /* binding */ Fallback; },\n/* harmony export */   Image: function() { return /* binding */ Image; },\n/* harmony export */   Root: function() { return /* binding */ Root; },\n/* harmony export */   createAvatarScope: function() { return /* binding */ createAvatarScope; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _radix_ui_react_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @radix-ui/react-context */ \"(app-pages-browser)/./node_modules/@radix-ui/react-context/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_use_callback_ref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @radix-ui/react-use-callback-ref */ \"(app-pages-browser)/./node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_use_layout_effect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @radix-ui/react-use-layout-effect */ \"(app-pages-browser)/./node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @radix-ui/react-primitive */ \"(app-pages-browser)/./node_modules/@radix-ui/react-primitive/dist/index.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n\"use client\";\n\n// packages/react/avatar/src/Avatar.tsx\n\n\n\n\n\n\nvar AVATAR_NAME = \"Avatar\";\nvar [createAvatarContext, createAvatarScope] = (0,_radix_ui_react_context__WEBPACK_IMPORTED_MODULE_2__.createContextScope)(AVATAR_NAME);\nvar [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);\nvar Avatar = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeAvatar, ...avatarProps } = props;\n    const [imageLoadingStatus, setImageLoadingStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"idle\");\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      AvatarProvider,\n      {\n        scope: __scopeAvatar,\n        imageLoadingStatus,\n        onImageLoadingStatusChange: setImageLoadingStatus,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_3__.Primitive.span, { ...avatarProps, ref: forwardedRef })\n      }\n    );\n  }\n);\nAvatar.displayName = AVATAR_NAME;\nvar IMAGE_NAME = \"AvatarImage\";\nvar AvatarImage = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeAvatar, src, onLoadingStatusChange = () => {\n    }, ...imageProps } = props;\n    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);\n    const imageLoadingStatus = useImageLoadingStatus(src, imageProps.referrerPolicy);\n    const handleLoadingStatusChange = (0,_radix_ui_react_use_callback_ref__WEBPACK_IMPORTED_MODULE_4__.useCallbackRef)((status) => {\n      onLoadingStatusChange(status);\n      context.onImageLoadingStatusChange(status);\n    });\n    (0,_radix_ui_react_use_layout_effect__WEBPACK_IMPORTED_MODULE_5__.useLayoutEffect)(() => {\n      if (imageLoadingStatus !== \"idle\") {\n        handleLoadingStatusChange(imageLoadingStatus);\n      }\n    }, [imageLoadingStatus, handleLoadingStatusChange]);\n    return imageLoadingStatus === \"loaded\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_3__.Primitive.img, { ...imageProps, ref: forwardedRef, src }) : null;\n  }\n);\nAvatarImage.displayName = IMAGE_NAME;\nvar FALLBACK_NAME = \"AvatarFallback\";\nvar AvatarFallback = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeAvatar, delayMs, ...fallbackProps } = props;\n    const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);\n    const [canRender, setCanRender] = react__WEBPACK_IMPORTED_MODULE_0__.useState(delayMs === void 0);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      if (delayMs !== void 0) {\n        const timerId = window.setTimeout(() => setCanRender(true), delayMs);\n        return () => window.clearTimeout(timerId);\n      }\n    }, [delayMs]);\n    return canRender && context.imageLoadingStatus !== \"loaded\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_3__.Primitive.span, { ...fallbackProps, ref: forwardedRef }) : null;\n  }\n);\nAvatarFallback.displayName = FALLBACK_NAME;\nfunction useImageLoadingStatus(src, referrerPolicy) {\n  const [loadingStatus, setLoadingStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"idle\");\n  (0,_radix_ui_react_use_layout_effect__WEBPACK_IMPORTED_MODULE_5__.useLayoutEffect)(() => {\n    if (!src) {\n      setLoadingStatus(\"error\");\n      return;\n    }\n    let isMounted = true;\n    const image = new window.Image();\n    const updateStatus = (status) => () => {\n      if (!isMounted) return;\n      setLoadingStatus(status);\n    };\n    setLoadingStatus(\"loading\");\n    image.onload = updateStatus(\"loaded\");\n    image.onerror = updateStatus(\"error\");\n    image.src = src;\n    if (referrerPolicy) {\n      image.referrerPolicy = referrerPolicy;\n    }\n    return () => {\n      isMounted = false;\n    };\n  }, [src, referrerPolicy]);\n  return loadingStatus;\n}\nvar Root = Avatar;\nvar Image = AvatarImage;\nvar Fallback = AvatarFallback;\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtYXZhdGFyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUMrQjtBQUM4QjtBQUNLO0FBQ0U7QUFDZDtBQUNkO0FBQ3hDO0FBQ0EsK0NBQStDLDJFQUFrQjtBQUNqRTtBQUNBLGFBQWEsNkNBQWdCO0FBQzdCO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUMsd0RBQXdELDJDQUFjO0FBQ3RFLDJCQUEyQixzREFBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNEQUFHLENBQUMsZ0VBQVMsU0FBUyxtQ0FBbUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZDQUFnQjtBQUNsQztBQUNBLFlBQVk7QUFDWixLQUFLLGtCQUFrQjtBQUN2QjtBQUNBO0FBQ0Esc0NBQXNDLGdGQUFjO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxrRkFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkRBQTZELHNEQUFHLENBQUMsZ0VBQVMsUUFBUSx1Q0FBdUM7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQWdCO0FBQ3JDO0FBQ0EsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQSxzQ0FBc0MsMkNBQWM7QUFDcEQsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrRkFBa0Ysc0RBQUcsQ0FBQyxnRUFBUyxTQUFTLHFDQUFxQztBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywyQ0FBYztBQUMxRCxFQUFFLGtGQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1hdmF0YXIvZGlzdC9pbmRleC5tanM/ZTBkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3QvYXZhdGFyL3NyYy9BdmF0YXIudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHRTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29udGV4dFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2tSZWYgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1jYWxsYmFjay1yZWZcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBVkFUQVJfTkFNRSA9IFwiQXZhdGFyXCI7XG52YXIgW2NyZWF0ZUF2YXRhckNvbnRleHQsIGNyZWF0ZUF2YXRhclNjb3BlXSA9IGNyZWF0ZUNvbnRleHRTY29wZShBVkFUQVJfTkFNRSk7XG52YXIgW0F2YXRhclByb3ZpZGVyLCB1c2VBdmF0YXJDb250ZXh0XSA9IGNyZWF0ZUF2YXRhckNvbnRleHQoQVZBVEFSX05BTUUpO1xudmFyIEF2YXRhciA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlQXZhdGFyLCAuLi5hdmF0YXJQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgW2ltYWdlTG9hZGluZ1N0YXR1cywgc2V0SW1hZ2VMb2FkaW5nU3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlKFwiaWRsZVwiKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIEF2YXRhclByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICBzY29wZTogX19zY29wZUF2YXRhcixcbiAgICAgICAgaW1hZ2VMb2FkaW5nU3RhdHVzLFxuICAgICAgICBvbkltYWdlTG9hZGluZ1N0YXR1c0NoYW5nZTogc2V0SW1hZ2VMb2FkaW5nU3RhdHVzLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuc3BhbiwgeyAuLi5hdmF0YXJQcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuQXZhdGFyLmRpc3BsYXlOYW1lID0gQVZBVEFSX05BTUU7XG52YXIgSU1BR0VfTkFNRSA9IFwiQXZhdGFySW1hZ2VcIjtcbnZhciBBdmF0YXJJbWFnZSA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlQXZhdGFyLCBzcmMsIG9uTG9hZGluZ1N0YXR1c0NoYW5nZSA9ICgpID0+IHtcbiAgICB9LCAuLi5pbWFnZVByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQXZhdGFyQ29udGV4dChJTUFHRV9OQU1FLCBfX3Njb3BlQXZhdGFyKTtcbiAgICBjb25zdCBpbWFnZUxvYWRpbmdTdGF0dXMgPSB1c2VJbWFnZUxvYWRpbmdTdGF0dXMoc3JjLCBpbWFnZVByb3BzLnJlZmVycmVyUG9saWN5KTtcbiAgICBjb25zdCBoYW5kbGVMb2FkaW5nU3RhdHVzQ2hhbmdlID0gdXNlQ2FsbGJhY2tSZWYoKHN0YXR1cykgPT4ge1xuICAgICAgb25Mb2FkaW5nU3RhdHVzQ2hhbmdlKHN0YXR1cyk7XG4gICAgICBjb250ZXh0Lm9uSW1hZ2VMb2FkaW5nU3RhdHVzQ2hhbmdlKHN0YXR1cyk7XG4gICAgfSk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpbWFnZUxvYWRpbmdTdGF0dXMgIT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGhhbmRsZUxvYWRpbmdTdGF0dXNDaGFuZ2UoaW1hZ2VMb2FkaW5nU3RhdHVzKTtcbiAgICAgIH1cbiAgICB9LCBbaW1hZ2VMb2FkaW5nU3RhdHVzLCBoYW5kbGVMb2FkaW5nU3RhdHVzQ2hhbmdlXSk7XG4gICAgcmV0dXJuIGltYWdlTG9hZGluZ1N0YXR1cyA9PT0gXCJsb2FkZWRcIiA/IC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmltZywgeyAuLi5pbWFnZVByb3BzLCByZWY6IGZvcndhcmRlZFJlZiwgc3JjIH0pIDogbnVsbDtcbiAgfVxuKTtcbkF2YXRhckltYWdlLmRpc3BsYXlOYW1lID0gSU1BR0VfTkFNRTtcbnZhciBGQUxMQkFDS19OQU1FID0gXCJBdmF0YXJGYWxsYmFja1wiO1xudmFyIEF2YXRhckZhbGxiYWNrID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVBdmF0YXIsIGRlbGF5TXMsIC4uLmZhbGxiYWNrUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VBdmF0YXJDb250ZXh0KEZBTExCQUNLX05BTUUsIF9fc2NvcGVBdmF0YXIpO1xuICAgIGNvbnN0IFtjYW5SZW5kZXIsIHNldENhblJlbmRlcl0gPSBSZWFjdC51c2VTdGF0ZShkZWxheU1zID09PSB2b2lkIDApO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoZGVsYXlNcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHRpbWVySWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzZXRDYW5SZW5kZXIodHJ1ZSksIGRlbGF5TXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4gd2luZG93LmNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgIH1cbiAgICB9LCBbZGVsYXlNc10pO1xuICAgIHJldHVybiBjYW5SZW5kZXIgJiYgY29udGV4dC5pbWFnZUxvYWRpbmdTdGF0dXMgIT09IFwibG9hZGVkXCIgPyAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5zcGFuLCB7IC4uLmZhbGxiYWNrUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pIDogbnVsbDtcbiAgfVxuKTtcbkF2YXRhckZhbGxiYWNrLmRpc3BsYXlOYW1lID0gRkFMTEJBQ0tfTkFNRTtcbmZ1bmN0aW9uIHVzZUltYWdlTG9hZGluZ1N0YXR1cyhzcmMsIHJlZmVycmVyUG9saWN5KSB7XG4gIGNvbnN0IFtsb2FkaW5nU3RhdHVzLCBzZXRMb2FkaW5nU3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlKFwiaWRsZVwiKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNyYykge1xuICAgICAgc2V0TG9hZGluZ1N0YXR1cyhcImVycm9yXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcbiAgICBjb25zdCB1cGRhdGVTdGF0dXMgPSAoc3RhdHVzKSA9PiAoKSA9PiB7XG4gICAgICBpZiAoIWlzTW91bnRlZCkgcmV0dXJuO1xuICAgICAgc2V0TG9hZGluZ1N0YXR1cyhzdGF0dXMpO1xuICAgIH07XG4gICAgc2V0TG9hZGluZ1N0YXR1cyhcImxvYWRpbmdcIik7XG4gICAgaW1hZ2Uub25sb2FkID0gdXBkYXRlU3RhdHVzKFwibG9hZGVkXCIpO1xuICAgIGltYWdlLm9uZXJyb3IgPSB1cGRhdGVTdGF0dXMoXCJlcnJvclwiKTtcbiAgICBpbWFnZS5zcmMgPSBzcmM7XG4gICAgaWYgKHJlZmVycmVyUG9saWN5KSB7XG4gICAgICBpbWFnZS5yZWZlcnJlclBvbGljeSA9IHJlZmVycmVyUG9saWN5O1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW3NyYywgcmVmZXJyZXJQb2xpY3ldKTtcbiAgcmV0dXJuIGxvYWRpbmdTdGF0dXM7XG59XG52YXIgUm9vdCA9IEF2YXRhcjtcbnZhciBJbWFnZSA9IEF2YXRhckltYWdlO1xudmFyIEZhbGxiYWNrID0gQXZhdGFyRmFsbGJhY2s7XG5leHBvcnQge1xuICBBdmF0YXIsXG4gIEF2YXRhckZhbGxiYWNrLFxuICBBdmF0YXJJbWFnZSxcbiAgRmFsbGJhY2ssXG4gIEltYWdlLFxuICBSb290LFxuICBjcmVhdGVBdmF0YXJTY29wZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-avatar/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-compose-refs/dist/index.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@radix-ui/react-compose-refs/dist/index.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   composeRefs: function() { return /* binding */ composeRefs; },\n/* harmony export */   useComposedRefs: function() { return /* binding */ useComposedRefs; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n// packages/react/compose-refs/src/composeRefs.tsx\n\nfunction setRef(ref, value) {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (ref !== null && ref !== void 0) {\n    ref.current = value;\n  }\n}\nfunction composeRefs(...refs) {\n  return (node) => refs.forEach((ref) => setRef(ref, node));\n}\nfunction useComposedRefs(...refs) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(composeRefs(...refs), refs);\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQytCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOENBQWlCO0FBQzFCO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWNvbXBvc2UtcmVmcy9kaXN0L2luZGV4Lm1qcz8zOTcwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhY2thZ2VzL3JlYWN0L2NvbXBvc2UtcmVmcy9zcmMvY29tcG9zZVJlZnMudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHNldFJlZihyZWYsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZWYodmFsdWUpO1xuICB9IGVsc2UgaWYgKHJlZiAhPT0gbnVsbCAmJiByZWYgIT09IHZvaWQgMCkge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VSZWZzKC4uLnJlZnMpIHtcbiAgcmV0dXJuIChub2RlKSA9PiByZWZzLmZvckVhY2goKHJlZikgPT4gc2V0UmVmKHJlZiwgbm9kZSkpO1xufVxuZnVuY3Rpb24gdXNlQ29tcG9zZWRSZWZzKC4uLnJlZnMpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGNvbXBvc2VSZWZzKC4uLnJlZnMpLCByZWZzKTtcbn1cbmV4cG9ydCB7XG4gIGNvbXBvc2VSZWZzLFxuICB1c2VDb21wb3NlZFJlZnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-compose-refs/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-context/dist/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@radix-ui/react-context/dist/index.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createContext: function() { return /* binding */ createContext2; },\n/* harmony export */   createContextScope: function() { return /* binding */ createContextScope; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n// packages/react/context/src/createContext.tsx\n\n\nfunction createContext2(rootComponentName, defaultContext) {\n  const Context = react__WEBPACK_IMPORTED_MODULE_0__.createContext(defaultContext);\n  const Provider = (props) => {\n    const { children, ...context } = props;\n    const value = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => context, Object.values(context));\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Context.Provider, { value, children });\n  };\n  Provider.displayName = rootComponentName + \"Provider\";\n  function useContext2(consumerName) {\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== void 0) return defaultContext;\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n  return [Provider, useContext2];\n}\nfunction createContextScope(scopeName, createContextScopeDeps = []) {\n  let defaultContexts = [];\n  function createContext3(rootComponentName, defaultContext) {\n    const BaseContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n    const Provider = (props) => {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const value = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => context, Object.values(context));\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Context.Provider, { value, children });\n    };\n    Provider.displayName = rootComponentName + \"Provider\";\n    function useContext2(consumerName, scope) {\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== void 0) return defaultContext;\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n    return [Provider, useContext2];\n  }\n  const createScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return react__WEBPACK_IMPORTED_MODULE_0__.createContext(defaultContext);\n    });\n    return function useScope(scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n  createScope.scopeName = scopeName;\n  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];\n}\nfunction composeContextScopes(...scopes) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n  const createScope = () => {\n    const scopeHooks = scopes.map((createScope2) => ({\n      useScope: createScope2(),\n      scopeName: createScope2.scopeName\n    }));\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes2, ...currentScope };\n      }, {});\n      return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtY29udGV4dC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDK0I7QUFDUztBQUN4QztBQUNBLGtCQUFrQixnREFBbUI7QUFDckM7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQyxrQkFBa0IsMENBQWE7QUFDL0IsMkJBQTJCLHNEQUFHLHFCQUFxQixpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUFnQjtBQUNwQztBQUNBO0FBQ0EseUJBQXlCLGFBQWEsMkJBQTJCLGtCQUFrQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0Esb0JBQW9CLDBDQUFhO0FBQ2pDLDZCQUE2QixzREFBRyxxQkFBcUIsaUJBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFnQjtBQUN0QztBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsMkJBQTJCLGtCQUFrQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnREFBbUI7QUFDaEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLDBDQUFhO0FBQzFCLGlCQUFpQixXQUFXLFVBQVUsTUFBTSxtQ0FBbUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJEQUEyRCxxQkFBcUI7QUFDaEY7QUFDQSxrREFBa0QsVUFBVTtBQUM1RCxpQkFBaUI7QUFDakIsT0FBTyxJQUFJO0FBQ1gsYUFBYSwwQ0FBYSxVQUFVLFdBQVcsb0JBQW9CLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWNvbnRleHQvZGlzdC9pbmRleC5tanM/ODYwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwYWNrYWdlcy9yZWFjdC9jb250ZXh0L3NyYy9jcmVhdGVDb250ZXh0LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQyKHJvb3RDb21wb25lbnROYW1lLCBkZWZhdWx0Q29udGV4dCkge1xuICBjb25zdCBDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0Q29udGV4dCk7XG4gIGNvbnN0IFByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4uY29udGV4dCB9ID0gcHJvcHM7XG4gICAgY29uc3QgdmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNvbnRleHQsIE9iamVjdC52YWx1ZXMoY29udGV4dCkpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWUsIGNoaWxkcmVuIH0pO1xuICB9O1xuICBQcm92aWRlci5kaXNwbGF5TmFtZSA9IHJvb3RDb21wb25lbnROYW1lICsgXCJQcm92aWRlclwiO1xuICBmdW5jdGlvbiB1c2VDb250ZXh0Mihjb25zdW1lck5hbWUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0KTtcbiAgICBpZiAoY29udGV4dCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgaWYgKGRlZmF1bHRDb250ZXh0ICE9PSB2b2lkIDApIHJldHVybiBkZWZhdWx0Q29udGV4dDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYCR7Y29uc3VtZXJOYW1lfVxcYCBtdXN0IGJlIHVzZWQgd2l0aGluIFxcYCR7cm9vdENvbXBvbmVudE5hbWV9XFxgYCk7XG4gIH1cbiAgcmV0dXJuIFtQcm92aWRlciwgdXNlQ29udGV4dDJdO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dFNjb3BlKHNjb3BlTmFtZSwgY3JlYXRlQ29udGV4dFNjb3BlRGVwcyA9IFtdKSB7XG4gIGxldCBkZWZhdWx0Q29udGV4dHMgPSBbXTtcbiAgZnVuY3Rpb24gY3JlYXRlQ29udGV4dDMocm9vdENvbXBvbmVudE5hbWUsIGRlZmF1bHRDb250ZXh0KSB7XG4gICAgY29uc3QgQmFzZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGRlZmF1bHRDb250ZXh0KTtcbiAgICBjb25zdCBpbmRleCA9IGRlZmF1bHRDb250ZXh0cy5sZW5ndGg7XG4gICAgZGVmYXVsdENvbnRleHRzID0gWy4uLmRlZmF1bHRDb250ZXh0cywgZGVmYXVsdENvbnRleHRdO1xuICAgIGNvbnN0IFByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gICAgICBjb25zdCB7IHNjb3BlLCBjaGlsZHJlbiwgLi4uY29udGV4dCB9ID0gcHJvcHM7XG4gICAgICBjb25zdCBDb250ZXh0ID0gc2NvcGU/LltzY29wZU5hbWVdPy5baW5kZXhdIHx8IEJhc2VDb250ZXh0O1xuICAgICAgY29uc3QgdmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNvbnRleHQsIE9iamVjdC52YWx1ZXMoY29udGV4dCkpO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZSwgY2hpbGRyZW4gfSk7XG4gICAgfTtcbiAgICBQcm92aWRlci5kaXNwbGF5TmFtZSA9IHJvb3RDb21wb25lbnROYW1lICsgXCJQcm92aWRlclwiO1xuICAgIGZ1bmN0aW9uIHVzZUNvbnRleHQyKGNvbnN1bWVyTmFtZSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IENvbnRleHQgPSBzY29wZT8uW3Njb3BlTmFtZV0/LltpbmRleF0gfHwgQmFzZUNvbnRleHQ7XG4gICAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0KTtcbiAgICAgIGlmIChjb250ZXh0KSByZXR1cm4gY29udGV4dDtcbiAgICAgIGlmIChkZWZhdWx0Q29udGV4dCAhPT0gdm9pZCAwKSByZXR1cm4gZGVmYXVsdENvbnRleHQ7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYCR7Y29uc3VtZXJOYW1lfVxcYCBtdXN0IGJlIHVzZWQgd2l0aGluIFxcYCR7cm9vdENvbXBvbmVudE5hbWV9XFxgYCk7XG4gICAgfVxuICAgIHJldHVybiBbUHJvdmlkZXIsIHVzZUNvbnRleHQyXTtcbiAgfVxuICBjb25zdCBjcmVhdGVTY29wZSA9ICgpID0+IHtcbiAgICBjb25zdCBzY29wZUNvbnRleHRzID0gZGVmYXVsdENvbnRleHRzLm1hcCgoZGVmYXVsdENvbnRleHQpID0+IHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVDb250ZXh0KGRlZmF1bHRDb250ZXh0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXNlU2NvcGUoc2NvcGUpIHtcbiAgICAgIGNvbnN0IGNvbnRleHRzID0gc2NvcGU/LltzY29wZU5hbWVdIHx8IHNjb3BlQ29udGV4dHM7XG4gICAgICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAgICAgKCkgPT4gKHsgW2BfX3Njb3BlJHtzY29wZU5hbWV9YF06IHsgLi4uc2NvcGUsIFtzY29wZU5hbWVdOiBjb250ZXh0cyB9IH0pLFxuICAgICAgICBbc2NvcGUsIGNvbnRleHRzXVxuICAgICAgKTtcbiAgICB9O1xuICB9O1xuICBjcmVhdGVTY29wZS5zY29wZU5hbWUgPSBzY29wZU5hbWU7XG4gIHJldHVybiBbY3JlYXRlQ29udGV4dDMsIGNvbXBvc2VDb250ZXh0U2NvcGVzKGNyZWF0ZVNjb3BlLCAuLi5jcmVhdGVDb250ZXh0U2NvcGVEZXBzKV07XG59XG5mdW5jdGlvbiBjb21wb3NlQ29udGV4dFNjb3BlcyguLi5zY29wZXMpIHtcbiAgY29uc3QgYmFzZVNjb3BlID0gc2NvcGVzWzBdO1xuICBpZiAoc2NvcGVzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGJhc2VTY29wZTtcbiAgY29uc3QgY3JlYXRlU2NvcGUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2NvcGVIb29rcyA9IHNjb3Blcy5tYXAoKGNyZWF0ZVNjb3BlMikgPT4gKHtcbiAgICAgIHVzZVNjb3BlOiBjcmVhdGVTY29wZTIoKSxcbiAgICAgIHNjb3BlTmFtZTogY3JlYXRlU2NvcGUyLnNjb3BlTmFtZVxuICAgIH0pKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXNlQ29tcG9zZWRTY29wZXMob3ZlcnJpZGVTY29wZXMpIHtcbiAgICAgIGNvbnN0IG5leHRTY29wZXMgPSBzY29wZUhvb2tzLnJlZHVjZSgobmV4dFNjb3BlczIsIHsgdXNlU2NvcGUsIHNjb3BlTmFtZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHNjb3BlUHJvcHMgPSB1c2VTY29wZShvdmVycmlkZVNjb3Blcyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTY29wZSA9IHNjb3BlUHJvcHNbYF9fc2NvcGUke3Njb3BlTmFtZX1gXTtcbiAgICAgICAgcmV0dXJuIHsgLi4ubmV4dFNjb3BlczIsIC4uLmN1cnJlbnRTY29wZSB9O1xuICAgICAgfSwge30pO1xuICAgICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHsgW2BfX3Njb3BlJHtiYXNlU2NvcGUuc2NvcGVOYW1lfWBdOiBuZXh0U2NvcGVzIH0pLCBbbmV4dFNjb3Blc10pO1xuICAgIH07XG4gIH07XG4gIGNyZWF0ZVNjb3BlLnNjb3BlTmFtZSA9IGJhc2VTY29wZS5zY29wZU5hbWU7XG4gIHJldHVybiBjcmVhdGVTY29wZTtcbn1cbmV4cG9ydCB7XG4gIGNyZWF0ZUNvbnRleHQyIGFzIGNyZWF0ZUNvbnRleHQsXG4gIGNyZWF0ZUNvbnRleHRTY29wZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-context/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-primitive/dist/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@radix-ui/react-primitive/dist/index.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Primitive: function() { return /* binding */ Primitive; },\n/* harmony export */   Root: function() { return /* binding */ Root; },\n/* harmony export */   dispatchDiscreteCustomEvent: function() { return /* binding */ dispatchDiscreteCustomEvent; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(app-pages-browser)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n// packages/react/primitive/src/Primitive.tsx\n\n\n\n\nvar NODES = [\n  \"a\",\n  \"button\",\n  \"div\",\n  \"form\",\n  \"h2\",\n  \"h3\",\n  \"img\",\n  \"input\",\n  \"label\",\n  \"li\",\n  \"nav\",\n  \"ol\",\n  \"p\",\n  \"span\",\n  \"svg\",\n  \"ul\"\n];\nvar Primitive = NODES.reduce((primitive, node) => {\n  const Node = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_3__.Slot : node;\n    if (typeof window !== \"undefined\") {\n      window[Symbol.for(\"radix-ui\")] = true;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });\n  });\n  Node.displayName = `Primitive.${node}`;\n  return { ...primitive, [node]: Node };\n}, {});\nfunction dispatchDiscreteCustomEvent(target, event) {\n  if (target) react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(() => target.dispatchEvent(event));\n}\nvar Root = Primitive;\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUMrQjtBQUNPO0FBQ007QUFDSjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkNBQWdCO0FBQy9CLFlBQVksNkJBQTZCO0FBQ3pDLDJCQUEyQixzREFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0RBQUcsU0FBUyxzQ0FBc0M7QUFDN0UsR0FBRztBQUNILGtDQUFrQyxLQUFLO0FBQ3ZDLFdBQVc7QUFDWCxDQUFDLElBQUk7QUFDTDtBQUNBLGNBQWMsZ0RBQWtCO0FBQ2hDO0FBQ0E7QUFLRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlL2Rpc3QvaW5kZXgubWpzP2FiYTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFja2FnZXMvcmVhY3QvcHJpbWl0aXZlL3NyYy9QcmltaXRpdmUudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IFNsb3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXNsb3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE5PREVTID0gW1xuICBcImFcIixcbiAgXCJidXR0b25cIixcbiAgXCJkaXZcIixcbiAgXCJmb3JtXCIsXG4gIFwiaDJcIixcbiAgXCJoM1wiLFxuICBcImltZ1wiLFxuICBcImlucHV0XCIsXG4gIFwibGFiZWxcIixcbiAgXCJsaVwiLFxuICBcIm5hdlwiLFxuICBcIm9sXCIsXG4gIFwicFwiLFxuICBcInNwYW5cIixcbiAgXCJzdmdcIixcbiAgXCJ1bFwiXG5dO1xudmFyIFByaW1pdGl2ZSA9IE5PREVTLnJlZHVjZSgocHJpbWl0aXZlLCBub2RlKSA9PiB7XG4gIGNvbnN0IE5vZGUgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBhc0NoaWxkLCAuLi5wcmltaXRpdmVQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgQ29tcCA9IGFzQ2hpbGQgPyBTbG90IDogbm9kZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93W1N5bWJvbC5mb3IoXCJyYWRpeC11aVwiKV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDb21wLCB7IC4uLnByaW1pdGl2ZVByb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KTtcbiAgfSk7XG4gIE5vZGUuZGlzcGxheU5hbWUgPSBgUHJpbWl0aXZlLiR7bm9kZX1gO1xuICByZXR1cm4geyAuLi5wcmltaXRpdmUsIFtub2RlXTogTm9kZSB9O1xufSwge30pO1xuZnVuY3Rpb24gZGlzcGF0Y2hEaXNjcmV0ZUN1c3RvbUV2ZW50KHRhcmdldCwgZXZlbnQpIHtcbiAgaWYgKHRhcmdldCkgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KSk7XG59XG52YXIgUm9vdCA9IFByaW1pdGl2ZTtcbmV4cG9ydCB7XG4gIFByaW1pdGl2ZSxcbiAgUm9vdCxcbiAgZGlzcGF0Y2hEaXNjcmV0ZUN1c3RvbUV2ZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-primitive/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-slot/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@radix-ui/react-slot/dist/index.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Root: function() { return /* binding */ Root; },\n/* harmony export */   Slot: function() { return /* binding */ Slot; },\n/* harmony export */   Slottable: function() { return /* binding */ Slottable; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @radix-ui/react-compose-refs */ \"(app-pages-browser)/./node_modules/@radix-ui/react-compose-refs/dist/index.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n// packages/react/slot/src/Slot.tsx\n\n\n\nvar Slot = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childrenArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);\n  const slottable = childrenArray.find(isSlottable);\n  if (slottable) {\n    const newElement = slottable.props.children;\n    const newChildren = childrenArray.map((child) => {\n      if (child === slottable) {\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(newElement) > 1) return react__WEBPACK_IMPORTED_MODULE_0__.Children.only(null);\n        return react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(newElement) ? newElement.props.children : null;\n      } else {\n        return child;\n      }\n    });\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(newElement) ? react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(newElement, void 0, newChildren) : null });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });\n});\nSlot.displayName = \"Slot\";\nvar SlotClone = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  if (react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(children)) {\n    const childrenRef = getElementRef(children);\n    return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(children, {\n      ...mergeProps(slotProps, children.props),\n      // @ts-ignore\n      ref: forwardedRef ? (0,_radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_2__.composeRefs)(forwardedRef, childrenRef) : childrenRef\n    });\n  }\n  return react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children) > 1 ? react__WEBPACK_IMPORTED_MODULE_0__.Children.only(null) : null;\n});\nSlotClone.displayName = \"SlotClone\";\nvar Slottable = ({ children }) => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children });\n};\nfunction isSlottable(child) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(child) && child.type === Slottable;\n}\nfunction mergeProps(slotProps, childProps) {\n  const overrideProps = { ...childProps };\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args) => {\n          childPropValue(...args);\n          slotPropValue(...args);\n        };\n      } else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    } else if (propName === \"style\") {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === \"className\") {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(\" \");\n    }\n  }\n  return { ...slotProps, ...overrideProps };\n}\nfunction getElementRef(element) {\n  let getter = Object.getOwnPropertyDescriptor(element.props, \"ref\")?.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.ref;\n  }\n  getter = Object.getOwnPropertyDescriptor(element, \"ref\")?.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n  return element.props.ref || element.ref;\n}\nvar Root = Slot;\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3Qtc2xvdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUMrQjtBQUM0QjtBQUNUO0FBQ2xELFdBQVcsNkNBQWdCO0FBQzNCLFVBQVUseUJBQXlCO0FBQ25DLHdCQUF3QiwyQ0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBYywrQkFBK0IsMkNBQWM7QUFDdkUsZUFBZSxpREFBb0I7QUFDbkMsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLHNEQUFHLGNBQWMsMkNBQTJDLGlEQUFvQixlQUFlLCtDQUFrQiwwQ0FBMEM7QUFDdEw7QUFDQSx5QkFBeUIsc0RBQUcsY0FBYywyQ0FBMkM7QUFDckYsQ0FBQztBQUNEO0FBQ0EsZ0JBQWdCLDZDQUFnQjtBQUNoQyxVQUFVLHlCQUF5QjtBQUNuQyxNQUFNLGlEQUFvQjtBQUMxQjtBQUNBLFdBQVcsK0NBQWtCO0FBQzdCO0FBQ0E7QUFDQSwwQkFBMEIseUVBQVc7QUFDckMsS0FBSztBQUNMO0FBQ0EsU0FBUywyQ0FBYyx1QkFBdUIsMkNBQWM7QUFDNUQsQ0FBQztBQUNEO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0IseUJBQXlCLHNEQUFHLENBQUMsdURBQVEsSUFBSSxVQUFVO0FBQ25EO0FBQ0E7QUFDQSxTQUFTLGlEQUFvQjtBQUM3QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0NBQWtDO0FBQ2xDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXNsb3QvZGlzdC9pbmRleC5tanM/MmU5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwYWNrYWdlcy9yZWFjdC9zbG90L3NyYy9TbG90LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjb21wb3NlUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBGcmFnbWVudCwganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgU2xvdCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4uc2xvdFByb3BzIH0gPSBwcm9wcztcbiAgY29uc3QgY2hpbGRyZW5BcnJheSA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuICBjb25zdCBzbG90dGFibGUgPSBjaGlsZHJlbkFycmF5LmZpbmQoaXNTbG90dGFibGUpO1xuICBpZiAoc2xvdHRhYmxlKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IHNsb3R0YWJsZS5wcm9wcy5jaGlsZHJlbjtcbiAgICBjb25zdCBuZXdDaGlsZHJlbiA9IGNoaWxkcmVuQXJyYXkubWFwKChjaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkID09PSBzbG90dGFibGUpIHtcbiAgICAgICAgaWYgKFJlYWN0LkNoaWxkcmVuLmNvdW50KG5ld0VsZW1lbnQpID4gMSkgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLm9ubHkobnVsbCk7XG4gICAgICAgIHJldHVybiBSZWFjdC5pc1ZhbGlkRWxlbWVudChuZXdFbGVtZW50KSA/IG5ld0VsZW1lbnQucHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNsb3RDbG9uZSwgeyAuLi5zbG90UHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmLCBjaGlsZHJlbjogUmVhY3QuaXNWYWxpZEVsZW1lbnQobmV3RWxlbWVudCkgPyBSZWFjdC5jbG9uZUVsZW1lbnQobmV3RWxlbWVudCwgdm9pZCAwLCBuZXdDaGlsZHJlbikgOiBudWxsIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNsb3RDbG9uZSwgeyAuLi5zbG90UHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmLCBjaGlsZHJlbiB9KTtcbn0pO1xuU2xvdC5kaXNwbGF5TmFtZSA9IFwiU2xvdFwiO1xudmFyIFNsb3RDbG9uZSA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4uc2xvdFByb3BzIH0gPSBwcm9wcztcbiAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGNvbnN0IGNoaWxkcmVuUmVmID0gZ2V0RWxlbWVudFJlZihjaGlsZHJlbik7XG4gICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuICAgICAgLi4ubWVyZ2VQcm9wcyhzbG90UHJvcHMsIGNoaWxkcmVuLnByb3BzKSxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmID8gY29tcG9zZVJlZnMoZm9yd2FyZGVkUmVmLCBjaGlsZHJlblJlZikgOiBjaGlsZHJlblJlZlxuICAgIH0pO1xuICB9XG4gIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPiAxID8gUmVhY3QuQ2hpbGRyZW4ub25seShudWxsKSA6IG51bGw7XG59KTtcblNsb3RDbG9uZS5kaXNwbGF5TmFtZSA9IFwiU2xvdENsb25lXCI7XG52YXIgU2xvdHRhYmxlID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbiB9KTtcbn07XG5mdW5jdGlvbiBpc1Nsb3R0YWJsZShjaGlsZCkge1xuICByZXR1cm4gUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLnR5cGUgPT09IFNsb3R0YWJsZTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoc2xvdFByb3BzLCBjaGlsZFByb3BzKSB7XG4gIGNvbnN0IG92ZXJyaWRlUHJvcHMgPSB7IC4uLmNoaWxkUHJvcHMgfTtcbiAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBjaGlsZFByb3BzKSB7XG4gICAgY29uc3Qgc2xvdFByb3BWYWx1ZSA9IHNsb3RQcm9wc1twcm9wTmFtZV07XG4gICAgY29uc3QgY2hpbGRQcm9wVmFsdWUgPSBjaGlsZFByb3BzW3Byb3BOYW1lXTtcbiAgICBjb25zdCBpc0hhbmRsZXIgPSAvXm9uW0EtWl0vLnRlc3QocHJvcE5hbWUpO1xuICAgIGlmIChpc0hhbmRsZXIpIHtcbiAgICAgIGlmIChzbG90UHJvcFZhbHVlICYmIGNoaWxkUHJvcFZhbHVlKSB7XG4gICAgICAgIG92ZXJyaWRlUHJvcHNbcHJvcE5hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBjaGlsZFByb3BWYWx1ZSguLi5hcmdzKTtcbiAgICAgICAgICBzbG90UHJvcFZhbHVlKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChzbG90UHJvcFZhbHVlKSB7XG4gICAgICAgIG92ZXJyaWRlUHJvcHNbcHJvcE5hbWVdID0gc2xvdFByb3BWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAgIG92ZXJyaWRlUHJvcHNbcHJvcE5hbWVdID0geyAuLi5zbG90UHJvcFZhbHVlLCAuLi5jaGlsZFByb3BWYWx1ZSB9O1xuICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09IFwiY2xhc3NOYW1lXCIpIHtcbiAgICAgIG92ZXJyaWRlUHJvcHNbcHJvcE5hbWVdID0gW3Nsb3RQcm9wVmFsdWUsIGNoaWxkUHJvcFZhbHVlXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IC4uLnNsb3RQcm9wcywgLi4ub3ZlcnJpZGVQcm9wcyB9O1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFJlZihlbGVtZW50KSB7XG4gIGxldCBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGVsZW1lbnQucHJvcHMsIFwicmVmXCIpPy5nZXQ7XG4gIGxldCBtYXlXYXJuID0gZ2V0dGVyICYmIFwiaXNSZWFjdFdhcm5pbmdcIiBpbiBnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nO1xuICBpZiAobWF5V2Fybikge1xuICAgIHJldHVybiBlbGVtZW50LnJlZjtcbiAgfVxuICBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGVsZW1lbnQsIFwicmVmXCIpPy5nZXQ7XG4gIG1heVdhcm4gPSBnZXR0ZXIgJiYgXCJpc1JlYWN0V2FybmluZ1wiIGluIGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmc7XG4gIGlmIChtYXlXYXJuKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQucHJvcHMucmVmO1xuICB9XG4gIHJldHVybiBlbGVtZW50LnByb3BzLnJlZiB8fCBlbGVtZW50LnJlZjtcbn1cbnZhciBSb290ID0gU2xvdDtcbmV4cG9ydCB7XG4gIFJvb3QsXG4gIFNsb3QsXG4gIFNsb3R0YWJsZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-slot/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCallbackRef: function() { return /* binding */ useCallbackRef; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n// packages/react/use-callback-ref/src/useCallbackRef.tsx\n\nfunction useCallbackRef(callback) {\n  const callbackRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    callbackRef.current = callback;\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (...args) => callbackRef.current?.(...args), []);\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZi9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQytCO0FBQy9CO0FBQ0Esc0JBQXNCLHlDQUFZO0FBQ2xDLEVBQUUsNENBQWU7QUFDakI7QUFDQSxHQUFHO0FBQ0gsU0FBUywwQ0FBYTtBQUN0QjtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmL2Rpc3QvaW5kZXgubWpzP2U2MmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFja2FnZXMvcmVhY3QvdXNlLWNhbGxiYWNrLXJlZi9zcmMvdXNlQ2FsbGJhY2tSZWYudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUNhbGxiYWNrUmVmKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGNhbGxiYWNrUmVmID0gUmVhY3QudXNlUmVmKGNhbGxiYWNrKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYWxsYmFja1JlZi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoLi4uYXJncykgPT4gY2FsbGJhY2tSZWYuY3VycmVudD8uKC4uLmFyZ3MpLCBbXSk7XG59XG5leHBvcnQge1xuICB1c2VDYWxsYmFja1JlZlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLayoutEffect: function() { return /* binding */ useLayoutEffect2; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n// packages/react/use-layout-effect/src/useLayoutEffect.tsx\n\nvar useLayoutEffect2 = Boolean(globalThis?.document) ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : () => {\n};\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUMrQjtBQUMvQix1REFBdUQsa0RBQXFCO0FBQzVFO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXVzZS1sYXlvdXQtZWZmZWN0L2Rpc3QvaW5kZXgubWpzP2JiNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFja2FnZXMvcmVhY3QvdXNlLWxheW91dC1lZmZlY3Qvc3JjL3VzZUxheW91dEVmZmVjdC50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZUxheW91dEVmZmVjdDIgPSBCb29sZWFuKGdsb2JhbFRoaXM/LmRvY3VtZW50KSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6ICgpID0+IHtcbn07XG5leHBvcnQge1xuICB1c2VMYXlvdXRFZmZlY3QyIGFzIHVzZUxheW91dEVmZmVjdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/class-variance-authority/dist/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/class-variance-authority/dist/index.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cva: function() { return /* binding */ cva; },\n/* harmony export */   cx: function() { return /* binding */ cx; }\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/class-variance-authority/node_modules/clsx/dist/clsx.mjs\");\n\nconst falsyToString = (value)=>typeof value === \"boolean\" ? \"\".concat(value) : value === 0 ? \"0\" : value;\nconst cx = clsx__WEBPACK_IMPORTED_MODULE_0__.clsx;\nconst cva = (base, config)=>{\n    return (props)=>{\n        var ref;\n        if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);\n        const { variants , defaultVariants  } = config;\n        const getVariantClassNames = Object.keys(variants).map((variant)=>{\n            const variantProp = props === null || props === void 0 ? void 0 : props[variant];\n            const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];\n            if (variantProp === null) return null;\n            const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);\n            return variants[variant][variantKey];\n        });\n        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param)=>{\n            let [key, value] = param;\n            if (value === undefined) {\n                return acc;\n            }\n            acc[key] = value;\n            return acc;\n        }, {});\n        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (ref = config.compoundVariants) === null || ref === void 0 ? void 0 : ref.reduce((acc, param1)=>{\n            let { class: cvClass , className: cvClassName , ...compoundVariantOptions } = param1;\n            return Object.entries(compoundVariantOptions).every((param)=>{\n                let [key, value] = param;\n                return Array.isArray(value) ? value.includes({\n                    ...defaultVariants,\n                    ...propsWithoutUndefined\n                }[key]) : ({\n                    ...defaultVariants,\n                    ...propsWithoutUndefined\n                })[key] === value;\n            }) ? [\n                ...acc,\n                cvClass,\n                cvClassName\n            ] : acc;\n        }, []);\n        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);\n    };\n};\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbGFzcy12YXJpYW5jZS1hdXRob3JpdHkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRCO0FBQzVCO0FBQ08sV0FBVyxzQ0FBSTtBQUNmO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBLGtCQUFrQixzRUFBc0U7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jbGFzcy12YXJpYW5jZS1hdXRob3JpdHkvZGlzdC9pbmRleC5tanM/Y2Q0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcbmNvbnN0IGZhbHN5VG9TdHJpbmcgPSAodmFsdWUpPT50eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiID8gXCJcIi5jb25jYXQodmFsdWUpIDogdmFsdWUgPT09IDAgPyBcIjBcIiA6IHZhbHVlO1xuZXhwb3J0IGNvbnN0IGN4ID0gY2xzeDtcbmV4cG9ydCBjb25zdCBjdmEgPSAoYmFzZSwgY29uZmlnKT0+e1xuICAgIHJldHVybiAocHJvcHMpPT57XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGlmICgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnZhcmlhbnRzKSA9PSBudWxsKSByZXR1cm4gY3goYmFzZSwgcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLmNsYXNzLCBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuY2xhc3NOYW1lKTtcbiAgICAgICAgY29uc3QgeyB2YXJpYW50cyAsIGRlZmF1bHRWYXJpYW50cyAgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgZ2V0VmFyaWFudENsYXNzTmFtZXMgPSBPYmplY3Qua2V5cyh2YXJpYW50cykubWFwKCh2YXJpYW50KT0+e1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudFByb3AgPSBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHNbdmFyaWFudF07XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFyaWFudFByb3AgPSBkZWZhdWx0VmFyaWFudHMgPT09IG51bGwgfHwgZGVmYXVsdFZhcmlhbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZhdWx0VmFyaWFudHNbdmFyaWFudF07XG4gICAgICAgICAgICBpZiAodmFyaWFudFByb3AgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudEtleSA9IGZhbHN5VG9TdHJpbmcodmFyaWFudFByb3ApIHx8IGZhbHN5VG9TdHJpbmcoZGVmYXVsdFZhcmlhbnRQcm9wKTtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50c1t2YXJpYW50XVt2YXJpYW50S2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb3BzV2l0aG91dFVuZGVmaW5lZCA9IHByb3BzICYmIE9iamVjdC5lbnRyaWVzKHByb3BzKS5yZWR1Y2UoKGFjYywgcGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gcGFyYW07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBjb25zdCBnZXRDb21wb3VuZFZhcmlhbnRDbGFzc05hbWVzID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKHJlZiA9IGNvbmZpZy5jb21wb3VuZFZhcmlhbnRzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5yZWR1Y2UoKGFjYywgcGFyYW0xKT0+e1xuICAgICAgICAgICAgbGV0IHsgY2xhc3M6IGN2Q2xhc3MgLCBjbGFzc05hbWU6IGN2Q2xhc3NOYW1lICwgLi4uY29tcG91bmRWYXJpYW50T3B0aW9ucyB9ID0gcGFyYW0xO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNvbXBvdW5kVmFyaWFudE9wdGlvbnMpLmV2ZXJ5KChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gcGFyYW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuaW5jbHVkZXMoe1xuICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0VmFyaWFudHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnByb3BzV2l0aG91dFVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH1ba2V5XSkgOiAoe1xuICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0VmFyaWFudHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnByb3BzV2l0aG91dFVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pW2tleV0gPT09IHZhbHVlO1xuICAgICAgICAgICAgfSkgPyBbXG4gICAgICAgICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgICAgICAgIGN2Q2xhc3MsXG4gICAgICAgICAgICAgICAgY3ZDbGFzc05hbWVcbiAgICAgICAgICAgIF0gOiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIGN4KGJhc2UsIGdldFZhcmlhbnRDbGFzc05hbWVzLCBnZXRDb21wb3VuZFZhcmlhbnRDbGFzc05hbWVzLCBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuY2xhc3MsIHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5jbGFzc05hbWUpO1xuICAgIH07XG59O1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/class-variance-authority/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/class-variance-authority/node_modules/clsx/dist/clsx.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/class-variance-authority/node_modules/clsx/dist/clsx.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbGFzcy12YXJpYW5jZS1hdXRob3JpdHkvbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsY0FBYyxhQUFhLCtDQUErQyx1REFBdUQsV0FBVywwQ0FBMEMseUNBQXlDLFNBQWdCLGdCQUFnQixxQkFBcUIsbUJBQW1CLGtEQUFrRCxTQUFTLCtEQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NsYXNzLXZhcmlhbmNlLWF1dGhvcml0eS9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubWpzPzdjNzEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/class-variance-authority/node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs":
/*!*****************************************!*\
  !*** ./node_modules/clsx/dist/clsx.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGNBQWMsYUFBYSwrQ0FBK0MsZ0RBQWdELGVBQWUsUUFBUSxJQUFJLDBDQUEwQyx5Q0FBeUMsU0FBZ0IsZ0JBQWdCLHdDQUF3QyxJQUFJLG1EQUFtRCxTQUFTLCtEQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcz9jZmZjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/pdfjs-dist/build/pdf.mjs":
/*!***********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: function() { return /* binding */ __webpack_exports__AbortException; },\n/* harmony export */   AnnotationEditorLayer: function() { return /* binding */ __webpack_exports__AnnotationEditorLayer; },\n/* harmony export */   AnnotationEditorParamsType: function() { return /* binding */ __webpack_exports__AnnotationEditorParamsType; },\n/* harmony export */   AnnotationEditorType: function() { return /* binding */ __webpack_exports__AnnotationEditorType; },\n/* harmony export */   AnnotationEditorUIManager: function() { return /* binding */ __webpack_exports__AnnotationEditorUIManager; },\n/* harmony export */   AnnotationLayer: function() { return /* binding */ __webpack_exports__AnnotationLayer; },\n/* harmony export */   AnnotationMode: function() { return /* binding */ __webpack_exports__AnnotationMode; },\n/* harmony export */   ColorPicker: function() { return /* binding */ __webpack_exports__ColorPicker; },\n/* harmony export */   DOMSVGFactory: function() { return /* binding */ __webpack_exports__DOMSVGFactory; },\n/* harmony export */   DrawLayer: function() { return /* binding */ __webpack_exports__DrawLayer; },\n/* harmony export */   FeatureTest: function() { return /* binding */ __webpack_exports__FeatureTest; },\n/* harmony export */   GlobalWorkerOptions: function() { return /* binding */ __webpack_exports__GlobalWorkerOptions; },\n/* harmony export */   ImageKind: function() { return /* binding */ __webpack_exports__ImageKind; },\n/* harmony export */   InvalidPDFException: function() { return /* binding */ __webpack_exports__InvalidPDFException; },\n/* harmony export */   MissingPDFException: function() { return /* binding */ __webpack_exports__MissingPDFException; },\n/* harmony export */   OPS: function() { return /* binding */ __webpack_exports__OPS; },\n/* harmony export */   OutputScale: function() { return /* binding */ __webpack_exports__OutputScale; },\n/* harmony export */   PDFDataRangeTransport: function() { return /* binding */ __webpack_exports__PDFDataRangeTransport; },\n/* harmony export */   PDFDateString: function() { return /* binding */ __webpack_exports__PDFDateString; },\n/* harmony export */   PDFWorker: function() { return /* binding */ __webpack_exports__PDFWorker; },\n/* harmony export */   PasswordResponses: function() { return /* binding */ __webpack_exports__PasswordResponses; },\n/* harmony export */   PermissionFlag: function() { return /* binding */ __webpack_exports__PermissionFlag; },\n/* harmony export */   PixelsPerInch: function() { return /* binding */ __webpack_exports__PixelsPerInch; },\n/* harmony export */   RenderingCancelledException: function() { return /* binding */ __webpack_exports__RenderingCancelledException; },\n/* harmony export */   TextLayer: function() { return /* binding */ __webpack_exports__TextLayer; },\n/* harmony export */   UnexpectedResponseException: function() { return /* binding */ __webpack_exports__UnexpectedResponseException; },\n/* harmony export */   Util: function() { return /* binding */ __webpack_exports__Util; },\n/* harmony export */   VerbosityLevel: function() { return /* binding */ __webpack_exports__VerbosityLevel; },\n/* harmony export */   XfaLayer: function() { return /* binding */ __webpack_exports__XfaLayer; },\n/* harmony export */   build: function() { return /* binding */ __webpack_exports__build; },\n/* harmony export */   createValidAbsoluteUrl: function() { return /* binding */ __webpack_exports__createValidAbsoluteUrl; },\n/* harmony export */   fetchData: function() { return /* binding */ __webpack_exports__fetchData; },\n/* harmony export */   getDocument: function() { return /* binding */ __webpack_exports__getDocument; },\n/* harmony export */   getFilenameFromUrl: function() { return /* binding */ __webpack_exports__getFilenameFromUrl; },\n/* harmony export */   getPdfFilenameFromUrl: function() { return /* binding */ __webpack_exports__getPdfFilenameFromUrl; },\n/* harmony export */   getXfaPageViewport: function() { return /* binding */ __webpack_exports__getXfaPageViewport; },\n/* harmony export */   isDataScheme: function() { return /* binding */ __webpack_exports__isDataScheme; },\n/* harmony export */   isPdfFile: function() { return /* binding */ __webpack_exports__isPdfFile; },\n/* harmony export */   noContextMenu: function() { return /* binding */ __webpack_exports__noContextMenu; },\n/* harmony export */   normalizeUnicode: function() { return /* binding */ __webpack_exports__normalizeUnicode; },\n/* harmony export */   setLayerDimensions: function() { return /* binding */ __webpack_exports__setLayerDimensions; },\n/* harmony export */   shadow: function() { return /* binding */ __webpack_exports__shadow; },\n/* harmony export */   version: function() { return /* binding */ __webpack_exports__version; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2024 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */\n\n/******/ // The require scope\n/******/ var __nested_webpack_require_839__ = {};\n/******/ \n/************************************************************************/\n/******/ /* webpack/runtime/define property getters */\n/******/ (() => {\n/******/ \t// define getter functions for harmony exports\n/******/ \t__nested_webpack_require_839__.d = (exports, definition) => {\n/******/ \t\tfor(var key in definition) {\n/******/ \t\t\tif(__nested_webpack_require_839__.o(definition, key) && !__nested_webpack_require_839__.o(exports, key)) {\n/******/ \t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t};\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/hasOwnProperty shorthand */\n/******/ (() => {\n/******/ \t__nested_webpack_require_839__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ })();\n/******/ \n/************************************************************************/\nvar __nested_webpack_exports__ = globalThis.pdfjsLib = {};\n\n// EXPORTS\n__nested_webpack_require_839__.d(__nested_webpack_exports__, {\n  AbortException: () => (/* reexport */ AbortException),\n  AnnotationEditorLayer: () => (/* reexport */ AnnotationEditorLayer),\n  AnnotationEditorParamsType: () => (/* reexport */ AnnotationEditorParamsType),\n  AnnotationEditorType: () => (/* reexport */ AnnotationEditorType),\n  AnnotationEditorUIManager: () => (/* reexport */ AnnotationEditorUIManager),\n  AnnotationLayer: () => (/* reexport */ AnnotationLayer),\n  AnnotationMode: () => (/* reexport */ AnnotationMode),\n  ColorPicker: () => (/* reexport */ ColorPicker),\n  DOMSVGFactory: () => (/* reexport */ DOMSVGFactory),\n  DrawLayer: () => (/* reexport */ DrawLayer),\n  FeatureTest: () => (/* reexport */ util_FeatureTest),\n  GlobalWorkerOptions: () => (/* reexport */ GlobalWorkerOptions),\n  ImageKind: () => (/* reexport */ util_ImageKind),\n  InvalidPDFException: () => (/* reexport */ InvalidPDFException),\n  MissingPDFException: () => (/* reexport */ MissingPDFException),\n  OPS: () => (/* reexport */ OPS),\n  OutputScale: () => (/* reexport */ OutputScale),\n  PDFDataRangeTransport: () => (/* reexport */ PDFDataRangeTransport),\n  PDFDateString: () => (/* reexport */ PDFDateString),\n  PDFWorker: () => (/* reexport */ PDFWorker),\n  PasswordResponses: () => (/* reexport */ PasswordResponses),\n  PermissionFlag: () => (/* reexport */ PermissionFlag),\n  PixelsPerInch: () => (/* reexport */ PixelsPerInch),\n  RenderingCancelledException: () => (/* reexport */ RenderingCancelledException),\n  TextLayer: () => (/* reexport */ TextLayer),\n  UnexpectedResponseException: () => (/* reexport */ UnexpectedResponseException),\n  Util: () => (/* reexport */ Util),\n  VerbosityLevel: () => (/* reexport */ VerbosityLevel),\n  XfaLayer: () => (/* reexport */ XfaLayer),\n  build: () => (/* reexport */ build),\n  createValidAbsoluteUrl: () => (/* reexport */ createValidAbsoluteUrl),\n  fetchData: () => (/* reexport */ fetchData),\n  getDocument: () => (/* reexport */ getDocument),\n  getFilenameFromUrl: () => (/* reexport */ getFilenameFromUrl),\n  getPdfFilenameFromUrl: () => (/* reexport */ getPdfFilenameFromUrl),\n  getXfaPageViewport: () => (/* reexport */ getXfaPageViewport),\n  isDataScheme: () => (/* reexport */ isDataScheme),\n  isPdfFile: () => (/* reexport */ isPdfFile),\n  noContextMenu: () => (/* reexport */ noContextMenu),\n  normalizeUnicode: () => (/* reexport */ normalizeUnicode),\n  setLayerDimensions: () => (/* reexport */ setLayerDimensions),\n  shadow: () => (/* reexport */ shadow),\n  version: () => (/* reexport */ version)\n});\n\n;// ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nconst MAX_IMAGE_SIZE_TO_CACHE = 10e6;\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  SAVE: 0x08,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  IS_EDITING: 0x80,\n  OPLIST: 0x100\n};\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n  DISABLE: -1,\n  NONE: 0,\n  FREETEXT: 3,\n  HIGHLIGHT: 9,\n  STAMP: 13,\n  INK: 15\n};\nconst AnnotationEditorParamsType = {\n  RESIZE: 1,\n  CREATE: 2,\n  FREETEXT_SIZE: 11,\n  FREETEXT_COLOR: 12,\n  FREETEXT_OPACITY: 13,\n  INK_COLOR: 21,\n  INK_THICKNESS: 22,\n  INK_OPACITY: 23,\n  HIGHLIGHT_COLOR: 31,\n  HIGHLIGHT_DEFAULT_COLOR: 32,\n  HIGHLIGHT_THICKNESS: 33,\n  HIGHLIGHT_FREE: 34,\n  HIGHLIGHT_SHOW_ALL: 35\n};\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91,\n  setStrokeTransparent: 92,\n  setFillTransparent: 93\n};\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\nfunction getVerbosityLevel() {\n  return verbosity;\n}\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\nfunction _isValidProtocol(url) {\n  switch (url?.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n  if (!url) {\n    return null;\n  }\n  try {\n    if (options && typeof url === \"string\") {\n      if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n        const dots = url.match(/\\./g);\n        if (dots?.length >= 2) {\n          url = `http://${url}`;\n        }\n      }\n      if (options.tryConvertEncoding) {\n        try {\n          url = stringToUTF8String(url);\n        } catch {}\n      }\n    }\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch {}\n  return null;\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: !nonSerializable,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message, name) {\n    this.message = message;\n    this.name = name;\n  }\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n}\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n}\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n}\nclass MissingPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"MissingPDFException\");\n  }\n}\nclass UnexpectedResponseException extends BaseException {\n  constructor(msg, status) {\n    super(msg, \"UnexpectedResponseException\");\n    this.status = status;\n  }\n}\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n}\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n}\nfunction bytesToString(bytes) {\n  if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n    unreachable(\"Invalid argument for bytesToString\");\n  }\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n  const strBuf = [];\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n  if (typeof str !== \"string\") {\n    unreachable(\"Invalid argument for stringToBytes\");\n  }\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n  return bytes;\n}\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\nfunction objectFromMap(map) {\n  const obj = Object.create(null);\n  for (const [key, value] of map) {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch {\n    return false;\n  }\n}\nclass util_FeatureTest {\n  static get isLittleEndian() {\n    return shadow(this, \"isLittleEndian\", isLittleEndian());\n  }\n  static get isEvalSupported() {\n    return shadow(this, \"isEvalSupported\", isEvalSupported());\n  }\n  static get isOffscreenCanvasSupported() {\n    return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n  }\n  static get platform() {\n    if (typeof navigator !== \"undefined\" && typeof navigator?.platform === \"string\") {\n      return shadow(this, \"platform\", {\n        isMac: navigator.platform.includes(\"Mac\"),\n        isWindows: navigator.platform.includes(\"Win\"),\n        isFirefox: typeof navigator?.userAgent === \"string\" && navigator.userAgent.includes(\"Firefox\")\n      });\n    }\n    return shadow(this, \"platform\", {\n      isMac: false,\n      isWindows: false,\n      isFirefox: false\n    });\n  }\n  static get isCSSRoundSupported() {\n    return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n  }\n}\nconst hexNumbers = Array.from(Array(256).keys(), n => n.toString(16).padStart(2, \"0\"));\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n  static scaleMinMax(transform, minMax) {\n    let temp;\n    if (transform[0]) {\n      if (transform[0] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[2];\n        minMax[2] = temp;\n      }\n      minMax[0] *= transform[0];\n      minMax[2] *= transform[0];\n      if (transform[3] < 0) {\n        temp = minMax[1];\n        minMax[1] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[1] *= transform[3];\n      minMax[3] *= transform[3];\n    } else {\n      temp = minMax[0];\n      minMax[0] = minMax[1];\n      minMax[1] = temp;\n      temp = minMax[2];\n      minMax[2] = minMax[3];\n      minMax[3] = temp;\n      if (transform[1] < 0) {\n        temp = minMax[1];\n        minMax[1] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[1] *= transform[1];\n      minMax[3] *= transform[1];\n      if (transform[2] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[2];\n        minMax[2] = temp;\n      }\n      minMax[0] *= transform[2];\n      minMax[2] *= transform[2];\n    }\n    minMax[0] += transform[4];\n    minMax[1] += transform[5];\n    minMax[2] += transform[4];\n    minMax[3] += transform[5];\n  }\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n  static applyTransform(p, m) {\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  }\n  static applyInverseTransform(p, m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  }\n  static getAxialAlignedBoundingBox(r, m) {\n    const p1 = this.applyTransform(r, m);\n    const p2 = this.applyTransform(r.slice(2, 4), m);\n    const p3 = this.applyTransform([r[0], r[3]], m);\n    const p4 = this.applyTransform([r[2], r[1]], m);\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n  }\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n  static singularValueDecompose2dScale(m) {\n    const transpose = [m[0], m[2], m[1], m[3]];\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\n    const first = (a + d) / 2;\n    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n    const sx = first + second || 1;\n    const sy = first - second || 1;\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  }\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n    return r;\n  }\n  static intersect(rect1, rect2) {\n    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n    if (xLow > xHigh) {\n      return null;\n    }\n    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n    if (yLow > yHigh) {\n      return null;\n    }\n    return [xLow, yLow, xHigh, yHigh];\n  }\n  static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n    if (t <= 0 || t >= 1) {\n      return;\n    }\n    const mt = 1 - t;\n    const tt = t * t;\n    const ttt = tt * t;\n    const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n    const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n    minMax[0] = Math.min(minMax[0], x);\n    minMax[1] = Math.min(minMax[1], y);\n    minMax[2] = Math.max(minMax[2], x);\n    minMax[3] = Math.max(minMax[3], y);\n  }\n  static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n    if (Math.abs(a) < 1e-12) {\n      if (Math.abs(b) >= 1e-12) {\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n      }\n      return;\n    }\n    const delta = b ** 2 - 4 * c * a;\n    if (delta < 0) {\n      return;\n    }\n    const sqrtDelta = Math.sqrt(delta);\n    const a2 = 2 * a;\n    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n  }\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n    if (minMax) {\n      minMax[0] = Math.min(minMax[0], x0, x3);\n      minMax[1] = Math.min(minMax[1], y0, y3);\n      minMax[2] = Math.max(minMax[2], x0, x3);\n      minMax[3] = Math.max(minMax[3], y0, y3);\n    } else {\n      minMax = [Math.min(x0, x3), Math.min(y0, y3), Math.max(x0, x3), Math.max(y0, y3)];\n    }\n    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n    return minMax;\n  }\n}\nconst PDFStringTranslateTable = (/* unused pure expression or super */ null && (0));\nfunction stringToPDFString(str) {\n  if (str[0] >= \"\\xEF\") {\n    let encoding;\n    if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n      encoding = \"utf-16be\";\n      if (str.length % 2 === 1) {\n        str = str.slice(0, -1);\n      }\n    } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n      encoding = \"utf-16le\";\n      if (str.length % 2 === 1) {\n        str = str.slice(0, -1);\n      }\n    } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") {\n      encoding = \"utf-8\";\n    }\n    if (encoding) {\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(str);\n        const decoded = decoder.decode(buffer);\n        if (!decoded.includes(\"\\x1b\")) {\n          return decoded;\n        }\n        return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n      } catch (ex) {\n        warn(`stringToPDFString: \"${ex}\".`);\n      }\n    }\n  }\n  const strBuf = [];\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const charCode = str.charCodeAt(i);\n    if (charCode === 0x1b) {\n      while (++i < ii && str.charCodeAt(i) !== 0x1b) {}\n      continue;\n    }\n    const code = PDFStringTranslateTable[charCode];\n    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getModificationDate(date = new Date()) {\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n  if (!NormalizeRegex) {\n    NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n    NormalizationMap = new Map([[\"\", \"t\"]]);\n  }\n  return str.replaceAll(NormalizeRegex, (_, p1, p2) => p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n  if (typeof crypto !== \"undefined\" && typeof crypto?.randomUUID === \"function\") {\n    return crypto.randomUUID();\n  }\n  const buf = new Uint8Array(32);\n  if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues === \"function\") {\n    crypto.getRandomValues(buf);\n  } else {\n    for (let i = 0; i < 32; i++) {\n      buf[i] = Math.floor(Math.random() * 255);\n    }\n  }\n  return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nconst FontRenderOps = {\n  BEZIER_CURVE_TO: 0,\n  MOVE_TO: 1,\n  LINE_TO: 2,\n  QUADRATIC_CURVE_TO: 3,\n  RESTORE: 4,\n  SAVE: 5,\n  SCALE: 6,\n  TRANSFORM: 7,\n  TRANSLATE: 8\n};\nfunction toHexUtil(arr) {\n  if (Uint8Array.prototype.toHex) {\n    return arr.toHex();\n  }\n  return Array.from(arr, num => hexNumbers[num]).join(\"\");\n}\nfunction toBase64Util(arr) {\n  if (Uint8Array.prototype.toBase64) {\n    return arr.toBase64();\n  }\n  return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n  if (Uint8Array.fromBase64) {\n    return Uint8Array.fromBase64(str);\n  }\n  return stringToBytes(atob(str));\n}\n\n;// ./src/display/display_utils.js\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n  static CSS = 96.0;\n  static PDF = 72.0;\n  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n}\nasync function fetchData(url, type = \"text\") {\n  if (isValidFetchUrl(url, document.baseURI)) {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n    switch (type) {\n      case \"arraybuffer\":\n        return response.arrayBuffer();\n      case \"blob\":\n        return response.blob();\n      case \"json\":\n        return response.json();\n    }\n    return response.text();\n  }\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n    request.responseType = type;\n    request.onreadystatechange = () => {\n      if (request.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n      if (request.status === 200 || request.status === 0) {\n        switch (type) {\n          case \"arraybuffer\":\n          case \"blob\":\n          case \"json\":\n            resolve(request.response);\n            return;\n        }\n        resolve(request.responseText);\n        return;\n      }\n      reject(new Error(request.statusText));\n    };\n    request.send(null);\n  });\n}\nclass PageViewport {\n  constructor({\n    viewBox,\n    scale,\n    rotation,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  }) {\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    rotation %= 360;\n    if (rotation < 0) {\n      rotation += 360;\n    }\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = (viewBox[3] - viewBox[1]) * scale;\n      height = (viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = (viewBox[2] - viewBox[0]) * scale;\n      height = (viewBox[3] - viewBox[1]) * scale;\n    }\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n  get rawDims() {\n    const {\n      viewBox\n    } = this;\n    return shadow(this, \"rawDims\", {\n      pageWidth: viewBox[2] - viewBox[0],\n      pageHeight: viewBox[3] - viewBox[1],\n      pageX: viewBox[0],\n      pageY: viewBox[1]\n    });\n  }\n  clone({\n    scale = this.scale,\n    rotation = this.rotation,\n    offsetX = this.offsetX,\n    offsetY = this.offsetY,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n  convertToViewportPoint(x, y) {\n    return Util.applyTransform([x, y], this.transform);\n  }\n  convertToViewportRectangle(rect) {\n    const topLeft = Util.applyTransform([rect[0], rect[1]], this.transform);\n    const bottomRight = Util.applyTransform([rect[2], rect[3]], this.transform);\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n  convertToPdfPoint(x, y) {\n    return Util.applyInverseTransform([x, y], this.transform);\n  }\n}\nclass RenderingCancelledException extends BaseException {\n  constructor(msg, extraDelay = 0) {\n    super(msg, \"RenderingCancelledException\");\n    this.extraDelay = extraDelay;\n  }\n}\nfunction isDataScheme(url) {\n  const ii = url.length;\n  let i = 0;\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n  return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n  [url] = url.split(/[#?]/, 1);\n  return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n  if (isDataScheme(url)) {\n    warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n    return defaultFilename;\n  }\n  const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n  const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n  const splitURI = reURI.exec(url);\n  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n  if (suggestedFilename) {\n    suggestedFilename = suggestedFilename[0];\n    if (suggestedFilename.includes(\"%\")) {\n      try {\n        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n      } catch {}\n    }\n  }\n  return suggestedFilename || defaultFilename;\n}\nclass StatTimer {\n  started = Object.create(null);\n  times = [];\n  time(name) {\n    if (name in this.started) {\n      warn(`Timer is already running for ${name}`);\n    }\n    this.started[name] = Date.now();\n  }\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      warn(`Timer has not been started for ${name}`);\n    }\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now()\n    });\n    delete this.started[name];\n  }\n  toString() {\n    const outBuf = [];\n    let longest = 0;\n    for (const {\n      name\n    } of this.times) {\n      longest = Math.max(name.length, longest);\n    }\n    for (const {\n      name,\n      start,\n      end\n    } of this.times) {\n      outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n    }\n    return outBuf.join(\"\");\n  }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    const {\n      protocol\n    } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    return protocol === \"http:\" || protocol === \"https:\";\n  } catch {\n    return false;\n  }\n}\nfunction noContextMenu(e) {\n  e.preventDefault();\n}\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n  static #regex;\n  static toDateObject(input) {\n    if (!input || typeof input !== \"string\") {\n      return null;\n    }\n    this.#regex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n    const matches = this.#regex.exec(input);\n    if (!matches) {\n      return null;\n    }\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || \"Z\";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n    if (universalTimeRelation === \"-\") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === \"+\") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n}\nfunction getXfaPageViewport(xfaPage, {\n  scale = 1,\n  rotation = 0\n}) {\n  const {\n    width,\n    height\n  } = xfaPage.attributes.style;\n  const viewBox = [0, 0, parseInt(width), parseInt(height)];\n  return new PageViewport({\n    viewBox,\n    scale,\n    rotation\n  });\n}\nfunction getRGB(color) {\n  if (color.startsWith(\"#\")) {\n    const colorRGB = parseInt(color.slice(1), 16);\n    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];\n  }\n  if (color.startsWith(\"rgb(\")) {\n    return color.slice(4, -1).split(\",\").map(x => parseInt(x));\n  }\n  if (color.startsWith(\"rgba(\")) {\n    return color.slice(5, -1).split(\",\").map(x => parseInt(x)).slice(0, 3);\n  }\n  warn(`Not a valid color format: \"${color}\"`);\n  return [0, 0, 0];\n}\nfunction getColorValues(colors) {\n  const span = document.createElement(\"span\");\n  span.style.visibility = \"hidden\";\n  document.body.append(span);\n  for (const name of colors.keys()) {\n    span.style.color = name;\n    const computedColor = window.getComputedStyle(span).color;\n    colors.set(name, getRGB(computedColor));\n  }\n  span.remove();\n}\nfunction getCurrentTransform(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform();\n  return [a, b, c, d, e, f];\n}\nfunction getCurrentTransformInverse(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform().invertSelf();\n  return [a, b, c, d, e, f];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n  if (viewport instanceof PageViewport) {\n    const {\n      pageWidth,\n      pageHeight\n    } = viewport.rawDims;\n    const {\n      style\n    } = div;\n    const useRound = util_FeatureTest.isCSSRoundSupported;\n    const w = `var(--scale-factor) * ${pageWidth}px`,\n      h = `var(--scale-factor) * ${pageHeight}px`;\n    const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x, 1px))` : `calc(${w})`,\n      heightStr = useRound ? `round(down, ${h}, var(--scale-round-y, 1px))` : `calc(${h})`;\n    if (!mustFlip || viewport.rotation % 180 === 0) {\n      style.width = widthStr;\n      style.height = heightStr;\n    } else {\n      style.width = heightStr;\n      style.height = widthStr;\n    }\n  }\n  if (mustRotate) {\n    div.setAttribute(\"data-main-rotation\", viewport.rotation);\n  }\n}\nclass OutputScale {\n  constructor() {\n    const pixelRatio = window.devicePixelRatio || 1;\n    this.sx = pixelRatio;\n    this.sy = pixelRatio;\n  }\n  get scaled() {\n    return this.sx !== 1 || this.sy !== 1;\n  }\n  get symmetric() {\n    return this.sx === this.sy;\n  }\n}\n\n;// ./src/display/editor/toolbar.js\n\nclass EditorToolbar {\n  #toolbar = null;\n  #colorPicker = null;\n  #editor;\n  #buttons = null;\n  #altText = null;\n  static #l10nRemove = null;\n  constructor(editor) {\n    this.#editor = editor;\n    EditorToolbar.#l10nRemove ||= Object.freeze({\n      freetext: \"pdfjs-editor-remove-freetext-button\",\n      highlight: \"pdfjs-editor-remove-highlight-button\",\n      ink: \"pdfjs-editor-remove-ink-button\",\n      stamp: \"pdfjs-editor-remove-stamp-button\"\n    });\n  }\n  render() {\n    const editToolbar = this.#toolbar = document.createElement(\"div\");\n    editToolbar.classList.add(\"editToolbar\", \"hidden\");\n    editToolbar.setAttribute(\"role\", \"toolbar\");\n    const signal = this.#editor._uiManager._signal;\n    editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n      signal\n    });\n    const buttons = this.#buttons = document.createElement(\"div\");\n    buttons.className = \"buttons\";\n    editToolbar.append(buttons);\n    const position = this.#editor.toolbarPosition;\n    if (position) {\n      const {\n        style\n      } = editToolbar;\n      const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n      style.insetInlineEnd = `${100 * x}%`;\n      style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n    }\n    this.#addDeleteButton();\n    return editToolbar;\n  }\n  get div() {\n    return this.#toolbar;\n  }\n  static #pointerDown(e) {\n    e.stopPropagation();\n  }\n  #focusIn(e) {\n    this.#editor._focusEventsAllowed = false;\n    e.preventDefault();\n    e.stopPropagation();\n  }\n  #focusOut(e) {\n    this.#editor._focusEventsAllowed = true;\n    e.preventDefault();\n    e.stopPropagation();\n  }\n  #addListenersToElement(element) {\n    const signal = this.#editor._uiManager._signal;\n    element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n      capture: true,\n      signal\n    });\n    element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n      capture: true,\n      signal\n    });\n    element.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n  }\n  hide() {\n    this.#toolbar.classList.add(\"hidden\");\n    this.#colorPicker?.hideDropdown();\n  }\n  show() {\n    this.#toolbar.classList.remove(\"hidden\");\n    this.#altText?.shown();\n  }\n  #addDeleteButton() {\n    const {\n      editorType,\n      _uiManager\n    } = this.#editor;\n    const button = document.createElement(\"button\");\n    button.className = \"delete\";\n    button.tabIndex = 0;\n    button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n    this.#addListenersToElement(button);\n    button.addEventListener(\"click\", e => {\n      _uiManager.delete();\n    }, {\n      signal: _uiManager._signal\n    });\n    this.#buttons.append(button);\n  }\n  get #divider() {\n    const divider = document.createElement(\"div\");\n    divider.className = \"divider\";\n    return divider;\n  }\n  async addAltText(altText) {\n    const button = await altText.render();\n    this.#addListenersToElement(button);\n    this.#buttons.prepend(button, this.#divider);\n    this.#altText = altText;\n  }\n  addColorPicker(colorPicker) {\n    this.#colorPicker = colorPicker;\n    const button = colorPicker.renderButton();\n    this.#addListenersToElement(button);\n    this.#buttons.prepend(button, this.#divider);\n  }\n  remove() {\n    this.#toolbar.remove();\n    this.#colorPicker?.destroy();\n    this.#colorPicker = null;\n  }\n}\nclass HighlightToolbar {\n  #buttons = null;\n  #toolbar = null;\n  #uiManager;\n  constructor(uiManager) {\n    this.#uiManager = uiManager;\n  }\n  #render() {\n    const editToolbar = this.#toolbar = document.createElement(\"div\");\n    editToolbar.className = \"editToolbar\";\n    editToolbar.setAttribute(\"role\", \"toolbar\");\n    editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n      signal: this.#uiManager._signal\n    });\n    const buttons = this.#buttons = document.createElement(\"div\");\n    buttons.className = \"buttons\";\n    editToolbar.append(buttons);\n    this.#addHighlightButton();\n    return editToolbar;\n  }\n  #getLastPoint(boxes, isLTR) {\n    let lastY = 0;\n    let lastX = 0;\n    for (const box of boxes) {\n      const y = box.y + box.height;\n      if (y < lastY) {\n        continue;\n      }\n      const x = box.x + (isLTR ? box.width : 0);\n      if (y > lastY) {\n        lastX = x;\n        lastY = y;\n        continue;\n      }\n      if (isLTR) {\n        if (x > lastX) {\n          lastX = x;\n        }\n      } else if (x < lastX) {\n        lastX = x;\n      }\n    }\n    return [isLTR ? 1 - lastX : lastX, lastY];\n  }\n  show(parent, boxes, isLTR) {\n    const [x, y] = this.#getLastPoint(boxes, isLTR);\n    const {\n      style\n    } = this.#toolbar ||= this.#render();\n    parent.append(this.#toolbar);\n    style.insetInlineEnd = `${100 * x}%`;\n    style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n  }\n  hide() {\n    this.#toolbar.remove();\n  }\n  #addHighlightButton() {\n    const button = document.createElement(\"button\");\n    button.className = \"highlightButton\";\n    button.tabIndex = 0;\n    button.setAttribute(\"data-l10n-id\", `pdfjs-highlight-floating-button1`);\n    const span = document.createElement(\"span\");\n    button.append(span);\n    span.className = \"visuallyHidden\";\n    span.setAttribute(\"data-l10n-id\", \"pdfjs-highlight-floating-button-label\");\n    const signal = this.#uiManager._signal;\n    button.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    button.addEventListener(\"click\", () => {\n      this.#uiManager.highlightSelection(\"floating_button\");\n    }, {\n      signal\n    });\n    this.#buttons.append(button);\n  }\n}\n\n;// ./src/display/editor/tools.js\n\n\n\nfunction bindEvents(obj, element, names) {\n  for (const name of names) {\n    element.addEventListener(name, obj[name].bind(obj));\n  }\n}\nfunction opacityToHex(opacity) {\n  return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n}\nclass IdManager {\n  #id = 0;\n  get id() {\n    return `${AnnotationEditorPrefix}${this.#id++}`;\n  }\n}\nclass ImageManager {\n  #baseId = getUuid();\n  #id = 0;\n  #cache = null;\n  static get _isSVGFittingCanvas() {\n    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n    const canvas = new OffscreenCanvas(1, 3);\n    const ctx = canvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    const image = new Image();\n    image.src = svg;\n    const promise = image.decode().then(() => {\n      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n    });\n    return shadow(this, \"_isSVGFittingCanvas\", promise);\n  }\n  async #get(key, rawData) {\n    this.#cache ||= new Map();\n    let data = this.#cache.get(key);\n    if (data === null) {\n      return null;\n    }\n    if (data?.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    try {\n      data ||= {\n        bitmap: null,\n        id: `image_${this.#baseId}_${this.#id++}`,\n        refCounter: 0,\n        isSvg: false\n      };\n      let image;\n      if (typeof rawData === \"string\") {\n        data.url = rawData;\n        image = await fetchData(rawData, \"blob\");\n      } else if (rawData instanceof File) {\n        image = data.file = rawData;\n      } else if (rawData instanceof Blob) {\n        image = rawData;\n      }\n      if (image.type === \"image/svg+xml\") {\n        const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n        const fileReader = new FileReader();\n        const imageElement = new Image();\n        const imagePromise = new Promise((resolve, reject) => {\n          imageElement.onload = () => {\n            data.bitmap = imageElement;\n            data.isSvg = true;\n            resolve();\n          };\n          fileReader.onload = async () => {\n            const url = data.svgUrl = fileReader.result;\n            imageElement.src = (await mustRemoveAspectRatioPromise) ? `${url}#svgView(preserveAspectRatio(none))` : url;\n          };\n          imageElement.onerror = fileReader.onerror = reject;\n        });\n        fileReader.readAsDataURL(image);\n        await imagePromise;\n      } else {\n        data.bitmap = await createImageBitmap(image);\n      }\n      data.refCounter = 1;\n    } catch (e) {\n      console.error(e);\n      data = null;\n    }\n    this.#cache.set(key, data);\n    if (data) {\n      this.#cache.set(data.id, data);\n    }\n    return data;\n  }\n  async getFromFile(file) {\n    const {\n      lastModified,\n      name,\n      size,\n      type\n    } = file;\n    return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n  }\n  async getFromUrl(url) {\n    return this.#get(url, url);\n  }\n  async getFromBlob(id, blobPromise) {\n    const blob = await blobPromise;\n    return this.#get(id, blob);\n  }\n  async getFromId(id) {\n    this.#cache ||= new Map();\n    const data = this.#cache.get(id);\n    if (!data) {\n      return null;\n    }\n    if (data.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    if (data.file) {\n      return this.getFromFile(data.file);\n    }\n    if (data.blobPromise) {\n      const {\n        blobPromise\n      } = data;\n      delete data.blobPromise;\n      return this.getFromBlob(data.id, blobPromise);\n    }\n    return this.getFromUrl(data.url);\n  }\n  getFromCanvas(id, canvas) {\n    this.#cache ||= new Map();\n    let data = this.#cache.get(id);\n    if (data?.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n    const ctx = offscreen.getContext(\"2d\");\n    ctx.drawImage(canvas, 0, 0);\n    data = {\n      bitmap: offscreen.transferToImageBitmap(),\n      id: `image_${this.#baseId}_${this.#id++}`,\n      refCounter: 1,\n      isSvg: false\n    };\n    this.#cache.set(id, data);\n    this.#cache.set(data.id, data);\n    return data;\n  }\n  getSvgUrl(id) {\n    const data = this.#cache.get(id);\n    if (!data?.isSvg) {\n      return null;\n    }\n    return data.svgUrl;\n  }\n  deleteId(id) {\n    this.#cache ||= new Map();\n    const data = this.#cache.get(id);\n    if (!data) {\n      return;\n    }\n    data.refCounter -= 1;\n    if (data.refCounter !== 0) {\n      return;\n    }\n    const {\n      bitmap\n    } = data;\n    if (!data.url && !data.file) {\n      const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n      const ctx = canvas.getContext(\"bitmaprenderer\");\n      ctx.transferFromImageBitmap(bitmap);\n      data.blobPromise = canvas.convertToBlob();\n    }\n    bitmap.close?.();\n    data.bitmap = null;\n  }\n  isValidId(id) {\n    return id.startsWith(`image_${this.#baseId}_`);\n  }\n}\nclass CommandManager {\n  #commands = [];\n  #locked = false;\n  #maxSize;\n  #position = -1;\n  constructor(maxSize = 128) {\n    this.#maxSize = maxSize;\n  }\n  add({\n    cmd,\n    undo,\n    post,\n    mustExec,\n    type = NaN,\n    overwriteIfSameType = false,\n    keepUndo = false\n  }) {\n    if (mustExec) {\n      cmd();\n    }\n    if (this.#locked) {\n      return;\n    }\n    const save = {\n      cmd,\n      undo,\n      post,\n      type\n    };\n    if (this.#position === -1) {\n      if (this.#commands.length > 0) {\n        this.#commands.length = 0;\n      }\n      this.#position = 0;\n      this.#commands.push(save);\n      return;\n    }\n    if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n      if (keepUndo) {\n        save.undo = this.#commands[this.#position].undo;\n      }\n      this.#commands[this.#position] = save;\n      return;\n    }\n    const next = this.#position + 1;\n    if (next === this.#maxSize) {\n      this.#commands.splice(0, 1);\n    } else {\n      this.#position = next;\n      if (next < this.#commands.length) {\n        this.#commands.splice(next);\n      }\n    }\n    this.#commands.push(save);\n  }\n  undo() {\n    if (this.#position === -1) {\n      return;\n    }\n    this.#locked = true;\n    const {\n      undo,\n      post\n    } = this.#commands[this.#position];\n    undo();\n    post?.();\n    this.#locked = false;\n    this.#position -= 1;\n  }\n  redo() {\n    if (this.#position < this.#commands.length - 1) {\n      this.#position += 1;\n      this.#locked = true;\n      const {\n        cmd,\n        post\n      } = this.#commands[this.#position];\n      cmd();\n      post?.();\n      this.#locked = false;\n    }\n  }\n  hasSomethingToUndo() {\n    return this.#position !== -1;\n  }\n  hasSomethingToRedo() {\n    return this.#position < this.#commands.length - 1;\n  }\n  destroy() {\n    this.#commands = null;\n  }\n}\nclass KeyboardManager {\n  constructor(callbacks) {\n    this.buffer = [];\n    this.callbacks = new Map();\n    this.allKeys = new Set();\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    for (const [keys, callback, options = {}] of callbacks) {\n      for (const key of keys) {\n        const isMacKey = key.startsWith(\"mac+\");\n        if (isMac && isMacKey) {\n          this.callbacks.set(key.slice(4), {\n            callback,\n            options\n          });\n          this.allKeys.add(key.split(\"+\").at(-1));\n        } else if (!isMac && !isMacKey) {\n          this.callbacks.set(key, {\n            callback,\n            options\n          });\n          this.allKeys.add(key.split(\"+\").at(-1));\n        }\n      }\n    }\n  }\n  #serialize(event) {\n    if (event.altKey) {\n      this.buffer.push(\"alt\");\n    }\n    if (event.ctrlKey) {\n      this.buffer.push(\"ctrl\");\n    }\n    if (event.metaKey) {\n      this.buffer.push(\"meta\");\n    }\n    if (event.shiftKey) {\n      this.buffer.push(\"shift\");\n    }\n    this.buffer.push(event.key);\n    const str = this.buffer.join(\"+\");\n    this.buffer.length = 0;\n    return str;\n  }\n  exec(self, event) {\n    if (!this.allKeys.has(event.key)) {\n      return;\n    }\n    const info = this.callbacks.get(this.#serialize(event));\n    if (!info) {\n      return;\n    }\n    const {\n      callback,\n      options: {\n        bubbles = false,\n        args = [],\n        checker = null\n      }\n    } = info;\n    if (checker && !checker(self, event)) {\n      return;\n    }\n    callback.bind(self, ...args, event)();\n    if (!bubbles) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  }\n}\nclass ColorManager {\n  static _colorsMapping = new Map([[\"CanvasText\", [0, 0, 0]], [\"Canvas\", [255, 255, 255]]]);\n  get _colors() {\n    const colors = new Map([[\"CanvasText\", null], [\"Canvas\", null]]);\n    getColorValues(colors);\n    return shadow(this, \"_colors\", colors);\n  }\n  convert(color) {\n    const rgb = getRGB(color);\n    if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n      return rgb;\n    }\n    for (const [name, RGB] of this._colors) {\n      if (RGB.every((x, i) => x === rgb[i])) {\n        return ColorManager._colorsMapping.get(name);\n      }\n    }\n    return rgb;\n  }\n  getHexCode(name) {\n    const rgb = this._colors.get(name);\n    if (!rgb) {\n      return name;\n    }\n    return Util.makeHexColor(...rgb);\n  }\n}\nclass AnnotationEditorUIManager {\n  #abortController = new AbortController();\n  #activeEditor = null;\n  #allEditors = new Map();\n  #allLayers = new Map();\n  #altTextManager = null;\n  #annotationStorage = null;\n  #changedExistingAnnotations = null;\n  #commandManager = new CommandManager();\n  #copyPasteAC = null;\n  #currentPageIndex = 0;\n  #deletedAnnotationsElementIds = new Set();\n  #draggingEditors = null;\n  #editorTypes = null;\n  #editorsToRescale = new Set();\n  #enableHighlightFloatingButton = false;\n  #enableUpdatedAddImage = false;\n  #enableNewAltTextWhenAddingImage = false;\n  #filterFactory = null;\n  #focusMainContainerTimeoutId = null;\n  #focusManagerAC = null;\n  #highlightColors = null;\n  #highlightWhenShiftUp = false;\n  #highlightToolbar = null;\n  #idManager = new IdManager();\n  #isEnabled = false;\n  #isWaiting = false;\n  #keyboardManagerAC = null;\n  #lastActiveElement = null;\n  #mainHighlightColorPicker = null;\n  #mlManager = null;\n  #mode = AnnotationEditorType.NONE;\n  #selectedEditors = new Set();\n  #selectedTextNode = null;\n  #pageColors = null;\n  #showAllStates = null;\n  #previousStates = {\n    isEditing: false,\n    isEmpty: true,\n    hasSomethingToUndo: false,\n    hasSomethingToRedo: false,\n    hasSelectedEditor: false,\n    hasSelectedText: false\n  };\n  #translation = [0, 0];\n  #translationTimeoutId = null;\n  #container = null;\n  #viewer = null;\n  #updateModeCapability = null;\n  static TRANSLATE_SMALL = 1;\n  static TRANSLATE_BIG = 10;\n  static get _keyboardManager() {\n    const proto = AnnotationEditorUIManager.prototype;\n    const arrowChecker = self => self.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self.hasSomethingToControl();\n    const textInputChecker = (_self, {\n      target: el\n    }) => {\n      if (el instanceof HTMLInputElement) {\n        const {\n          type\n        } = el;\n        return type !== \"text\" && type !== \"number\";\n      }\n      return true;\n    };\n    const small = this.TRANSLATE_SMALL;\n    const big = this.TRANSLATE_BIG;\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"ctrl+a\", \"mac+meta+a\"], proto.selectAll, {\n      checker: textInputChecker\n    }], [[\"ctrl+z\", \"mac+meta+z\"], proto.undo, {\n      checker: textInputChecker\n    }], [[\"ctrl+y\", \"ctrl+shift+z\", \"mac+meta+shift+z\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"], proto.redo, {\n      checker: textInputChecker\n    }], [[\"Backspace\", \"alt+Backspace\", \"ctrl+Backspace\", \"shift+Backspace\", \"mac+Backspace\", \"mac+alt+Backspace\", \"mac+ctrl+Backspace\", \"Delete\", \"ctrl+Delete\", \"shift+Delete\", \"mac+Delete\"], proto.delete, {\n      checker: textInputChecker\n    }], [[\"Enter\", \"mac+Enter\"], proto.addNewEditorFromKeyboard, {\n      checker: (self, {\n        target: el\n      }) => !(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled\n    }], [[\" \", \"mac+ \"], proto.addNewEditorFromKeyboard, {\n      checker: (self, {\n        target: el\n      }) => !(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)\n    }], [[\"Escape\", \"mac+Escape\"], proto.unselectAll], [[\"ArrowLeft\", \"mac+ArrowLeft\"], proto.translateSelectedEditors, {\n      args: [-small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], proto.translateSelectedEditors, {\n      args: [-big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto.translateSelectedEditors, {\n      args: [small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], proto.translateSelectedEditors, {\n      args: [big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto.translateSelectedEditors, {\n      args: [0, -small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], proto.translateSelectedEditors, {\n      args: [0, -big],\n      checker: arrowChecker\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto.translateSelectedEditors, {\n      args: [0, small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], proto.translateSelectedEditors, {\n      args: [0, big],\n      checker: arrowChecker\n    }]]));\n  }\n  constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager) {\n    const signal = this._signal = this.#abortController.signal;\n    this.#container = container;\n    this.#viewer = viewer;\n    this.#altTextManager = altTextManager;\n    this._eventBus = eventBus;\n    eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n      signal\n    });\n    eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n      signal\n    });\n    eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n      signal\n    });\n    eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n      signal\n    });\n    eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n      signal\n    });\n    eventBus._on(\"switchannotationeditorparams\", evt => this.updateParams(evt.type, evt.value), {\n      signal\n    });\n    this.#addSelectionListener();\n    this.#addDragAndDropListeners();\n    this.#addKeyboardManager();\n    this.#annotationStorage = pdfDocument.annotationStorage;\n    this.#filterFactory = pdfDocument.filterFactory;\n    this.#pageColors = pageColors;\n    this.#highlightColors = highlightColors || null;\n    this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n    this.#enableUpdatedAddImage = enableUpdatedAddImage;\n    this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n    this.#mlManager = mlManager || null;\n    this.viewParameters = {\n      realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n      rotation: 0\n    };\n    this.isShiftKeyDown = false;\n  }\n  destroy() {\n    this.#updateModeCapability?.resolve();\n    this.#updateModeCapability = null;\n    this.#abortController?.abort();\n    this.#abortController = null;\n    this._signal = null;\n    for (const layer of this.#allLayers.values()) {\n      layer.destroy();\n    }\n    this.#allLayers.clear();\n    this.#allEditors.clear();\n    this.#editorsToRescale.clear();\n    this.#activeEditor = null;\n    this.#selectedEditors.clear();\n    this.#commandManager.destroy();\n    this.#altTextManager?.destroy();\n    this.#highlightToolbar?.hide();\n    this.#highlightToolbar = null;\n    if (this.#focusMainContainerTimeoutId) {\n      clearTimeout(this.#focusMainContainerTimeoutId);\n      this.#focusMainContainerTimeoutId = null;\n    }\n    if (this.#translationTimeoutId) {\n      clearTimeout(this.#translationTimeoutId);\n      this.#translationTimeoutId = null;\n    }\n  }\n  combinedSignal(ac) {\n    return AbortSignal.any([this._signal, ac.signal]);\n  }\n  get mlManager() {\n    return this.#mlManager;\n  }\n  get useNewAltTextFlow() {\n    return this.#enableUpdatedAddImage;\n  }\n  get useNewAltTextWhenAddingImage() {\n    return this.#enableNewAltTextWhenAddingImage;\n  }\n  get hcmFilter() {\n    return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n  }\n  get direction() {\n    return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n  }\n  get highlightColors() {\n    return shadow(this, \"highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map(pair => pair.split(\"=\").map(x => x.trim()))) : null);\n  }\n  get highlightColorNames() {\n    return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, e => e.reverse())) : null);\n  }\n  setMainHighlightColorPicker(colorPicker) {\n    this.#mainHighlightColorPicker = colorPicker;\n  }\n  editAltText(editor, firstTime = false) {\n    this.#altTextManager?.editAltText(this, editor, firstTime);\n  }\n  switchToMode(mode, callback) {\n    this._eventBus.on(\"annotationeditormodechanged\", callback, {\n      once: true,\n      signal: this._signal\n    });\n    this._eventBus.dispatch(\"showannotationeditorui\", {\n      source: this,\n      mode\n    });\n  }\n  setPreference(name, value) {\n    this._eventBus.dispatch(\"setpreference\", {\n      source: this,\n      name,\n      value\n    });\n  }\n  onSetPreference({\n    name,\n    value\n  }) {\n    switch (name) {\n      case \"enableNewAltTextWhenAddingImage\":\n        this.#enableNewAltTextWhenAddingImage = value;\n        break;\n    }\n  }\n  onPageChanging({\n    pageNumber\n  }) {\n    this.#currentPageIndex = pageNumber - 1;\n  }\n  focusMainContainer() {\n    this.#container.focus();\n  }\n  findParent(x, y) {\n    for (const layer of this.#allLayers.values()) {\n      const {\n        x: layerX,\n        y: layerY,\n        width,\n        height\n      } = layer.div.getBoundingClientRect();\n      if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n        return layer;\n      }\n    }\n    return null;\n  }\n  disableUserSelect(value = false) {\n    this.#viewer.classList.toggle(\"noUserSelect\", value);\n  }\n  addShouldRescale(editor) {\n    this.#editorsToRescale.add(editor);\n  }\n  removeShouldRescale(editor) {\n    this.#editorsToRescale.delete(editor);\n  }\n  onScaleChanging({\n    scale\n  }) {\n    this.commitOrRemove();\n    this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n    for (const editor of this.#editorsToRescale) {\n      editor.onScaleChanging();\n    }\n  }\n  onRotationChanging({\n    pagesRotation\n  }) {\n    this.commitOrRemove();\n    this.viewParameters.rotation = pagesRotation;\n  }\n  #getAnchorElementForSelection({\n    anchorNode\n  }) {\n    return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n  }\n  #getLayerForTextLayer(textLayer) {\n    const {\n      currentLayer\n    } = this;\n    if (currentLayer.hasTextLayer(textLayer)) {\n      return currentLayer;\n    }\n    for (const layer of this.#allLayers.values()) {\n      if (layer.hasTextLayer(textLayer)) {\n        return layer;\n      }\n    }\n    return null;\n  }\n  highlightSelection(methodOfCreation = \"\") {\n    const selection = document.getSelection();\n    if (!selection || selection.isCollapsed) {\n      return;\n    }\n    const {\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset\n    } = selection;\n    const text = selection.toString();\n    const anchorElement = this.#getAnchorElementForSelection(selection);\n    const textLayer = anchorElement.closest(\".textLayer\");\n    const boxes = this.getSelectionBoxes(textLayer);\n    if (!boxes) {\n      return;\n    }\n    selection.empty();\n    const layer = this.#getLayerForTextLayer(textLayer);\n    const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n    const callback = () => {\n      layer?.createAndAddNewEditor({\n        x: 0,\n        y: 0\n      }, false, {\n        methodOfCreation,\n        boxes,\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset,\n        text\n      });\n      if (isNoneMode) {\n        this.showAllEditors(\"highlight\", true, true);\n      }\n    };\n    if (isNoneMode) {\n      this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n      return;\n    }\n    callback();\n  }\n  #displayHighlightToolbar() {\n    const selection = document.getSelection();\n    if (!selection || selection.isCollapsed) {\n      return;\n    }\n    const anchorElement = this.#getAnchorElementForSelection(selection);\n    const textLayer = anchorElement.closest(\".textLayer\");\n    const boxes = this.getSelectionBoxes(textLayer);\n    if (!boxes) {\n      return;\n    }\n    this.#highlightToolbar ||= new HighlightToolbar(this);\n    this.#highlightToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n  }\n  addToAnnotationStorage(editor) {\n    if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n      this.#annotationStorage.setValue(editor.id, editor);\n    }\n  }\n  #selectionChange() {\n    const selection = document.getSelection();\n    if (!selection || selection.isCollapsed) {\n      if (this.#selectedTextNode) {\n        this.#highlightToolbar?.hide();\n        this.#selectedTextNode = null;\n        this.#dispatchUpdateStates({\n          hasSelectedText: false\n        });\n      }\n      return;\n    }\n    const {\n      anchorNode\n    } = selection;\n    if (anchorNode === this.#selectedTextNode) {\n      return;\n    }\n    const anchorElement = this.#getAnchorElementForSelection(selection);\n    const textLayer = anchorElement.closest(\".textLayer\");\n    if (!textLayer) {\n      if (this.#selectedTextNode) {\n        this.#highlightToolbar?.hide();\n        this.#selectedTextNode = null;\n        this.#dispatchUpdateStates({\n          hasSelectedText: false\n        });\n      }\n      return;\n    }\n    this.#highlightToolbar?.hide();\n    this.#selectedTextNode = anchorNode;\n    this.#dispatchUpdateStates({\n      hasSelectedText: true\n    });\n    if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n      return;\n    }\n    if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n      this.showAllEditors(\"highlight\", true, true);\n    }\n    this.#highlightWhenShiftUp = this.isShiftKeyDown;\n    if (!this.isShiftKeyDown) {\n      const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n      activeLayer?.toggleDrawing();\n      const ac = new AbortController();\n      const signal = this.combinedSignal(ac);\n      const pointerup = e => {\n        if (e.type === \"pointerup\" && e.button !== 0) {\n          return;\n        }\n        ac.abort();\n        activeLayer?.toggleDrawing(true);\n        if (e.type === \"pointerup\") {\n          this.#onSelectEnd(\"main_toolbar\");\n        }\n      };\n      window.addEventListener(\"pointerup\", pointerup, {\n        signal\n      });\n      window.addEventListener(\"blur\", pointerup, {\n        signal\n      });\n    }\n  }\n  #onSelectEnd(methodOfCreation = \"\") {\n    if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n      this.highlightSelection(methodOfCreation);\n    } else if (this.#enableHighlightFloatingButton) {\n      this.#displayHighlightToolbar();\n    }\n  }\n  #addSelectionListener() {\n    document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n      signal: this._signal\n    });\n  }\n  #addFocusManager() {\n    if (this.#focusManagerAC) {\n      return;\n    }\n    this.#focusManagerAC = new AbortController();\n    const signal = this.combinedSignal(this.#focusManagerAC);\n    window.addEventListener(\"focus\", this.focus.bind(this), {\n      signal\n    });\n    window.addEventListener(\"blur\", this.blur.bind(this), {\n      signal\n    });\n  }\n  #removeFocusManager() {\n    this.#focusManagerAC?.abort();\n    this.#focusManagerAC = null;\n  }\n  blur() {\n    this.isShiftKeyDown = false;\n    if (this.#highlightWhenShiftUp) {\n      this.#highlightWhenShiftUp = false;\n      this.#onSelectEnd(\"main_toolbar\");\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    for (const editor of this.#selectedEditors) {\n      if (editor.div.contains(activeElement)) {\n        this.#lastActiveElement = [editor, activeElement];\n        editor._focusEventsAllowed = false;\n        break;\n      }\n    }\n  }\n  focus() {\n    if (!this.#lastActiveElement) {\n      return;\n    }\n    const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n    this.#lastActiveElement = null;\n    lastActiveElement.addEventListener(\"focusin\", () => {\n      lastEditor._focusEventsAllowed = true;\n    }, {\n      once: true,\n      signal: this._signal\n    });\n    lastActiveElement.focus();\n  }\n  #addKeyboardManager() {\n    if (this.#keyboardManagerAC) {\n      return;\n    }\n    this.#keyboardManagerAC = new AbortController();\n    const signal = this.combinedSignal(this.#keyboardManagerAC);\n    window.addEventListener(\"keydown\", this.keydown.bind(this), {\n      signal\n    });\n    window.addEventListener(\"keyup\", this.keyup.bind(this), {\n      signal\n    });\n  }\n  #removeKeyboardManager() {\n    this.#keyboardManagerAC?.abort();\n    this.#keyboardManagerAC = null;\n  }\n  #addCopyPasteListeners() {\n    if (this.#copyPasteAC) {\n      return;\n    }\n    this.#copyPasteAC = new AbortController();\n    const signal = this.combinedSignal(this.#copyPasteAC);\n    document.addEventListener(\"copy\", this.copy.bind(this), {\n      signal\n    });\n    document.addEventListener(\"cut\", this.cut.bind(this), {\n      signal\n    });\n    document.addEventListener(\"paste\", this.paste.bind(this), {\n      signal\n    });\n  }\n  #removeCopyPasteListeners() {\n    this.#copyPasteAC?.abort();\n    this.#copyPasteAC = null;\n  }\n  #addDragAndDropListeners() {\n    const signal = this._signal;\n    document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n      signal\n    });\n    document.addEventListener(\"drop\", this.drop.bind(this), {\n      signal\n    });\n  }\n  addEditListeners() {\n    this.#addKeyboardManager();\n    this.#addCopyPasteListeners();\n  }\n  removeEditListeners() {\n    this.#removeKeyboardManager();\n    this.#removeCopyPasteListeners();\n  }\n  dragOver(event) {\n    for (const {\n      type\n    } of event.dataTransfer.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(type)) {\n          event.dataTransfer.dropEffect = \"copy\";\n          event.preventDefault();\n          return;\n        }\n      }\n    }\n  }\n  drop(event) {\n    for (const item of event.dataTransfer.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(item.type)) {\n          editorType.paste(item, this.currentLayer);\n          event.preventDefault();\n          return;\n        }\n      }\n    }\n  }\n  copy(event) {\n    event.preventDefault();\n    this.#activeEditor?.commitOrRemove();\n    if (!this.hasSelection) {\n      return;\n    }\n    const editors = [];\n    for (const editor of this.#selectedEditors) {\n      const serialized = editor.serialize(true);\n      if (serialized) {\n        editors.push(serialized);\n      }\n    }\n    if (editors.length === 0) {\n      return;\n    }\n    event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n  }\n  cut(event) {\n    this.copy(event);\n    this.delete();\n  }\n  async paste(event) {\n    event.preventDefault();\n    const {\n      clipboardData\n    } = event;\n    for (const item of clipboardData.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(item.type)) {\n          editorType.paste(item, this.currentLayer);\n          return;\n        }\n      }\n    }\n    let data = clipboardData.getData(\"application/pdfjs\");\n    if (!data) {\n      return;\n    }\n    try {\n      data = JSON.parse(data);\n    } catch (ex) {\n      warn(`paste: \"${ex.message}\".`);\n      return;\n    }\n    if (!Array.isArray(data)) {\n      return;\n    }\n    this.unselectAll();\n    const layer = this.currentLayer;\n    try {\n      const newEditors = [];\n      for (const editor of data) {\n        const deserializedEditor = await layer.deserialize(editor);\n        if (!deserializedEditor) {\n          return;\n        }\n        newEditors.push(deserializedEditor);\n      }\n      const cmd = () => {\n        for (const editor of newEditors) {\n          this.#addEditorToLayer(editor);\n        }\n        this.#selectEditors(newEditors);\n      };\n      const undo = () => {\n        for (const editor of newEditors) {\n          editor.remove();\n        }\n      };\n      this.addCommands({\n        cmd,\n        undo,\n        mustExec: true\n      });\n    } catch (ex) {\n      warn(`paste: \"${ex.message}\".`);\n    }\n  }\n  keydown(event) {\n    if (!this.isShiftKeyDown && event.key === \"Shift\") {\n      this.isShiftKeyDown = true;\n    }\n    if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n      AnnotationEditorUIManager._keyboardManager.exec(this, event);\n    }\n  }\n  keyup(event) {\n    if (this.isShiftKeyDown && event.key === \"Shift\") {\n      this.isShiftKeyDown = false;\n      if (this.#highlightWhenShiftUp) {\n        this.#highlightWhenShiftUp = false;\n        this.#onSelectEnd(\"main_toolbar\");\n      }\n    }\n  }\n  onEditingAction({\n    name\n  }) {\n    switch (name) {\n      case \"undo\":\n      case \"redo\":\n      case \"delete\":\n      case \"selectAll\":\n        this[name]();\n        break;\n      case \"highlightSelection\":\n        this.highlightSelection(\"context_menu\");\n        break;\n    }\n  }\n  #dispatchUpdateStates(details) {\n    const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);\n    if (hasChanged) {\n      this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n        source: this,\n        details: Object.assign(this.#previousStates, details)\n      });\n      if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n        this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_FREE, true]]);\n      }\n    }\n  }\n  #dispatchUpdateUI(details) {\n    this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n      source: this,\n      details\n    });\n  }\n  setEditingState(isEditing) {\n    if (isEditing) {\n      this.#addFocusManager();\n      this.#addCopyPasteListeners();\n      this.#dispatchUpdateStates({\n        isEditing: this.#mode !== AnnotationEditorType.NONE,\n        isEmpty: this.#isEmpty(),\n        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n        hasSelectedEditor: false\n      });\n    } else {\n      this.#removeFocusManager();\n      this.#removeCopyPasteListeners();\n      this.#dispatchUpdateStates({\n        isEditing: false\n      });\n      this.disableUserSelect(false);\n    }\n  }\n  registerEditorTypes(types) {\n    if (this.#editorTypes) {\n      return;\n    }\n    this.#editorTypes = types;\n    for (const editorType of this.#editorTypes) {\n      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n  }\n  getId() {\n    return this.#idManager.id;\n  }\n  get currentLayer() {\n    return this.#allLayers.get(this.#currentPageIndex);\n  }\n  getLayer(pageIndex) {\n    return this.#allLayers.get(pageIndex);\n  }\n  get currentPageIndex() {\n    return this.#currentPageIndex;\n  }\n  addLayer(layer) {\n    this.#allLayers.set(layer.pageIndex, layer);\n    if (this.#isEnabled) {\n      layer.enable();\n    } else {\n      layer.disable();\n    }\n  }\n  removeLayer(layer) {\n    this.#allLayers.delete(layer.pageIndex);\n  }\n  async updateMode(mode, editId = null, isFromKeyboard = false) {\n    if (this.#mode === mode) {\n      return;\n    }\n    if (this.#updateModeCapability) {\n      await this.#updateModeCapability.promise;\n      if (!this.#updateModeCapability) {\n        return;\n      }\n    }\n    this.#updateModeCapability = Promise.withResolvers();\n    this.#mode = mode;\n    if (mode === AnnotationEditorType.NONE) {\n      this.setEditingState(false);\n      this.#disableAll();\n      this.#updateModeCapability.resolve();\n      return;\n    }\n    this.setEditingState(true);\n    await this.#enableAll();\n    this.unselectAll();\n    for (const layer of this.#allLayers.values()) {\n      layer.updateMode(mode);\n    }\n    if (!editId) {\n      if (isFromKeyboard) {\n        this.addNewEditorFromKeyboard();\n      }\n      this.#updateModeCapability.resolve();\n      return;\n    }\n    for (const editor of this.#allEditors.values()) {\n      if (editor.annotationElementId === editId) {\n        this.setSelected(editor);\n        editor.enterInEditMode();\n      } else {\n        editor.unselect();\n      }\n    }\n    this.#updateModeCapability.resolve();\n  }\n  addNewEditorFromKeyboard() {\n    if (this.currentLayer.canCreateNewEmptyEditor()) {\n      this.currentLayer.addNewEditor();\n    }\n  }\n  updateToolbar(mode) {\n    if (mode === this.#mode) {\n      return;\n    }\n    this._eventBus.dispatch(\"switchannotationeditormode\", {\n      source: this,\n      mode\n    });\n  }\n  updateParams(type, value) {\n    if (!this.#editorTypes) {\n      return;\n    }\n    switch (type) {\n      case AnnotationEditorParamsType.CREATE:\n        this.currentLayer.addNewEditor();\n        return;\n      case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n        this.#mainHighlightColorPicker?.updateColor(value);\n        break;\n      case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n        this._eventBus.dispatch(\"reporttelemetry\", {\n          source: this,\n          details: {\n            type: \"editing\",\n            data: {\n              type: \"highlight\",\n              action: \"toggle_visibility\"\n            }\n          }\n        });\n        (this.#showAllStates ||= new Map()).set(type, value);\n        this.showAllEditors(\"highlight\", value);\n        break;\n    }\n    for (const editor of this.#selectedEditors) {\n      editor.updateParams(type, value);\n    }\n    for (const editorType of this.#editorTypes) {\n      editorType.updateDefaultParams(type, value);\n    }\n  }\n  showAllEditors(type, visible, updateButton = false) {\n    for (const editor of this.#allEditors.values()) {\n      if (editor.editorType === type) {\n        editor.show(visible);\n      }\n    }\n    const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n    if (state !== visible) {\n      this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible]]);\n    }\n  }\n  enableWaiting(mustWait = false) {\n    if (this.#isWaiting === mustWait) {\n      return;\n    }\n    this.#isWaiting = mustWait;\n    for (const layer of this.#allLayers.values()) {\n      if (mustWait) {\n        layer.disableClick();\n      } else {\n        layer.enableClick();\n      }\n      layer.div.classList.toggle(\"waiting\", mustWait);\n    }\n  }\n  async #enableAll() {\n    if (!this.#isEnabled) {\n      this.#isEnabled = true;\n      const promises = [];\n      for (const layer of this.#allLayers.values()) {\n        promises.push(layer.enable());\n      }\n      await Promise.all(promises);\n      for (const editor of this.#allEditors.values()) {\n        editor.enable();\n      }\n    }\n  }\n  #disableAll() {\n    this.unselectAll();\n    if (this.#isEnabled) {\n      this.#isEnabled = false;\n      for (const layer of this.#allLayers.values()) {\n        layer.disable();\n      }\n      for (const editor of this.#allEditors.values()) {\n        editor.disable();\n      }\n    }\n  }\n  getEditors(pageIndex) {\n    const editors = [];\n    for (const editor of this.#allEditors.values()) {\n      if (editor.pageIndex === pageIndex) {\n        editors.push(editor);\n      }\n    }\n    return editors;\n  }\n  getEditor(id) {\n    return this.#allEditors.get(id);\n  }\n  addEditor(editor) {\n    this.#allEditors.set(editor.id, editor);\n  }\n  removeEditor(editor) {\n    if (editor.div.contains(document.activeElement)) {\n      if (this.#focusMainContainerTimeoutId) {\n        clearTimeout(this.#focusMainContainerTimeoutId);\n      }\n      this.#focusMainContainerTimeoutId = setTimeout(() => {\n        this.focusMainContainer();\n        this.#focusMainContainerTimeoutId = null;\n      }, 0);\n    }\n    this.#allEditors.delete(editor.id);\n    this.unselect(editor);\n    if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n      this.#annotationStorage?.remove(editor.id);\n    }\n  }\n  addDeletedAnnotationElement(editor) {\n    this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n    this.addChangedExistingAnnotation(editor);\n    editor.deleted = true;\n  }\n  isDeletedAnnotationElement(annotationElementId) {\n    return this.#deletedAnnotationsElementIds.has(annotationElementId);\n  }\n  removeDeletedAnnotationElement(editor) {\n    this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n    this.removeChangedExistingAnnotation(editor);\n    editor.deleted = false;\n  }\n  #addEditorToLayer(editor) {\n    const layer = this.#allLayers.get(editor.pageIndex);\n    if (layer) {\n      layer.addOrRebuild(editor);\n    } else {\n      this.addEditor(editor);\n      this.addToAnnotationStorage(editor);\n    }\n  }\n  setActiveEditor(editor) {\n    if (this.#activeEditor === editor) {\n      return;\n    }\n    this.#activeEditor = editor;\n    if (editor) {\n      this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    }\n  }\n  get #lastSelectedEditor() {\n    let ed = null;\n    for (ed of this.#selectedEditors) {}\n    return ed;\n  }\n  updateUI(editor) {\n    if (this.#lastSelectedEditor === editor) {\n      this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    }\n  }\n  toggleSelected(editor) {\n    if (this.#selectedEditors.has(editor)) {\n      this.#selectedEditors.delete(editor);\n      editor.unselect();\n      this.#dispatchUpdateStates({\n        hasSelectedEditor: this.hasSelection\n      });\n      return;\n    }\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  setSelected(editor) {\n    for (const ed of this.#selectedEditors) {\n      if (ed !== editor) {\n        ed.unselect();\n      }\n    }\n    this.#selectedEditors.clear();\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  isSelected(editor) {\n    return this.#selectedEditors.has(editor);\n  }\n  get firstSelectedEditor() {\n    return this.#selectedEditors.values().next().value;\n  }\n  unselect(editor) {\n    editor.unselect();\n    this.#selectedEditors.delete(editor);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: this.hasSelection\n    });\n  }\n  get hasSelection() {\n    return this.#selectedEditors.size !== 0;\n  }\n  get isEnterHandled() {\n    return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n  }\n  undo() {\n    this.#commandManager.undo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n      hasSomethingToRedo: true,\n      isEmpty: this.#isEmpty()\n    });\n  }\n  redo() {\n    this.#commandManager.redo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n      isEmpty: this.#isEmpty()\n    });\n  }\n  addCommands(params) {\n    this.#commandManager.add(params);\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: false,\n      isEmpty: this.#isEmpty()\n    });\n  }\n  #isEmpty() {\n    if (this.#allEditors.size === 0) {\n      return true;\n    }\n    if (this.#allEditors.size === 1) {\n      for (const editor of this.#allEditors.values()) {\n        return editor.isEmpty();\n      }\n    }\n    return false;\n  }\n  delete() {\n    this.commitOrRemove();\n    if (!this.hasSelection) {\n      return;\n    }\n    const editors = [...this.#selectedEditors];\n    const cmd = () => {\n      for (const editor of editors) {\n        editor.remove();\n      }\n    };\n    const undo = () => {\n      for (const editor of editors) {\n        this.#addEditorToLayer(editor);\n      }\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n  commitOrRemove() {\n    this.#activeEditor?.commitOrRemove();\n  }\n  hasSomethingToControl() {\n    return this.#activeEditor || this.hasSelection;\n  }\n  #selectEditors(editors) {\n    for (const editor of this.#selectedEditors) {\n      editor.unselect();\n    }\n    this.#selectedEditors.clear();\n    for (const editor of editors) {\n      if (editor.isEmpty()) {\n        continue;\n      }\n      this.#selectedEditors.add(editor);\n      editor.select();\n    }\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: this.hasSelection\n    });\n  }\n  selectAll() {\n    for (const editor of this.#selectedEditors) {\n      editor.commit();\n    }\n    this.#selectEditors(this.#allEditors.values());\n  }\n  unselectAll() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n      if (this.#mode !== AnnotationEditorType.NONE) {\n        return;\n      }\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    for (const editor of this.#selectedEditors) {\n      editor.unselect();\n    }\n    this.#selectedEditors.clear();\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: false\n    });\n  }\n  translateSelectedEditors(x, y, noCommit = false) {\n    if (!noCommit) {\n      this.commitOrRemove();\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    this.#translation[0] += x;\n    this.#translation[1] += y;\n    const [totalX, totalY] = this.#translation;\n    const editors = [...this.#selectedEditors];\n    const TIME_TO_WAIT = 1000;\n    if (this.#translationTimeoutId) {\n      clearTimeout(this.#translationTimeoutId);\n    }\n    this.#translationTimeoutId = setTimeout(() => {\n      this.#translationTimeoutId = null;\n      this.#translation[0] = this.#translation[1] = 0;\n      this.addCommands({\n        cmd: () => {\n          for (const editor of editors) {\n            if (this.#allEditors.has(editor.id)) {\n              editor.translateInPage(totalX, totalY);\n            }\n          }\n        },\n        undo: () => {\n          for (const editor of editors) {\n            if (this.#allEditors.has(editor.id)) {\n              editor.translateInPage(-totalX, -totalY);\n            }\n          }\n        },\n        mustExec: false\n      });\n    }, TIME_TO_WAIT);\n    for (const editor of editors) {\n      editor.translateInPage(x, y);\n    }\n  }\n  setUpDragSession() {\n    if (!this.hasSelection) {\n      return;\n    }\n    this.disableUserSelect(true);\n    this.#draggingEditors = new Map();\n    for (const editor of this.#selectedEditors) {\n      this.#draggingEditors.set(editor, {\n        savedX: editor.x,\n        savedY: editor.y,\n        savedPageIndex: editor.pageIndex,\n        newX: 0,\n        newY: 0,\n        newPageIndex: -1\n      });\n    }\n  }\n  endDragSession() {\n    if (!this.#draggingEditors) {\n      return false;\n    }\n    this.disableUserSelect(false);\n    const map = this.#draggingEditors;\n    this.#draggingEditors = null;\n    let mustBeAddedInUndoStack = false;\n    for (const [{\n      x,\n      y,\n      pageIndex\n    }, value] of map) {\n      value.newX = x;\n      value.newY = y;\n      value.newPageIndex = pageIndex;\n      mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n    }\n    if (!mustBeAddedInUndoStack) {\n      return false;\n    }\n    const move = (editor, x, y, pageIndex) => {\n      if (this.#allEditors.has(editor.id)) {\n        const parent = this.#allLayers.get(pageIndex);\n        if (parent) {\n          editor._setParentAndPosition(parent, x, y);\n        } else {\n          editor.pageIndex = pageIndex;\n          editor.x = x;\n          editor.y = y;\n        }\n      }\n    };\n    this.addCommands({\n      cmd: () => {\n        for (const [editor, {\n          newX,\n          newY,\n          newPageIndex\n        }] of map) {\n          move(editor, newX, newY, newPageIndex);\n        }\n      },\n      undo: () => {\n        for (const [editor, {\n          savedX,\n          savedY,\n          savedPageIndex\n        }] of map) {\n          move(editor, savedX, savedY, savedPageIndex);\n        }\n      },\n      mustExec: true\n    });\n    return true;\n  }\n  dragSelectedEditors(tx, ty) {\n    if (!this.#draggingEditors) {\n      return;\n    }\n    for (const editor of this.#draggingEditors.keys()) {\n      editor.drag(tx, ty);\n    }\n  }\n  rebuild(editor) {\n    if (editor.parent === null) {\n      const parent = this.getLayer(editor.pageIndex);\n      if (parent) {\n        parent.changeParent(editor);\n        parent.addOrRebuild(editor);\n      } else {\n        this.addEditor(editor);\n        this.addToAnnotationStorage(editor);\n        editor.rebuild();\n      }\n    } else {\n      editor.parent.addOrRebuild(editor);\n    }\n  }\n  get isEditorHandlingKeyboard() {\n    return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n  }\n  isActive(editor) {\n    return this.#activeEditor === editor;\n  }\n  getActive() {\n    return this.#activeEditor;\n  }\n  getMode() {\n    return this.#mode;\n  }\n  get imageManager() {\n    return shadow(this, \"imageManager\", new ImageManager());\n  }\n  getSelectionBoxes(textLayer) {\n    if (!textLayer) {\n      return null;\n    }\n    const selection = document.getSelection();\n    for (let i = 0, ii = selection.rangeCount; i < ii; i++) {\n      if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n        return null;\n      }\n    }\n    const {\n      x: layerX,\n      y: layerY,\n      width: parentWidth,\n      height: parentHeight\n    } = textLayer.getBoundingClientRect();\n    let rotator;\n    switch (textLayer.getAttribute(\"data-main-rotation\")) {\n      case \"90\":\n        rotator = (x, y, w, h) => ({\n          x: (y - layerY) / parentHeight,\n          y: 1 - (x + w - layerX) / parentWidth,\n          width: h / parentHeight,\n          height: w / parentWidth\n        });\n        break;\n      case \"180\":\n        rotator = (x, y, w, h) => ({\n          x: 1 - (x + w - layerX) / parentWidth,\n          y: 1 - (y + h - layerY) / parentHeight,\n          width: w / parentWidth,\n          height: h / parentHeight\n        });\n        break;\n      case \"270\":\n        rotator = (x, y, w, h) => ({\n          x: 1 - (y + h - layerY) / parentHeight,\n          y: (x - layerX) / parentWidth,\n          width: h / parentHeight,\n          height: w / parentWidth\n        });\n        break;\n      default:\n        rotator = (x, y, w, h) => ({\n          x: (x - layerX) / parentWidth,\n          y: (y - layerY) / parentHeight,\n          width: w / parentWidth,\n          height: h / parentHeight\n        });\n        break;\n    }\n    const boxes = [];\n    for (let i = 0, ii = selection.rangeCount; i < ii; i++) {\n      const range = selection.getRangeAt(i);\n      if (range.collapsed) {\n        continue;\n      }\n      for (const {\n        x,\n        y,\n        width,\n        height\n      } of range.getClientRects()) {\n        if (width === 0 || height === 0) {\n          continue;\n        }\n        boxes.push(rotator(x, y, width, height));\n      }\n    }\n    return boxes.length === 0 ? null : boxes;\n  }\n  addChangedExistingAnnotation({\n    annotationElementId,\n    id\n  }) {\n    (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);\n  }\n  removeChangedExistingAnnotation({\n    annotationElementId\n  }) {\n    this.#changedExistingAnnotations?.delete(annotationElementId);\n  }\n  renderAnnotationElement(annotation) {\n    const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n    if (!editorId) {\n      return;\n    }\n    const editor = this.#annotationStorage.getRawValue(editorId);\n    if (!editor) {\n      return;\n    }\n    if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n      return;\n    }\n    editor.renderAnnotationElement(annotation);\n  }\n}\n\n;// ./src/display/editor/alt_text.js\n\nclass AltText {\n  #altText = null;\n  #altTextDecorative = false;\n  #altTextButton = null;\n  #altTextButtonLabel = null;\n  #altTextTooltip = null;\n  #altTextTooltipTimeout = null;\n  #altTextWasFromKeyBoard = false;\n  #badge = null;\n  #editor = null;\n  #guessedText = null;\n  #textWithDisclaimer = null;\n  #useNewAltTextFlow = false;\n  static #l10nNewButton = null;\n  static _l10n = null;\n  constructor(editor) {\n    this.#editor = editor;\n    this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n    AltText.#l10nNewButton ||= Object.freeze({\n      added: \"pdfjs-editor-new-alt-text-added-button\",\n      \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n      missing: \"pdfjs-editor-new-alt-text-missing-button\",\n      \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n      review: \"pdfjs-editor-new-alt-text-to-review-button\",\n      \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n    });\n  }\n  static initialize(l10n) {\n    AltText._l10n ??= l10n;\n  }\n  async render() {\n    const altText = this.#altTextButton = document.createElement(\"button\");\n    altText.className = \"altText\";\n    altText.tabIndex = \"0\";\n    const label = this.#altTextButtonLabel = document.createElement(\"span\");\n    altText.append(label);\n    if (this.#useNewAltTextFlow) {\n      altText.classList.add(\"new\");\n      altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n      label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n    } else {\n      altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n      label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n    }\n    const signal = this.#editor._uiManager._signal;\n    altText.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    altText.addEventListener(\"pointerdown\", event => event.stopPropagation(), {\n      signal\n    });\n    const onClick = event => {\n      event.preventDefault();\n      this.#editor._uiManager.editAltText(this.#editor);\n      if (this.#useNewAltTextFlow) {\n        this.#editor._reportTelemetry({\n          action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n          data: {\n            label: this.#label\n          }\n        });\n      }\n    };\n    altText.addEventListener(\"click\", onClick, {\n      capture: true,\n      signal\n    });\n    altText.addEventListener(\"keydown\", event => {\n      if (event.target === altText && event.key === \"Enter\") {\n        this.#altTextWasFromKeyBoard = true;\n        onClick(event);\n      }\n    }, {\n      signal\n    });\n    await this.#setState();\n    return altText;\n  }\n  get #label() {\n    return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n  }\n  finish() {\n    if (!this.#altTextButton) {\n      return;\n    }\n    this.#altTextButton.focus({\n      focusVisible: this.#altTextWasFromKeyBoard\n    });\n    this.#altTextWasFromKeyBoard = false;\n  }\n  isEmpty() {\n    if (this.#useNewAltTextFlow) {\n      return this.#altText === null;\n    }\n    return !this.#altText && !this.#altTextDecorative;\n  }\n  hasData() {\n    if (this.#useNewAltTextFlow) {\n      return this.#altText !== null || !!this.#guessedText;\n    }\n    return this.isEmpty();\n  }\n  get guessedText() {\n    return this.#guessedText;\n  }\n  async setGuessedText(guessedText) {\n    if (this.#altText !== null) {\n      return;\n    }\n    this.#guessedText = guessedText;\n    this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n      generatedAltText: guessedText\n    });\n    this.#setState();\n  }\n  toggleAltTextBadge(visibility = false) {\n    if (!this.#useNewAltTextFlow || this.#altText) {\n      this.#badge?.remove();\n      this.#badge = null;\n      return;\n    }\n    if (!this.#badge) {\n      const badge = this.#badge = document.createElement(\"div\");\n      badge.className = \"noAltTextBadge\";\n      this.#editor.div.append(badge);\n    }\n    this.#badge.classList.toggle(\"hidden\", !visibility);\n  }\n  serialize(isForCopying) {\n    let altText = this.#altText;\n    if (!isForCopying && this.#guessedText === altText) {\n      altText = this.#textWithDisclaimer;\n    }\n    return {\n      altText,\n      decorative: this.#altTextDecorative,\n      guessedText: this.#guessedText,\n      textWithDisclaimer: this.#textWithDisclaimer\n    };\n  }\n  get data() {\n    return {\n      altText: this.#altText,\n      decorative: this.#altTextDecorative\n    };\n  }\n  set data({\n    altText,\n    decorative,\n    guessedText,\n    textWithDisclaimer,\n    cancel = false\n  }) {\n    if (guessedText) {\n      this.#guessedText = guessedText;\n      this.#textWithDisclaimer = textWithDisclaimer;\n    }\n    if (this.#altText === altText && this.#altTextDecorative === decorative) {\n      return;\n    }\n    if (!cancel) {\n      this.#altText = altText;\n      this.#altTextDecorative = decorative;\n    }\n    this.#setState();\n  }\n  toggle(enabled = false) {\n    if (!this.#altTextButton) {\n      return;\n    }\n    if (!enabled && this.#altTextTooltipTimeout) {\n      clearTimeout(this.#altTextTooltipTimeout);\n      this.#altTextTooltipTimeout = null;\n    }\n    this.#altTextButton.disabled = !enabled;\n  }\n  shown() {\n    this.#editor._reportTelemetry({\n      action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n      data: {\n        label: this.#label\n      }\n    });\n  }\n  destroy() {\n    this.#altTextButton?.remove();\n    this.#altTextButton = null;\n    this.#altTextButtonLabel = null;\n    this.#altTextTooltip = null;\n    this.#badge?.remove();\n    this.#badge = null;\n  }\n  async #setState() {\n    const button = this.#altTextButton;\n    if (!button) {\n      return;\n    }\n    if (this.#useNewAltTextFlow) {\n      button.classList.toggle(\"done\", !!this.#altText);\n      button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n      this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n      if (!this.#altText) {\n        this.#altTextTooltip?.remove();\n        return;\n      }\n    } else {\n      if (!this.#altText && !this.#altTextDecorative) {\n        button.classList.remove(\"done\");\n        this.#altTextTooltip?.remove();\n        return;\n      }\n      button.classList.add(\"done\");\n      button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n    }\n    let tooltip = this.#altTextTooltip;\n    if (!tooltip) {\n      this.#altTextTooltip = tooltip = document.createElement(\"span\");\n      tooltip.className = \"tooltip\";\n      tooltip.setAttribute(\"role\", \"tooltip\");\n      tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n      const DELAY_TO_SHOW_TOOLTIP = 100;\n      const signal = this.#editor._uiManager._signal;\n      signal.addEventListener(\"abort\", () => {\n        clearTimeout(this.#altTextTooltipTimeout);\n        this.#altTextTooltipTimeout = null;\n      }, {\n        once: true\n      });\n      button.addEventListener(\"mouseenter\", () => {\n        this.#altTextTooltipTimeout = setTimeout(() => {\n          this.#altTextTooltipTimeout = null;\n          this.#altTextTooltip.classList.add(\"show\");\n          this.#editor._reportTelemetry({\n            action: \"alt_text_tooltip\"\n          });\n        }, DELAY_TO_SHOW_TOOLTIP);\n      }, {\n        signal\n      });\n      button.addEventListener(\"mouseleave\", () => {\n        if (this.#altTextTooltipTimeout) {\n          clearTimeout(this.#altTextTooltipTimeout);\n          this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextTooltip?.classList.remove(\"show\");\n      }, {\n        signal\n      });\n    }\n    if (this.#altTextDecorative) {\n      tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n    } else {\n      tooltip.removeAttribute(\"data-l10n-id\");\n      tooltip.textContent = this.#altText;\n    }\n    if (!tooltip.parentNode) {\n      button.append(tooltip);\n    }\n    const element = this.#editor.getImageForAltText();\n    element?.setAttribute(\"aria-describedby\", tooltip.id);\n  }\n}\n\n;// ./src/display/editor/editor.js\n\n\n\n\n\nclass AnnotationEditor {\n  #accessibilityData = null;\n  #allResizerDivs = null;\n  #altText = null;\n  #disabled = false;\n  #keepAspectRatio = false;\n  #resizersDiv = null;\n  #savedDimensions = null;\n  #focusAC = null;\n  #focusedResizerName = \"\";\n  #hasBeenClicked = false;\n  #initialPosition = null;\n  #isEditing = false;\n  #isInEditMode = false;\n  #isResizerEnabledForKeyboard = false;\n  #moveInDOMTimeout = null;\n  #prevDragX = 0;\n  #prevDragY = 0;\n  #telemetryTimeouts = null;\n  _editToolbar = null;\n  _initialOptions = Object.create(null);\n  _initialData = null;\n  _isVisible = true;\n  _uiManager = null;\n  _focusEventsAllowed = true;\n  static _l10n = null;\n  static _l10nResizer = null;\n  #isDraggable = false;\n  #zIndex = AnnotationEditor._zIndex++;\n  static _borderLineWidth = -1;\n  static _colorManager = new ColorManager();\n  static _zIndex = 1;\n  static _telemetryTimeout = 1000;\n  static get _resizerKeyboardManager() {\n    const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n    const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n    return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([[[\"ArrowLeft\", \"mac+ArrowLeft\"], resize, {\n      args: [-small, 0]\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], resize, {\n      args: [-big, 0]\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], resize, {\n      args: [small, 0]\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], resize, {\n      args: [big, 0]\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], resize, {\n      args: [0, -small]\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], resize, {\n      args: [0, -big]\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], resize, {\n      args: [0, small]\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], resize, {\n      args: [0, big]\n    }], [[\"Escape\", \"mac+Escape\"], AnnotationEditor.prototype._stopResizingWithKeyboard]]));\n  }\n  constructor(parameters) {\n    this.parent = parameters.parent;\n    this.id = parameters.id;\n    this.width = this.height = null;\n    this.pageIndex = parameters.parent.pageIndex;\n    this.name = parameters.name;\n    this.div = null;\n    this._uiManager = parameters.uiManager;\n    this.annotationElementId = null;\n    this._willKeepAspectRatio = false;\n    this._initialOptions.isCentered = parameters.isCentered;\n    this._structTreeParentId = null;\n    const {\n      rotation,\n      rawDims: {\n        pageWidth,\n        pageHeight,\n        pageX,\n        pageY\n      }\n    } = this.parent.viewport;\n    this.rotation = rotation;\n    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n    this.pageDimensions = [pageWidth, pageHeight];\n    this.pageTranslation = [pageX, pageY];\n    const [width, height] = this.parentDimensions;\n    this.x = parameters.x / width;\n    this.y = parameters.y / height;\n    this.isAttachedToDOM = false;\n    this.deleted = false;\n  }\n  get editorType() {\n    return Object.getPrototypeOf(this).constructor._type;\n  }\n  static get _defaultLineColor() {\n    return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n  }\n  static deleteAnnotationElement(editor) {\n    const fakeEditor = new FakeEditor({\n      id: editor.parent.getNextId(),\n      parent: editor.parent,\n      uiManager: editor._uiManager\n    });\n    fakeEditor.annotationElementId = editor.annotationElementId;\n    fakeEditor.deleted = true;\n    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n  }\n  static initialize(l10n, _uiManager) {\n    AnnotationEditor._l10n ??= l10n;\n    AnnotationEditor._l10nResizer ||= Object.freeze({\n      topLeft: \"pdfjs-editor-resizer-top-left\",\n      topMiddle: \"pdfjs-editor-resizer-top-middle\",\n      topRight: \"pdfjs-editor-resizer-top-right\",\n      middleRight: \"pdfjs-editor-resizer-middle-right\",\n      bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n      bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n      bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n      middleLeft: \"pdfjs-editor-resizer-middle-left\"\n    });\n    if (AnnotationEditor._borderLineWidth !== -1) {\n      return;\n    }\n    const style = getComputedStyle(document.documentElement);\n    AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n  }\n  static updateDefaultParams(_type, _value) {}\n  static get defaultPropertiesToUpdate() {\n    return [];\n  }\n  static isHandlingMimeForPasting(mime) {\n    return false;\n  }\n  static paste(item, parent) {\n    unreachable(\"Not implemented\");\n  }\n  get propertiesToUpdate() {\n    return [];\n  }\n  get _isDraggable() {\n    return this.#isDraggable;\n  }\n  set _isDraggable(value) {\n    this.#isDraggable = value;\n    this.div?.classList.toggle(\"draggable\", value);\n  }\n  get isEnterHandled() {\n    return true;\n  }\n  center() {\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    switch (this.parentRotation) {\n      case 90:\n        this.x -= this.height * pageHeight / (pageWidth * 2);\n        this.y += this.width * pageWidth / (pageHeight * 2);\n        break;\n      case 180:\n        this.x += this.width / 2;\n        this.y += this.height / 2;\n        break;\n      case 270:\n        this.x += this.height * pageHeight / (pageWidth * 2);\n        this.y -= this.width * pageWidth / (pageHeight * 2);\n        break;\n      default:\n        this.x -= this.width / 2;\n        this.y -= this.height / 2;\n        break;\n    }\n    this.fixAndSetPosition();\n  }\n  addCommands(params) {\n    this._uiManager.addCommands(params);\n  }\n  get currentLayer() {\n    return this._uiManager.currentLayer;\n  }\n  setInBackground() {\n    this.div.style.zIndex = 0;\n  }\n  setInForeground() {\n    this.div.style.zIndex = this.#zIndex;\n  }\n  setParent(parent) {\n    if (parent !== null) {\n      this.pageIndex = parent.pageIndex;\n      this.pageDimensions = parent.pageDimensions;\n    } else {\n      this.#stopResizing();\n    }\n    this.parent = parent;\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    if (!this.#hasBeenClicked) {\n      this.parent.setSelected(this);\n    } else {\n      this.#hasBeenClicked = false;\n    }\n  }\n  focusout(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    if (!this.isAttachedToDOM) {\n      return;\n    }\n    const target = event.relatedTarget;\n    if (target?.closest(`#${this.id}`)) {\n      return;\n    }\n    event.preventDefault();\n    if (!this.parent?.isMultipleSelection) {\n      this.commitOrRemove();\n    }\n  }\n  commitOrRemove() {\n    if (this.isEmpty()) {\n      this.remove();\n    } else {\n      this.commit();\n    }\n  }\n  commit() {\n    this.addToAnnotationStorage();\n  }\n  addToAnnotationStorage() {\n    this._uiManager.addToAnnotationStorage(this);\n  }\n  setAt(x, y, tx, ty) {\n    const [width, height] = this.parentDimensions;\n    [tx, ty] = this.screenToPageTranslation(tx, ty);\n    this.x = (x + tx) / width;\n    this.y = (y + ty) / height;\n    this.fixAndSetPosition();\n  }\n  #translate([width, height], x, y) {\n    [x, y] = this.screenToPageTranslation(x, y);\n    this.x += x / width;\n    this.y += y / height;\n    this.fixAndSetPosition();\n  }\n  translate(x, y) {\n    this.#translate(this.parentDimensions, x, y);\n  }\n  translateInPage(x, y) {\n    this.#initialPosition ||= [this.x, this.y];\n    this.#translate(this.pageDimensions, x, y);\n    this.div.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n  drag(tx, ty) {\n    this.#initialPosition ||= [this.x, this.y];\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.x += tx / parentWidth;\n    this.y += ty / parentHeight;\n    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n      const {\n        x,\n        y\n      } = this.div.getBoundingClientRect();\n      if (this.parent.findNewParent(this, x, y)) {\n        this.x -= Math.floor(this.x);\n        this.y -= Math.floor(this.y);\n      }\n    }\n    let {\n      x,\n      y\n    } = this;\n    const [bx, by] = this.getBaseTranslation();\n    x += bx;\n    y += by;\n    this.div.style.left = `${(100 * x).toFixed(2)}%`;\n    this.div.style.top = `${(100 * y).toFixed(2)}%`;\n    this.div.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n  get _hasBeenMoved() {\n    return !!this.#initialPosition && (this.#initialPosition[0] !== this.x || this.#initialPosition[1] !== this.y);\n  }\n  getBaseTranslation() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const {\n      _borderLineWidth\n    } = AnnotationEditor;\n    const x = _borderLineWidth / parentWidth;\n    const y = _borderLineWidth / parentHeight;\n    switch (this.rotation) {\n      case 90:\n        return [-x, y];\n      case 180:\n        return [x, y];\n      case 270:\n        return [x, -y];\n      default:\n        return [-x, -y];\n    }\n  }\n  get _mustFixPosition() {\n    return true;\n  }\n  fixAndSetPosition(rotation = this.rotation) {\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    let {\n      x,\n      y,\n      width,\n      height\n    } = this;\n    width *= pageWidth;\n    height *= pageHeight;\n    x *= pageWidth;\n    y *= pageHeight;\n    if (this._mustFixPosition) {\n      switch (rotation) {\n        case 0:\n          x = Math.max(0, Math.min(pageWidth - width, x));\n          y = Math.max(0, Math.min(pageHeight - height, y));\n          break;\n        case 90:\n          x = Math.max(0, Math.min(pageWidth - height, x));\n          y = Math.min(pageHeight, Math.max(width, y));\n          break;\n        case 180:\n          x = Math.min(pageWidth, Math.max(width, x));\n          y = Math.min(pageHeight, Math.max(height, y));\n          break;\n        case 270:\n          x = Math.min(pageWidth, Math.max(height, x));\n          y = Math.max(0, Math.min(pageHeight - width, y));\n          break;\n      }\n    }\n    this.x = x /= pageWidth;\n    this.y = y /= pageHeight;\n    const [bx, by] = this.getBaseTranslation();\n    x += bx;\n    y += by;\n    const {\n      style\n    } = this.div;\n    style.left = `${(100 * x).toFixed(2)}%`;\n    style.top = `${(100 * y).toFixed(2)}%`;\n    this.moveInDOM();\n  }\n  static #rotatePoint(x, y, angle) {\n    switch (angle) {\n      case 90:\n        return [y, -x];\n      case 180:\n        return [-x, -y];\n      case 270:\n        return [-y, x];\n      default:\n        return [x, y];\n    }\n  }\n  screenToPageTranslation(x, y) {\n    return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n  }\n  pageTranslationToScreen(x, y) {\n    return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n  }\n  #getRotationMatrix(rotation) {\n    switch (rotation) {\n      case 90:\n        {\n          const [pageWidth, pageHeight] = this.pageDimensions;\n          return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];\n        }\n      case 180:\n        return [-1, 0, 0, -1];\n      case 270:\n        {\n          const [pageWidth, pageHeight] = this.pageDimensions;\n          return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];\n        }\n      default:\n        return [1, 0, 0, 1];\n    }\n  }\n  get parentScale() {\n    return this._uiManager.viewParameters.realScale;\n  }\n  get parentRotation() {\n    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n  }\n  get parentDimensions() {\n    const {\n      parentScale,\n      pageDimensions: [pageWidth, pageHeight]\n    } = this;\n    return [pageWidth * parentScale, pageHeight * parentScale];\n  }\n  setDims(width, height) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n    if (!this.#keepAspectRatio) {\n      this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n    }\n  }\n  fixDims() {\n    const {\n      style\n    } = this.div;\n    const {\n      height,\n      width\n    } = style;\n    const widthPercent = width.endsWith(\"%\");\n    const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n    if (widthPercent && heightPercent) {\n      return;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    if (!widthPercent) {\n      style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n    }\n    if (!this.#keepAspectRatio && !heightPercent) {\n      style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n    }\n  }\n  getInitialTranslation() {\n    return [0, 0];\n  }\n  #createResizers() {\n    if (this.#resizersDiv) {\n      return;\n    }\n    this.#resizersDiv = document.createElement(\"div\");\n    this.#resizersDiv.classList.add(\"resizers\");\n    const classes = this._willKeepAspectRatio ? [\"topLeft\", \"topRight\", \"bottomRight\", \"bottomLeft\"] : [\"topLeft\", \"topMiddle\", \"topRight\", \"middleRight\", \"bottomRight\", \"bottomMiddle\", \"bottomLeft\", \"middleLeft\"];\n    const signal = this._uiManager._signal;\n    for (const name of classes) {\n      const div = document.createElement(\"div\");\n      this.#resizersDiv.append(div);\n      div.classList.add(\"resizer\", name);\n      div.setAttribute(\"data-resizer-name\", name);\n      div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n        signal\n      });\n      div.addEventListener(\"contextmenu\", noContextMenu, {\n        signal\n      });\n      div.tabIndex = -1;\n    }\n    this.div.prepend(this.#resizersDiv);\n  }\n  #resizerPointerdown(name, event) {\n    event.preventDefault();\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    this.#altText?.toggle(false);\n    const savedDraggable = this._isDraggable;\n    this._isDraggable = false;\n    const ac = new AbortController();\n    const signal = this._uiManager.combinedSignal(ac);\n    this.parent.togglePointerEvents(false);\n    window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n      passive: true,\n      capture: true,\n      signal\n    });\n    window.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    const savedX = this.x;\n    const savedY = this.y;\n    const savedWidth = this.width;\n    const savedHeight = this.height;\n    const savedParentCursor = this.parent.div.style.cursor;\n    const savedCursor = this.div.style.cursor;\n    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n    const pointerUpCallback = () => {\n      ac.abort();\n      this.parent.togglePointerEvents(true);\n      this.#altText?.toggle(true);\n      this._isDraggable = savedDraggable;\n      this.parent.div.style.cursor = savedParentCursor;\n      this.div.style.cursor = savedCursor;\n      this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);\n    };\n    window.addEventListener(\"pointerup\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"blur\", pointerUpCallback, {\n      signal\n    });\n  }\n  #addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight) {\n    const newX = this.x;\n    const newY = this.y;\n    const newWidth = this.width;\n    const newHeight = this.height;\n    if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n      return;\n    }\n    this.addCommands({\n      cmd: () => {\n        this.width = newWidth;\n        this.height = newHeight;\n        this.x = newX;\n        this.y = newY;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n        this.fixAndSetPosition();\n      },\n      undo: () => {\n        this.width = savedWidth;\n        this.height = savedHeight;\n        this.x = savedX;\n        this.y = savedY;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);\n        this.fixAndSetPosition();\n      },\n      mustExec: true\n    });\n  }\n  #resizerPointermove(name, event) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const savedX = this.x;\n    const savedY = this.y;\n    const savedWidth = this.width;\n    const savedHeight = this.height;\n    const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n    const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n    const round = x => Math.round(x * 10000) / 10000;\n    const rotationMatrix = this.#getRotationMatrix(this.rotation);\n    const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];\n    const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n    const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];\n    let getPoint;\n    let getOpposite;\n    let isDiagonal = false;\n    let isHorizontal = false;\n    switch (name) {\n      case \"topLeft\":\n        isDiagonal = true;\n        getPoint = (w, h) => [0, 0];\n        getOpposite = (w, h) => [w, h];\n        break;\n      case \"topMiddle\":\n        getPoint = (w, h) => [w / 2, 0];\n        getOpposite = (w, h) => [w / 2, h];\n        break;\n      case \"topRight\":\n        isDiagonal = true;\n        getPoint = (w, h) => [w, 0];\n        getOpposite = (w, h) => [0, h];\n        break;\n      case \"middleRight\":\n        isHorizontal = true;\n        getPoint = (w, h) => [w, h / 2];\n        getOpposite = (w, h) => [0, h / 2];\n        break;\n      case \"bottomRight\":\n        isDiagonal = true;\n        getPoint = (w, h) => [w, h];\n        getOpposite = (w, h) => [0, 0];\n        break;\n      case \"bottomMiddle\":\n        getPoint = (w, h) => [w / 2, h];\n        getOpposite = (w, h) => [w / 2, 0];\n        break;\n      case \"bottomLeft\":\n        isDiagonal = true;\n        getPoint = (w, h) => [0, h];\n        getOpposite = (w, h) => [w, 0];\n        break;\n      case \"middleLeft\":\n        isHorizontal = true;\n        getPoint = (w, h) => [0, h / 2];\n        getOpposite = (w, h) => [w, h / 2];\n        break;\n    }\n    const point = getPoint(savedWidth, savedHeight);\n    const oppositePoint = getOpposite(savedWidth, savedHeight);\n    let transfOppositePoint = transf(...oppositePoint);\n    const oppositeX = round(savedX + transfOppositePoint[0]);\n    const oppositeY = round(savedY + transfOppositePoint[1]);\n    let ratioX = 1;\n    let ratioY = 1;\n    let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);\n    [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n    if (isDiagonal) {\n      const oldDiag = Math.hypot(savedWidth, savedHeight);\n      ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n    } else if (isHorizontal) {\n      ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;\n    } else {\n      ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;\n    }\n    const newWidth = round(savedWidth * ratioX);\n    const newHeight = round(savedHeight * ratioY);\n    transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n    const newX = oppositeX - transfOppositePoint[0];\n    const newY = oppositeY - transfOppositePoint[1];\n    this.width = newWidth;\n    this.height = newHeight;\n    this.x = newX;\n    this.y = newY;\n    this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n    this.fixAndSetPosition();\n  }\n  altTextFinish() {\n    this.#altText?.finish();\n  }\n  async addEditToolbar() {\n    if (this._editToolbar || this.#isInEditMode) {\n      return this._editToolbar;\n    }\n    this._editToolbar = new EditorToolbar(this);\n    this.div.append(this._editToolbar.render());\n    if (this.#altText) {\n      await this._editToolbar.addAltText(this.#altText);\n    }\n    return this._editToolbar;\n  }\n  removeEditToolbar() {\n    if (!this._editToolbar) {\n      return;\n    }\n    this._editToolbar.remove();\n    this._editToolbar = null;\n    this.#altText?.destroy();\n  }\n  addContainer(container) {\n    const editToolbarDiv = this._editToolbar?.div;\n    if (editToolbarDiv) {\n      editToolbarDiv.before(container);\n    } else {\n      this.div.append(container);\n    }\n  }\n  getClientDimensions() {\n    return this.div.getBoundingClientRect();\n  }\n  async addAltTextButton() {\n    if (this.#altText) {\n      return;\n    }\n    AltText.initialize(AnnotationEditor._l10n);\n    this.#altText = new AltText(this);\n    if (this.#accessibilityData) {\n      this.#altText.data = this.#accessibilityData;\n      this.#accessibilityData = null;\n    }\n    await this.addEditToolbar();\n  }\n  get altTextData() {\n    return this.#altText?.data;\n  }\n  set altTextData(data) {\n    if (!this.#altText) {\n      return;\n    }\n    this.#altText.data = data;\n  }\n  get guessedAltText() {\n    return this.#altText?.guessedText;\n  }\n  async setGuessedAltText(text) {\n    await this.#altText?.setGuessedText(text);\n  }\n  serializeAltText(isForCopying) {\n    return this.#altText?.serialize(isForCopying);\n  }\n  hasAltText() {\n    return !!this.#altText && !this.#altText.isEmpty();\n  }\n  hasAltTextData() {\n    return this.#altText?.hasData() ?? false;\n  }\n  render() {\n    this.div = document.createElement(\"div\");\n    this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n    this.div.className = this.name;\n    this.div.setAttribute(\"id\", this.id);\n    this.div.tabIndex = this.#disabled ? -1 : 0;\n    if (!this._isVisible) {\n      this.div.classList.add(\"hidden\");\n    }\n    this.setInForeground();\n    this.#addFocusListeners();\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    if (this.parentRotation % 180 !== 0) {\n      this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n      this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n    }\n    const [tx, ty] = this.getInitialTranslation();\n    this.translate(tx, ty);\n    bindEvents(this, this.div, [\"pointerdown\"]);\n    return this.div;\n  }\n  pointerdown(event) {\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      event.preventDefault();\n      return;\n    }\n    this.#hasBeenClicked = true;\n    if (this._isDraggable) {\n      this.#setUpDragSession(event);\n      return;\n    }\n    this.#selectOnPointerEvent(event);\n  }\n  get isSelected() {\n    return this._uiManager.isSelected(this);\n  }\n  #selectOnPointerEvent(event) {\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n      this.parent.toggleSelected(this);\n    } else {\n      this.parent.setSelected(this);\n    }\n  }\n  #setUpDragSession(event) {\n    const {\n      isSelected\n    } = this;\n    this._uiManager.setUpDragSession();\n    const ac = new AbortController();\n    const signal = this._uiManager.combinedSignal(ac);\n    if (isSelected) {\n      this.div.classList.add(\"moving\");\n      this.#prevDragX = event.clientX;\n      this.#prevDragY = event.clientY;\n      const pointerMoveCallback = e => {\n        const {\n          clientX: x,\n          clientY: y\n        } = e;\n        const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n        this.#prevDragX = x;\n        this.#prevDragY = y;\n        this._uiManager.dragSelectedEditors(tx, ty);\n      };\n      window.addEventListener(\"pointermove\", pointerMoveCallback, {\n        passive: true,\n        capture: true,\n        signal\n      });\n    }\n    const pointerUpCallback = () => {\n      ac.abort();\n      if (isSelected) {\n        this.div.classList.remove(\"moving\");\n      }\n      this.#hasBeenClicked = false;\n      if (!this._uiManager.endDragSession()) {\n        this.#selectOnPointerEvent(event);\n      }\n    };\n    window.addEventListener(\"pointerup\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"blur\", pointerUpCallback, {\n      signal\n    });\n  }\n  moveInDOM() {\n    if (this.#moveInDOMTimeout) {\n      clearTimeout(this.#moveInDOMTimeout);\n    }\n    this.#moveInDOMTimeout = setTimeout(() => {\n      this.#moveInDOMTimeout = null;\n      this.parent?.moveEditorInDOM(this);\n    }, 0);\n  }\n  _setParentAndPosition(parent, x, y) {\n    parent.changeParent(this);\n    this.x = x;\n    this.y = y;\n    this.fixAndSetPosition();\n  }\n  getRect(tx, ty, rotation = this.rotation) {\n    const scale = this.parentScale;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const [pageX, pageY] = this.pageTranslation;\n    const shiftX = tx / scale;\n    const shiftY = ty / scale;\n    const x = this.x * pageWidth;\n    const y = this.y * pageHeight;\n    const width = this.width * pageWidth;\n    const height = this.height * pageHeight;\n    switch (rotation) {\n      case 0:\n        return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];\n      case 90:\n        return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];\n      case 180:\n        return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];\n      case 270:\n        return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n  getRectInCurrentCoords(rect, pageHeight) {\n    const [x1, y1, x2, y2] = rect;\n    const width = x2 - x1;\n    const height = y2 - y1;\n    switch (this.rotation) {\n      case 0:\n        return [x1, pageHeight - y2, width, height];\n      case 90:\n        return [x1, pageHeight - y1, height, width];\n      case 180:\n        return [x2, pageHeight - y1, width, height];\n      case 270:\n        return [x2, pageHeight - y2, height, width];\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n  onceAdded() {}\n  isEmpty() {\n    return false;\n  }\n  enableEditMode() {\n    this.#isInEditMode = true;\n  }\n  disableEditMode() {\n    this.#isInEditMode = false;\n  }\n  isInEditMode() {\n    return this.#isInEditMode;\n  }\n  shouldGetKeyboardEvents() {\n    return this.#isResizerEnabledForKeyboard;\n  }\n  needsToBeRebuilt() {\n    return this.div && !this.isAttachedToDOM;\n  }\n  #addFocusListeners() {\n    if (this.#focusAC || !this.div) {\n      return;\n    }\n    this.#focusAC = new AbortController();\n    const signal = this._uiManager.combinedSignal(this.#focusAC);\n    this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n      signal\n    });\n    this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n      signal\n    });\n  }\n  rebuild() {\n    this.#addFocusListeners();\n  }\n  rotate(_angle) {}\n  serializeDeleted() {\n    return {\n      id: this.annotationElementId,\n      deleted: true,\n      pageIndex: this.pageIndex,\n      popupRef: this._initialData?.popupRef || \"\"\n    };\n  }\n  serialize(isForCopying = false, context = null) {\n    unreachable(\"An editor must be serializable\");\n  }\n  static async deserialize(data, parent, uiManager) {\n    const editor = new this.prototype.constructor({\n      parent,\n      id: parent.getNextId(),\n      uiManager\n    });\n    editor.rotation = data.rotation;\n    editor.#accessibilityData = data.accessibilityData;\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n    editor.x = x / pageWidth;\n    editor.y = y / pageHeight;\n    editor.width = width / pageWidth;\n    editor.height = height / pageHeight;\n    return editor;\n  }\n  get hasBeenModified() {\n    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n  }\n  remove() {\n    this.#focusAC?.abort();\n    this.#focusAC = null;\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n    if (this.parent) {\n      this.parent.remove(this);\n    } else {\n      this._uiManager.removeEditor(this);\n    }\n    if (this.#moveInDOMTimeout) {\n      clearTimeout(this.#moveInDOMTimeout);\n      this.#moveInDOMTimeout = null;\n    }\n    this.#stopResizing();\n    this.removeEditToolbar();\n    if (this.#telemetryTimeouts) {\n      for (const timeout of this.#telemetryTimeouts.values()) {\n        clearTimeout(timeout);\n      }\n      this.#telemetryTimeouts = null;\n    }\n    this.parent = null;\n  }\n  get isResizable() {\n    return false;\n  }\n  makeResizable() {\n    if (this.isResizable) {\n      this.#createResizers();\n      this.#resizersDiv.classList.remove(\"hidden\");\n      bindEvents(this, this.div, [\"keydown\"]);\n    }\n  }\n  get toolbarPosition() {\n    return null;\n  }\n  keydown(event) {\n    if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n      return;\n    }\n    this._uiManager.setSelected(this);\n    this.#savedDimensions = {\n      savedX: this.x,\n      savedY: this.y,\n      savedWidth: this.width,\n      savedHeight: this.height\n    };\n    const children = this.#resizersDiv.children;\n    if (!this.#allResizerDivs) {\n      this.#allResizerDivs = Array.from(children);\n      const boundResizerKeydown = this.#resizerKeydown.bind(this);\n      const boundResizerBlur = this.#resizerBlur.bind(this);\n      const signal = this._uiManager._signal;\n      for (const div of this.#allResizerDivs) {\n        const name = div.getAttribute(\"data-resizer-name\");\n        div.setAttribute(\"role\", \"spinbutton\");\n        div.addEventListener(\"keydown\", boundResizerKeydown, {\n          signal\n        });\n        div.addEventListener(\"blur\", boundResizerBlur, {\n          signal\n        });\n        div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n          signal\n        });\n        div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n      }\n    }\n    const first = this.#allResizerDivs[0];\n    let firstPosition = 0;\n    for (const div of children) {\n      if (div === first) {\n        break;\n      }\n      firstPosition++;\n    }\n    const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n    if (nextFirstPosition !== firstPosition) {\n      if (nextFirstPosition < firstPosition) {\n        for (let i = 0; i < firstPosition - nextFirstPosition; i++) {\n          this.#resizersDiv.append(this.#resizersDiv.firstChild);\n        }\n      } else if (nextFirstPosition > firstPosition) {\n        for (let i = 0; i < nextFirstPosition - firstPosition; i++) {\n          this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n        }\n      }\n      let i = 0;\n      for (const child of children) {\n        const div = this.#allResizerDivs[i++];\n        const name = div.getAttribute(\"data-resizer-name\");\n        child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n      }\n    }\n    this.#setResizerTabIndex(0);\n    this.#isResizerEnabledForKeyboard = true;\n    this.#resizersDiv.firstChild.focus({\n      focusVisible: true\n    });\n    event.preventDefault();\n    event.stopImmediatePropagation();\n  }\n  #resizerKeydown(event) {\n    AnnotationEditor._resizerKeyboardManager.exec(this, event);\n  }\n  #resizerBlur(event) {\n    if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n      this.#stopResizing();\n    }\n  }\n  #resizerFocus(name) {\n    this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n  }\n  #setResizerTabIndex(value) {\n    if (!this.#allResizerDivs) {\n      return;\n    }\n    for (const div of this.#allResizerDivs) {\n      div.tabIndex = value;\n    }\n  }\n  _resizeWithKeyboard(x, y) {\n    if (!this.#isResizerEnabledForKeyboard) {\n      return;\n    }\n    this.#resizerPointermove(this.#focusedResizerName, {\n      movementX: x,\n      movementY: y\n    });\n  }\n  #stopResizing() {\n    this.#isResizerEnabledForKeyboard = false;\n    this.#setResizerTabIndex(-1);\n    if (this.#savedDimensions) {\n      const {\n        savedX,\n        savedY,\n        savedWidth,\n        savedHeight\n      } = this.#savedDimensions;\n      this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);\n      this.#savedDimensions = null;\n    }\n  }\n  _stopResizingWithKeyboard() {\n    this.#stopResizing();\n    this.div.focus();\n  }\n  select() {\n    this.makeResizable();\n    this.div?.classList.add(\"selectedEditor\");\n    if (!this._editToolbar) {\n      this.addEditToolbar().then(() => {\n        if (this.div?.classList.contains(\"selectedEditor\")) {\n          this._editToolbar?.show();\n        }\n      });\n      return;\n    }\n    this._editToolbar?.show();\n    this.#altText?.toggleAltTextBadge(false);\n  }\n  unselect() {\n    this.#resizersDiv?.classList.add(\"hidden\");\n    this.div?.classList.remove(\"selectedEditor\");\n    if (this.div?.contains(document.activeElement)) {\n      this._uiManager.currentLayer.div.focus({\n        preventScroll: true\n      });\n    }\n    this._editToolbar?.hide();\n    this.#altText?.toggleAltTextBadge(true);\n  }\n  updateParams(type, value) {}\n  disableEditing() {}\n  enableEditing() {}\n  enterInEditMode() {}\n  getImageForAltText() {\n    return null;\n  }\n  get contentDiv() {\n    return this.div;\n  }\n  get isEditing() {\n    return this.#isEditing;\n  }\n  set isEditing(value) {\n    this.#isEditing = value;\n    if (!this.parent) {\n      return;\n    }\n    if (value) {\n      this.parent.setSelected(this);\n      this.parent.setActiveEditor(this);\n    } else {\n      this.parent.setActiveEditor(null);\n    }\n  }\n  setAspectRatio(width, height) {\n    this.#keepAspectRatio = true;\n    const aspectRatio = width / height;\n    const {\n      style\n    } = this.div;\n    style.aspectRatio = aspectRatio;\n    style.height = \"auto\";\n  }\n  static get MIN_SIZE() {\n    return 16;\n  }\n  static canCreateNewEmptyEditor() {\n    return true;\n  }\n  get telemetryInitialData() {\n    return {\n      action: \"added\"\n    };\n  }\n  get telemetryFinalData() {\n    return null;\n  }\n  _reportTelemetry(data, mustWait = false) {\n    if (mustWait) {\n      this.#telemetryTimeouts ||= new Map();\n      const {\n        action\n      } = data;\n      let timeout = this.#telemetryTimeouts.get(action);\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n      timeout = setTimeout(() => {\n        this._reportTelemetry(data);\n        this.#telemetryTimeouts.delete(action);\n        if (this.#telemetryTimeouts.size === 0) {\n          this.#telemetryTimeouts = null;\n        }\n      }, AnnotationEditor._telemetryTimeout);\n      this.#telemetryTimeouts.set(action, timeout);\n      return;\n    }\n    data.type ||= this.editorType;\n    this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n      source: this,\n      details: {\n        type: \"editing\",\n        data\n      }\n    });\n  }\n  show(visible = this._isVisible) {\n    this.div.classList.toggle(\"hidden\", !visible);\n    this._isVisible = visible;\n  }\n  enable() {\n    if (this.div) {\n      this.div.tabIndex = 0;\n    }\n    this.#disabled = false;\n  }\n  disable() {\n    if (this.div) {\n      this.div.tabIndex = -1;\n    }\n    this.#disabled = true;\n  }\n  renderAnnotationElement(annotation) {\n    let content = annotation.container.querySelector(\".annotationContent\");\n    if (!content) {\n      content = document.createElement(\"div\");\n      content.classList.add(\"annotationContent\", this.editorType);\n      annotation.container.prepend(content);\n    } else if (content.nodeName === \"CANVAS\") {\n      const canvas = content;\n      content = document.createElement(\"div\");\n      content.classList.add(\"annotationContent\", this.editorType);\n      canvas.before(content);\n    }\n    return content;\n  }\n  resetAnnotationElement(annotation) {\n    const {\n      firstChild\n    } = annotation.container;\n    if (firstChild?.nodeName === \"DIV\" && firstChild.classList.contains(\"annotationContent\")) {\n      firstChild.remove();\n    }\n  }\n}\nclass FakeEditor extends AnnotationEditor {\n  constructor(params) {\n    super(params);\n    this.annotationElementId = params.annotationElementId;\n    this.deleted = true;\n  }\n  serialize() {\n    return this.serializeDeleted();\n  }\n}\n\n;// ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n  constructor(seed) {\n    this.h1 = seed ? seed & 0xffffffff : SEED;\n    this.h2 = seed ? seed & 0xffffffff : SEED;\n  }\n  update(input) {\n    let data, length;\n    if (typeof input === \"string\") {\n      data = new Uint8Array(input.length * 2);\n      length = 0;\n      for (let i = 0, ii = input.length; i < ii; i++) {\n        const code = input.charCodeAt(i);\n        if (code <= 0xff) {\n          data[length++] = code;\n        } else {\n          data[length++] = code >>> 8;\n          data[length++] = code & 0xff;\n        }\n      }\n    } else if (ArrayBuffer.isView(input)) {\n      data = input.slice();\n      length = data.byteLength;\n    } else {\n      throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n    }\n    const blockCounts = length >> 2;\n    const tailLength = length - blockCounts * 4;\n    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n    let k1 = 0,\n      k2 = 0;\n    let h1 = this.h1,\n      h2 = this.h2;\n    const C1 = 0xcc9e2d51,\n      C2 = 0x1b873593;\n    const C1_LOW = C1 & MASK_LOW,\n      C2_LOW = C2 & MASK_LOW;\n    for (let i = 0; i < blockCounts; i++) {\n      if (i & 1) {\n        k1 = dataUint32[i];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        h1 ^= k1;\n        h1 = h1 << 13 | h1 >>> 19;\n        h1 = h1 * 5 + 0xe6546b64;\n      } else {\n        k2 = dataUint32[i];\n        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n        k2 = k2 << 15 | k2 >>> 17;\n        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n        h2 ^= k2;\n        h2 = h2 << 13 | h2 >>> 19;\n        h2 = h2 * 5 + 0xe6546b64;\n      }\n    }\n    k1 = 0;\n    switch (tailLength) {\n      case 3:\n        k1 ^= data[blockCounts * 4 + 2] << 16;\n      case 2:\n        k1 ^= data[blockCounts * 4 + 1] << 8;\n      case 1:\n        k1 ^= data[blockCounts * 4];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        if (blockCounts & 1) {\n          h1 ^= k1;\n        } else {\n          h2 ^= k1;\n        }\n    }\n    this.h1 = h1;\n    this.h2 = h2;\n  }\n  hexdigest() {\n    let h1 = this.h1,\n      h2 = this.h2;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n  }\n}\n\n;// ./src/display/annotation_storage.js\n\n\n\nconst SerializableEmpty = Object.freeze({\n  map: null,\n  hash: \"\",\n  transfer: undefined\n});\nclass AnnotationStorage {\n  #modified = false;\n  #modifiedIds = null;\n  #storage = new Map();\n  constructor() {\n    this.onSetModified = null;\n    this.onResetModified = null;\n    this.onAnnotationEditor = null;\n  }\n  getValue(key, defaultValue) {\n    const value = this.#storage.get(key);\n    if (value === undefined) {\n      return defaultValue;\n    }\n    return Object.assign(defaultValue, value);\n  }\n  getRawValue(key) {\n    return this.#storage.get(key);\n  }\n  remove(key) {\n    this.#storage.delete(key);\n    if (this.#storage.size === 0) {\n      this.resetModified();\n    }\n    if (typeof this.onAnnotationEditor === \"function\") {\n      for (const value of this.#storage.values()) {\n        if (value instanceof AnnotationEditor) {\n          return;\n        }\n      }\n      this.onAnnotationEditor(null);\n    }\n  }\n  setValue(key, value) {\n    const obj = this.#storage.get(key);\n    let modified = false;\n    if (obj !== undefined) {\n      for (const [entry, val] of Object.entries(value)) {\n        if (obj[entry] !== val) {\n          modified = true;\n          obj[entry] = val;\n        }\n      }\n    } else {\n      modified = true;\n      this.#storage.set(key, value);\n    }\n    if (modified) {\n      this.#setModified();\n    }\n    if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n      this.onAnnotationEditor(value.constructor._type);\n    }\n  }\n  has(key) {\n    return this.#storage.has(key);\n  }\n  getAll() {\n    return this.#storage.size > 0 ? objectFromMap(this.#storage) : null;\n  }\n  setAll(obj) {\n    for (const [key, val] of Object.entries(obj)) {\n      this.setValue(key, val);\n    }\n  }\n  get size() {\n    return this.#storage.size;\n  }\n  #setModified() {\n    if (!this.#modified) {\n      this.#modified = true;\n      if (typeof this.onSetModified === \"function\") {\n        this.onSetModified();\n      }\n    }\n  }\n  resetModified() {\n    if (this.#modified) {\n      this.#modified = false;\n      if (typeof this.onResetModified === \"function\") {\n        this.onResetModified();\n      }\n    }\n  }\n  get print() {\n    return new PrintAnnotationStorage(this);\n  }\n  get serializable() {\n    if (this.#storage.size === 0) {\n      return SerializableEmpty;\n    }\n    const map = new Map(),\n      hash = new MurmurHash3_64(),\n      transfer = [];\n    const context = Object.create(null);\n    let hasBitmap = false;\n    for (const [key, val] of this.#storage) {\n      const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n      if (serialized) {\n        map.set(key, serialized);\n        hash.update(`${key}:${JSON.stringify(serialized)}`);\n        hasBitmap ||= !!serialized.bitmap;\n      }\n    }\n    if (hasBitmap) {\n      for (const value of map.values()) {\n        if (value.bitmap) {\n          transfer.push(value.bitmap);\n        }\n      }\n    }\n    return map.size > 0 ? {\n      map,\n      hash: hash.hexdigest(),\n      transfer\n    } : SerializableEmpty;\n  }\n  get editorStats() {\n    let stats = null;\n    const typeToEditor = new Map();\n    for (const value of this.#storage.values()) {\n      if (!(value instanceof AnnotationEditor)) {\n        continue;\n      }\n      const editorStats = value.telemetryFinalData;\n      if (!editorStats) {\n        continue;\n      }\n      const {\n        type\n      } = editorStats;\n      if (!typeToEditor.has(type)) {\n        typeToEditor.set(type, Object.getPrototypeOf(value).constructor);\n      }\n      stats ||= Object.create(null);\n      const map = stats[type] ||= new Map();\n      for (const [key, val] of Object.entries(editorStats)) {\n        if (key === \"type\") {\n          continue;\n        }\n        let counters = map.get(key);\n        if (!counters) {\n          counters = new Map();\n          map.set(key, counters);\n        }\n        const count = counters.get(val) ?? 0;\n        counters.set(val, count + 1);\n      }\n    }\n    for (const [type, editor] of typeToEditor) {\n      stats[type] = editor.computeTelemetryFinalData(stats[type]);\n    }\n    return stats;\n  }\n  resetModifiedIds() {\n    this.#modifiedIds = null;\n  }\n  get modifiedIds() {\n    if (this.#modifiedIds) {\n      return this.#modifiedIds;\n    }\n    const ids = [];\n    for (const value of this.#storage.values()) {\n      if (!(value instanceof AnnotationEditor) || !value.annotationElementId || !value.serialize()) {\n        continue;\n      }\n      ids.push(value.annotationElementId);\n    }\n    return this.#modifiedIds = {\n      ids: new Set(ids),\n      hash: ids.join(\",\")\n    };\n  }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n  #serializable;\n  constructor(parent) {\n    super();\n    const {\n      map,\n      hash,\n      transfer\n    } = parent.serializable;\n    const clone = structuredClone(map, transfer ? {\n      transfer\n    } : null);\n    this.#serializable = {\n      map: clone,\n      hash,\n      transfer\n    };\n  }\n  get print() {\n    unreachable(\"Should not call PrintAnnotationStorage.print\");\n  }\n  get serializable() {\n    return this.#serializable;\n  }\n  get modifiedIds() {\n    return shadow(this, \"modifiedIds\", {\n      ids: new Set(),\n      hash: \"\"\n    });\n  }\n}\n\n;// ./src/display/font_loader.js\n\nclass FontLoader {\n  #systemFonts = new Set();\n  constructor({\n    ownerDocument = globalThis.document,\n    styleElement = null\n  }) {\n    this._document = ownerDocument;\n    this.nativeFontFaces = new Set();\n    this.styleElement = null;\n    this.loadingRequests = [];\n    this.loadTestFontId = 0;\n  }\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.add(nativeFontFace);\n    this._document.fonts.add(nativeFontFace);\n  }\n  removeNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.delete(nativeFontFace);\n    this._document.fonts.delete(nativeFontFace);\n  }\n  insertRule(rule) {\n    if (!this.styleElement) {\n      this.styleElement = this._document.createElement(\"style\");\n      this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n    }\n    const styleSheet = this.styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n  clear() {\n    for (const nativeFontFace of this.nativeFontFaces) {\n      this._document.fonts.delete(nativeFontFace);\n    }\n    this.nativeFontFaces.clear();\n    this.#systemFonts.clear();\n    if (this.styleElement) {\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n  async loadSystemFont({\n    systemFontInfo: info,\n    _inspectFont\n  }) {\n    if (!info || this.#systemFonts.has(info.loadedName)) {\n      return;\n    }\n    assert(!this.disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n    if (this.isFontLoadingAPISupported) {\n      const {\n        loadedName,\n        src,\n        style\n      } = info;\n      const fontFace = new FontFace(loadedName, src, style);\n      this.addNativeFontFace(fontFace);\n      try {\n        await fontFace.load();\n        this.#systemFonts.add(loadedName);\n        _inspectFont?.(info);\n      } catch {\n        warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n        this.removeNativeFontFace(fontFace);\n      }\n      return;\n    }\n    unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n  }\n  async bind(font) {\n    if (font.attached || font.missingFile && !font.systemFontInfo) {\n      return;\n    }\n    font.attached = true;\n    if (font.systemFontInfo) {\n      await this.loadSystemFont(font);\n      return;\n    }\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n      return;\n    }\n    const rule = font.createFontFaceRule();\n    if (rule) {\n      this.insertRule(rule);\n      if (this.isSyncFontLoadingSupported) {\n        return;\n      }\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n        this._prepareFontLoadEvent(font, request);\n      });\n    }\n  }\n  get isFontLoadingAPISupported() {\n    const hasFonts = !!this._document?.fonts;\n    return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n  }\n  get isSyncFontLoadingSupported() {\n    let supported = false;\n    if (isNodeJS) {\n      supported = true;\n    } else if (typeof navigator !== \"undefined\" && typeof navigator?.userAgent === \"string\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n      supported = true;\n    }\n    return shadow(this, \"isSyncFontLoadingSupported\", supported);\n  }\n  _queueLoadingCallback(callback) {\n    function completeRequest() {\n      assert(!request.done, \"completeRequest() cannot be called twice.\");\n      request.done = true;\n      while (loadingRequests.length > 0 && loadingRequests[0].done) {\n        const otherRequest = loadingRequests.shift();\n        setTimeout(otherRequest.callback, 0);\n      }\n    }\n    const {\n      loadingRequests\n    } = this;\n    const request = {\n      done: false,\n      complete: completeRequest,\n      callback\n    };\n    loadingRequests.push(request);\n    return request;\n  }\n  get _loadTestFont() {\n    const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n    return shadow(this, \"_loadTestFont\", testFont);\n  }\n  _prepareFontLoadEvent(font, request) {\n    function int32(data, offset) {\n      return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n    }\n    function spliceString(s, offset, remove, insert) {\n      const chunk1 = s.substring(0, offset);\n      const chunk2 = s.substring(offset + remove);\n      return chunk1 + insert + chunk2;\n    }\n    let i, ii;\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = 1;\n    const ctx = canvas.getContext(\"2d\");\n    let called = 0;\n    function isFontReady(name, callback) {\n      if (++called > 30) {\n        warn(\"Load test font never loaded.\");\n        callback();\n        return;\n      }\n      ctx.font = \"30px \" + name;\n      ctx.fillText(\".\", 0, 20);\n      const imageData = ctx.getImageData(0, 0, 1, 1);\n      if (imageData.data[3] > 0) {\n        callback();\n        return;\n      }\n      setTimeout(isFontReady.bind(null, name, callback));\n    }\n    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n    let data = this._loadTestFont;\n    const COMMENT_OFFSET = 976;\n    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n    const CFF_CHECKSUM_OFFSET = 16;\n    const XXXX_VALUE = 0x58585858;\n    let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n    }\n    if (i < loadTestFontId.length) {\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n    }\n    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n    const url = `url(data:font/opentype;base64,${btoa(data)});`;\n    const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n    this.insertRule(rule);\n    const div = this._document.createElement(\"div\");\n    div.style.visibility = \"hidden\";\n    div.style.width = div.style.height = \"10px\";\n    div.style.position = \"absolute\";\n    div.style.top = div.style.left = \"0px\";\n    for (const name of [font.loadedName, loadTestFontId]) {\n      const span = this._document.createElement(\"span\");\n      span.textContent = \"Hi\";\n      span.style.fontFamily = name;\n      div.append(span);\n    }\n    this._document.body.append(div);\n    isFontReady(loadTestFontId, () => {\n      div.remove();\n      request.complete();\n    });\n  }\n}\nclass FontFaceObject {\n  constructor(translatedData, {\n    disableFontFace = false,\n    inspectFont = null\n  }) {\n    this.compiledGlyphs = Object.create(null);\n    for (const i in translatedData) {\n      this[i] = translatedData[i];\n    }\n    this.disableFontFace = disableFontFace === true;\n    this._inspectFont = inspectFont;\n  }\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    let nativeFontFace;\n    if (!this.cssFontInfo) {\n      nativeFontFace = new FontFace(this.loadedName, this.data, {});\n    } else {\n      const css = {\n        weight: this.cssFontInfo.fontWeight\n      };\n      if (this.cssFontInfo.italicAngle) {\n        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n      }\n      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n    }\n    this._inspectFont?.(this);\n    return nativeFontFace;\n  }\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n    let rule;\n    if (!this.cssFontInfo) {\n      rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n    } else {\n      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n      if (this.cssFontInfo.italicAngle) {\n        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n      }\n      rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n    }\n    this._inspectFont?.(this, url);\n    return rule;\n  }\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n    let cmds;\n    try {\n      cmds = objs.get(this.loadedName + \"_path_\" + character);\n    } catch (ex) {\n      warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n    }\n    if (!Array.isArray(cmds) || cmds.length === 0) {\n      return this.compiledGlyphs[character] = function (c, size) {};\n    }\n    const commands = [];\n    for (let i = 0, ii = cmds.length; i < ii;) {\n      switch (cmds[i++]) {\n        case FontRenderOps.BEZIER_CURVE_TO:\n          {\n            const [a, b, c, d, e, f] = cmds.slice(i, i + 6);\n            commands.push(ctx => ctx.bezierCurveTo(a, b, c, d, e, f));\n            i += 6;\n          }\n          break;\n        case FontRenderOps.MOVE_TO:\n          {\n            const [a, b] = cmds.slice(i, i + 2);\n            commands.push(ctx => ctx.moveTo(a, b));\n            i += 2;\n          }\n          break;\n        case FontRenderOps.LINE_TO:\n          {\n            const [a, b] = cmds.slice(i, i + 2);\n            commands.push(ctx => ctx.lineTo(a, b));\n            i += 2;\n          }\n          break;\n        case FontRenderOps.QUADRATIC_CURVE_TO:\n          {\n            const [a, b, c, d] = cmds.slice(i, i + 4);\n            commands.push(ctx => ctx.quadraticCurveTo(a, b, c, d));\n            i += 4;\n          }\n          break;\n        case FontRenderOps.RESTORE:\n          commands.push(ctx => ctx.restore());\n          break;\n        case FontRenderOps.SAVE:\n          commands.push(ctx => ctx.save());\n          break;\n        case FontRenderOps.SCALE:\n          assert(commands.length === 2, \"Scale command is only valid at the third position.\");\n          break;\n        case FontRenderOps.TRANSFORM:\n          {\n            const [a, b, c, d, e, f] = cmds.slice(i, i + 6);\n            commands.push(ctx => ctx.transform(a, b, c, d, e, f));\n            i += 6;\n          }\n          break;\n        case FontRenderOps.TRANSLATE:\n          {\n            const [a, b] = cmds.slice(i, i + 2);\n            commands.push(ctx => ctx.translate(a, b));\n            i += 2;\n          }\n          break;\n      }\n    }\n    return this.compiledGlyphs[character] = function glyphDrawer(ctx, size) {\n      commands[0](ctx);\n      commands[1](ctx);\n      ctx.scale(size, -size);\n      for (let i = 2, ii = commands.length; i < ii; i++) {\n        commands[i](ctx);\n      }\n    };\n  }\n}\n\n;// ./src/display/canvas_factory.js\n\nclass BaseCanvasFactory {\n  #enableHWA = false;\n  constructor({\n    enableHWA = false\n  }) {\n    this.#enableHWA = enableHWA;\n  }\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    const canvas = this._createCanvas(width, height);\n    return {\n      canvas,\n      context: canvas.getContext(\"2d\", {\n        willReadFrequently: !this.#enableHWA\n      })\n    };\n  }\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n  _createCanvas(width, height) {\n    unreachable(\"Abstract method `_createCanvas` called.\");\n  }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n  constructor({\n    ownerDocument = globalThis.document,\n    enableHWA = false\n  }) {\n    super({\n      enableHWA\n    });\n    this._document = ownerDocument;\n  }\n  _createCanvas(width, height) {\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n}\n\n;// ./src/display/cmap_reader_factory.js\n\n\nclass BaseCMapReaderFactory {\n  constructor({\n    baseUrl = null,\n    isCompressed = true\n  }) {\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n  async fetch({\n    name\n  }) {\n    if (!this.baseUrl) {\n      throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n    }\n    if (!name) {\n      throw new Error(\"CMap name must be specified.\");\n    }\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n    return this._fetch(url).then(cMapData => ({\n      cMapData,\n      isCompressed: this.isCompressed\n    })).catch(reason => {\n      throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n    });\n  }\n  async _fetch(url) {\n    unreachable(\"Abstract method `_fetch` called.\");\n  }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n  async _fetch(url) {\n    const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n    return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n  }\n}\n\n;// ./src/display/filter_factory.js\n\n\nclass BaseFilterFactory {\n  addFilter(maps) {\n    return \"none\";\n  }\n  addHCMFilter(fgColor, bgColor) {\n    return \"none\";\n  }\n  addAlphaFilter(map) {\n    return \"none\";\n  }\n  addLuminosityFilter(map) {\n    return \"none\";\n  }\n  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n    return \"none\";\n  }\n  destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n  #baseUrl;\n  #_cache;\n  #_defs;\n  #docId;\n  #document;\n  #_hcmCache;\n  #id = 0;\n  constructor({\n    docId,\n    ownerDocument = globalThis.document\n  }) {\n    super();\n    this.#docId = docId;\n    this.#document = ownerDocument;\n  }\n  get #cache() {\n    return this.#_cache ||= new Map();\n  }\n  get #hcmCache() {\n    return this.#_hcmCache ||= new Map();\n  }\n  get #defs() {\n    if (!this.#_defs) {\n      const div = this.#document.createElement(\"div\");\n      const {\n        style\n      } = div;\n      style.visibility = \"hidden\";\n      style.contain = \"strict\";\n      style.width = style.height = 0;\n      style.position = \"absolute\";\n      style.top = style.left = 0;\n      style.zIndex = -1;\n      const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n      svg.setAttribute(\"width\", 0);\n      svg.setAttribute(\"height\", 0);\n      this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n      div.append(svg);\n      svg.append(this.#_defs);\n      this.#document.body.append(div);\n    }\n    return this.#_defs;\n  }\n  #createTables(maps) {\n    if (maps.length === 1) {\n      const mapR = maps[0];\n      const buffer = new Array(256);\n      for (let i = 0; i < 256; i++) {\n        buffer[i] = mapR[i] / 255;\n      }\n      const table = buffer.join(\",\");\n      return [table, table, table];\n    }\n    const [mapR, mapG, mapB] = maps;\n    const bufferR = new Array(256);\n    const bufferG = new Array(256);\n    const bufferB = new Array(256);\n    for (let i = 0; i < 256; i++) {\n      bufferR[i] = mapR[i] / 255;\n      bufferG[i] = mapG[i] / 255;\n      bufferB[i] = mapB[i] / 255;\n    }\n    return [bufferR.join(\",\"), bufferG.join(\",\"), bufferB.join(\",\")];\n  }\n  #createUrl(id) {\n    if (this.#baseUrl === undefined) {\n      this.#baseUrl = \"\";\n      const url = this.#document.URL;\n      if (url !== this.#document.baseURI) {\n        if (isDataScheme(url)) {\n          warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n        } else {\n          this.#baseUrl = url.split(\"#\", 1)[0];\n        }\n      }\n    }\n    return `url(${this.#baseUrl}#${id})`;\n  }\n  addFilter(maps) {\n    if (!maps) {\n      return \"none\";\n    }\n    let value = this.#cache.get(maps);\n    if (value) {\n      return value;\n    }\n    const [tableR, tableG, tableB] = this.#createTables(maps);\n    const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(maps, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n    const url = this.#createUrl(id);\n    this.#cache.set(maps, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n    return url;\n  }\n  addHCMFilter(fgColor, bgColor) {\n    const key = `${fgColor}-${bgColor}`;\n    const filterName = \"base\";\n    let info = this.#hcmCache.get(filterName);\n    if (info?.key === key) {\n      return info.url;\n    }\n    if (info) {\n      info.filter?.remove();\n      info.key = key;\n      info.url = \"none\";\n      info.filter = null;\n    } else {\n      info = {\n        key,\n        url: \"none\",\n        filter: null\n      };\n      this.#hcmCache.set(filterName, info);\n    }\n    if (!fgColor || !bgColor) {\n      return info.url;\n    }\n    const fgRGB = this.#getRGB(fgColor);\n    fgColor = Util.makeHexColor(...fgRGB);\n    const bgRGB = this.#getRGB(bgColor);\n    bgColor = Util.makeHexColor(...bgRGB);\n    this.#defs.style.color = \"\";\n    if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n      return info.url;\n    }\n    const map = new Array(256);\n    for (let i = 0; i <= 255; i++) {\n      const x = i / 255;\n      map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n    }\n    const table = map.join(\",\");\n    const id = `g_${this.#docId}_hcm_filter`;\n    const filter = info.filter = this.#createFilter(id);\n    this.#addTransferMapConversion(table, table, table, filter);\n    this.#addGrayConversion(filter);\n    const getSteps = (c, n) => {\n      const start = fgRGB[c] / 255;\n      const end = bgRGB[c] / 255;\n      const arr = new Array(n + 1);\n      for (let i = 0; i <= n; i++) {\n        arr[i] = start + i / n * (end - start);\n      }\n      return arr.join(\",\");\n    };\n    this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n    info.url = this.#createUrl(id);\n    return info.url;\n  }\n  addAlphaFilter(map) {\n    let value = this.#cache.get(map);\n    if (value) {\n      return value;\n    }\n    const [tableA] = this.#createTables([map]);\n    const key = `alpha_${tableA}`;\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(map, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n    const url = this.#createUrl(id);\n    this.#cache.set(map, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addTransferMapAlphaConversion(tableA, filter);\n    return url;\n  }\n  addLuminosityFilter(map) {\n    let value = this.#cache.get(map || \"luminosity\");\n    if (value) {\n      return value;\n    }\n    let tableA, key;\n    if (map) {\n      [tableA] = this.#createTables([map]);\n      key = `luminosity_${tableA}`;\n    } else {\n      key = \"luminosity\";\n    }\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(map, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n    const url = this.#createUrl(id);\n    this.#cache.set(map, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addLuminosityConversion(filter);\n    if (map) {\n      this.#addTransferMapAlphaConversion(tableA, filter);\n    }\n    return url;\n  }\n  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n    let info = this.#hcmCache.get(filterName);\n    if (info?.key === key) {\n      return info.url;\n    }\n    if (info) {\n      info.filter?.remove();\n      info.key = key;\n      info.url = \"none\";\n      info.filter = null;\n    } else {\n      info = {\n        key,\n        url: \"none\",\n        filter: null\n      };\n      this.#hcmCache.set(filterName, info);\n    }\n    if (!fgColor || !bgColor) {\n      return info.url;\n    }\n    const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));\n    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));\n    if (bgGray < fgGray) {\n      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];\n    }\n    this.#defs.style.color = \"\";\n    const getSteps = (fg, bg, n) => {\n      const arr = new Array(256);\n      const step = (bgGray - fgGray) / n;\n      const newStart = fg / 255;\n      const newStep = (bg - fg) / (255 * n);\n      let prev = 0;\n      for (let i = 0; i <= n; i++) {\n        const k = Math.round(fgGray + i * step);\n        const value = newStart + i * newStep;\n        for (let j = prev; j <= k; j++) {\n          arr[j] = value;\n        }\n        prev = k + 1;\n      }\n      for (let i = prev; i < 256; i++) {\n        arr[i] = arr[prev - 1];\n      }\n      return arr.join(\",\");\n    };\n    const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n    const filter = info.filter = this.#createFilter(id);\n    this.#addGrayConversion(filter);\n    this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n    info.url = this.#createUrl(id);\n    return info.url;\n  }\n  destroy(keepHCM = false) {\n    if (keepHCM && this.#hcmCache.size !== 0) {\n      return;\n    }\n    if (this.#_defs) {\n      this.#_defs.parentNode.parentNode.remove();\n      this.#_defs = null;\n    }\n    if (this.#_cache) {\n      this.#_cache.clear();\n      this.#_cache = null;\n    }\n    this.#id = 0;\n  }\n  #addLuminosityConversion(filter) {\n    const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n    feColorMatrix.setAttribute(\"type\", \"matrix\");\n    feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n    filter.append(feColorMatrix);\n  }\n  #addGrayConversion(filter) {\n    const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n    feColorMatrix.setAttribute(\"type\", \"matrix\");\n    feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n    filter.append(feColorMatrix);\n  }\n  #createFilter(id) {\n    const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n    filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n    filter.setAttribute(\"id\", id);\n    this.#defs.append(filter);\n    return filter;\n  }\n  #appendFeFunc(feComponentTransfer, func, table) {\n    const feFunc = this.#document.createElementNS(SVG_NS, func);\n    feFunc.setAttribute(\"type\", \"discrete\");\n    feFunc.setAttribute(\"tableValues\", table);\n    feComponentTransfer.append(feFunc);\n  }\n  #addTransferMapConversion(rTable, gTable, bTable, filter) {\n    const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n    filter.append(feComponentTransfer);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n  }\n  #addTransferMapAlphaConversion(aTable, filter) {\n    const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n    filter.append(feComponentTransfer);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n  }\n  #getRGB(color) {\n    this.#defs.style.color = color;\n    return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n  }\n}\n\n;// ./src/display/standard_fontdata_factory.js\n\n\nclass BaseStandardFontDataFactory {\n  constructor({\n    baseUrl = null\n  }) {\n    this.baseUrl = baseUrl;\n  }\n  async fetch({\n    filename\n  }) {\n    if (!this.baseUrl) {\n      throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n    }\n    if (!filename) {\n      throw new Error(\"Font filename must be specified.\");\n    }\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetch(url).catch(reason => {\n      throw new Error(`Unable to load font data at: ${url}`);\n    });\n  }\n  async _fetch(url) {\n    unreachable(\"Abstract method `_fetch` called.\");\n  }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n  async _fetch(url) {\n    const data = await fetchData(url, \"arraybuffer\");\n    return new Uint8Array(data);\n  }\n}\n\n;// ./src/display/node_utils.js\n\n\n\n\n\nif (isNodeJS) {\n  var packageCapability = Promise.withResolvers();\n  var packageMap = null;\n  const loadPackages = async () => {\n    const fs = await import(/*webpackIgnore: true*/\"fs\"),\n      http = await import(/*webpackIgnore: true*/\"http\"),\n      https = await import(/*webpackIgnore: true*/\"https\"),\n      url = await import(/*webpackIgnore: true*/\"url\");\n    let canvas, path2d;\n    return new Map(Object.entries({\n      fs,\n      http,\n      https,\n      url,\n      canvas,\n      path2d\n    }));\n  };\n  loadPackages().then(map => {\n    packageMap = map;\n    packageCapability.resolve();\n  }, reason => {\n    warn(`loadPackages: ${reason}`);\n    packageMap = new Map();\n    packageCapability.resolve();\n  });\n}\nclass NodePackages {\n  static get promise() {\n    return packageCapability.promise;\n  }\n  static get(name) {\n    return packageMap?.get(name);\n  }\n}\nasync function node_utils_fetchData(url) {\n  const fs = NodePackages.get(\"fs\");\n  const data = await fs.promises.readFile(url);\n  return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n  _createCanvas(width, height) {\n    const canvas = NodePackages.get(\"canvas\");\n    return canvas.createCanvas(width, height);\n  }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n  async _fetch(url) {\n    return node_utils_fetchData(url);\n  }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n  async _fetch(url) {\n    return node_utils_fetchData(url);\n  }\n}\n\n;// ./src/display/pattern_helper.js\n\n\nconst PathType = {\n  FILL: \"Fill\",\n  STROKE: \"Stroke\",\n  SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox) {\n    return;\n  }\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\nclass BaseShadingPattern {\n  getPattern() {\n    unreachable(\"Abstract method `getPattern` called.\");\n  }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._type = IR[1];\n    this._bbox = IR[2];\n    this._colorStops = IR[3];\n    this._p0 = IR[4];\n    this._p1 = IR[5];\n    this._r0 = IR[6];\n    this._r1 = IR[7];\n    this.matrix = null;\n  }\n  _createGradient(ctx) {\n    let grad;\n    if (this._type === \"axial\") {\n      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n    } else if (this._type === \"radial\") {\n      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n    }\n    for (const colorStop of this._colorStops) {\n      grad.addColorStop(colorStop[0], colorStop[1]);\n    }\n    return grad;\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    let pattern;\n    if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];\n      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.beginPath();\n      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n      inverse = Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n      tmpCtx.transform(...owner.baseTransform);\n      if (this.matrix) {\n        tmpCtx.transform(...this.matrix);\n      }\n      applyBoundingBox(tmpCtx, this._bbox);\n      tmpCtx.fillStyle = this._createGradient(tmpCtx);\n      tmpCtx.fill();\n      pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n      const domMatrix = new DOMMatrix(inverse);\n      pattern.setTransform(domMatrix);\n    } else {\n      applyBoundingBox(ctx, this._bbox);\n      pattern = this._createGradient(ctx);\n    }\n    return pattern;\n  }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n  const coords = context.coords,\n    colors = context.colors;\n  const bytes = data.data,\n    rowSize = data.width * 4;\n  let tmp;\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  if (coords[p2 + 1] > coords[p3 + 1]) {\n    tmp = p2;\n    p2 = p3;\n    p3 = tmp;\n    tmp = c2;\n    c2 = c3;\n    c3 = tmp;\n  }\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n  const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n  const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n  if (y1 >= y3) {\n    return;\n  }\n  const c1r = colors[c1],\n    c1g = colors[c1 + 1],\n    c1b = colors[c1 + 2];\n  const c2r = colors[c2],\n    c2g = colors[c2 + 1],\n    c2b = colors[c2 + 2];\n  const c3r = colors[c3],\n    c3g = colors[c3 + 1],\n    c3b = colors[c3 + 2];\n  const minY = Math.round(y1),\n    maxY = Math.round(y3);\n  let xa, car, cag, cab;\n  let xb, cbr, cbg, cbb;\n  for (let y = minY; y <= maxY; y++) {\n    if (y < y2) {\n      const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n      xa = x1 - (x1 - x2) * k;\n      car = c1r - (c1r - c2r) * k;\n      cag = c1g - (c1g - c2g) * k;\n      cab = c1b - (c1b - c2b) * k;\n    } else {\n      let k;\n      if (y > y3) {\n        k = 1;\n      } else if (y2 === y3) {\n        k = 0;\n      } else {\n        k = (y2 - y) / (y2 - y3);\n      }\n      xa = x2 - (x2 - x3) * k;\n      car = c2r - (c2r - c3r) * k;\n      cag = c2g - (c2g - c3g) * k;\n      cab = c2b - (c2b - c3b) * k;\n    }\n    let k;\n    if (y < y1) {\n      k = 0;\n    } else if (y > y3) {\n      k = 1;\n    } else {\n      k = (y1 - y) / (y1 - y3);\n    }\n    xb = x1 - (x1 - x3) * k;\n    cbr = c1r - (c1r - c3r) * k;\n    cbg = c1g - (c1g - c3g) * k;\n    cbb = c1b - (c1b - c3b) * k;\n    const x1_ = Math.round(Math.min(xa, xb));\n    const x2_ = Math.round(Math.max(xa, xb));\n    let j = rowSize * y + x1_ * 4;\n    for (let x = x1_; x <= x2_; x++) {\n      k = (xa - x) / (xa - xb);\n      if (k < 0) {\n        k = 0;\n      } else if (k > 1) {\n        k = 1;\n      }\n      bytes[j++] = car - (car - cbr) * k | 0;\n      bytes[j++] = cag - (cag - cbg) * k | 0;\n      bytes[j++] = cab - (cab - cbb) * k | 0;\n      bytes[j++] = 255;\n    }\n  }\n}\nfunction drawFigure(data, figure, context) {\n  const ps = figure.coords;\n  const cs = figure.colors;\n  let i, ii;\n  switch (figure.type) {\n    case \"lattice\":\n      const verticesPerRow = figure.verticesPerRow;\n      const rows = Math.floor(ps.length / verticesPerRow) - 1;\n      const cols = verticesPerRow - 1;\n      for (i = 0; i < rows; i++) {\n        let q = i * verticesPerRow;\n        for (let j = 0; j < cols; j++, q++) {\n          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n        }\n      }\n      break;\n    case \"triangles\":\n      for (i = 0, ii = ps.length; i < ii; i += 3) {\n        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n      }\n      break;\n    default:\n      throw new Error(\"illegal figure\");\n  }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._coords = IR[2];\n    this._colors = IR[3];\n    this._figures = IR[4];\n    this._bounds = IR[5];\n    this._bbox = IR[7];\n    this._background = IR[8];\n    this.matrix = null;\n  }\n  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n    const EXPECTED_SCALE = 1.1;\n    const MAX_PATTERN_SIZE = 3000;\n    const BORDER_SIZE = 2;\n    const offsetX = Math.floor(this._bounds[0]);\n    const offsetY = Math.floor(this._bounds[1]);\n    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const scaleX = boundsWidth / width;\n    const scaleY = boundsHeight / height;\n    const context = {\n      coords: this._coords,\n      colors: this._colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    const paddedWidth = width + BORDER_SIZE * 2;\n    const paddedHeight = height + BORDER_SIZE * 2;\n    const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n    const tmpCtx = tmpCanvas.context;\n    const data = tmpCtx.createImageData(width, height);\n    if (backgroundColor) {\n      const bytes = data.data;\n      for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n        bytes[i] = backgroundColor[0];\n        bytes[i + 1] = backgroundColor[1];\n        bytes[i + 2] = backgroundColor[2];\n        bytes[i + 3] = 255;\n      }\n    }\n    for (const figure of this._figures) {\n      drawFigure(data, figure, context);\n    }\n    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n    const canvas = tmpCanvas.canvas;\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY\n    };\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    applyBoundingBox(ctx, this._bbox);\n    let scale;\n    if (pathType === PathType.SHADING) {\n      scale = Util.singularValueDecompose2dScale(getCurrentTransform(ctx));\n    } else {\n      scale = Util.singularValueDecompose2dScale(owner.baseTransform);\n      if (this.matrix) {\n        const matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n      }\n    }\n    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n    if (pathType !== PathType.SHADING) {\n      ctx.setTransform(...owner.baseTransform);\n      if (this.matrix) {\n        ctx.transform(...this.matrix);\n      }\n    }\n    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n    return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n  }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n  getPattern() {\n    return \"hotpink\";\n  }\n}\nfunction getShadingPattern(IR) {\n  switch (IR[0]) {\n    case \"RadialAxial\":\n      return new RadialAxialShadingPattern(IR);\n    case \"Mesh\":\n      return new MeshShadingPattern(IR);\n    case \"Dummy\":\n      return new DummyShadingPattern();\n  }\n  throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n  COLORED: 1,\n  UNCOLORED: 2\n};\nclass TilingPattern {\n  static MAX_PATTERN_SIZE = 3000;\n  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.ctx = ctx;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n  }\n  createPatternCanvas(owner) {\n    const {\n      bbox,\n      operatorList,\n      paintType,\n      tilingType,\n      color,\n      canvasGraphicsFactory\n    } = this;\n    let {\n      xstep,\n      ystep\n    } = this;\n    xstep = Math.abs(xstep);\n    ystep = Math.abs(ystep);\n    info(\"TilingType: \" + tilingType);\n    const x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3];\n    const width = x1 - x0;\n    const height = y1 - y0;\n    const matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n    const curMatrixScale = Util.singularValueDecompose2dScale(this.baseTransform);\n    const combinedScaleX = matrixScale[0] * curMatrixScale[0];\n    const combinedScaleY = matrixScale[1] * curMatrixScale[1];\n    let canvasWidth = width,\n      canvasHeight = height,\n      redrawHorizontally = false,\n      redrawVertically = false;\n    const xScaledStep = Math.ceil(xstep * combinedScaleX);\n    const yScaledStep = Math.ceil(ystep * combinedScaleY);\n    const xScaledWidth = Math.ceil(width * combinedScaleX);\n    const yScaledHeight = Math.ceil(height * combinedScaleY);\n    if (xScaledStep >= xScaledWidth) {\n      canvasWidth = xstep;\n    } else {\n      redrawHorizontally = true;\n    }\n    if (yScaledStep >= yScaledHeight) {\n      canvasHeight = ystep;\n    } else {\n      redrawVertically = true;\n    }\n    const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n    const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n    const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n    const tmpCtx = tmpCanvas.context;\n    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n    graphics.groupLevel = owner.groupLevel;\n    this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n    tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n    tmpCtx.save();\n    this.clipBbox(graphics, x0, y0, x1, y1);\n    graphics.baseTransform = getCurrentTransform(graphics.ctx);\n    graphics.executeOperatorList(operatorList);\n    graphics.endDrawing();\n    tmpCtx.restore();\n    if (redrawHorizontally || redrawVertically) {\n      const image = tmpCanvas.canvas;\n      if (redrawHorizontally) {\n        canvasWidth = xstep;\n      }\n      if (redrawVertically) {\n        canvasHeight = ystep;\n      }\n      const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n      const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n      const xSize = dimx2.size;\n      const ySize = dimy2.size;\n      const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n      const tmpCtx2 = tmpCanvas2.context;\n      const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n      const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n      for (let i = 0; i <= ii; i++) {\n        for (let j = 0; j <= jj; j++) {\n          tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n        }\n      }\n      return {\n        canvas: tmpCanvas2.canvas,\n        scaleX: dimx2.scale,\n        scaleY: dimy2.scale,\n        offsetX: x0,\n        offsetY: y0\n      };\n    }\n    return {\n      canvas: tmpCanvas.canvas,\n      scaleX: dimx.scale,\n      scaleY: dimy.scale,\n      offsetX: x0,\n      offsetY: y0\n    };\n  }\n  getSizeAndScale(step, realOutputSize, scale) {\n    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n    let size = Math.ceil(step * scale);\n    if (size >= maxSize) {\n      size = maxSize;\n    } else {\n      scale = size / step;\n    }\n    return {\n      scale,\n      size\n    };\n  }\n  clipBbox(graphics, x0, y0, x1, y1) {\n    const bboxWidth = x1 - x0;\n    const bboxHeight = y1 - y0;\n    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n    graphics.current.updateRectMinMax(getCurrentTransform(graphics.ctx), [x0, y0, x1, y1]);\n    graphics.clip();\n    graphics.endPath();\n  }\n  setFillAndStrokeStyleToContext(graphics, paintType, color) {\n    const context = graphics.ctx,\n      current = graphics.current;\n    switch (paintType) {\n      case PaintType.COLORED:\n        const ctx = this.ctx;\n        context.fillStyle = ctx.fillStyle;\n        context.strokeStyle = ctx.strokeStyle;\n        current.fillColor = ctx.fillStyle;\n        current.strokeColor = ctx.strokeStyle;\n        break;\n      case PaintType.UNCOLORED:\n        const cssColor = Util.makeHexColor(color[0], color[1], color[2]);\n        context.fillStyle = cssColor;\n        context.strokeStyle = cssColor;\n        current.fillColor = cssColor;\n        current.strokeColor = cssColor;\n        break;\n      default:\n        throw new FormatError(`Unsupported paint type: ${paintType}`);\n    }\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    let matrix = inverse;\n    if (pathType !== PathType.SHADING) {\n      matrix = Util.transform(matrix, owner.baseTransform);\n      if (this.matrix) {\n        matrix = Util.transform(matrix, this.matrix);\n      }\n    }\n    const temporaryPatternCanvas = this.createPatternCanvas(owner);\n    let domMatrix = new DOMMatrix(matrix);\n    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n    pattern.setTransform(domMatrix);\n    return pattern;\n  }\n}\n\n;// ./src/shared/image_utils.js\n\nfunction convertToRGBA(params) {\n  switch (params.kind) {\n    case ImageKind.GRAYSCALE_1BPP:\n      return convertBlackAndWhiteToRGBA(params);\n    case ImageKind.RGB_24BPP:\n      return convertRGBToRGBA(params);\n  }\n  return null;\n}\nfunction convertBlackAndWhiteToRGBA({\n  src,\n  srcPos = 0,\n  dest,\n  width,\n  height,\n  nonBlackColor = 0xffffffff,\n  inverseDecode = false\n}) {\n  const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];\n  const widthInSource = width >> 3;\n  const widthRemainder = width & 7;\n  const srcLength = src.length;\n  dest = new Uint32Array(dest.buffer);\n  let destPos = 0;\n  for (let i = 0; i < height; i++) {\n    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {\n      const elem = srcPos < srcLength ? src[srcPos] : 255;\n      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;\n    }\n    if (widthRemainder === 0) {\n      continue;\n    }\n    const elem = srcPos < srcLength ? src[srcPos++] : 255;\n    for (let j = 0; j < widthRemainder; j++) {\n      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n    }\n  }\n  return {\n    srcPos,\n    destPos\n  };\n}\nfunction convertRGBToRGBA({\n  src,\n  srcPos = 0,\n  dest,\n  destPos = 0,\n  width,\n  height\n}) {\n  let i = 0;\n  const len32 = src.length >> 2;\n  const src32 = new Uint32Array(src.buffer, srcPos, len32);\n  if (FeatureTest.isLittleEndian) {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff000000;\n      dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n      dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n      dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n    }\n    for (let j = i * 4, jj = src.length; j < jj; j += 3) {\n      dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n    }\n  } else {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff;\n      dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n      dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n      dest[destPos + 3] = s3 << 8 | 0xff;\n    }\n    for (let j = i * 4, jj = src.length; j < jj; j += 3) {\n      dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n    }\n  }\n  return {\n    srcPos,\n    destPos\n  };\n}\nfunction grayToRGBA(src, dest) {\n  if (FeatureTest.isLittleEndian) {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x10101 | 0xff000000;\n    }\n  } else {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x1010100 | 0x000000ff;\n    }\n  }\n}\n\n;// ./src/display/canvas.js\n\n\n\n\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst MAX_SIZE_TO_COMPILE = 1000;\nconst FULL_CHUNK_HEIGHT = 16;\nfunction mirrorContextOperations(ctx, destCtx) {\n  if (ctx._removeMirroring) {\n    throw new Error(\"Context is already forwarding operations.\");\n  }\n  ctx.__originalSave = ctx.save;\n  ctx.__originalRestore = ctx.restore;\n  ctx.__originalRotate = ctx.rotate;\n  ctx.__originalScale = ctx.scale;\n  ctx.__originalTranslate = ctx.translate;\n  ctx.__originalTransform = ctx.transform;\n  ctx.__originalSetTransform = ctx.setTransform;\n  ctx.__originalResetTransform = ctx.resetTransform;\n  ctx.__originalClip = ctx.clip;\n  ctx.__originalMoveTo = ctx.moveTo;\n  ctx.__originalLineTo = ctx.lineTo;\n  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n  ctx.__originalRect = ctx.rect;\n  ctx.__originalClosePath = ctx.closePath;\n  ctx.__originalBeginPath = ctx.beginPath;\n  ctx._removeMirroring = () => {\n    ctx.save = ctx.__originalSave;\n    ctx.restore = ctx.__originalRestore;\n    ctx.rotate = ctx.__originalRotate;\n    ctx.scale = ctx.__originalScale;\n    ctx.translate = ctx.__originalTranslate;\n    ctx.transform = ctx.__originalTransform;\n    ctx.setTransform = ctx.__originalSetTransform;\n    ctx.resetTransform = ctx.__originalResetTransform;\n    ctx.clip = ctx.__originalClip;\n    ctx.moveTo = ctx.__originalMoveTo;\n    ctx.lineTo = ctx.__originalLineTo;\n    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n    ctx.rect = ctx.__originalRect;\n    ctx.closePath = ctx.__originalClosePath;\n    ctx.beginPath = ctx.__originalBeginPath;\n    delete ctx._removeMirroring;\n  };\n  ctx.save = function ctxSave() {\n    destCtx.save();\n    this.__originalSave();\n  };\n  ctx.restore = function ctxRestore() {\n    destCtx.restore();\n    this.__originalRestore();\n  };\n  ctx.translate = function ctxTranslate(x, y) {\n    destCtx.translate(x, y);\n    this.__originalTranslate(x, y);\n  };\n  ctx.scale = function ctxScale(x, y) {\n    destCtx.scale(x, y);\n    this.__originalScale(x, y);\n  };\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    destCtx.transform(a, b, c, d, e, f);\n    this.__originalTransform(a, b, c, d, e, f);\n  };\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    destCtx.setTransform(a, b, c, d, e, f);\n    this.__originalSetTransform(a, b, c, d, e, f);\n  };\n  ctx.resetTransform = function ctxResetTransform() {\n    destCtx.resetTransform();\n    this.__originalResetTransform();\n  };\n  ctx.rotate = function ctxRotate(angle) {\n    destCtx.rotate(angle);\n    this.__originalRotate(angle);\n  };\n  ctx.clip = function ctxRotate(rule) {\n    destCtx.clip(rule);\n    this.__originalClip(rule);\n  };\n  ctx.moveTo = function (x, y) {\n    destCtx.moveTo(x, y);\n    this.__originalMoveTo(x, y);\n  };\n  ctx.lineTo = function (x, y) {\n    destCtx.lineTo(x, y);\n    this.__originalLineTo(x, y);\n  };\n  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  };\n  ctx.rect = function (x, y, width, height) {\n    destCtx.rect(x, y, width, height);\n    this.__originalRect(x, y, width, height);\n  };\n  ctx.closePath = function () {\n    destCtx.closePath();\n    this.__originalClosePath();\n  };\n  ctx.beginPath = function () {\n    destCtx.beginPath();\n    this.__originalBeginPath();\n  };\n}\nclass CachedCanvases {\n  constructor(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n  getCanvas(id, width, height) {\n    let canvasEntry;\n    if (this.cache[id] !== undefined) {\n      canvasEntry = this.cache[id];\n      this.canvasFactory.reset(canvasEntry, width, height);\n    } else {\n      canvasEntry = this.canvasFactory.create(width, height);\n      this.cache[id] = canvasEntry;\n    }\n    return canvasEntry;\n  }\n  delete(id) {\n    delete this.cache[id];\n  }\n  clear() {\n    for (const id in this.cache) {\n      const canvasEntry = this.cache[id];\n      this.canvasFactory.destroy(canvasEntry);\n      delete this.cache[id];\n    }\n  }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n  const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n  if (b === 0 && c === 0) {\n    const tlX = destX * a + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destY * d + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destX + destW) * a + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destY + destH) * d + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rWidth, rHeight];\n  }\n  if (a === 0 && d === 0) {\n    const tlX = destY * c + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destX * b + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destY + destH) * c + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destX + destW) * b + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rHeight, rWidth];\n  }\n  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n  const scaleX = Math.hypot(a, b);\n  const scaleY = Math.hypot(c, d);\n  return [scaleX * destW, scaleY * destH];\n}\nfunction compileType3Glyph(imgData) {\n  const {\n    width,\n    height\n  } = imgData;\n  if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n    return null;\n  }\n  const POINT_TO_PROCESS_LIMIT = 1000;\n  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n  const width1 = width + 1;\n  let points = new Uint8Array(width1 * (height + 1));\n  let i, j, j0;\n  const lineSize = width + 7 & ~7;\n  let data = new Uint8Array(lineSize * height),\n    pos = 0;\n  for (const elem of imgData.data) {\n    let mask = 128;\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n  let count = 0;\n  pos = 0;\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n    pos++;\n  }\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n      pos++;\n    }\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n    pos++;\n  }\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  const path = new Path2D();\n  for (i = 0; count && i <= height; i++) {\n    let p = i * width1;\n    const end = p + width;\n    while (p < end && !points[p]) {\n      p++;\n    }\n    if (p === end) {\n      continue;\n    }\n    path.moveTo(p % width1, i);\n    const p0 = p;\n    let type = points[p];\n    do {\n      const step = steps[type];\n      do {\n        p += step;\n      } while (!points[p]);\n      const pp = points[p];\n      if (pp !== 5 && pp !== 10) {\n        type = pp;\n        points[p] = 0;\n      } else {\n        type = pp & 0x33 * type >> 4;\n        points[p] &= type >> 2 | type << 2;\n      }\n      path.lineTo(p % width1, p / width1 | 0);\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n    --i;\n  }\n  data = null;\n  points = null;\n  const drawOutline = function (c) {\n    c.save();\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.fill(path);\n    c.beginPath();\n    c.restore();\n  };\n  return drawOutline;\n}\nclass CanvasExtraState {\n  constructor(width, height) {\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = TextRenderingMode.FILL;\n    this.textRise = 0;\n    this.fillColor = \"#000000\";\n    this.strokeColor = \"#000000\";\n    this.patternFill = false;\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.transferMaps = \"none\";\n    this.startNewPathAndClipBox([0, 0, width, height]);\n  }\n  clone() {\n    const clone = Object.create(this);\n    clone.clipBox = this.clipBox.slice();\n    return clone;\n  }\n  setCurrentPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  updatePathMinMax(transform, x, y) {\n    [x, y] = Util.applyTransform([x, y], transform);\n    this.minX = Math.min(this.minX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxX = Math.max(this.maxX, x);\n    this.maxY = Math.max(this.maxY, y);\n  }\n  updateRectMinMax(transform, rect) {\n    const p1 = Util.applyTransform(rect, transform);\n    const p2 = Util.applyTransform(rect.slice(2), transform);\n    const p3 = Util.applyTransform([rect[0], rect[3]], transform);\n    const p4 = Util.applyTransform([rect[2], rect[1]], transform);\n    this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);\n    this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);\n    this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);\n    this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);\n  }\n  updateScalingPathMinMax(transform, minMax) {\n    Util.scaleMinMax(transform, minMax);\n    this.minX = Math.min(this.minX, minMax[0]);\n    this.minY = Math.min(this.minY, minMax[1]);\n    this.maxX = Math.max(this.maxX, minMax[2]);\n    this.maxY = Math.max(this.maxY, minMax[3]);\n  }\n  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n    const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);\n    if (minMax) {\n      return;\n    }\n    this.updateRectMinMax(transform, box);\n  }\n  getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n    const box = [this.minX, this.minY, this.maxX, this.maxY];\n    if (pathType === PathType.STROKE) {\n      if (!transform) {\n        unreachable(\"Stroke bounding box must include transform.\");\n      }\n      const scale = Util.singularValueDecompose2dScale(transform);\n      const xStrokePad = scale[0] * this.lineWidth / 2;\n      const yStrokePad = scale[1] * this.lineWidth / 2;\n      box[0] -= xStrokePad;\n      box[1] -= yStrokePad;\n      box[2] += xStrokePad;\n      box[3] += yStrokePad;\n    }\n    return box;\n  }\n  updateClipFromPath() {\n    const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n  }\n  isEmptyClip() {\n    return this.minX === Infinity;\n  }\n  startNewPathAndClipBox(box) {\n    this.clipBox = box;\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = 0;\n    this.maxY = 0;\n  }\n  getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n    return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n  }\n}\nfunction putBinaryImageData(ctx, imgData) {\n  if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n    ctx.putImageData(imgData, 0, 0);\n    return;\n  }\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0,\n    destPos;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  let i, j, thisChunkHeight, elemsInThisChunk;\n  if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n    const srcLength = src.byteLength;\n    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n    const dest32DataLength = dest32.length;\n    const fullSrcDiff = width + 7 >> 3;\n    const white = 0xffffffff;\n    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    for (i = 0; i < totalChunks; i++) {\n      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      destPos = 0;\n      for (j = 0; j < thisChunkHeight; j++) {\n        const srcDiff = srcLength - srcPos;\n        let k = 0;\n        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n        const kEndUnrolled = kEnd & ~7;\n        let mask = 0;\n        let srcByte = 0;\n        for (; k < kEndUnrolled; k += 8) {\n          srcByte = src[srcPos++];\n          dest32[destPos++] = srcByte & 128 ? white : black;\n          dest32[destPos++] = srcByte & 64 ? white : black;\n          dest32[destPos++] = srcByte & 32 ? white : black;\n          dest32[destPos++] = srcByte & 16 ? white : black;\n          dest32[destPos++] = srcByte & 8 ? white : black;\n          dest32[destPos++] = srcByte & 4 ? white : black;\n          dest32[destPos++] = srcByte & 2 ? white : black;\n          dest32[destPos++] = srcByte & 1 ? white : black;\n        }\n        for (; k < kEnd; k++) {\n          if (mask === 0) {\n            srcByte = src[srcPos++];\n            mask = 128;\n          }\n          dest32[destPos++] = srcByte & mask ? white : black;\n          mask >>= 1;\n        }\n      }\n      while (destPos < dest32DataLength) {\n        dest32[destPos++] = 0;\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n    j = 0;\n    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n    for (i = 0; i < fullChunks; i++) {\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      srcPos += elemsInThisChunk;\n      ctx.putImageData(chunkImgData, 0, j);\n      j += FULL_CHUNK_HEIGHT;\n    }\n    if (i < totalChunks) {\n      elemsInThisChunk = width * partialChunkHeight * 4;\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      ctx.putImageData(chunkImgData, 0, j);\n    }\n  } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n    thisChunkHeight = FULL_CHUNK_HEIGHT;\n    elemsInThisChunk = width * thisChunkHeight;\n    for (i = 0; i < totalChunks; i++) {\n      if (i >= fullChunks) {\n        thisChunkHeight = partialChunkHeight;\n        elemsInThisChunk = width * thisChunkHeight;\n      }\n      destPos = 0;\n      for (j = elemsInThisChunk; j--;) {\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = 255;\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else {\n    throw new Error(`bad image kind: ${imgData.kind}`);\n  }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n  if (imgData.bitmap) {\n    ctx.drawImage(imgData.bitmap, 0, 0);\n    return;\n  }\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  for (let i = 0; i < totalChunks; i++) {\n    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n    ({\n      srcPos\n    } = convertBlackAndWhiteToRGBA({\n      src,\n      srcPos,\n      dest,\n      width,\n      height: thisChunkHeight,\n      nonBlackColor: 0\n    }));\n    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n  }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n  const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\", \"filter\"];\n  for (const property of properties) {\n    if (sourceCtx[property] !== undefined) {\n      destCtx[property] = sourceCtx[property];\n    }\n  }\n  if (sourceCtx.setLineDash !== undefined) {\n    destCtx.setLineDash(sourceCtx.getLineDash());\n    destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n  }\n}\nfunction resetCtxToDefault(ctx) {\n  ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n  ctx.fillRule = \"nonzero\";\n  ctx.globalAlpha = 1;\n  ctx.lineWidth = 1;\n  ctx.lineCap = \"butt\";\n  ctx.lineJoin = \"miter\";\n  ctx.miterLimit = 10;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.font = \"10px sans-serif\";\n  if (ctx.setLineDash !== undefined) {\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = 0;\n  }\n  if (!isNodeJS) {\n    const {\n      filter\n    } = ctx;\n    if (filter !== \"none\" && filter !== \"\") {\n      ctx.filter = \"none\";\n    }\n  }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n  if (interpolate) {\n    return true;\n  }\n  const scale = Util.singularValueDecompose2dScale(transform);\n  scale[0] = Math.fround(scale[0]);\n  scale[1] = Math.fround(scale[1]);\n  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS);\n  return scale[0] <= actualScale && scale[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {\n    optionalContentConfig,\n    markedContentStack = null\n  }, annotationCanvasMap, pageColors) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.filterFactory = filterFactory;\n    this.groupStack = [];\n    this.processingType3 = null;\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.suspendedCtx = null;\n    this.contentVisible = true;\n    this.markedContentStack = markedContentStack || [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n    this.cachedPatterns = new Map();\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.viewportScale = 1;\n    this.outputScaleX = 1;\n    this.outputScaleY = 1;\n    this.pageColors = pageColors;\n    this._cachedScaleForStroking = [-1, 0];\n    this._cachedGetSinglePixelWidth = null;\n    this._cachedBitmapsMap = new Map();\n  }\n  getObject(data, fallback = null) {\n    if (typeof data === \"string\") {\n      return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n    }\n    return fallback;\n  }\n  beginDrawing({\n    transform,\n    viewport,\n    transparency = false,\n    background = null\n  }) {\n    const width = this.ctx.canvas.width;\n    const height = this.ctx.canvas.height;\n    const savedFillStyle = this.ctx.fillStyle;\n    this.ctx.fillStyle = background || \"#ffffff\";\n    this.ctx.fillRect(0, 0, width, height);\n    this.ctx.fillStyle = savedFillStyle;\n    if (transparency) {\n      const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n      this.compositeCtx = this.ctx;\n      this.transparentCanvas = transparentCanvas.canvas;\n      this.ctx = transparentCanvas.context;\n      this.ctx.save();\n      this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n    }\n    this.ctx.save();\n    resetCtxToDefault(this.ctx);\n    if (transform) {\n      this.ctx.transform(...transform);\n      this.outputScaleX = transform[0];\n      this.outputScaleY = transform[0];\n    }\n    this.ctx.transform(...viewport.transform);\n    this.viewportScale = viewport.scale;\n    this.baseTransform = getCurrentTransform(this.ctx);\n  }\n  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    let i = executionStartIdx || 0;\n    const argsArrayLen = argsArray.length;\n    if (argsArrayLen === i) {\n      return i;\n    }\n    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n    let steps = 0;\n    const commonObjs = this.commonObjs;\n    const objs = this.objs;\n    let fnId;\n    while (true) {\n      if (stepper !== undefined && i === stepper.nextBreakPoint) {\n        stepper.breakIt(i, continueCallback);\n        return i;\n      }\n      fnId = fnArray[i];\n      if (fnId !== OPS.dependency) {\n        this[fnId].apply(this, argsArray[i]);\n      } else {\n        for (const depObjId of argsArray[i]) {\n          const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n          if (!objsPool.has(depObjId)) {\n            objsPool.get(depObjId, continueCallback);\n            return i;\n          }\n        }\n      }\n      i++;\n      if (i === argsArrayLen) {\n        return i;\n      }\n      if (chunkOperations && ++steps > EXECUTION_STEPS) {\n        if (Date.now() > endTime) {\n          continueCallback();\n          return i;\n        }\n        steps = 0;\n      }\n    }\n  }\n  #restoreInitialState() {\n    while (this.stateStack.length || this.inSMaskMode) {\n      this.restore();\n    }\n    this.current.activeSMask = null;\n    this.ctx.restore();\n    if (this.transparentCanvas) {\n      this.ctx = this.compositeCtx;\n      this.ctx.save();\n      this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx.drawImage(this.transparentCanvas, 0, 0);\n      this.ctx.restore();\n      this.transparentCanvas = null;\n    }\n  }\n  endDrawing() {\n    this.#restoreInitialState();\n    this.cachedCanvases.clear();\n    this.cachedPatterns.clear();\n    for (const cache of this._cachedBitmapsMap.values()) {\n      for (const canvas of cache.values()) {\n        if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n          canvas.width = canvas.height = 0;\n        }\n      }\n      cache.clear();\n    }\n    this._cachedBitmapsMap.clear();\n    this.#drawFilter();\n  }\n  #drawFilter() {\n    if (this.pageColors) {\n      const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n      if (hcmFilterId !== \"none\") {\n        const savedFilter = this.ctx.filter;\n        this.ctx.filter = hcmFilterId;\n        this.ctx.drawImage(this.ctx.canvas, 0, 0);\n        this.ctx.filter = savedFilter;\n      }\n    }\n  }\n  _scaleImage(img, inverseTransform) {\n    const width = img.width ?? img.displayWidth;\n    const height = img.height ?? img.displayHeight;\n    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n    let paintWidth = width,\n      paintHeight = height;\n    let tmpCanvasId = \"prescale1\";\n    let tmpCanvas, tmpCtx;\n    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n      let newWidth = paintWidth,\n        newHeight = paintHeight;\n      if (widthScale > 2 && paintWidth > 1) {\n        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n        widthScale /= paintWidth / newWidth;\n      }\n      if (heightScale > 2 && paintHeight > 1) {\n        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n        heightScale /= paintHeight / newHeight;\n      }\n      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n      tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, newWidth, newHeight);\n      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n      img = tmpCanvas.canvas;\n      paintWidth = newWidth;\n      paintHeight = newHeight;\n      tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n    }\n    return {\n      img,\n      paintWidth,\n      paintHeight\n    };\n  }\n  _createMaskCanvas(img) {\n    const ctx = this.ctx;\n    const {\n      width,\n      height\n    } = img;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    const currentTransform = getCurrentTransform(ctx);\n    let cache, cacheKey, scaled, maskCanvas;\n    if ((img.bitmap || img.data) && img.count > 1) {\n      const mainKey = img.bitmap || img.data.buffer;\n      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);\n      cache = this._cachedBitmapsMap.get(mainKey);\n      if (!cache) {\n        cache = new Map();\n        this._cachedBitmapsMap.set(mainKey, cache);\n      }\n      const cachedImage = cache.get(cacheKey);\n      if (cachedImage && !isPatternFill) {\n        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n        return {\n          canvas: cachedImage,\n          offsetX,\n          offsetY\n        };\n      }\n      scaled = cachedImage;\n    }\n    if (!scaled) {\n      maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      putBinaryImageMask(maskCanvas.context, img);\n    }\n    let maskToCanvas = Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);\n    maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n    const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox([0, 0, width, height], maskToCanvas);\n    const drawnWidth = Math.round(maxX - minX) || 1;\n    const drawnHeight = Math.round(maxY - minY) || 1;\n    const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n    const fillCtx = fillCanvas.context;\n    const offsetX = minX;\n    const offsetY = minY;\n    fillCtx.translate(-offsetX, -offsetY);\n    fillCtx.transform(...maskToCanvas);\n    if (!scaled) {\n      scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n      scaled = scaled.img;\n      if (cache && isPatternFill) {\n        cache.set(cacheKey, scaled);\n      }\n    }\n    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n    fillCtx.globalCompositeOperation = \"source-in\";\n    const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);\n    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;\n    fillCtx.fillRect(0, 0, width, height);\n    if (cache && !isPatternFill) {\n      this.cachedCanvases.delete(\"fillCanvas\");\n      cache.set(cacheKey, fillCanvas.canvas);\n    }\n    return {\n      canvas: fillCanvas.canvas,\n      offsetX: Math.round(offsetX),\n      offsetY: Math.round(offsetY)\n    };\n  }\n  setLineWidth(width) {\n    if (width !== this.current.lineWidth) {\n      this._cachedScaleForStroking[0] = -1;\n    }\n    this.current.lineWidth = width;\n    this.ctx.lineWidth = width;\n  }\n  setLineCap(style) {\n    this.ctx.lineCap = LINE_CAP_STYLES[style];\n  }\n  setLineJoin(style) {\n    this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n  }\n  setMiterLimit(limit) {\n    this.ctx.miterLimit = limit;\n  }\n  setDash(dashArray, dashPhase) {\n    const ctx = this.ctx;\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash(dashArray);\n      ctx.lineDashOffset = dashPhase;\n    }\n  }\n  setRenderingIntent(intent) {}\n  setFlatness(flatness) {}\n  setGState(states) {\n    for (const [key, value] of states) {\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(value);\n          break;\n        case \"LC\":\n          this.setLineCap(value);\n          break;\n        case \"LJ\":\n          this.setLineJoin(value);\n          break;\n        case \"ML\":\n          this.setMiterLimit(value);\n          break;\n        case \"D\":\n          this.setDash(value[0], value[1]);\n          break;\n        case \"RI\":\n          this.setRenderingIntent(value);\n          break;\n        case \"FL\":\n          this.setFlatness(value);\n          break;\n        case \"Font\":\n          this.setFont(value[0], value[1]);\n          break;\n        case \"CA\":\n          this.current.strokeAlpha = value;\n          break;\n        case \"ca\":\n          this.current.fillAlpha = value;\n          this.ctx.globalAlpha = value;\n          break;\n        case \"BM\":\n          this.ctx.globalCompositeOperation = value;\n          break;\n        case \"SMask\":\n          this.current.activeSMask = value ? this.tempSMask : null;\n          this.tempSMask = null;\n          this.checkSMaskState();\n          break;\n        case \"TR\":\n          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n          break;\n      }\n    }\n  }\n  get inSMaskMode() {\n    return !!this.suspendedCtx;\n  }\n  checkSMaskState() {\n    const inSMaskMode = this.inSMaskMode;\n    if (this.current.activeSMask && !inSMaskMode) {\n      this.beginSMaskMode();\n    } else if (!this.current.activeSMask && inSMaskMode) {\n      this.endSMaskMode();\n    }\n  }\n  beginSMaskMode() {\n    if (this.inSMaskMode) {\n      throw new Error(\"beginSMaskMode called while already in smask mode\");\n    }\n    const drawnWidth = this.ctx.canvas.width;\n    const drawnHeight = this.ctx.canvas.height;\n    const cacheId = \"smaskGroupAt\" + this.groupLevel;\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    this.suspendedCtx = this.ctx;\n    this.ctx = scratchCanvas.context;\n    const ctx = this.ctx;\n    ctx.setTransform(...getCurrentTransform(this.suspendedCtx));\n    copyCtxState(this.suspendedCtx, ctx);\n    mirrorContextOperations(ctx, this.suspendedCtx);\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n  }\n  endSMaskMode() {\n    if (!this.inSMaskMode) {\n      throw new Error(\"endSMaskMode called while not in smask mode\");\n    }\n    this.ctx._removeMirroring();\n    copyCtxState(this.ctx, this.suspendedCtx);\n    this.ctx = this.suspendedCtx;\n    this.suspendedCtx = null;\n  }\n  compose(dirtyBox) {\n    if (!this.current.activeSMask) {\n      return;\n    }\n    if (!dirtyBox) {\n      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n    } else {\n      dirtyBox[0] = Math.floor(dirtyBox[0]);\n      dirtyBox[1] = Math.floor(dirtyBox[1]);\n      dirtyBox[2] = Math.ceil(dirtyBox[2]);\n      dirtyBox[3] = Math.ceil(dirtyBox[3]);\n    }\n    const smask = this.current.activeSMask;\n    const suspendedCtx = this.suspendedCtx;\n    this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n    this.ctx.save();\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.restore();\n  }\n  composeSMask(ctx, smask, layerCtx, layerBox) {\n    const layerOffsetX = layerBox[0];\n    const layerOffsetY = layerBox[1];\n    const layerWidth = layerBox[2] - layerOffsetX;\n    const layerHeight = layerBox[3] - layerOffsetY;\n    if (layerWidth === 0 || layerHeight === 0) {\n      return;\n    }\n    this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n    ctx.save();\n    ctx.globalAlpha = 1;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(layerCtx.canvas, 0, 0);\n    ctx.restore();\n  }\n  genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n    let maskCanvas = maskCtx.canvas;\n    let maskX = layerOffsetX - maskOffsetX;\n    let maskY = layerOffsetY - maskOffsetY;\n    if (backdrop) {\n      const backdropRGB = Util.makeHexColor(...backdrop);\n      if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n        const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n        const ctx = canvas.context;\n        ctx.drawImage(maskCanvas, -maskX, -maskY);\n        ctx.globalCompositeOperation = \"destination-atop\";\n        ctx.fillStyle = backdropRGB;\n        ctx.fillRect(0, 0, width, height);\n        ctx.globalCompositeOperation = \"source-over\";\n        maskCanvas = canvas.canvas;\n        maskX = maskY = 0;\n      } else {\n        maskCtx.save();\n        maskCtx.globalAlpha = 1;\n        maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n        const clip = new Path2D();\n        clip.rect(maskX, maskY, width, height);\n        maskCtx.clip(clip);\n        maskCtx.globalCompositeOperation = \"destination-atop\";\n        maskCtx.fillStyle = backdropRGB;\n        maskCtx.fillRect(maskX, maskY, width, height);\n        maskCtx.restore();\n      }\n    }\n    layerCtx.save();\n    layerCtx.globalAlpha = 1;\n    layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n    if (subtype === \"Alpha\" && transferMap) {\n      layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n    } else if (subtype === \"Luminosity\") {\n      layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n    }\n    const clip = new Path2D();\n    clip.rect(layerOffsetX, layerOffsetY, width, height);\n    layerCtx.clip(clip);\n    layerCtx.globalCompositeOperation = \"destination-in\";\n    layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n    layerCtx.restore();\n  }\n  save() {\n    if (this.inSMaskMode) {\n      copyCtxState(this.ctx, this.suspendedCtx);\n      this.suspendedCtx.save();\n    } else {\n      this.ctx.save();\n    }\n    const old = this.current;\n    this.stateStack.push(old);\n    this.current = old.clone();\n  }\n  restore() {\n    if (this.stateStack.length === 0 && this.inSMaskMode) {\n      this.endSMaskMode();\n    }\n    if (this.stateStack.length !== 0) {\n      this.current = this.stateStack.pop();\n      if (this.inSMaskMode) {\n        this.suspendedCtx.restore();\n        copyCtxState(this.suspendedCtx, this.ctx);\n      } else {\n        this.ctx.restore();\n      }\n      this.checkSMaskState();\n      this.pendingClip = null;\n      this._cachedScaleForStroking[0] = -1;\n      this._cachedGetSinglePixelWidth = null;\n    }\n  }\n  transform(a, b, c, d, e, f) {\n    this.ctx.transform(a, b, c, d, e, f);\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n  }\n  constructPath(ops, args, minMax) {\n    const ctx = this.ctx;\n    const current = this.current;\n    let x = current.x,\n      y = current.y;\n    let startX, startY;\n    const currentTransform = getCurrentTransform(ctx);\n    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\n      switch (ops[i] | 0) {\n        case OPS.rectangle:\n          x = args[j++];\n          y = args[j++];\n          const width = args[j++];\n          const height = args[j++];\n          const xw = x + width;\n          const yh = y + height;\n          ctx.moveTo(x, y);\n          if (width === 0 || height === 0) {\n            ctx.lineTo(xw, yh);\n          } else {\n            ctx.lineTo(xw, y);\n            ctx.lineTo(xw, yh);\n            ctx.lineTo(x, yh);\n          }\n          if (!isScalingMatrix) {\n            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);\n          }\n          ctx.closePath();\n          break;\n        case OPS.moveTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.moveTo(x, y);\n          if (!isScalingMatrix) {\n            current.updatePathMinMax(currentTransform, x, y);\n          }\n          break;\n        case OPS.lineTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.lineTo(x, y);\n          if (!isScalingMatrix) {\n            current.updatePathMinMax(currentTransform, x, y);\n          }\n          break;\n        case OPS.curveTo:\n          startX = x;\n          startY = y;\n          x = args[j + 4];\n          y = args[j + 5];\n          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n          j += 6;\n          break;\n        case OPS.curveTo2:\n          startX = x;\n          startY = y;\n          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n          x = args[j + 2];\n          y = args[j + 3];\n          j += 4;\n          break;\n        case OPS.curveTo3:\n          startX = x;\n          startY = y;\n          x = args[j + 2];\n          y = args[j + 3];\n          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n          j += 4;\n          break;\n        case OPS.closePath:\n          ctx.closePath();\n          break;\n      }\n    }\n    if (isScalingMatrix) {\n      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n    }\n    current.setCurrentPoint(x, y);\n  }\n  closePath() {\n    this.ctx.closePath();\n  }\n  stroke(consumePath = true) {\n    const ctx = this.ctx;\n    const strokeColor = this.current.strokeColor;\n    ctx.globalAlpha = this.current.strokeAlpha;\n    if (this.contentVisible) {\n      if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n        this.rescaleAndStroke(false);\n        ctx.restore();\n      } else {\n        this.rescaleAndStroke(true);\n      }\n    }\n    if (consumePath) {\n      this.consumePath(this.current.getClippedPathBoundingBox());\n    }\n    ctx.globalAlpha = this.current.fillAlpha;\n  }\n  closeStroke() {\n    this.closePath();\n    this.stroke();\n  }\n  fill(consumePath = true) {\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    let needRestore = false;\n    if (isPatternFill) {\n      ctx.save();\n      ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n      needRestore = true;\n    }\n    const intersect = this.current.getClippedPathBoundingBox();\n    if (this.contentVisible && intersect !== null) {\n      if (this.pendingEOFill) {\n        ctx.fill(\"evenodd\");\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill();\n      }\n    }\n    if (needRestore) {\n      ctx.restore();\n    }\n    if (consumePath) {\n      this.consumePath(intersect);\n    }\n  }\n  eoFill() {\n    this.pendingEOFill = true;\n    this.fill();\n  }\n  fillStroke() {\n    this.fill(false);\n    this.stroke(false);\n    this.consumePath();\n  }\n  eoFillStroke() {\n    this.pendingEOFill = true;\n    this.fillStroke();\n  }\n  closeFillStroke() {\n    this.closePath();\n    this.fillStroke();\n  }\n  closeEOFillStroke() {\n    this.pendingEOFill = true;\n    this.closePath();\n    this.fillStroke();\n  }\n  endPath() {\n    this.consumePath();\n  }\n  clip() {\n    this.pendingClip = NORMAL_CLIP;\n  }\n  eoClip() {\n    this.pendingClip = EO_CLIP;\n  }\n  beginText() {\n    this.current.textMatrix = IDENTITY_MATRIX;\n    this.current.textMatrixScale = 1;\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n  endText() {\n    const paths = this.pendingTextPaths;\n    const ctx = this.ctx;\n    if (paths === undefined) {\n      ctx.beginPath();\n      return;\n    }\n    ctx.save();\n    ctx.beginPath();\n    for (const path of paths) {\n      ctx.setTransform(...path.transform);\n      ctx.translate(path.x, path.y);\n      path.addToPath(ctx, path.fontSize);\n    }\n    ctx.restore();\n    ctx.clip();\n    ctx.beginPath();\n    delete this.pendingTextPaths;\n  }\n  setCharSpacing(spacing) {\n    this.current.charSpacing = spacing;\n  }\n  setWordSpacing(spacing) {\n    this.current.wordSpacing = spacing;\n  }\n  setHScale(scale) {\n    this.current.textHScale = scale / 100;\n  }\n  setLeading(leading) {\n    this.current.leading = -leading;\n  }\n  setFont(fontRefName, size) {\n    const fontObj = this.commonObjs.get(fontRefName);\n    const current = this.current;\n    if (!fontObj) {\n      throw new Error(`Can't find font for ${fontRefName}`);\n    }\n    current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n      warn(\"Invalid font matrix for font \" + fontRefName);\n    }\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n    this.current.font = fontObj;\n    this.current.fontSize = size;\n    if (fontObj.isType3Font) {\n      return;\n    }\n    const name = fontObj.loadedName || \"sans-serif\";\n    const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n    let bold = \"normal\";\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    let browserFontSize = size;\n    if (size < MIN_FONT_SIZE) {\n      browserFontSize = MIN_FONT_SIZE;\n    } else if (size > MAX_FONT_SIZE) {\n      browserFontSize = MAX_FONT_SIZE;\n    }\n    this.current.fontSizeScale = size / browserFontSize;\n    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n  }\n  setTextRenderingMode(mode) {\n    this.current.textRenderingMode = mode;\n  }\n  setTextRise(rise) {\n    this.current.textRise = rise;\n  }\n  moveText(x, y) {\n    this.current.x = this.current.lineX += x;\n    this.current.y = this.current.lineY += y;\n  }\n  setLeadingMoveText(x, y) {\n    this.setLeading(-y);\n    this.moveText(x, y);\n  }\n  setTextMatrix(a, b, c, d, e, f) {\n    this.current.textMatrix = [a, b, c, d, e, f];\n    this.current.textMatrixScale = Math.hypot(a, b);\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n  nextLine() {\n    this.moveText(0, this.current.leading);\n  }\n  paintChar(character, x, y, patternTransform) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const textRenderingMode = current.textRenderingMode;\n    const fontSize = current.fontSize / current.fontSizeScale;\n    const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n    const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n    const patternFill = current.patternFill && !font.missingFile;\n    let addToPath;\n    if (font.disableFontFace || isAddToPathSet || patternFill) {\n      addToPath = font.getPathGenerator(this.commonObjs, character);\n    }\n    if (font.disableFontFace || patternFill) {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.beginPath();\n      addToPath(ctx, fontSize);\n      if (patternTransform) {\n        ctx.setTransform(...patternTransform);\n      }\n      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        ctx.fill();\n      }\n      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        ctx.stroke();\n      }\n      ctx.restore();\n    } else {\n      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        ctx.fillText(character, x, y);\n      }\n      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        ctx.strokeText(character, x, y);\n      }\n    }\n    if (isAddToPathSet) {\n      const paths = this.pendingTextPaths ||= [];\n      paths.push({\n        transform: getCurrentTransform(ctx),\n        x,\n        y,\n        fontSize,\n        addToPath\n      });\n    }\n  }\n  get isFontSubpixelAAEnabled() {\n    const {\n      context: ctx\n    } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n    ctx.scale(1.5, 1);\n    ctx.fillText(\"I\", 0, 10);\n    const data = ctx.getImageData(0, 0, 10, 10).data;\n    let enabled = false;\n    for (let i = 3; i < data.length; i += 4) {\n      if (data[i] > 0 && data[i] < 255) {\n        enabled = true;\n        break;\n      }\n    }\n    return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n  }\n  showText(glyphs) {\n    const current = this.current;\n    const font = current.font;\n    if (font.isType3Font) {\n      return this.showType3Text(glyphs);\n    }\n    const fontSize = current.fontSize;\n    if (fontSize === 0) {\n      return undefined;\n    }\n    const ctx = this.ctx;\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const glyphsLength = glyphs.length;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n    ctx.save();\n    ctx.transform(...current.textMatrix);\n    ctx.translate(current.x, current.y + current.textRise);\n    if (fontDirection > 0) {\n      ctx.scale(textHScale, -1);\n    } else {\n      ctx.scale(textHScale, 1);\n    }\n    let patternTransform;\n    if (current.patternFill) {\n      ctx.save();\n      const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n      patternTransform = getCurrentTransform(ctx);\n      ctx.restore();\n      ctx.fillStyle = pattern;\n    }\n    let lineWidth = current.lineWidth;\n    const scale = current.textMatrixScale;\n    if (scale === 0 || lineWidth === 0) {\n      const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        lineWidth = this.getSinglePixelWidth();\n      }\n    } else {\n      lineWidth /= scale;\n    }\n    if (fontSizeScale !== 1.0) {\n      ctx.scale(fontSizeScale, fontSizeScale);\n      lineWidth /= fontSizeScale;\n    }\n    ctx.lineWidth = lineWidth;\n    if (font.isInvalidPDFjsFont) {\n      const chars = [];\n      let width = 0;\n      for (const glyph of glyphs) {\n        chars.push(glyph.unicode);\n        width += glyph.width;\n      }\n      ctx.fillText(chars.join(\"\"), 0, 0);\n      current.x += width * widthAdvanceScale * textHScale;\n      ctx.restore();\n      this.compose();\n      return undefined;\n    }\n    let x = 0,\n      i;\n    for (i = 0; i < glyphsLength; ++i) {\n      const glyph = glyphs[i];\n      if (typeof glyph === \"number\") {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n      let restoreNeeded = false;\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      const accent = glyph.accent;\n      let scaledX, scaledY;\n      let width = glyph.width;\n      if (vertical) {\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n      if (font.remeasure && width > 0) {\n        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n          const characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        } else if (width !== measuredWidth) {\n          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n        }\n      }\n      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n        if (simpleFillText && !accent) {\n          ctx.fillText(character, scaledX, scaledY);\n        } else {\n          this.paintChar(character, scaledX, scaledY, patternTransform);\n          if (accent) {\n            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n          }\n        }\n      }\n      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n      x += charWidth;\n      if (restoreNeeded) {\n        ctx.restore();\n      }\n    }\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n    ctx.restore();\n    this.compose();\n    return undefined;\n  }\n  showType3Text(glyphs) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    const fontDirection = current.fontDirection;\n    const spacingDir = font.vertical ? 1 : -1;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const textHScale = current.textHScale * fontDirection;\n    const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n    const glyphsLength = glyphs.length;\n    const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n    let i, glyph, width, spacingLength;\n    if (isTextInvisible || fontSize === 0) {\n      return;\n    }\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n    ctx.save();\n    ctx.transform(...current.textMatrix);\n    ctx.translate(current.x, current.y);\n    ctx.scale(textHScale, fontDirection);\n    for (i = 0; i < glyphsLength; ++i) {\n      glyph = glyphs[i];\n      if (typeof glyph === \"number\") {\n        spacingLength = spacingDir * glyph * fontSize / 1000;\n        this.ctx.translate(spacingLength, 0);\n        current.x += spacingLength * textHScale;\n        continue;\n      }\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const operatorList = font.charProcOperatorList[glyph.operatorListId];\n      if (!operatorList) {\n        warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n        continue;\n      }\n      if (this.contentVisible) {\n        this.processingType3 = glyph;\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform(...fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n      }\n      const transformed = Util.applyTransform([glyph.width, 0], fontMatrix);\n      width = transformed[0] * fontSize + spacing;\n      ctx.translate(width, 0);\n      current.x += width * textHScale;\n    }\n    ctx.restore();\n    this.processingType3 = null;\n  }\n  setCharWidth(xWidth, yWidth) {}\n  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n    this.ctx.rect(llx, lly, urx - llx, ury - lly);\n    this.ctx.clip();\n    this.endPath();\n  }\n  getColorN_Pattern(IR) {\n    let pattern;\n    if (IR[0] === \"TilingPattern\") {\n      const color = IR[1];\n      const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n      const canvasGraphicsFactory = {\n        createCanvasGraphics: ctx => new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n          optionalContentConfig: this.optionalContentConfig,\n          markedContentStack: this.markedContentStack\n        })\n      };\n      pattern = new TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n    } else {\n      pattern = this._getPattern(IR[1], IR[2]);\n    }\n    return pattern;\n  }\n  setStrokeColorN() {\n    this.current.strokeColor = this.getColorN_Pattern(arguments);\n  }\n  setFillColorN() {\n    this.current.fillColor = this.getColorN_Pattern(arguments);\n    this.current.patternFill = true;\n  }\n  setStrokeRGBColor(r, g, b) {\n    this.ctx.strokeStyle = this.current.strokeColor = Util.makeHexColor(r, g, b);\n  }\n  setStrokeTransparent() {\n    this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n  }\n  setFillRGBColor(r, g, b) {\n    this.ctx.fillStyle = this.current.fillColor = Util.makeHexColor(r, g, b);\n    this.current.patternFill = false;\n  }\n  setFillTransparent() {\n    this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n    this.current.patternFill = false;\n  }\n  _getPattern(objId, matrix = null) {\n    let pattern;\n    if (this.cachedPatterns.has(objId)) {\n      pattern = this.cachedPatterns.get(objId);\n    } else {\n      pattern = getShadingPattern(this.getObject(objId));\n      this.cachedPatterns.set(objId, pattern);\n    }\n    if (matrix) {\n      pattern.matrix = matrix;\n    }\n    return pattern;\n  }\n  shadingFill(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    this.save();\n    const pattern = this._getPattern(objId);\n    ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);\n    const inv = getCurrentTransformInverse(ctx);\n    if (inv) {\n      const {\n        width,\n        height\n      } = ctx.canvas;\n      const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);\n      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n    } else {\n      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n    }\n    this.compose(this.current.getClippedPathBoundingBox());\n    this.restore();\n  }\n  beginInlineImage() {\n    unreachable(\"Should not call beginInlineImage\");\n  }\n  beginImageData() {\n    unreachable(\"Should not call beginImageData\");\n  }\n  paintFormXObjectBegin(matrix, bbox) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save();\n    this.baseTransformStack.push(this.baseTransform);\n    if (matrix) {\n      this.transform(...matrix);\n    }\n    this.baseTransform = getCurrentTransform(this.ctx);\n    if (bbox) {\n      const width = bbox[2] - bbox[0];\n      const height = bbox[3] - bbox[1];\n      this.ctx.rect(bbox[0], bbox[1], width, height);\n      this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);\n      this.clip();\n      this.endPath();\n    }\n  }\n  paintFormXObjectEnd() {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.restore();\n    this.baseTransform = this.baseTransformStack.pop();\n  }\n  beginGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save();\n    if (this.inSMaskMode) {\n      this.endSMaskMode();\n      this.current.activeSMask = null;\n    }\n    const currentCtx = this.ctx;\n    if (!group.isolated) {\n      info(\"TODO: Support non-isolated groups.\");\n    }\n    if (group.knockout) {\n      warn(\"Knockout groups not supported.\");\n    }\n    const currentTransform = getCurrentTransform(currentCtx);\n    if (group.matrix) {\n      currentCtx.transform(...group.matrix);\n    }\n    if (!group.bbox) {\n      throw new Error(\"Bounding box is required.\");\n    }\n    let bounds = Util.getAxialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx));\n    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n    bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n    const offsetX = Math.floor(bounds[0]);\n    const offsetY = Math.floor(bounds[1]);\n    const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n    const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n    let cacheId = \"groupAt\" + this.groupLevel;\n    if (group.smask) {\n      cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n    }\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    const groupCtx = scratchCanvas.context;\n    groupCtx.translate(-offsetX, -offsetY);\n    groupCtx.transform(...currentTransform);\n    if (group.smask) {\n      this.smaskStack.push({\n        canvas: scratchCanvas.canvas,\n        context: groupCtx,\n        offsetX,\n        offsetY,\n        subtype: group.smask.subtype,\n        backdrop: group.smask.backdrop,\n        transferMap: group.smask.transferMap || null,\n        startTransformInverse: null\n      });\n    } else {\n      currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n      currentCtx.translate(offsetX, offsetY);\n      currentCtx.save();\n    }\n    copyCtxState(currentCtx, groupCtx);\n    this.ctx = groupCtx;\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n    this.groupStack.push(currentCtx);\n    this.groupLevel++;\n  }\n  endGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.groupLevel--;\n    const groupCtx = this.ctx;\n    const ctx = this.groupStack.pop();\n    this.ctx = ctx;\n    this.ctx.imageSmoothingEnabled = false;\n    if (group.smask) {\n      this.tempSMask = this.smaskStack.pop();\n      this.restore();\n    } else {\n      this.ctx.restore();\n      const currentMtx = getCurrentTransform(this.ctx);\n      this.restore();\n      this.ctx.save();\n      this.ctx.setTransform(...currentMtx);\n      const dirtyBox = Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);\n      this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      this.ctx.restore();\n      this.compose(dirtyBox);\n    }\n  }\n  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n    this.#restoreInitialState();\n    resetCtxToDefault(this.ctx);\n    this.ctx.save();\n    this.save();\n    if (this.baseTransform) {\n      this.ctx.setTransform(...this.baseTransform);\n    }\n    if (rect) {\n      const width = rect[2] - rect[0];\n      const height = rect[3] - rect[1];\n      if (hasOwnCanvas && this.annotationCanvasMap) {\n        transform = transform.slice();\n        transform[4] -= rect[0];\n        transform[5] -= rect[1];\n        rect = rect.slice();\n        rect[0] = rect[1] = 0;\n        rect[2] = width;\n        rect[3] = height;\n        const [scaleX, scaleY] = Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx));\n        const {\n          viewportScale\n        } = this;\n        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n        const {\n          canvas,\n          context\n        } = this.annotationCanvas;\n        this.annotationCanvasMap.set(id, canvas);\n        this.annotationCanvas.savedCtx = this.ctx;\n        this.ctx = context;\n        this.ctx.save();\n        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n        resetCtxToDefault(this.ctx);\n      } else {\n        resetCtxToDefault(this.ctx);\n        this.endPath();\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.ctx.clip();\n        this.ctx.beginPath();\n      }\n    }\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.transform(...transform);\n    this.transform(...matrix);\n  }\n  endAnnotation() {\n    if (this.annotationCanvas) {\n      this.ctx.restore();\n      this.#drawFilter();\n      this.ctx = this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas;\n    }\n  }\n  paintImageMaskXObject(img) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const count = img.count;\n    img = this.getObject(img.data, img);\n    img.count = count;\n    const ctx = this.ctx;\n    const glyph = this.processingType3;\n    if (glyph) {\n      if (glyph.compiled === undefined) {\n        glyph.compiled = compileType3Glyph(img);\n      }\n      if (glyph.compiled) {\n        glyph.compiled(ctx);\n        return;\n      }\n    }\n    const mask = this._createMaskCanvas(img);\n    const maskCanvas = mask.canvas;\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n    ctx.restore();\n    this.compose();\n  }\n  paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n    img = this.getObject(img.data, img);\n    const ctx = this.ctx;\n    ctx.save();\n    const currentTransform = getCurrentTransform(ctx);\n    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n    const mask = this._createMaskCanvas(img);\n    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      const trans = Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n      const [x, y] = Util.applyTransform([0, 0], trans);\n      ctx.drawImage(mask.canvas, x, y);\n    }\n    ctx.restore();\n    this.compose();\n  }\n  paintImageMaskXObjectGroup(images) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    for (const image of images) {\n      const {\n        data,\n        width,\n        height,\n        transform\n      } = image;\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      const maskCtx = maskCanvas.context;\n      maskCtx.save();\n      const img = this.getObject(data, image);\n      putBinaryImageMask(maskCtx, img);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      ctx.save();\n      ctx.transform(...transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n      ctx.restore();\n    }\n    this.compose();\n  }\n  paintImageXObject(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = this.getObject(objId);\n    if (!imgData) {\n      warn(\"Dependent image isn't ready yet\");\n      return;\n    }\n    this.paintInlineImageXObject(imgData);\n  }\n  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = this.getObject(objId);\n    if (!imgData) {\n      warn(\"Dependent image isn't ready yet\");\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const map = [];\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      map.push({\n        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n        x: 0,\n        y: 0,\n        w: width,\n        h: height\n      });\n    }\n    this.paintInlineImageXObjectGroup(imgData, map);\n  }\n  applyTransferMapsToCanvas(ctx) {\n    if (this.current.transferMaps !== \"none\") {\n      ctx.filter = this.current.transferMaps;\n      ctx.drawImage(ctx.canvas, 0, 0);\n      ctx.filter = \"none\";\n    }\n    return ctx.canvas;\n  }\n  applyTransferMapsToBitmap(imgData) {\n    if (this.current.transferMaps === \"none\") {\n      return imgData.bitmap;\n    }\n    const {\n      bitmap,\n      width,\n      height\n    } = imgData;\n    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n    const tmpCtx = tmpCanvas.context;\n    tmpCtx.filter = this.current.transferMaps;\n    tmpCtx.drawImage(bitmap, 0, 0);\n    tmpCtx.filter = \"none\";\n    return tmpCanvas.canvas;\n  }\n  paintInlineImageXObject(imgData) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const ctx = this.ctx;\n    this.save();\n    if (!isNodeJS) {\n      const {\n        filter\n      } = ctx;\n      if (filter !== \"none\" && filter !== \"\") {\n        ctx.filter = \"none\";\n      }\n    }\n    ctx.scale(1 / width, -1 / height);\n    let imgToPaint;\n    if (imgData.bitmap) {\n      imgToPaint = this.applyTransferMapsToBitmap(imgData);\n    } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n      imgToPaint = imgData;\n    } else {\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n    }\n    const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n    this.compose();\n    this.restore();\n  }\n  paintInlineImageXObjectGroup(imgData, map) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    let imgToPaint;\n    if (imgData.bitmap) {\n      imgToPaint = imgData.bitmap;\n    } else {\n      const w = imgData.width;\n      const h = imgData.height;\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n    }\n    for (const entry of map) {\n      ctx.save();\n      ctx.transform(...entry.transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n      ctx.restore();\n    }\n    this.compose();\n  }\n  paintSolidColorImageMask() {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.ctx.fillRect(0, 0, 1, 1);\n    this.compose();\n  }\n  markPoint(tag) {}\n  markPointProps(tag, properties) {}\n  beginMarkedContent(tag) {\n    this.markedContentStack.push({\n      visible: true\n    });\n  }\n  beginMarkedContentProps(tag, properties) {\n    if (tag === \"OC\") {\n      this.markedContentStack.push({\n        visible: this.optionalContentConfig.isVisible(properties)\n      });\n    } else {\n      this.markedContentStack.push({\n        visible: true\n      });\n    }\n    this.contentVisible = this.isContentVisible();\n  }\n  endMarkedContent() {\n    this.markedContentStack.pop();\n    this.contentVisible = this.isContentVisible();\n  }\n  beginCompat() {}\n  endCompat() {}\n  consumePath(clipBox) {\n    const isEmpty = this.current.isEmptyClip();\n    if (this.pendingClip) {\n      this.current.updateClipFromPath();\n    }\n    if (!this.pendingClip) {\n      this.compose(clipBox);\n    }\n    const ctx = this.ctx;\n    if (this.pendingClip) {\n      if (!isEmpty) {\n        if (this.pendingClip === EO_CLIP) {\n          ctx.clip(\"evenodd\");\n        } else {\n          ctx.clip();\n        }\n      }\n      this.pendingClip = null;\n    }\n    this.current.startNewPathAndClipBox(this.current.clipBox);\n    ctx.beginPath();\n  }\n  getSinglePixelWidth() {\n    if (!this._cachedGetSinglePixelWidth) {\n      const m = getCurrentTransform(this.ctx);\n      if (m[1] === 0 && m[2] === 0) {\n        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n      } else {\n        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n        const normX = Math.hypot(m[0], m[2]);\n        const normY = Math.hypot(m[1], m[3]);\n        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n      }\n    }\n    return this._cachedGetSinglePixelWidth;\n  }\n  getScaleForStroking() {\n    if (this._cachedScaleForStroking[0] === -1) {\n      const {\n        lineWidth\n      } = this.current;\n      const {\n        a,\n        b,\n        c,\n        d\n      } = this.ctx.getTransform();\n      let scaleX, scaleY;\n      if (b === 0 && c === 0) {\n        const normX = Math.abs(a);\n        const normY = Math.abs(d);\n        if (normX === normY) {\n          if (lineWidth === 0) {\n            scaleX = scaleY = 1 / normX;\n          } else {\n            const scaledLineWidth = normX * lineWidth;\n            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n          }\n        } else if (lineWidth === 0) {\n          scaleX = 1 / normX;\n          scaleY = 1 / normY;\n        } else {\n          const scaledXLineWidth = normX * lineWidth;\n          const scaledYLineWidth = normY * lineWidth;\n          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n        }\n      } else {\n        const absDet = Math.abs(a * d - b * c);\n        const normX = Math.hypot(a, b);\n        const normY = Math.hypot(c, d);\n        if (lineWidth === 0) {\n          scaleX = normY / absDet;\n          scaleY = normX / absDet;\n        } else {\n          const baseArea = lineWidth * absDet;\n          scaleX = normY > baseArea ? normY / baseArea : 1;\n          scaleY = normX > baseArea ? normX / baseArea : 1;\n        }\n      }\n      this._cachedScaleForStroking[0] = scaleX;\n      this._cachedScaleForStroking[1] = scaleY;\n    }\n    return this._cachedScaleForStroking;\n  }\n  rescaleAndStroke(saveRestore) {\n    const {\n      ctx\n    } = this;\n    const {\n      lineWidth\n    } = this.current;\n    const [scaleX, scaleY] = this.getScaleForStroking();\n    ctx.lineWidth = lineWidth || 1;\n    if (scaleX === 1 && scaleY === 1) {\n      ctx.stroke();\n      return;\n    }\n    const dashes = ctx.getLineDash();\n    if (saveRestore) {\n      ctx.save();\n    }\n    ctx.scale(scaleX, scaleY);\n    if (dashes.length > 0) {\n      const scale = Math.max(scaleX, scaleY);\n      ctx.setLineDash(dashes.map(x => x / scale));\n      ctx.lineDashOffset /= scale;\n    }\n    ctx.stroke();\n    if (saveRestore) {\n      ctx.restore();\n    }\n  }\n  isContentVisible() {\n    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n      if (!this.markedContentStack[i].visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nfor (const op in OPS) {\n  if (CanvasGraphics.prototype[op] !== undefined) {\n    CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n  }\n}\n\n;// ./src/display/worker_options.js\nclass GlobalWorkerOptions {\n  static #port = null;\n  static #src = \"\";\n  static get workerPort() {\n    return this.#port;\n  }\n  static set workerPort(val) {\n    if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n      throw new Error(\"Invalid `workerPort` type.\");\n    }\n    this.#port = val;\n  }\n  static get workerSrc() {\n    return this.#src;\n  }\n  static set workerSrc(val) {\n    if (typeof val !== \"string\") {\n      throw new Error(\"Invalid `workerSrc` type.\");\n    }\n    this.#src = val;\n  }\n}\n\n;// ./src/shared/message_handler.js\n\nconst CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\nfunction wrapReason(reason) {\n  if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n    unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n  }\n  switch (reason.name) {\n    case \"AbortException\":\n      return new AbortException(reason.message);\n    case \"MissingPDFException\":\n      return new MissingPDFException(reason.message);\n    case \"PasswordException\":\n      return new PasswordException(reason.message, reason.code);\n    case \"UnexpectedResponseException\":\n      return new UnexpectedResponseException(reason.message, reason.status);\n    case \"UnknownErrorException\":\n      return new UnknownErrorException(reason.message, reason.details);\n    default:\n      return new UnknownErrorException(reason.message, reason.toString());\n  }\n}\nclass MessageHandler {\n  #messageAC = new AbortController();\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n    comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n      signal: this.#messageAC.signal\n    });\n  }\n  #onMessage({\n    data\n  }) {\n    if (data.targetName !== this.sourceName) {\n      return;\n    }\n    if (data.stream) {\n      this.#processStreamMessage(data);\n      return;\n    }\n    if (data.callback) {\n      const callbackId = data.callbackId;\n      const capability = this.callbackCapabilities[callbackId];\n      if (!capability) {\n        throw new Error(`Cannot resolve callback ${callbackId}`);\n      }\n      delete this.callbackCapabilities[callbackId];\n      if (data.callback === CallbackKind.DATA) {\n        capability.resolve(data.data);\n      } else if (data.callback === CallbackKind.ERROR) {\n        capability.reject(wrapReason(data.reason));\n      } else {\n        throw new Error(\"Unexpected callback case\");\n      }\n      return;\n    }\n    const action = this.actionHandler[data.action];\n    if (!action) {\n      throw new Error(`Unknown action from worker: ${data.action}`);\n    }\n    if (data.callbackId) {\n      const sourceName = this.sourceName,\n        targetName = data.sourceName,\n        comObj = this.comObj;\n      new Promise(function (resolve) {\n        resolve(action(data.data));\n      }).then(function (result) {\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          callback: CallbackKind.DATA,\n          callbackId: data.callbackId,\n          data: result\n        });\n      }, function (reason) {\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          callback: CallbackKind.ERROR,\n          callbackId: data.callbackId,\n          reason: wrapReason(reason)\n        });\n      });\n      return;\n    }\n    if (data.streamId) {\n      this.#createStreamSink(data);\n      return;\n    }\n    action(data.data);\n  }\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n    ah[actionName] = handler;\n  }\n  send(actionName, data, transfers) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = Promise.withResolvers();\n    this.callbackCapabilities[callbackId] = capability;\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n    return capability.promise;\n  }\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n      sourceName = this.sourceName,\n      targetName = this.targetName,\n      comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = Promise.withResolvers();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = Promise.withResolvers();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        assert(reason instanceof Error, \"cancel must have a valid reason\");\n        const cancelCapability = Promise.withResolvers();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n  #createStreamSink(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const self = this,\n      action = this.actionHandler[data.action];\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = Promise.withResolvers();\n          this.ready = this.sinkCapability.promise;\n        }\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n      error(reason) {\n        assert(reason instanceof Error, \"error must have a valid reason\");\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n      sinkCapability: Promise.withResolvers(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    new Promise(function (resolve) {\n      resolve(action(data.data, streamSink));\n    }).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n  #processStreamMessage(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n      streamSink = this.streamSinks[streamId];\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL:\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n        streamSink.desiredSize = data.desiredSize;\n        new Promise(function (resolve) {\n          resolve(streamSink.onPull?.());\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n      case StreamKind.ENQUEUE:\n        assert(streamController, \"enqueue should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.controller.enqueue(data.chunk);\n        break;\n      case StreamKind.CLOSE:\n        assert(streamController, \"close should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.isClosed = true;\n        streamController.controller.close();\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.ERROR:\n        assert(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n        new Promise(function (resolve) {\n          resolve(streamSink.onCancel?.(wrapReason(data.reason)));\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        streamSink.sinkCapability.reject(wrapReason(data.reason));\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n  async #deleteStreamController(streamController, streamId) {\n    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);\n    delete this.streamControllers[streamId];\n  }\n  destroy() {\n    this.#messageAC?.abort();\n    this.#messageAC = null;\n  }\n}\n\n;// ./src/display/metadata.js\n\nclass Metadata {\n  #metadataMap;\n  #data;\n  constructor({\n    parsedData,\n    rawData\n  }) {\n    this.#metadataMap = parsedData;\n    this.#data = rawData;\n  }\n  getRaw() {\n    return this.#data;\n  }\n  get(name) {\n    return this.#metadataMap.get(name) ?? null;\n  }\n  getAll() {\n    return objectFromMap(this.#metadataMap);\n  }\n  has(name) {\n    return this.#metadataMap.has(name);\n  }\n}\n\n;// ./src/display/optional_content_config.js\n\n\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n  #isDisplay = false;\n  #isPrint = false;\n  #userSet = false;\n  #visible = true;\n  constructor(renderingIntent, {\n    name,\n    intent,\n    usage,\n    rbGroups\n  }) {\n    this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n    this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n    this.name = name;\n    this.intent = intent;\n    this.usage = usage;\n    this.rbGroups = rbGroups;\n  }\n  get visible() {\n    if (this.#userSet) {\n      return this.#visible;\n    }\n    if (!this.#visible) {\n      return false;\n    }\n    const {\n      print,\n      view\n    } = this.usage;\n    if (this.#isDisplay) {\n      return view?.viewState !== \"OFF\";\n    } else if (this.#isPrint) {\n      return print?.printState !== \"OFF\";\n    }\n    return true;\n  }\n  _setVisible(internal, visible, userSet = false) {\n    if (internal !== INTERNAL) {\n      unreachable(\"Internal method `_setVisible` called.\");\n    }\n    this.#userSet = userSet;\n    this.#visible = visible;\n  }\n}\nclass OptionalContentConfig {\n  #cachedGetHash = null;\n  #groups = new Map();\n  #initialHash = null;\n  #order = null;\n  constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY) {\n    this.renderingIntent = renderingIntent;\n    this.name = null;\n    this.creator = null;\n    if (data === null) {\n      return;\n    }\n    this.name = data.name;\n    this.creator = data.creator;\n    this.#order = data.order;\n    for (const group of data.groups) {\n      this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n    }\n    if (data.baseState === \"OFF\") {\n      for (const group of this.#groups.values()) {\n        group._setVisible(INTERNAL, false);\n      }\n    }\n    for (const on of data.on) {\n      this.#groups.get(on)._setVisible(INTERNAL, true);\n    }\n    for (const off of data.off) {\n      this.#groups.get(off)._setVisible(INTERNAL, false);\n    }\n    this.#initialHash = this.getHash();\n  }\n  #evaluateVisibilityExpression(array) {\n    const length = array.length;\n    if (length < 2) {\n      return true;\n    }\n    const operator = array[0];\n    for (let i = 1; i < length; i++) {\n      const element = array[i];\n      let state;\n      if (Array.isArray(element)) {\n        state = this.#evaluateVisibilityExpression(element);\n      } else if (this.#groups.has(element)) {\n        state = this.#groups.get(element).visible;\n      } else {\n        warn(`Optional content group not found: ${element}`);\n        return true;\n      }\n      switch (operator) {\n        case \"And\":\n          if (!state) {\n            return false;\n          }\n          break;\n        case \"Or\":\n          if (state) {\n            return true;\n          }\n          break;\n        case \"Not\":\n          return !state;\n        default:\n          return true;\n      }\n    }\n    return operator === \"And\";\n  }\n  isVisible(group) {\n    if (this.#groups.size === 0) {\n      return true;\n    }\n    if (!group) {\n      info(\"Optional content group not defined.\");\n      return true;\n    }\n    if (group.type === \"OCG\") {\n      if (!this.#groups.has(group.id)) {\n        warn(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n      return this.#groups.get(group.id).visible;\n    } else if (group.type === \"OCMD\") {\n      if (group.expression) {\n        return this.#evaluateVisibilityExpression(group.expression);\n      }\n      if (!group.policy || group.policy === \"AnyOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      } else if (group.policy === \"AnyOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      }\n      warn(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n    warn(`Unknown group type ${group.type}.`);\n    return true;\n  }\n  setVisibility(id, visible = true, preserveRB = true) {\n    const group = this.#groups.get(id);\n    if (!group) {\n      warn(`Optional content group not found: ${id}`);\n      return;\n    }\n    if (preserveRB && visible && group.rbGroups.length) {\n      for (const rbGroup of group.rbGroups) {\n        for (const otherId of rbGroup) {\n          if (otherId !== id) {\n            this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n          }\n        }\n      }\n    }\n    group._setVisible(INTERNAL, !!visible, true);\n    this.#cachedGetHash = null;\n  }\n  setOCGState({\n    state,\n    preserveRB\n  }) {\n    let operator;\n    for (const elem of state) {\n      switch (elem) {\n        case \"ON\":\n        case \"OFF\":\n        case \"Toggle\":\n          operator = elem;\n          continue;\n      }\n      const group = this.#groups.get(elem);\n      if (!group) {\n        continue;\n      }\n      switch (operator) {\n        case \"ON\":\n          this.setVisibility(elem, true, preserveRB);\n          break;\n        case \"OFF\":\n          this.setVisibility(elem, false, preserveRB);\n          break;\n        case \"Toggle\":\n          this.setVisibility(elem, !group.visible, preserveRB);\n          break;\n      }\n    }\n    this.#cachedGetHash = null;\n  }\n  get hasInitialVisibility() {\n    return this.#initialHash === null || this.getHash() === this.#initialHash;\n  }\n  getOrder() {\n    if (!this.#groups.size) {\n      return null;\n    }\n    if (this.#order) {\n      return this.#order.slice();\n    }\n    return [...this.#groups.keys()];\n  }\n  getGroups() {\n    return this.#groups.size > 0 ? objectFromMap(this.#groups) : null;\n  }\n  getGroup(id) {\n    return this.#groups.get(id) || null;\n  }\n  getHash() {\n    if (this.#cachedGetHash !== null) {\n      return this.#cachedGetHash;\n    }\n    const hash = new MurmurHash3_64();\n    for (const [id, group] of this.#groups) {\n      hash.update(`${id}:${group.visible}`);\n    }\n    return this.#cachedGetHash = hash.hexdigest();\n  }\n}\n\n;// ./src/display/transport_stream.js\n\n\nclass PDFDataTransportStream {\n  constructor(pdfDataRangeTransport, {\n    disableRange = false,\n    disableStream = false\n  }) {\n    assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    const {\n      length,\n      initialData,\n      progressiveDone,\n      contentDispositionFilename\n    } = pdfDataRangeTransport;\n    this._queuedChunks = [];\n    this._progressiveDone = progressiveDone;\n    this._contentDispositionFilename = contentDispositionFilename;\n    if (initialData?.length > 0) {\n      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n      this._queuedChunks.push(buffer);\n    }\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !disableStream;\n    this._isRangeSupported = !disableRange;\n    this._contentLength = length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n    pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({\n        begin,\n        chunk\n      });\n    });\n    pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({\n        loaded,\n        total\n      });\n    });\n    pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({\n        chunk\n      });\n    });\n    pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n    pdfDataRangeTransport.transportReady();\n  }\n  _onReceiveData({\n    begin,\n    chunk\n  }) {\n    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n    if (begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== begin) {\n          return false;\n        }\n        rangeReader._enqueue(buffer);\n        return true;\n      });\n      assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n    }\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      this._rangeReaders[0]?.onProgress?.({\n        loaded: evt.loaded\n      });\n    } else {\n      this._fullRequestReader?.onProgress?.({\n        loaded: evt.loaded,\n        total: evt.total\n      });\n    }\n  }\n  _onProgressiveDone() {\n    this._fullRequestReader?.progressiveDone();\n    this._progressiveDone = true;\n  }\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n  }\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n    this._rangeReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n    this._pdfDataRangeTransport.abort();\n  }\n}\nclass PDFDataTransportStreamReader {\n  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n    this._loaded += chunk.byteLength;\n  }\n  get headersReady() {\n    return this._headersReady;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n  }\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n    this._done = true;\n  }\n}\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n      requestsCapability.resolve({\n        value: chunk,\n        done: false\n      });\n      for (const requestCapability of this._requests) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n      this._requests.length = 0;\n    }\n    this._done = true;\n    this._stream._removeRangeReader(this);\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    this._stream._removeRangeReader(this);\n  }\n}\n\n;// ./src/display/content_disposition.js\n\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n  tmp = rfc2231getparam(contentDisposition);\n  if (tmp) {\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(value);\n        value = decoder.decode(buffer);\n        needsEncodingFixup = false;\n      } catch {}\n    }\n    return value;\n  }\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n    return value;\n  }\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match;\n      n = parseInt(n, 10);\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n        continue;\n      }\n      matches[n] = [quot, part];\n    }\n    const parts = [];\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        break;\n      }\n      let [quot, part] = matches[n];\n      part = rfc2616unquote(part);\n      if (quot) {\n        part = unescape(part);\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n      parts.push(part);\n    }\n    return parts.join(\"\");\n  }\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      const parts = value.slice(1).split('\\\\\"');\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf('\"');\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n        parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n      }\n      value = parts.join('\"');\n    }\n    return value;\n  }\n  function rfc5987decode(extvalue) {\n    const encodingend = extvalue.indexOf(\"'\");\n    if (encodingend === -1) {\n      return extvalue;\n    }\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    const value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n    return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replaceAll(\"_\", \" \");\n        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n      try {\n        text = atob(text);\n      } catch {}\n      return textdecode(charset, text);\n    });\n  }\n  return \"\";\n}\n\n;// ./src/display/network_utils.js\n\n\n\nfunction createHeaders(isHttp, httpHeaders) {\n  const headers = new Headers();\n  if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n    return headers;\n  }\n  for (const key in httpHeaders) {\n    const val = httpHeaders[key];\n    if (val !== undefined) {\n      headers.append(key, val);\n    }\n  }\n  return headers;\n}\nfunction validateRangeRequestCapabilities({\n  responseHeaders,\n  isHttp,\n  rangeChunkSize,\n  disableRange\n}) {\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n  returnValues.suggestedLength = length;\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n  if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n  const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n  const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n  if (contentDisposition) {\n    let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch {}\n    }\n    if (isPdfFile(filename)) {\n      return filename;\n    }\n  }\n  return null;\n}\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n    return new MissingPDFException('Missing PDF \"' + url + '\".');\n  }\n  return new UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n}\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n;// ./src/display/fetch_stream.js\n\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers,\n    signal: abortController.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\nfunction getArrayBuffer(val) {\n  if (val instanceof Uint8Array) {\n    return val.buffer;\n  }\n  if (val instanceof ArrayBuffer) {\n    return val;\n  }\n  warn(`getArrayBuffer - unexpected data format: ${val}`);\n  return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.headers = createHeaders(this.isHttp, source.httpHeaders);\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = Promise.withResolvers();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._abortController = new AbortController();\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    const headers = new Headers(stream.headers);\n    const url = source.url;\n    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then(response => {\n      if (!validateResponseStatus(response.status)) {\n        throw createResponseStatusError(response.status, url);\n      }\n      this._reader = response.body.getReader();\n      this._headersCapability.resolve();\n      const responseHeaders = response.headers;\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = validateRangeRequestCapabilities({\n        responseHeaders,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = extractFilenameFromHeader(responseHeaders);\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this.cancel(new AbortException(\"Streaming is disabled.\"));\n      }\n    }).catch(this._headersCapability.reject);\n    this.onProgress = null;\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._headersCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n    this._loaded += value.byteLength;\n    this.onProgress?.({\n      loaded: this._loaded,\n      total: this._contentLength\n    });\n    return {\n      value: getArrayBuffer(value),\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader?.cancel(reason);\n    this._abortController.abort();\n  }\n}\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = Promise.withResolvers();\n    this._isStreamingSupported = !source.disableStream;\n    this._abortController = new AbortController();\n    const headers = new Headers(stream.headers);\n    headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n    const url = source.url;\n    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then(response => {\n      if (!validateResponseStatus(response.status)) {\n        throw createResponseStatusError(response.status, url);\n      }\n      this._readCapability.resolve();\n      this._reader = response.body.getReader();\n    }).catch(this._readCapability.reject);\n    this.onProgress = null;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n    this._loaded += value.byteLength;\n    this.onProgress?.({\n      loaded: this._loaded\n    });\n    return {\n      value: getArrayBuffer(value),\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader?.cancel(reason);\n    this._abortController.abort();\n  }\n}\n\n;// ./src/display/network.js\n\n\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n  const data = xhr.response;\n  if (typeof data !== \"string\") {\n    return data;\n  }\n  return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n  constructor({\n    url,\n    httpHeaders,\n    withCredentials\n  }) {\n    this.url = url;\n    this.isHttp = /^https?:/i.test(url);\n    this.headers = createHeaders(this.isHttp, httpHeaders);\n    this.withCredentials = withCredentials || false;\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n  requestRange(begin, end, listeners) {\n    const args = {\n      begin,\n      end\n    };\n    for (const prop in listeners) {\n      args[prop] = listeners[prop];\n    }\n    return this.request(args);\n  }\n  requestFull(listeners) {\n    return this.request(listeners);\n  }\n  request(args) {\n    const xhr = new XMLHttpRequest();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = this.pendingRequests[xhrId] = {\n      xhr\n    };\n    xhr.open(\"GET\", this.url);\n    xhr.withCredentials = this.withCredentials;\n    for (const [key, val] of this.headers) {\n      xhr.setRequestHeader(key, val);\n    }\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n    xhr.responseType = \"arraybuffer\";\n    if (args.onError) {\n      xhr.onerror = function (evt) {\n        args.onError(xhr.status);\n      };\n    }\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n    xhr.send(null);\n    return xhrId;\n  }\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return;\n    }\n    pendingRequest.onProgress?.(evt);\n  }\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return;\n    }\n    const xhr = pendingRequest.xhr;\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n    if (xhr.readyState !== 4) {\n      return;\n    }\n    if (!(xhrId in this.pendingRequests)) {\n      return;\n    }\n    delete this.pendingRequests[xhrId];\n    if (xhr.status === 0 && this.isHttp) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n    const xhrStatus = xhr.status || OK_RESPONSE;\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n    const chunk = network_getArrayBuffer(xhr);\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      pendingRequest.onDone({\n        begin: parseInt(matches[1], 10),\n        chunk\n      });\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk\n      });\n    } else {\n      pendingRequest.onError?.(xhr.status);\n    }\n  }\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n}\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source);\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n    const args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersCapability = Promise.withResolvers();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n    const responseHeaders = new Headers(fullRequestXhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/).map(x => {\n      const [key, ...val] = x.split(\": \");\n      return [key, val.join(\": \")];\n    }));\n    const {\n      allowRangeRequests,\n      suggestedLength\n    } = validateRangeRequestCapabilities({\n      responseHeaders,\n      isHttp: this._manager.isHttp,\n      rangeChunkSize: this._rangeChunkSize,\n      disableRange: this._disableRange\n    });\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n    this._contentLength = suggestedLength || this._contentLength;\n    this._filename = extractFilenameFromHeader(responseHeaders);\n    if (this._isRangeSupported) {\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n    this._headersCapability.resolve();\n  }\n  _onDone(data) {\n    if (data) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n        requestCapability.resolve({\n          value: data.chunk,\n          done: false\n        });\n      } else {\n        this._cachedChunks.push(data.chunk);\n      }\n    }\n    this._done = true;\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n  }\n  _onError(status) {\n    this._storedError = createResponseStatusError(status, this._url);\n    this._headersCapability.reject(this._storedError);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._cachedChunks.length = 0;\n  }\n  _onProgress(evt) {\n    this.onProgress?.({\n      loaded: evt.loaded,\n      total: evt.lengthComputable ? evt.total : this._contentLength\n    });\n  }\n  get filename() {\n    return this._filename;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    this._headersCapability.reject(reason);\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n    this._fullRequestReader = null;\n  }\n}\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n    const args = {\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = manager.url;\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this._storedError = undefined;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n  _close() {\n    this.onClosed?.(this);\n  }\n  _onDone(data) {\n    const chunk = data.chunk;\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunk = chunk;\n    }\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    this._close();\n  }\n  _onError(status) {\n    this._storedError = createResponseStatusError(status, this._url);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._queuedChunk = null;\n  }\n  _onProgress(evt) {\n    if (!this.isStreamingSupported) {\n      this.onProgress?.({\n        loaded: evt.loaded\n      });\n    }\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n    this._close();\n  }\n}\n\n;// ./src/display/node_stream.js\n\n\n\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n  if (urlRegex.test(sourceUrl)) {\n    return new URL(sourceUrl);\n  }\n  const url = NodePackages.get(\"url\");\n  return new URL(url.pathToFileURL(sourceUrl));\n}\nfunction createRequest(url, headers, callback) {\n  if (url.protocol === \"http:\") {\n    const http = NodePackages.get(\"http\");\n    return http.request(url, {\n      headers\n    }, callback);\n  }\n  const https = NodePackages.get(\"https\");\n  return https.request(url, {\n    headers\n  }, callback);\n}\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrlOrPath(source.url);\n    this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n    this.isFsUrl = this.url.protocol === \"file:\";\n    this.headers = createHeaders(this.isHttp, source.httpHeaders);\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n    return this._fullRequestReader;\n  }\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n    this._rangeRequestReaders.push(rangeReader);\n    return rangeReader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nclass BaseFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = Promise.withResolvers();\n    this._headersCapability = Promise.withResolvers();\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = Promise.withResolvers();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    this.onProgress?.({\n      loaded: this._loaded,\n      total: this._contentLength\n    });\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new AbortException(\"streaming is disabled\"));\n    }\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\nclass BaseRangeReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = Promise.withResolvers();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = Promise.withResolvers();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    this.onProgress?.({\n      loaded: this._loaded\n    });\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\nclass PDFNodeStreamFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    const headers = Object.fromEntries(stream.headers);\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        this._headersCapability.reject(error);\n        return;\n      }\n      this._headersCapability.resolve();\n      this._setReadableStream(response);\n      const responseHeaders = new Headers(this._readableStream.headers);\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = validateRangeRequestCapabilities({\n        responseHeaders,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = extractFilenameFromHeader(responseHeaders);\n    };\n    this._request = createRequest(this._url, headers, handleResponse);\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n      this._headersCapability.reject(reason);\n    });\n    this._request.end();\n  }\n}\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    const headers = Object.fromEntries(stream.headers);\n    headers.Range = `bytes=${start}-${end - 1}`;\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        return;\n      }\n      this._setReadableStream(response);\n    };\n    this._request = createRequest(this._url, headers, handleResponse);\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n    });\n    this._request.end();\n  }\n}\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    const fs = NodePackages.get(\"fs\");\n    fs.promises.lstat(this._url).then(stat => {\n      this._contentLength = stat.size;\n      this._setReadableStream(fs.createReadStream(this._url));\n      this._headersCapability.resolve();\n    }, error => {\n      if (error.code === \"ENOENT\") {\n        error = new MissingPDFException(`Missing PDF \"${this._url}\".`);\n      }\n      this._storedError = error;\n      this._headersCapability.reject(error);\n    });\n  }\n}\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    const fs = NodePackages.get(\"fs\");\n    this._setReadableStream(fs.createReadStream(this._url, {\n      start,\n      end: end - 1\n    }));\n  }\n}\n\n;// ./src/display/text_layer.js\n\n\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nclass TextLayer {\n  #capability = Promise.withResolvers();\n  #container = null;\n  #disableProcessItems = false;\n  #fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n  #lang = null;\n  #layoutTextParams = null;\n  #pageHeight = 0;\n  #pageWidth = 0;\n  #reader = null;\n  #rootContainer = null;\n  #rotation = 0;\n  #scale = 0;\n  #styleCache = Object.create(null);\n  #textContentItemsStr = [];\n  #textContentSource = null;\n  #textDivs = [];\n  #textDivProperties = new WeakMap();\n  #transform = null;\n  static #ascentCache = new Map();\n  static #canvasContexts = new Map();\n  static #canvasCtxFonts = new WeakMap();\n  static #minFontSize = null;\n  static #pendingTextLayers = new Set();\n  constructor({\n    textContentSource,\n    container,\n    viewport\n  }) {\n    if (textContentSource instanceof ReadableStream) {\n      this.#textContentSource = textContentSource;\n    } else if (typeof textContentSource === \"object\") {\n      this.#textContentSource = new ReadableStream({\n        start(controller) {\n          controller.enqueue(textContentSource);\n          controller.close();\n        }\n      });\n    } else {\n      throw new Error('No \"textContentSource\" parameter specified.');\n    }\n    this.#container = this.#rootContainer = container;\n    this.#scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n    this.#rotation = viewport.rotation;\n    this.#layoutTextParams = {\n      div: null,\n      properties: null,\n      ctx: null\n    };\n    const {\n      pageWidth,\n      pageHeight,\n      pageX,\n      pageY\n    } = viewport.rawDims;\n    this.#transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];\n    this.#pageWidth = pageWidth;\n    this.#pageHeight = pageHeight;\n    TextLayer.#ensureMinFontSizeComputed();\n    setLayerDimensions(container, viewport);\n    this.#capability.promise.finally(() => {\n      TextLayer.#pendingTextLayers.delete(this);\n      this.#layoutTextParams = null;\n      this.#styleCache = null;\n    }).catch(() => {});\n  }\n  static get fontFamilyMap() {\n    const {\n      isWindows,\n      isFirefox\n    } = util_FeatureTest.platform;\n    return shadow(this, \"fontFamilyMap\", new Map([[\"sans-serif\", `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`], [\"monospace\", `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`]]));\n  }\n  render() {\n    const pump = () => {\n      this.#reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          this.#capability.resolve();\n          return;\n        }\n        this.#lang ??= value.lang;\n        Object.assign(this.#styleCache, value.styles);\n        this.#processItems(value.items);\n        pump();\n      }, this.#capability.reject);\n    };\n    this.#reader = this.#textContentSource.getReader();\n    TextLayer.#pendingTextLayers.add(this);\n    pump();\n    return this.#capability.promise;\n  }\n  update({\n    viewport,\n    onBefore = null\n  }) {\n    const scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n    const rotation = viewport.rotation;\n    if (rotation !== this.#rotation) {\n      onBefore?.();\n      this.#rotation = rotation;\n      setLayerDimensions(this.#rootContainer, {\n        rotation\n      });\n    }\n    if (scale !== this.#scale) {\n      onBefore?.();\n      this.#scale = scale;\n      const params = {\n        div: null,\n        properties: null,\n        ctx: TextLayer.#getCtx(this.#lang)\n      };\n      for (const div of this.#textDivs) {\n        params.properties = this.#textDivProperties.get(div);\n        params.div = div;\n        this.#layout(params);\n      }\n    }\n  }\n  cancel() {\n    const abortEx = new AbortException(\"TextLayer task cancelled.\");\n    this.#reader?.cancel(abortEx).catch(() => {});\n    this.#reader = null;\n    this.#capability.reject(abortEx);\n  }\n  get textDivs() {\n    return this.#textDivs;\n  }\n  get textContentItemsStr() {\n    return this.#textContentItemsStr;\n  }\n  #processItems(items) {\n    if (this.#disableProcessItems) {\n      return;\n    }\n    this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n    const textDivs = this.#textDivs,\n      textContentItemsStr = this.#textContentItemsStr;\n    for (const item of items) {\n      if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n        warn(\"Ignoring additional textDivs for performance reasons.\");\n        this.#disableProcessItems = true;\n        return;\n      }\n      if (item.str === undefined) {\n        if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n          const parent = this.#container;\n          this.#container = document.createElement(\"span\");\n          this.#container.classList.add(\"markedContent\");\n          if (item.id !== null) {\n            this.#container.setAttribute(\"id\", `${item.id}`);\n          }\n          parent.append(this.#container);\n        } else if (item.type === \"endMarkedContent\") {\n          this.#container = this.#container.parentNode;\n        }\n        continue;\n      }\n      textContentItemsStr.push(item.str);\n      this.#appendText(item);\n    }\n  }\n  #appendText(geom) {\n    const textDiv = document.createElement(\"span\");\n    const textDivProperties = {\n      angle: 0,\n      canvasWidth: 0,\n      hasText: geom.str !== \"\",\n      hasEOL: geom.hasEOL,\n      fontSize: 0\n    };\n    this.#textDivs.push(textDiv);\n    const tx = Util.transform(this.#transform, geom.transform);\n    let angle = Math.atan2(tx[1], tx[0]);\n    const style = this.#styleCache[geom.fontName];\n    if (style.vertical) {\n      angle += Math.PI / 2;\n    }\n    let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n    fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n    const fontHeight = Math.hypot(tx[2], tx[3]);\n    const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, this.#lang);\n    let left, top;\n    if (angle === 0) {\n      left = tx[4];\n      top = tx[5] - fontAscent;\n    } else {\n      left = tx[4] + fontAscent * Math.sin(angle);\n      top = tx[5] - fontAscent * Math.cos(angle);\n    }\n    const scaleFactorStr = \"calc(var(--scale-factor)*\";\n    const divStyle = textDiv.style;\n    if (this.#container === this.#rootContainer) {\n      divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n      divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n    } else {\n      divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n      divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n    }\n    divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n    divStyle.fontFamily = fontFamily;\n    textDivProperties.fontSize = fontHeight;\n    textDiv.setAttribute(\"role\", \"presentation\");\n    textDiv.textContent = geom.str;\n    textDiv.dir = geom.dir;\n    if (this.#fontInspectorEnabled) {\n      textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n    }\n    if (angle !== 0) {\n      textDivProperties.angle = angle * (180 / Math.PI);\n    }\n    let shouldScaleText = false;\n    if (geom.str.length > 1) {\n      shouldScaleText = true;\n    } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n      const absScaleX = Math.abs(geom.transform[0]),\n        absScaleY = Math.abs(geom.transform[3]);\n      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n        shouldScaleText = true;\n      }\n    }\n    if (shouldScaleText) {\n      textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n    }\n    this.#textDivProperties.set(textDiv, textDivProperties);\n    this.#layoutTextParams.div = textDiv;\n    this.#layoutTextParams.properties = textDivProperties;\n    this.#layout(this.#layoutTextParams);\n    if (textDivProperties.hasText) {\n      this.#container.append(textDiv);\n    }\n    if (textDivProperties.hasEOL) {\n      const br = document.createElement(\"br\");\n      br.setAttribute(\"role\", \"presentation\");\n      this.#container.append(br);\n    }\n  }\n  #layout(params) {\n    const {\n      div,\n      properties,\n      ctx\n    } = params;\n    const {\n      style\n    } = div;\n    let transform = \"\";\n    if (TextLayer.#minFontSize > 1) {\n      transform = `scale(${1 / TextLayer.#minFontSize})`;\n    }\n    if (properties.canvasWidth !== 0 && properties.hasText) {\n      const {\n        fontFamily\n      } = style;\n      const {\n        canvasWidth,\n        fontSize\n      } = properties;\n      TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n      const {\n        width\n      } = ctx.measureText(div.textContent);\n      if (width > 0) {\n        transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n      }\n    }\n    if (properties.angle !== 0) {\n      transform = `rotate(${properties.angle}deg) ${transform}`;\n    }\n    if (transform.length > 0) {\n      style.transform = transform;\n    }\n  }\n  static cleanup() {\n    if (this.#pendingTextLayers.size > 0) {\n      return;\n    }\n    this.#ascentCache.clear();\n    for (const {\n      canvas\n    } of this.#canvasContexts.values()) {\n      canvas.remove();\n    }\n    this.#canvasContexts.clear();\n  }\n  static #getCtx(lang = null) {\n    let ctx = this.#canvasContexts.get(lang ||= \"\");\n    if (!ctx) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.className = \"hiddenCanvasElement\";\n      canvas.lang = lang;\n      document.body.append(canvas);\n      ctx = canvas.getContext(\"2d\", {\n        alpha: false,\n        willReadFrequently: true\n      });\n      this.#canvasContexts.set(lang, ctx);\n      this.#canvasCtxFonts.set(ctx, {\n        size: 0,\n        family: \"\"\n      });\n    }\n    return ctx;\n  }\n  static #ensureCtxFont(ctx, size, family) {\n    const cached = this.#canvasCtxFonts.get(ctx);\n    if (size === cached.size && family === cached.family) {\n      return;\n    }\n    ctx.font = `${size}px ${family}`;\n    cached.size = size;\n    cached.family = family;\n  }\n  static #ensureMinFontSizeComputed() {\n    if (this.#minFontSize !== null) {\n      return;\n    }\n    const div = document.createElement(\"div\");\n    div.style.opacity = 0;\n    div.style.lineHeight = 1;\n    div.style.fontSize = \"1px\";\n    div.style.position = \"absolute\";\n    div.textContent = \"X\";\n    document.body.append(div);\n    this.#minFontSize = div.getBoundingClientRect().height;\n    div.remove();\n  }\n  static #getAscent(fontFamily, lang) {\n    const cachedAscent = this.#ascentCache.get(fontFamily);\n    if (cachedAscent) {\n      return cachedAscent;\n    }\n    const ctx = this.#getCtx(lang);\n    ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n    this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n    const metrics = ctx.measureText(\"\");\n    let ascent = metrics.fontBoundingBoxAscent;\n    let descent = Math.abs(metrics.fontBoundingBoxDescent);\n    if (ascent) {\n      const ratio = ascent / (ascent + descent);\n      this.#ascentCache.set(fontFamily, ratio);\n      ctx.canvas.width = ctx.canvas.height = 0;\n      return ratio;\n    }\n    ctx.strokeStyle = \"red\";\n    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n    ctx.strokeText(\"g\", 0, 0);\n    let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n    descent = 0;\n    for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {\n      if (pixels[i] > 0) {\n        descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n        break;\n      }\n    }\n    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n    ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n    pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n    ascent = 0;\n    for (let i = 0, ii = pixels.length; i < ii; i += 4) {\n      if (pixels[i] > 0) {\n        ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n        break;\n      }\n    }\n    ctx.canvas.width = ctx.canvas.height = 0;\n    const ratio = ascent ? ascent / (ascent + descent) : DEFAULT_FONT_ASCENT;\n    this.#ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n}\n\n;// ./src/display/xfa_text.js\nclass XfaText {\n  static textContent(xfa) {\n    const items = [];\n    const output = {\n      items,\n      styles: Object.create(null)\n    };\n    function walk(node) {\n      if (!node) {\n        return;\n      }\n      let str = null;\n      const name = node.name;\n      if (name === \"#text\") {\n        str = node.value;\n      } else if (!XfaText.shouldBuildText(name)) {\n        return;\n      } else if (node?.attributes?.textContent) {\n        str = node.attributes.textContent;\n      } else if (node.value) {\n        str = node.value;\n      }\n      if (str !== null) {\n        items.push({\n          str\n        });\n      }\n      if (!node.children) {\n        return;\n      }\n      for (const child of node.children) {\n        walk(child);\n      }\n    }\n    walk(xfa);\n    return output;\n  }\n  static shouldBuildText(name) {\n    return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n  }\n}\n\n;// ./src/display/api.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nconst DELAYED_CLEANUP_TIMEOUT = 5000;\nconst DefaultCanvasFactory = isNodeJS ? NodeCanvasFactory : DOMCanvasFactory;\nconst DefaultCMapReaderFactory = isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory;\nconst DefaultFilterFactory = isNodeJS ? NodeFilterFactory : DOMFilterFactory;\nconst DefaultStandardFontDataFactory = isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory;\nfunction getDocument(src = {}) {\n  if (typeof src === \"string\" || src instanceof URL) {\n    src = {\n      url: src\n    };\n  } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n    src = {\n      data: src\n    };\n  }\n  const task = new PDFDocumentLoadingTask();\n  const {\n    docId\n  } = task;\n  const url = src.url ? getUrlProp(src.url) : null;\n  const data = src.data ? getDataProp(src.data) : null;\n  const httpHeaders = src.httpHeaders || null;\n  const withCredentials = src.withCredentials === true;\n  const password = src.password ?? null;\n  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n  let worker = src.worker instanceof PDFWorker ? src.worker : null;\n  const verbosity = src.verbosity;\n  const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n  const cMapUrl = typeof src.cMapUrl === \"string\" ? src.cMapUrl : null;\n  const cMapPacked = src.cMapPacked !== false;\n  const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;\n  const standardFontDataUrl = typeof src.standardFontDataUrl === \"string\" ? src.standardFontDataUrl : null;\n  const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;\n  const ignoreErrors = src.stopAtErrors !== true;\n  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n  const isEvalSupported = src.isEvalSupported !== false;\n  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n  const isChrome = typeof src.isChrome === \"boolean\" ? src.isChrome : !util_FeatureTest.platform.isFirefox && typeof window !== \"undefined\" && !!window?.chrome;\n  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n  const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n  const fontExtraProperties = src.fontExtraProperties === true;\n  const enableXfa = src.enableXfa === true;\n  const ownerDocument = src.ownerDocument || globalThis.document;\n  const disableRange = src.disableRange === true;\n  const disableStream = src.disableStream === true;\n  const disableAutoFetch = src.disableAutoFetch === true;\n  const pdfBug = src.pdfBug === true;\n  const CanvasFactory = src.CanvasFactory || DefaultCanvasFactory;\n  const FilterFactory = src.FilterFactory || DefaultFilterFactory;\n  const enableHWA = src.enableHWA === true;\n  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n  const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n  const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI);\n  if (src.canvasFactory) {\n    deprecated(\"`canvasFactory`-instance option, please use `CanvasFactory` instead.\");\n  }\n  if (src.filterFactory) {\n    deprecated(\"`filterFactory`-instance option, please use `FilterFactory` instead.\");\n  }\n  const styleElement = null;\n  setVerbosityLevel(verbosity);\n  const transportFactory = {\n    canvasFactory: new CanvasFactory({\n      ownerDocument,\n      enableHWA\n    }),\n    filterFactory: new FilterFactory({\n      docId,\n      ownerDocument\n    }),\n    cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n      baseUrl: cMapUrl,\n      isCompressed: cMapPacked\n    }),\n    standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n      baseUrl: standardFontDataUrl\n    })\n  };\n  if (!worker) {\n    const workerParams = {\n      verbosity,\n      port: GlobalWorkerOptions.workerPort\n    };\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n  const docParams = {\n    docId,\n    apiVersion: \"4.8.69\",\n    data,\n    password,\n    disableAutoFetch,\n    rangeChunkSize,\n    length,\n    docBaseUrl,\n    enableXfa,\n    evaluatorOptions: {\n      maxImageSize,\n      disableFontFace,\n      ignoreErrors,\n      isEvalSupported,\n      isOffscreenCanvasSupported,\n      isChrome,\n      canvasMaxAreaInBytes,\n      fontExtraProperties,\n      useSystemFonts,\n      cMapUrl: useWorkerFetch ? cMapUrl : null,\n      standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null\n    }\n  };\n  const transportParams = {\n    disableFontFace,\n    fontExtraProperties,\n    ownerDocument,\n    pdfBug,\n    styleElement,\n    loadingParams: {\n      disableAutoFetch,\n      enableXfa\n    }\n  };\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n    if (worker.destroyed) {\n      throw new Error(\"Worker was destroyed\");\n    }\n    const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [data.buffer] : null);\n    let networkStream;\n    if (rangeTransport) {\n      networkStream = new PDFDataTransportStream(rangeTransport, {\n        disableRange,\n        disableStream\n      });\n    } else if (!data) {\n      if (!url) {\n        throw new Error(\"getDocument - no `url` parameter provided.\");\n      }\n      let NetworkStream;\n      if (isNodeJS) {\n        const isFetchSupported = typeof fetch !== \"undefined\" && typeof Response !== \"undefined\" && \"body\" in Response.prototype;\n        NetworkStream = isFetchSupported && isValidFetchUrl(url) ? PDFFetchStream : PDFNodeStream;\n      } else {\n        NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : PDFNetworkStream;\n      }\n      networkStream = new NetworkStream({\n        url,\n        length,\n        httpHeaders,\n        withCredentials,\n        rangeChunkSize,\n        disableRange,\n        disableStream\n      });\n    }\n    return workerIdPromise.then(workerId => {\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n      if (worker.destroyed) {\n        throw new Error(\"Worker was destroyed\");\n      }\n      const messageHandler = new MessageHandler(docId, workerId, worker.port);\n      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  }).catch(task._capability.reject);\n  return task;\n}\nfunction getUrlProp(val) {\n  if (val instanceof URL) {\n    return val.href;\n  }\n  try {\n    return new URL(val, window.location).href;\n  } catch {\n    if (isNodeJS && typeof val === \"string\") {\n      return val;\n    }\n  }\n  throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n  if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n    throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n  }\n  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n    return val;\n  }\n  if (typeof val === \"string\") {\n    return stringToBytes(val);\n  }\n  if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n    return new Uint8Array(val);\n  }\n  throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nfunction isRefProxy(ref) {\n  return typeof ref === \"object\" && Number.isInteger(ref?.num) && ref.num >= 0 && Number.isInteger(ref?.gen) && ref.gen >= 0;\n}\nclass PDFDocumentLoadingTask {\n  static #docId = 0;\n  constructor() {\n    this._capability = Promise.withResolvers();\n    this._transport = null;\n    this._worker = null;\n    this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n    this.destroyed = false;\n    this.onPassword = null;\n    this.onProgress = null;\n  }\n  get promise() {\n    return this._capability.promise;\n  }\n  async destroy() {\n    this.destroyed = true;\n    try {\n      if (this._worker?.port) {\n        this._worker._pendingDestroy = true;\n      }\n      await this._transport?.destroy();\n    } catch (ex) {\n      if (this._worker?.port) {\n        delete this._worker._pendingDestroy;\n      }\n      throw ex;\n    }\n    this._transport = null;\n    if (this._worker) {\n      this._worker.destroy();\n      this._worker = null;\n    }\n  }\n}\nclass PDFDataRangeTransport {\n  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this.contentDispositionFilename = contentDispositionFilename;\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = Promise.withResolvers();\n  }\n  addRangeListener(listener) {\n    this._rangeListeners.push(listener);\n  }\n  addProgressListener(listener) {\n    this._progressListeners.push(listener);\n  }\n  addProgressiveReadListener(listener) {\n    this._progressiveReadListeners.push(listener);\n  }\n  addProgressiveDoneListener(listener) {\n    this._progressiveDoneListeners.push(listener);\n  }\n  onDataRange(begin, chunk) {\n    for (const listener of this._rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n  onDataProgress(loaded, total) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n  onDataProgressiveRead(chunk) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n  onDataProgressiveDone() {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n  transportReady() {\n    this._readyCapability.resolve();\n  }\n  requestDataRange(begin, end) {\n    unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n  }\n  abort() {}\n}\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n  }\n  get annotationStorage() {\n    return this._transport.annotationStorage;\n  }\n  get canvasFactory() {\n    return this._transport.canvasFactory;\n  }\n  get filterFactory() {\n    return this._transport.filterFactory;\n  }\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n  get fingerprints() {\n    return this._pdfInfo.fingerprints;\n  }\n  get isPureXfa() {\n    return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n  }\n  get allXfaHtml() {\n    return this._transport._htmlForXfa;\n  }\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n  getJSActions() {\n    return this._transport.getDocJSActions();\n  }\n  getOutline() {\n    return this._transport.getOutline();\n  }\n  getOptionalContentConfig({\n    intent = \"display\"\n  } = {}) {\n    const {\n      renderingIntent\n    } = this._transport.getRenderingIntent(intent);\n    return this._transport.getOptionalContentConfig(renderingIntent);\n  }\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n  getMarkInfo() {\n    return this._transport.getMarkInfo();\n  }\n  getData() {\n    return this._transport.getData();\n  }\n  saveDocument() {\n    return this._transport.saveDocument();\n  }\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n  cleanup(keepLoadedFonts = false) {\n    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n  }\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n  cachedPageNumber(ref) {\n    return this._transport.cachedPageNumber(ref);\n  }\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n  getFieldObjects() {\n    return this._transport.getFieldObjects();\n  }\n  hasJSActions() {\n    return this._transport.hasJSActions();\n  }\n  getCalculationOrderIds() {\n    return this._transport.getCalculationOrderIds();\n  }\n}\nclass PDFPageProxy {\n  #delayedCleanupTimeout = null;\n  #pendingCleanup = false;\n  constructor(pageIndex, pageInfo, transport, pdfBug = false) {\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._transport = transport;\n    this._stats = pdfBug ? new StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this._maybeCleanupAfterRender = false;\n    this._intentStates = new Map();\n    this.destroyed = false;\n  }\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n  get ref() {\n    return this._pageInfo.ref;\n  }\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n  get view() {\n    return this._pageInfo.view;\n  }\n  getViewport({\n    scale,\n    rotation = this.rotate,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.view,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n  getAnnotations({\n    intent = \"display\"\n  } = {}) {\n    const {\n      renderingIntent\n    } = this._transport.getRenderingIntent(intent);\n    return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n  }\n  getJSActions() {\n    return this._transport.getPageJSActions(this._pageIndex);\n  }\n  get filterFactory() {\n    return this._transport.filterFactory;\n  }\n  get isPureXfa() {\n    return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n  }\n  async getXfa() {\n    return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n  }\n  render({\n    canvasContext,\n    viewport,\n    intent = \"display\",\n    annotationMode = AnnotationMode.ENABLE,\n    transform = null,\n    background = null,\n    optionalContentConfigPromise = null,\n    annotationCanvasMap = null,\n    pageColors = null,\n    printAnnotationStorage = null,\n    isEditing = false\n  }) {\n    this._stats?.time(\"Overall\");\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n    const {\n      renderingIntent,\n      cacheKey\n    } = intentArgs;\n    this.#pendingCleanup = false;\n    this.#abortDelayedCleanup();\n    optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n    let intentState = this._intentStates.get(cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(cacheKey, intentState);\n    }\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n    const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = Promise.withResolvers();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n      this._stats?.time(\"Page Request\");\n      this._pumpOperatorList(intentArgs);\n    }\n    const complete = error => {\n      intentState.renderTasks.delete(internalRenderTask);\n      if (this._maybeCleanupAfterRender || intentPrint) {\n        this.#pendingCleanup = true;\n      }\n      this.#tryCleanup(!intentPrint);\n      if (error) {\n        internalRenderTask.capability.reject(error);\n        this._abortOperatorList({\n          intentState,\n          reason: error instanceof Error ? error : new Error(error)\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n      if (this._stats) {\n        this._stats.timeEnd(\"Rendering\");\n        this._stats.timeEnd(\"Overall\");\n        if (globalThis.Stats?.enabled) {\n          globalThis.Stats.add(this.pageNumber, this._stats);\n        }\n      }\n    };\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      params: {\n        canvasContext,\n        viewport,\n        transform,\n        background\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      annotationCanvasMap,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: this._transport.canvasFactory,\n      filterFactory: this._transport.filterFactory,\n      useRequestAnimationFrame: !intentPrint,\n      pdfBug: this._pdfBug,\n      pageColors\n    });\n    (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n      if (this.destroyed) {\n        complete();\n        return;\n      }\n      this._stats?.time(\"Rendering\");\n      if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n        throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` \" + \"and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n      }\n      internalRenderTask.initializeGraphics({\n        transparency,\n        optionalContentConfig\n      });\n      internalRenderTask.operatorListChanged();\n    }).catch(complete);\n    return renderTask;\n  }\n  getOperatorList({\n    intent = \"display\",\n    annotationMode = AnnotationMode.ENABLE,\n    printAnnotationStorage = null,\n    isEditing = false\n  } = {}) {\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n        intentState.renderTasks.delete(opListTask);\n      }\n    }\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n    let opListTask;\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = Promise.withResolvers();\n      (intentState.renderTasks ||= new Set()).add(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n      this._stats?.time(\"Page Request\");\n      this._pumpOperatorList(intentArgs);\n    }\n    return intentState.opListReadCapability.promise;\n  }\n  streamTextContent({\n    includeMarkedContent = false,\n    disableNormalization = false\n  } = {}) {\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n    return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n      pageIndex: this._pageIndex,\n      includeMarkedContent: includeMarkedContent === true,\n      disableNormalization: disableNormalization === true\n    }, {\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n      size(textContent) {\n        return textContent.items.length;\n      }\n    });\n  }\n  getTextContent(params = {}) {\n    if (this._transport._htmlForXfa) {\n      return this.getXfa().then(xfa => XfaText.textContent(xfa));\n    }\n    const readableStream = this.streamTextContent(params);\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n          textContent.lang ??= value.lang;\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null),\n        lang: null\n      };\n      pump();\n    });\n  }\n  getStructTree() {\n    return this._transport.getStructTree(this._pageIndex);\n  }\n  _destroy() {\n    this.destroyed = true;\n    const waitOn = [];\n    for (const intentState of this._intentStates.values()) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error(\"Page was destroyed.\"),\n        force: true\n      });\n      if (intentState.opListReadCapability) {\n        continue;\n      }\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n    this.objs.clear();\n    this.#pendingCleanup = false;\n    this.#abortDelayedCleanup();\n    return Promise.all(waitOn);\n  }\n  cleanup(resetStats = false) {\n    this.#pendingCleanup = true;\n    const success = this.#tryCleanup(false);\n    if (resetStats && success) {\n      this._stats &&= new StatTimer();\n    }\n    return success;\n  }\n  #tryCleanup(delayed = false) {\n    this.#abortDelayedCleanup();\n    if (!this.#pendingCleanup || this.destroyed) {\n      return false;\n    }\n    if (delayed) {\n      this.#delayedCleanupTimeout = setTimeout(() => {\n        this.#delayedCleanupTimeout = null;\n        this.#tryCleanup(false);\n      }, DELAYED_CLEANUP_TIMEOUT);\n      return false;\n    }\n    for (const {\n      renderTasks,\n      operatorList\n    } of this._intentStates.values()) {\n      if (renderTasks.size > 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n    this._intentStates.clear();\n    this.objs.clear();\n    this.#pendingCleanup = false;\n    return true;\n  }\n  #abortDelayedCleanup() {\n    if (this.#delayedCleanupTimeout) {\n      clearTimeout(this.#delayedCleanupTimeout);\n      this.#delayedCleanupTimeout = null;\n    }\n  }\n  _startRenderPage(transparency, cacheKey) {\n    const intentState = this._intentStates.get(cacheKey);\n    if (!intentState) {\n      return;\n    }\n    this._stats?.timeEnd(\"Page Request\");\n    intentState.displayReadyCapability?.resolve(transparency);\n  }\n  _renderPageChunk(operatorListChunk, intentState) {\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n    for (const internalRenderTask of intentState.renderTasks) {\n      internalRenderTask.operatorListChanged();\n    }\n    if (operatorListChunk.lastChunk) {\n      this.#tryCleanup(true);\n    }\n  }\n  _pumpOperatorList({\n    renderingIntent,\n    cacheKey,\n    annotationStorageSerializable,\n    modifiedIds\n  }) {\n    const {\n      map,\n      transfer\n    } = annotationStorageSerializable;\n    const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n      pageIndex: this._pageIndex,\n      intent: renderingIntent,\n      cacheKey,\n      annotationStorage: map,\n      modifiedIds\n    }, transfer);\n    const reader = readableStream.getReader();\n    const intentState = this._intentStates.get(cacheKey);\n    intentState.streamReader = reader;\n    const pump = () => {\n      reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          intentState.streamReader = null;\n          return;\n        }\n        if (this._transport.destroyed) {\n          return;\n        }\n        this._renderPageChunk(value, intentState);\n        pump();\n      }, reason => {\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n          return;\n        }\n        if (intentState.operatorList) {\n          intentState.operatorList.lastChunk = true;\n          for (const internalRenderTask of intentState.renderTasks) {\n            internalRenderTask.operatorListChanged();\n          }\n          this.#tryCleanup(true);\n        }\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(reason);\n        } else if (intentState.opListReadCapability) {\n          intentState.opListReadCapability.reject(reason);\n        } else {\n          throw reason;\n        }\n      });\n    };\n    pump();\n  }\n  _abortOperatorList({\n    intentState,\n    reason,\n    force = false\n  }) {\n    if (!intentState.streamReader) {\n      return;\n    }\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n    if (!force) {\n      if (intentState.renderTasks.size > 0) {\n        return;\n      }\n      if (reason instanceof RenderingCancelledException) {\n        let delay = RENDERING_CANCELLED_TIMEOUT;\n        if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n          delay += reason.extraDelay;\n        }\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          intentState.streamReaderCancelTimeout = null;\n          this._abortOperatorList({\n            intentState,\n            reason,\n            force: true\n          });\n        }, delay);\n        return;\n      }\n    }\n    intentState.streamReader.cancel(new AbortException(reason.message)).catch(() => {});\n    intentState.streamReader = null;\n    if (this._transport.destroyed) {\n      return;\n    }\n    for (const [curCacheKey, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(curCacheKey);\n        break;\n      }\n    }\n    this.cleanup();\n  }\n  get stats() {\n    return this._stats;\n  }\n}\nclass LoopbackPort {\n  #listeners = new Map();\n  #deferred = Promise.resolve();\n  postMessage(obj, transfer) {\n    const event = {\n      data: structuredClone(obj, transfer ? {\n        transfer\n      } : null)\n    };\n    this.#deferred.then(() => {\n      for (const [listener] of this.#listeners) {\n        listener.call(this, event);\n      }\n    });\n  }\n  addEventListener(name, listener, options = null) {\n    let rmAbort = null;\n    if (options?.signal instanceof AbortSignal) {\n      const {\n        signal\n      } = options;\n      if (signal.aborted) {\n        warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n        return;\n      }\n      const onAbort = () => this.removeEventListener(name, listener);\n      rmAbort = () => signal.removeEventListener(\"abort\", onAbort);\n      signal.addEventListener(\"abort\", onAbort);\n    }\n    this.#listeners.set(listener, rmAbort);\n  }\n  removeEventListener(name, listener) {\n    const rmAbort = this.#listeners.get(listener);\n    rmAbort?.();\n    this.#listeners.delete(listener);\n  }\n  terminate() {\n    for (const [, rmAbort] of this.#listeners) {\n      rmAbort?.();\n    }\n    this.#listeners.clear();\n  }\n}\nclass PDFWorker {\n  static #fakeWorkerId = 0;\n  static #isWorkerDisabled = false;\n  static #workerPorts;\n  static {\n    if (isNodeJS) {\n      this.#isWorkerDisabled = true;\n      GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n    }\n    this._isSameOrigin = (baseUrl, otherUrl) => {\n      let base;\n      try {\n        base = new URL(baseUrl);\n        if (!base.origin || base.origin === \"null\") {\n          return false;\n        }\n      } catch {\n        return false;\n      }\n      const other = new URL(otherUrl, base);\n      return base.origin === other.origin;\n    };\n    this._createCDNWrapper = url => {\n      const wrapper = `await import(\"${url}\");`;\n      return URL.createObjectURL(new Blob([wrapper], {\n        type: \"text/javascript\"\n      }));\n    };\n  }\n  constructor({\n    name = null,\n    port = null,\n    verbosity = getVerbosityLevel()\n  } = {}) {\n    this.name = name;\n    this.destroyed = false;\n    this.verbosity = verbosity;\n    this._readyCapability = Promise.withResolvers();\n    this._port = null;\n    this._webWorker = null;\n    this._messageHandler = null;\n    if (port) {\n      if (PDFWorker.#workerPorts?.has(port)) {\n        throw new Error(\"Cannot use more than one PDFWorker per port.\");\n      }\n      (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);\n      this._initializeFromPort(port);\n      return;\n    }\n    this._initialize();\n  }\n  get promise() {\n    if (isNodeJS) {\n      return Promise.all([NodePackages.promise, this._readyCapability.promise]);\n    }\n    return this._readyCapability.promise;\n  }\n  #resolve() {\n    this._readyCapability.resolve();\n    this._messageHandler.send(\"configure\", {\n      verbosity: this.verbosity\n    });\n  }\n  get port() {\n    return this._port;\n  }\n  get messageHandler() {\n    return this._messageHandler;\n  }\n  _initializeFromPort(port) {\n    this._port = port;\n    this._messageHandler = new MessageHandler(\"main\", \"worker\", port);\n    this._messageHandler.on(\"ready\", function () {});\n    this.#resolve();\n  }\n  _initialize() {\n    if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {\n      this._setupFakeWorker();\n      return;\n    }\n    let {\n      workerSrc\n    } = PDFWorker;\n    try {\n      if (!PDFWorker._isSameOrigin(window.location.href, workerSrc)) {\n        workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n      }\n      const worker = new Worker(workerSrc, {\n        type: \"module\"\n      });\n      const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n      const terminateEarly = () => {\n        ac.abort();\n        messageHandler.destroy();\n        worker.terminate();\n        if (this.destroyed) {\n          this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n        } else {\n          this._setupFakeWorker();\n        }\n      };\n      const ac = new AbortController();\n      worker.addEventListener(\"error\", () => {\n        if (!this._webWorker) {\n          terminateEarly();\n        }\n      }, {\n        signal: ac.signal\n      });\n      messageHandler.on(\"test\", data => {\n        ac.abort();\n        if (this.destroyed || !data) {\n          terminateEarly();\n          return;\n        }\n        this._messageHandler = messageHandler;\n        this._port = worker;\n        this._webWorker = worker;\n        this.#resolve();\n      });\n      messageHandler.on(\"ready\", data => {\n        ac.abort();\n        if (this.destroyed) {\n          terminateEarly();\n          return;\n        }\n        try {\n          sendTest();\n        } catch {\n          this._setupFakeWorker();\n        }\n      });\n      const sendTest = () => {\n        const testObj = new Uint8Array();\n        messageHandler.send(\"test\", testObj, [testObj.buffer]);\n      };\n      sendTest();\n      return;\n    } catch {\n      info(\"The worker has been disabled.\");\n    }\n    this._setupFakeWorker();\n  }\n  _setupFakeWorker() {\n    if (!PDFWorker.#isWorkerDisabled) {\n      warn(\"Setting up fake worker.\");\n      PDFWorker.#isWorkerDisabled = true;\n    }\n    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {\n      if (this.destroyed) {\n        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n        return;\n      }\n      const port = new LoopbackPort();\n      this._port = port;\n      const id = `fake${PDFWorker.#fakeWorkerId++}`;\n      const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n      WorkerMessageHandler.setup(workerHandler, port);\n      this._messageHandler = new MessageHandler(id, id + \"_worker\", port);\n      this.#resolve();\n    }).catch(reason => {\n      this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n    });\n  }\n  destroy() {\n    this.destroyed = true;\n    if (this._webWorker) {\n      this._webWorker.terminate();\n      this._webWorker = null;\n    }\n    PDFWorker.#workerPorts?.delete(this._port);\n    this._port = null;\n    if (this._messageHandler) {\n      this._messageHandler.destroy();\n      this._messageHandler = null;\n    }\n  }\n  static fromPort(params) {\n    if (!params?.port) {\n      throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n    }\n    const cachedPort = this.#workerPorts?.get(params.port);\n    if (cachedPort) {\n      if (cachedPort._pendingDestroy) {\n        throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n      }\n      return cachedPort;\n    }\n    return new PDFWorker(params);\n  }\n  static get workerSrc() {\n    if (GlobalWorkerOptions.workerSrc) {\n      return GlobalWorkerOptions.workerSrc;\n    }\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n  static get #mainThreadWorkerMessageHandler() {\n    try {\n      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch {\n      return null;\n    }\n  }\n  static get _setupFakeWorkerGlobal() {\n    const loader = async () => {\n      if (this.#mainThreadWorkerMessageHandler) {\n        return this.#mainThreadWorkerMessageHandler;\n      }\n      const worker = await import(/*webpackIgnore: true*/this.workerSrc);\n      return worker.WorkerMessageHandler;\n    };\n    return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n  }\n}\nclass WorkerTransport {\n  #methodPromises = new Map();\n  #pageCache = new Map();\n  #pagePromises = new Map();\n  #pageRefCache = new Map();\n  #passwordCapability = null;\n  constructor(messageHandler, loadingTask, networkStream, params, factory) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new FontLoader({\n      ownerDocument: params.ownerDocument,\n      styleElement: params.styleElement\n    });\n    this.loadingParams = params.loadingParams;\n    this._params = params;\n    this.canvasFactory = factory.canvasFactory;\n    this.filterFactory = factory.filterFactory;\n    this.cMapReaderFactory = factory.cMapReaderFactory;\n    this.standardFontDataFactory = factory.standardFontDataFactory;\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.downloadInfoCapability = Promise.withResolvers();\n    this.setupMessageHandler();\n  }\n  #cacheSimpleMethod(name, data = null) {\n    const cachedPromise = this.#methodPromises.get(name);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(name, data);\n    this.#methodPromises.set(name, promise);\n    return promise;\n  }\n  get annotationStorage() {\n    return shadow(this, \"annotationStorage\", new AnnotationStorage());\n  }\n  getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n    let renderingIntent = RenderingIntentFlag.DISPLAY;\n    let annotationStorageSerializable = SerializableEmpty;\n    switch (intent) {\n      case \"any\":\n        renderingIntent = RenderingIntentFlag.ANY;\n        break;\n      case \"display\":\n        break;\n      case \"print\":\n        renderingIntent = RenderingIntentFlag.PRINT;\n        break;\n      default:\n        warn(`getRenderingIntent - invalid intent: ${intent}`);\n    }\n    const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n    switch (annotationMode) {\n      case AnnotationMode.DISABLE:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n        break;\n      case AnnotationMode.ENABLE:\n        break;\n      case AnnotationMode.ENABLE_FORMS:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n        break;\n      case AnnotationMode.ENABLE_STORAGE:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n        annotationStorageSerializable = annotationStorage.serializable;\n        break;\n      default:\n        warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n    }\n    if (isEditing) {\n      renderingIntent += RenderingIntentFlag.IS_EDITING;\n    }\n    if (isOpList) {\n      renderingIntent += RenderingIntentFlag.OPLIST;\n    }\n    const {\n      ids: modifiedIds,\n      hash: modifiedIdsHash\n    } = annotationStorage.modifiedIds;\n    const cacheKeyBuf = [renderingIntent, annotationStorageSerializable.hash, modifiedIdsHash];\n    return {\n      renderingIntent,\n      cacheKey: cacheKeyBuf.join(\"_\"),\n      annotationStorageSerializable,\n      modifiedIds\n    };\n  }\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n    this.destroyed = true;\n    this.destroyCapability = Promise.withResolvers();\n    this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n    const waitOn = [];\n    for (const page of this.#pageCache.values()) {\n      waitOn.push(page._destroy());\n    }\n    this.#pageCache.clear();\n    this.#pagePromises.clear();\n    this.#pageRefCache.clear();\n    if (this.hasOwnProperty(\"annotationStorage\")) {\n      this.annotationStorage.resetModified();\n    }\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n    waitOn.push(terminated);\n    Promise.all(waitOn).then(() => {\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n      this.#methodPromises.clear();\n      this.filterFactory.destroy();\n      TextLayer.cleanup();\n      this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n      if (this.messageHandler) {\n        this.messageHandler.destroy();\n        this.messageHandler = null;\n      }\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n  setupMessageHandler() {\n    const {\n      messageHandler,\n      loadingTask\n    } = this;\n    messageHandler.on(\"GetReader\", (data, sink) => {\n      assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n      this._fullReader = this._networkStream.getFullReader();\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total\n        };\n      };\n      sink.onPull = () => {\n        this._fullReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n          assert(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"ReaderHeadersReady\", async data => {\n      await this._fullReader.headersReady;\n      const {\n        isStreamingSupported,\n        isRangeSupported,\n        contentLength\n      } = this._fullReader;\n      if (!isStreamingSupported || !isRangeSupported) {\n        if (this._lastProgress) {\n          loadingTask.onProgress?.(this._lastProgress);\n        }\n        this._fullReader.onProgress = evt => {\n          loadingTask.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.total\n          });\n        };\n      }\n      return {\n        isStreamingSupported,\n        isRangeSupported,\n        contentLength\n      };\n    });\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\n      assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n      sink.onPull = () => {\n        rangeReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n          assert(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"GetDoc\", ({\n      pdfInfo\n    }) => {\n      this._numPages = pdfInfo.numPages;\n      this._htmlForXfa = pdfInfo.htmlForXfa;\n      delete pdfInfo.htmlForXfa;\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n    messageHandler.on(\"DocException\", function (ex) {\n      let reason;\n      switch (ex.name) {\n        case \"PasswordException\":\n          reason = new PasswordException(ex.message, ex.code);\n          break;\n        case \"InvalidPDFException\":\n          reason = new InvalidPDFException(ex.message);\n          break;\n        case \"MissingPDFException\":\n          reason = new MissingPDFException(ex.message);\n          break;\n        case \"UnexpectedResponseException\":\n          reason = new UnexpectedResponseException(ex.message, ex.status);\n          break;\n        case \"UnknownErrorException\":\n          reason = new UnknownErrorException(ex.message, ex.details);\n          break;\n        default:\n          unreachable(\"DocException - expected a valid Error.\");\n      }\n      loadingTask._capability.reject(reason);\n    });\n    messageHandler.on(\"PasswordRequest\", exception => {\n      this.#passwordCapability = Promise.withResolvers();\n      if (loadingTask.onPassword) {\n        const updatePassword = password => {\n          if (password instanceof Error) {\n            this.#passwordCapability.reject(password);\n          } else {\n            this.#passwordCapability.resolve({\n              password\n            });\n          }\n        };\n        try {\n          loadingTask.onPassword(updatePassword, exception.code);\n        } catch (ex) {\n          this.#passwordCapability.reject(ex);\n        }\n      } else {\n        this.#passwordCapability.reject(new PasswordException(exception.message, exception.code));\n      }\n      return this.#passwordCapability.promise;\n    });\n    messageHandler.on(\"DataLoaded\", data => {\n      loadingTask.onProgress?.({\n        loaded: data.length,\n        total: data.length\n      });\n      this.downloadInfoCapability.resolve(data);\n    });\n    messageHandler.on(\"StartRenderPage\", data => {\n      if (this.destroyed) {\n        return;\n      }\n      const page = this.#pageCache.get(data.pageIndex);\n      page._startRenderPage(data.transparency, data.cacheKey);\n    });\n    messageHandler.on(\"commonobj\", ([id, type, exportedData]) => {\n      if (this.destroyed) {\n        return null;\n      }\n      if (this.commonObjs.has(id)) {\n        return null;\n      }\n      switch (type) {\n        case \"Font\":\n          const {\n            disableFontFace,\n            fontExtraProperties,\n            pdfBug\n          } = this._params;\n          if (\"error\" in exportedData) {\n            const exportedError = exportedData.error;\n            warn(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n          const inspectFont = pdfBug && globalThis.FontInspector?.enabled ? (font, url) => globalThis.FontInspector.fontAdded(font, url) : null;\n          const font = new FontFaceObject(exportedData, {\n            disableFontFace,\n            inspectFont\n          });\n          this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise(\"FontFallback\", {\n            id\n          })).finally(() => {\n            if (!fontExtraProperties && font.data) {\n              font.data = null;\n            }\n            this.commonObjs.resolve(id, font);\n          });\n          break;\n        case \"CopyLocalImage\":\n          const {\n            imageRef\n          } = exportedData;\n          assert(imageRef, \"The imageRef must be defined.\");\n          for (const pageProxy of this.#pageCache.values()) {\n            for (const [, data] of pageProxy.objs) {\n              if (data?.ref !== imageRef) {\n                continue;\n              }\n              if (!data.dataLen) {\n                return null;\n              }\n              this.commonObjs.resolve(id, structuredClone(data));\n              return data.dataLen;\n            }\n          }\n          break;\n        case \"FontPath\":\n        case \"Image\":\n        case \"Pattern\":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n      return null;\n    });\n    messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n      if (this.destroyed) {\n        return;\n      }\n      const pageProxy = this.#pageCache.get(pageIndex);\n      if (pageProxy.objs.has(id)) {\n        return;\n      }\n      if (pageProxy._intentStates.size === 0) {\n        imageData?.bitmap?.close();\n        return;\n      }\n      switch (type) {\n        case \"Image\":\n          pageProxy.objs.resolve(id, imageData);\n          if (imageData?.dataLen > MAX_IMAGE_SIZE_TO_CACHE) {\n            pageProxy._maybeCleanupAfterRender = true;\n          }\n          break;\n        case \"Pattern\":\n          pageProxy.objs.resolve(id, imageData);\n          break;\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n    });\n    messageHandler.on(\"DocProgress\", data => {\n      if (this.destroyed) {\n        return;\n      }\n      loadingTask.onProgress?.({\n        loaded: data.loaded,\n        total: data.total\n      });\n    });\n    messageHandler.on(\"FetchBuiltInCMap\", async data => {\n      if (this.destroyed) {\n        throw new Error(\"Worker was destroyed.\");\n      }\n      if (!this.cMapReaderFactory) {\n        throw new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\");\n      }\n      return this.cMapReaderFactory.fetch(data);\n    });\n    messageHandler.on(\"FetchStandardFontData\", async data => {\n      if (this.destroyed) {\n        throw new Error(\"Worker was destroyed.\");\n      }\n      if (!this.standardFontDataFactory) {\n        throw new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\");\n      }\n      return this.standardFontDataFactory.fetch(data);\n    });\n  }\n  getData() {\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\n  }\n  saveDocument() {\n    if (this.annotationStorage.size <= 0) {\n      warn(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n    }\n    const {\n      map,\n      transfer\n    } = this.annotationStorage.serializable;\n    return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n      isPureXfa: !!this._htmlForXfa,\n      numPages: this._numPages,\n      annotationStorage: map,\n      filename: this._fullReader?.filename ?? null\n    }, transfer).finally(() => {\n      this.annotationStorage.resetModified();\n    });\n  }\n  getPage(pageNumber) {\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n      return Promise.reject(new Error(\"Invalid page request.\"));\n    }\n    const pageIndex = pageNumber - 1,\n      cachedPromise = this.#pagePromises.get(pageIndex);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n      pageIndex\n    }).then(pageInfo => {\n      if (this.destroyed) {\n        throw new Error(\"Transport destroyed\");\n      }\n      if (pageInfo.refStr) {\n        this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n      }\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n      this.#pageCache.set(pageIndex, page);\n      return page;\n    });\n    this.#pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n  getPageIndex(ref) {\n    if (!isRefProxy(ref)) {\n      return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n      num: ref.num,\n      gen: ref.gen\n    });\n  }\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n      pageIndex,\n      intent\n    });\n  }\n  getFieldObjects() {\n    return this.#cacheSimpleMethod(\"GetFieldObjects\");\n  }\n  hasJSActions() {\n    return this.#cacheSimpleMethod(\"HasJSActions\");\n  }\n  getCalculationOrderIds() {\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n  }\n  getDestinations() {\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n  }\n  getDestination(id) {\n    if (typeof id !== \"string\") {\n      return Promise.reject(new Error(\"Invalid destination request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\n      id\n    });\n  }\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n  }\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n  }\n  getPageMode() {\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n  }\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n  }\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n  }\n  getAttachments() {\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n  }\n  getDocJSActions() {\n    return this.#cacheSimpleMethod(\"GetDocJSActions\");\n  }\n  getPageJSActions(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n      pageIndex\n    });\n  }\n  getStructTree(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n      pageIndex\n    });\n  }\n  getOutline() {\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n  }\n  getOptionalContentConfig(renderingIntent) {\n    return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then(data => new OptionalContentConfig(data, renderingIntent));\n  }\n  getPermissions() {\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n  }\n  getMetadata() {\n    const name = \"GetMetadata\",\n      cachedPromise = this.#methodPromises.get(name);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(name, null).then(results => ({\n      info: results[0],\n      metadata: results[1] ? new Metadata(results[1]) : null,\n      contentDispositionFilename: this._fullReader?.filename ?? null,\n      contentLength: this._fullReader?.contentLength ?? null\n    }));\n    this.#methodPromises.set(name, promise);\n    return promise;\n  }\n  getMarkInfo() {\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n  }\n  async startCleanup(keepLoadedFonts = false) {\n    if (this.destroyed) {\n      return;\n    }\n    await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n    for (const page of this.#pageCache.values()) {\n      const cleanupSuccessful = page.cleanup();\n      if (!cleanupSuccessful) {\n        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n      }\n    }\n    this.commonObjs.clear();\n    if (!keepLoadedFonts) {\n      this.fontLoader.clear();\n    }\n    this.#methodPromises.clear();\n    this.filterFactory.destroy(true);\n    TextLayer.cleanup();\n  }\n  cachedPageNumber(ref) {\n    if (!isRefProxy(ref)) {\n      return null;\n    }\n    const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n    return this.#pageRefCache.get(refStr) ?? null;\n  }\n}\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n  #objs = Object.create(null);\n  #ensureObj(objId) {\n    return this.#objs[objId] ||= {\n      ...Promise.withResolvers(),\n      data: INITIAL_DATA\n    };\n  }\n  get(objId, callback = null) {\n    if (callback) {\n      const obj = this.#ensureObj(objId);\n      obj.promise.then(() => callback(obj.data));\n      return null;\n    }\n    const obj = this.#objs[objId];\n    if (!obj || obj.data === INITIAL_DATA) {\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n    }\n    return obj.data;\n  }\n  has(objId) {\n    const obj = this.#objs[objId];\n    return !!obj && obj.data !== INITIAL_DATA;\n  }\n  resolve(objId, data = null) {\n    const obj = this.#ensureObj(objId);\n    obj.data = data;\n    obj.resolve();\n  }\n  clear() {\n    for (const objId in this.#objs) {\n      const {\n        data\n      } = this.#objs[objId];\n      data?.bitmap?.close();\n    }\n    this.#objs = Object.create(null);\n  }\n  *[Symbol.iterator]() {\n    for (const objId in this.#objs) {\n      const {\n        data\n      } = this.#objs[objId];\n      if (data === INITIAL_DATA) {\n        continue;\n      }\n      yield [objId, data];\n    }\n  }\n}\nclass RenderTask {\n  #internalRenderTask = null;\n  constructor(internalRenderTask) {\n    this.#internalRenderTask = internalRenderTask;\n    this.onContinue = null;\n  }\n  get promise() {\n    return this.#internalRenderTask.capability.promise;\n  }\n  cancel(extraDelay = 0) {\n    this.#internalRenderTask.cancel(null, extraDelay);\n  }\n  get separateAnnots() {\n    const {\n      separateAnnots\n    } = this.#internalRenderTask.operatorList;\n    if (!separateAnnots) {\n      return false;\n    }\n    const {\n      annotationCanvasMap\n    } = this.#internalRenderTask;\n    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n  }\n}\nclass InternalRenderTask {\n  #rAF = null;\n  static #canvasInUse = new WeakSet();\n  constructor({\n    callback,\n    params,\n    objs,\n    commonObjs,\n    annotationCanvasMap,\n    operatorList,\n    pageIndex,\n    canvasFactory,\n    filterFactory,\n    useRequestAnimationFrame = false,\n    pdfBug = false,\n    pageColors = null\n  }) {\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this._pageIndex = pageIndex;\n    this.canvasFactory = canvasFactory;\n    this.filterFactory = filterFactory;\n    this._pdfBug = pdfBug;\n    this.pageColors = pageColors;\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n    this.cancelled = false;\n    this.capability = Promise.withResolvers();\n    this.task = new RenderTask(this);\n    this._cancelBound = this.cancel.bind(this);\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n    this._canvas = params.canvasContext.canvas;\n  }\n  get completed() {\n    return this.capability.promise.catch(function () {});\n  }\n  initializeGraphics({\n    transparency = false,\n    optionalContentConfig\n  }) {\n    if (this.cancelled) {\n      return;\n    }\n    if (this._canvas) {\n      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n        throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n      }\n      InternalRenderTask.#canvasInUse.add(this._canvas);\n    }\n    if (this._pdfBug && globalThis.StepperManager?.enabled) {\n      this.stepper = globalThis.StepperManager.create(this._pageIndex);\n      this.stepper.init(this.operatorList);\n      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n    }\n    const {\n      canvasContext,\n      viewport,\n      transform,\n      background\n    } = this.params;\n    this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n      optionalContentConfig\n    }, this.annotationCanvasMap, this.pageColors);\n    this.gfx.beginDrawing({\n      transform,\n      viewport,\n      transparency,\n      background\n    });\n    this.operatorListIdx = 0;\n    this.graphicsReady = true;\n    this.graphicsReadyCallback?.();\n  }\n  cancel(error = null, extraDelay = 0) {\n    this.running = false;\n    this.cancelled = true;\n    this.gfx?.endDrawing();\n    if (this.#rAF) {\n      window.cancelAnimationFrame(this.#rAF);\n      this.#rAF = null;\n    }\n    InternalRenderTask.#canvasInUse.delete(this._canvas);\n    this.callback(error || new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));\n  }\n  operatorListChanged() {\n    if (!this.graphicsReady) {\n      this.graphicsReadyCallback ||= this._continueBound;\n      return;\n    }\n    this.stepper?.updateOperatorList(this.operatorList);\n    if (this.running) {\n      return;\n    }\n    this._continue();\n  }\n  _continue() {\n    this.running = true;\n    if (this.cancelled) {\n      return;\n    }\n    if (this.task.onContinue) {\n      this.task.onContinue(this._scheduleNextBound);\n    } else {\n      this._scheduleNext();\n    }\n  }\n  _scheduleNext() {\n    if (this._useRequestAnimationFrame) {\n      this.#rAF = window.requestAnimationFrame(() => {\n        this.#rAF = null;\n        this._nextBound().catch(this._cancelBound);\n      });\n    } else {\n      Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n    }\n  }\n  async _next() {\n    if (this.cancelled) {\n      return;\n    }\n    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n    if (this.operatorListIdx === this.operatorList.argsArray.length) {\n      this.running = false;\n      if (this.operatorList.lastChunk) {\n        this.gfx.endDrawing();\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        this.callback();\n      }\n    }\n  }\n}\nconst version = \"4.8.69\";\nconst build = \"3634dab10\";\n\n;// ./src/shared/scripting_utils.js\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n  return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n  static CMYK_G([c, y, m, k]) {\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n  static G_CMYK([g]) {\n    return [\"CMYK\", 0, 0, 0, 1 - g];\n  }\n  static G_RGB([g]) {\n    return [\"RGB\", g, g, g];\n  }\n  static G_rgb([g]) {\n    g = scaleAndClamp(g);\n    return [g, g, g];\n  }\n  static G_HTML([g]) {\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n  static RGB_G([r, g, b]) {\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n  static RGB_rgb(color) {\n    return color.map(scaleAndClamp);\n  }\n  static RGB_HTML(color) {\n    return `#${color.map(makeColorComp).join(\"\")}`;\n  }\n  static T_HTML() {\n    return \"#00000000\";\n  }\n  static T_rgb() {\n    return [null];\n  }\n  static CMYK_RGB([c, y, m, k]) {\n    return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n  }\n  static CMYK_rgb([c, y, m, k]) {\n    return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];\n  }\n  static CMYK_HTML(components) {\n    const rgb = this.CMYK_RGB(components).slice(1);\n    return this.RGB_HTML(rgb);\n  }\n  static RGB_CMYK([r, g, b]) {\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return [\"CMYK\", c, m, y, k];\n  }\n}\n\n;// ./src/display/svg_factory.js\n\n\nclass BaseSVGFactory {\n  create(width, height, skipDimensions = false) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid SVG dimensions\");\n    }\n    const svg = this._createSVG(\"svg:svg\");\n    svg.setAttribute(\"version\", \"1.1\");\n    if (!skipDimensions) {\n      svg.setAttribute(\"width\", `${width}px`);\n      svg.setAttribute(\"height\", `${height}px`);\n    }\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    return svg;\n  }\n  createElement(type) {\n    if (typeof type !== \"string\") {\n      throw new Error(\"Invalid SVG element type\");\n    }\n    return this._createSVG(type);\n  }\n  _createSVG(type) {\n    unreachable(\"Abstract method `_createSVG` called.\");\n  }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n  _createSVG(type) {\n    return document.createElementNS(SVG_NS, type);\n  }\n}\n\n;// ./src/display/xfa_layer.js\n\nclass XfaLayer {\n  static setupStorage(html, id, element, storage, intent) {\n    const storedData = storage.getValue(id, {\n      value: null\n    });\n    switch (element.name) {\n      case \"textarea\":\n        if (storedData.value !== null) {\n          html.textContent = storedData.value;\n        }\n        if (intent === \"print\") {\n          break;\n        }\n        html.addEventListener(\"input\", event => {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n        break;\n      case \"input\":\n        if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n          if (storedData.value === element.attributes.xfaOn) {\n            html.setAttribute(\"checked\", true);\n          } else if (storedData.value === element.attributes.xfaOff) {\n            html.removeAttribute(\"checked\");\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"change\", event => {\n            storage.setValue(id, {\n              value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n            });\n          });\n        } else {\n          if (storedData.value !== null) {\n            html.setAttribute(\"value\", storedData.value);\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"input\", event => {\n            storage.setValue(id, {\n              value: event.target.value\n            });\n          });\n        }\n        break;\n      case \"select\":\n        if (storedData.value !== null) {\n          html.setAttribute(\"value\", storedData.value);\n          for (const option of element.children) {\n            if (option.attributes.value === storedData.value) {\n              option.attributes.selected = true;\n            } else if (option.attributes.hasOwnProperty(\"selected\")) {\n              delete option.attributes.selected;\n            }\n          }\n        }\n        html.addEventListener(\"input\", event => {\n          const options = event.target.options;\n          const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n          storage.setValue(id, {\n            value\n          });\n        });\n        break;\n    }\n  }\n  static setAttributes({\n    html,\n    element,\n    storage = null,\n    intent,\n    linkService\n  }) {\n    const {\n      attributes\n    } = element;\n    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n    if (attributes.type === \"radio\") {\n      attributes.name = `${attributes.name}-${intent}`;\n    }\n    for (const [key, value] of Object.entries(attributes)) {\n      if (value === null || value === undefined) {\n        continue;\n      }\n      switch (key) {\n        case \"class\":\n          if (value.length) {\n            html.setAttribute(key, value.join(\" \"));\n          }\n          break;\n        case \"dataId\":\n          break;\n        case \"id\":\n          html.setAttribute(\"data-element-id\", value);\n          break;\n        case \"style\":\n          Object.assign(html.style, value);\n          break;\n        case \"textContent\":\n          html.textContent = value;\n          break;\n        default:\n          if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n            html.setAttribute(key, value);\n          }\n      }\n    }\n    if (isHTMLAnchorElement) {\n      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n    }\n    if (storage && attributes.dataId) {\n      this.setupStorage(html, attributes.dataId, element, storage);\n    }\n  }\n  static render(parameters) {\n    const storage = parameters.annotationStorage;\n    const linkService = parameters.linkService;\n    const root = parameters.xfaHtml;\n    const intent = parameters.intent || \"display\";\n    const rootHtml = document.createElement(root.name);\n    if (root.attributes) {\n      this.setAttributes({\n        html: rootHtml,\n        element: root,\n        intent,\n        linkService\n      });\n    }\n    const isNotForRichText = intent !== \"richText\";\n    const rootDiv = parameters.div;\n    rootDiv.append(rootHtml);\n    if (parameters.viewport) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n      rootDiv.style.transform = transform;\n    }\n    if (isNotForRichText) {\n      rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n    }\n    const textDivs = [];\n    if (root.children.length === 0) {\n      if (root.value) {\n        const node = document.createTextNode(root.value);\n        rootHtml.append(node);\n        if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n          textDivs.push(node);\n        }\n      }\n      return {\n        textDivs\n      };\n    }\n    const stack = [[root, -1, rootHtml]];\n    while (stack.length > 0) {\n      const [parent, i, html] = stack.at(-1);\n      if (i + 1 === parent.children.length) {\n        stack.pop();\n        continue;\n      }\n      const child = parent.children[++stack.at(-1)[1]];\n      if (child === null) {\n        continue;\n      }\n      const {\n        name\n      } = child;\n      if (name === \"#text\") {\n        const node = document.createTextNode(child.value);\n        textDivs.push(node);\n        html.append(node);\n        continue;\n      }\n      const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n      html.append(childHtml);\n      if (child.attributes) {\n        this.setAttributes({\n          html: childHtml,\n          element: child,\n          storage,\n          intent,\n          linkService\n        });\n      }\n      if (child.children?.length > 0) {\n        stack.push([child, -1, childHtml]);\n      } else if (child.value) {\n        const node = document.createTextNode(child.value);\n        if (isNotForRichText && XfaText.shouldBuildText(name)) {\n          textDivs.push(node);\n        }\n        childHtml.append(node);\n      }\n    }\n    for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) {\n      el.setAttribute(\"readOnly\", true);\n    }\n    return {\n      textDivs\n    };\n  }\n  static update(parameters) {\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n    parameters.div.style.transform = transform;\n    parameters.div.hidden = false;\n  }\n}\n\n;// ./src/display/annotation_layer.js\n\n\n\n\n\n\nconst DEFAULT_TAB_INDEX = 1000;\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nfunction getRectDims(rect) {\n  return {\n    width: rect[2] - rect[0],\n    height: rect[3] - rect[1]\n  };\n}\nclass AnnotationElementFactory {\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n    switch (subtype) {\n      case AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n      case AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n      case AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotationElement(parameters);\n          case \"Btn\":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n            return new PushButtonWidgetAnnotationElement(parameters);\n          case \"Ch\":\n            return new ChoiceWidgetAnnotationElement(parameters);\n          case \"Sig\":\n            return new SignatureWidgetAnnotationElement(parameters);\n        }\n        return new WidgetAnnotationElement(parameters);\n      case AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n      case AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n      case AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n      case AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n      case AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n      case AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n      case AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n      case AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n      case AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n      case AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n      case AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n      case AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n      case AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n      case AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n      case AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n}\nclass AnnotationElement {\n  #updates = null;\n  #hasBorder = false;\n  #popupElement = null;\n  constructor(parameters, {\n    isRenderable = false,\n    ignoreBorder = false,\n    createQuadrilaterals = false\n  } = {}) {\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderForms = parameters.renderForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._fieldObjects = parameters.fieldObjects;\n    this.parent = parameters.parent;\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n    if (createQuadrilaterals) {\n      this._createQuadrilaterals();\n    }\n  }\n  static _hasPopupData({\n    titleObj,\n    contentsObj,\n    richText\n  }) {\n    return !!(titleObj?.str || contentsObj?.str || richText?.str);\n  }\n  get _isEditable() {\n    return this.data.isEditable;\n  }\n  get hasPopupData() {\n    return AnnotationElement._hasPopupData(this.data);\n  }\n  updateEdited(params) {\n    if (!this.container) {\n      return;\n    }\n    this.#updates ||= {\n      rect: this.data.rect.slice(0)\n    };\n    const {\n      rect\n    } = params;\n    if (rect) {\n      this.#setRectEdited(rect);\n    }\n    this.#popupElement?.popup.updateEdited(params);\n  }\n  resetEdited() {\n    if (!this.#updates) {\n      return;\n    }\n    this.#setRectEdited(this.#updates.rect);\n    this.#popupElement?.popup.resetEdited();\n    this.#updates = null;\n  }\n  #setRectEdited(rect) {\n    const {\n      container: {\n        style\n      },\n      data: {\n        rect: currentRect,\n        rotation\n      },\n      parent: {\n        viewport: {\n          rawDims: {\n            pageWidth,\n            pageHeight,\n            pageX,\n            pageY\n          }\n        }\n      }\n    } = this;\n    currentRect?.splice(0, 4, ...rect);\n    const {\n      width,\n      height\n    } = getRectDims(rect);\n    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n    style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n    if (rotation === 0) {\n      style.width = `${100 * width / pageWidth}%`;\n      style.height = `${100 * height / pageHeight}%`;\n    } else {\n      this.setRotation(rotation);\n    }\n  }\n  _createContainer(ignoreBorder) {\n    const {\n      data,\n      parent: {\n        page,\n        viewport\n      }\n    } = this;\n    const container = document.createElement(\"section\");\n    container.setAttribute(\"data-annotation-id\", data.id);\n    if (!(this instanceof WidgetAnnotationElement)) {\n      container.tabIndex = DEFAULT_TAB_INDEX;\n    }\n    const {\n      style\n    } = container;\n    style.zIndex = this.parent.zIndex++;\n    if (data.alternativeText) {\n      container.title = data.alternativeText;\n    }\n    if (data.noRotate) {\n      container.classList.add(\"norotate\");\n    }\n    if (!data.rect || this instanceof PopupAnnotationElement) {\n      const {\n        rotation\n      } = data;\n      if (!data.hasOwnCanvas && rotation !== 0) {\n        this.setRotation(rotation, container);\n      }\n      return container;\n    }\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      style.borderWidth = `${data.borderStyle.width}px`;\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n        style.borderRadius = radius;\n      } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n        style.borderRadius = radius;\n      }\n      switch (data.borderStyle.style) {\n        case AnnotationBorderStyleType.SOLID:\n          style.borderStyle = \"solid\";\n          break;\n        case AnnotationBorderStyleType.DASHED:\n          style.borderStyle = \"dashed\";\n          break;\n        case AnnotationBorderStyleType.BEVELED:\n          warn(\"Unimplemented border style: beveled\");\n          break;\n        case AnnotationBorderStyleType.INSET:\n          warn(\"Unimplemented border style: inset\");\n          break;\n        case AnnotationBorderStyleType.UNDERLINE:\n          style.borderBottomStyle = \"solid\";\n          break;\n        default:\n          break;\n      }\n      const borderColor = data.borderColor || null;\n      if (borderColor) {\n        this.#hasBorder = true;\n        style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n      } else {\n        style.borderWidth = 0;\n      }\n    }\n    const rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n    const {\n      pageWidth,\n      pageHeight,\n      pageX,\n      pageY\n    } = viewport.rawDims;\n    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n    style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n    const {\n      rotation\n    } = data;\n    if (data.hasOwnCanvas || rotation === 0) {\n      style.width = `${100 * width / pageWidth}%`;\n      style.height = `${100 * height / pageHeight}%`;\n    } else {\n      this.setRotation(rotation, container);\n    }\n    return container;\n  }\n  setRotation(angle, container = this.container) {\n    if (!this.data.rect) {\n      return;\n    }\n    const {\n      pageWidth,\n      pageHeight\n    } = this.parent.viewport.rawDims;\n    const {\n      width,\n      height\n    } = getRectDims(this.data.rect);\n    let elementWidth, elementHeight;\n    if (angle % 180 === 0) {\n      elementWidth = 100 * width / pageWidth;\n      elementHeight = 100 * height / pageHeight;\n    } else {\n      elementWidth = 100 * height / pageWidth;\n      elementHeight = 100 * width / pageHeight;\n    }\n    container.style.width = `${elementWidth}%`;\n    container.style.height = `${elementHeight}%`;\n    container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n  }\n  get _commonActions() {\n    const setColor = (jsName, styleName, event) => {\n      const color = event.detail[jsName];\n      const colorType = color[0];\n      const colorArray = color.slice(1);\n      event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n      this.annotationStorage.setValue(this.data.id, {\n        [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n      });\n    };\n    return shadow(this, \"_commonActions\", {\n      display: event => {\n        const {\n          display\n        } = event.detail;\n        const hidden = display % 2 === 1;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          noView: hidden,\n          noPrint: display === 1 || display === 2\n        });\n      },\n      print: event => {\n        this.annotationStorage.setValue(this.data.id, {\n          noPrint: !event.detail.print\n        });\n      },\n      hidden: event => {\n        const {\n          hidden\n        } = event.detail;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          noPrint: hidden,\n          noView: hidden\n        });\n      },\n      focus: event => {\n        setTimeout(() => event.target.focus({\n          preventScroll: false\n        }), 0);\n      },\n      userName: event => {\n        event.target.title = event.detail.userName;\n      },\n      readonly: event => {\n        event.target.disabled = event.detail.readonly;\n      },\n      required: event => {\n        this._setRequired(event.target, event.detail.required);\n      },\n      bgColor: event => {\n        setColor(\"bgColor\", \"backgroundColor\", event);\n      },\n      fillColor: event => {\n        setColor(\"fillColor\", \"backgroundColor\", event);\n      },\n      fgColor: event => {\n        setColor(\"fgColor\", \"color\", event);\n      },\n      textColor: event => {\n        setColor(\"textColor\", \"color\", event);\n      },\n      borderColor: event => {\n        setColor(\"borderColor\", \"borderColor\", event);\n      },\n      strokeColor: event => {\n        setColor(\"strokeColor\", \"borderColor\", event);\n      },\n      rotation: event => {\n        const angle = event.detail.rotation;\n        this.setRotation(angle);\n        this.annotationStorage.setValue(this.data.id, {\n          rotation: angle\n        });\n      }\n    });\n  }\n  _dispatchEventFromSandbox(actions, jsEvent) {\n    const commonActions = this._commonActions;\n    for (const name of Object.keys(jsEvent.detail)) {\n      const action = actions[name] || commonActions[name];\n      action?.(jsEvent);\n    }\n  }\n  _setDefaultPropertiesFromJS(element) {\n    if (!this.enableScripting) {\n      return;\n    }\n    const storedData = this.annotationStorage.getRawValue(this.data.id);\n    if (!storedData) {\n      return;\n    }\n    const commonActions = this._commonActions;\n    for (const [actionName, detail] of Object.entries(storedData)) {\n      const action = commonActions[actionName];\n      if (action) {\n        const eventProxy = {\n          detail: {\n            [actionName]: detail\n          },\n          target: element\n        };\n        action(eventProxy);\n        delete storedData[actionName];\n      }\n    }\n  }\n  _createQuadrilaterals() {\n    if (!this.container) {\n      return;\n    }\n    const {\n      quadPoints\n    } = this.data;\n    if (!quadPoints) {\n      return;\n    }\n    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map(x => Math.fround(x));\n    if (quadPoints.length === 8) {\n      const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n        return;\n      }\n    }\n    const {\n      style\n    } = this.container;\n    let svgBuffer;\n    if (this.#hasBorder) {\n      const {\n        borderColor,\n        borderWidth\n      } = style;\n      style.borderWidth = 0;\n      svgBuffer = [\"url('data:image/svg+xml;utf8,\", `<svg xmlns=\"http://www.w3.org/2000/svg\"`, ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`, `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`];\n      this.container.classList.add(\"hasBorder\");\n    }\n    const width = rectTrX - rectBlX;\n    const height = rectTrY - rectBlY;\n    const {\n      svgFactory\n    } = this;\n    const svg = svgFactory.createElement(\"svg\");\n    svg.classList.add(\"quadrilateralsContainer\");\n    svg.setAttribute(\"width\", 0);\n    svg.setAttribute(\"height\", 0);\n    const defs = svgFactory.createElement(\"defs\");\n    svg.append(defs);\n    const clipPath = svgFactory.createElement(\"clipPath\");\n    const id = `clippath_${this.data.id}`;\n    clipPath.setAttribute(\"id\", id);\n    clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n    defs.append(clipPath);\n    for (let i = 2, ii = quadPoints.length; i < ii; i += 8) {\n      const trX = quadPoints[i];\n      const trY = quadPoints[i + 1];\n      const blX = quadPoints[i + 2];\n      const blY = quadPoints[i + 3];\n      const rect = svgFactory.createElement(\"rect\");\n      const x = (blX - rectBlX) / width;\n      const y = (rectTrY - trY) / height;\n      const rectWidth = (trX - blX) / width;\n      const rectHeight = (trY - blY) / height;\n      rect.setAttribute(\"x\", x);\n      rect.setAttribute(\"y\", y);\n      rect.setAttribute(\"width\", rectWidth);\n      rect.setAttribute(\"height\", rectHeight);\n      clipPath.append(rect);\n      svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n    }\n    if (this.#hasBorder) {\n      svgBuffer.push(`</g></svg>')`);\n      style.backgroundImage = svgBuffer.join(\"\");\n    }\n    this.container.append(svg);\n    this.container.style.clipPath = `url(#${id})`;\n  }\n  _createPopup() {\n    const {\n      data\n    } = this;\n    const popup = this.#popupElement = new PopupAnnotationElement({\n      data: {\n        color: data.color,\n        titleObj: data.titleObj,\n        modificationDate: data.modificationDate,\n        contentsObj: data.contentsObj,\n        richText: data.richText,\n        parentRect: data.rect,\n        borderStyle: 0,\n        id: `popup_${data.id}`,\n        rotation: data.rotation\n      },\n      parent: this.parent,\n      elements: [this]\n    });\n    this.parent.div.append(popup.render());\n  }\n  render() {\n    unreachable(\"Abstract method `AnnotationElement.render` called\");\n  }\n  _getElementsByName(name, skipId = null) {\n    const fields = [];\n    if (this._fieldObjects) {\n      const fieldObj = this._fieldObjects[name];\n      if (fieldObj) {\n        for (const {\n          page,\n          id,\n          exportValues\n        } of fieldObj) {\n          if (page === -1) {\n            continue;\n          }\n          if (id === skipId) {\n            continue;\n          }\n          const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n          const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n          if (domElement && !GetElementsByNameSet.has(domElement)) {\n            warn(`_getElementsByName - element not allowed: ${id}`);\n            continue;\n          }\n          fields.push({\n            id,\n            exportValue,\n            domElement\n          });\n        }\n      }\n      return fields;\n    }\n    for (const domElement of document.getElementsByName(name)) {\n      const {\n        exportValue\n      } = domElement;\n      const id = domElement.getAttribute(\"data-element-id\");\n      if (id === skipId) {\n        continue;\n      }\n      if (!GetElementsByNameSet.has(domElement)) {\n        continue;\n      }\n      fields.push({\n        id,\n        exportValue,\n        domElement\n      });\n    }\n    return fields;\n  }\n  show() {\n    if (this.container) {\n      this.container.hidden = false;\n    }\n    this.popup?.maybeShow();\n  }\n  hide() {\n    if (this.container) {\n      this.container.hidden = true;\n    }\n    this.popup?.forceHide();\n  }\n  getElementsToTriggerPopup() {\n    return this.container;\n  }\n  addHighlightArea() {\n    const triggers = this.getElementsToTriggerPopup();\n    if (Array.isArray(triggers)) {\n      for (const element of triggers) {\n        element.classList.add(\"highlightArea\");\n      }\n    } else {\n      triggers.classList.add(\"highlightArea\");\n    }\n  }\n  _editOnDoubleClick() {\n    if (!this._isEditable) {\n      return;\n    }\n    const {\n      annotationEditorType: mode,\n      data: {\n        id: editId\n      }\n    } = this;\n    this.container.addEventListener(\"dblclick\", () => {\n      this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n        source: this,\n        mode,\n        editId\n      });\n    });\n  }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters, options = null) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: !!options?.ignoreBorder,\n      createQuadrilaterals: true\n    });\n    this.isTooltipOnly = parameters.data.isTooltipOnly;\n  }\n  render() {\n    const {\n      data,\n      linkService\n    } = this;\n    const link = document.createElement(\"a\");\n    link.setAttribute(\"data-element-id\", data.id);\n    let isBound = false;\n    if (data.url) {\n      linkService.addLinkAttributes(link, data.url, data.newWindow);\n      isBound = true;\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action);\n      isBound = true;\n    } else if (data.attachment) {\n      this.#bindAttachment(link, data.attachment, data.attachmentDest);\n      isBound = true;\n    } else if (data.setOCGState) {\n      this.#bindSetOCGState(link, data.setOCGState);\n      isBound = true;\n    } else if (data.dest) {\n      this._bindLink(link, data.dest);\n      isBound = true;\n    } else {\n      if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        this._bindJSAction(link, data);\n        isBound = true;\n      }\n      if (data.resetForm) {\n        this._bindResetFormAction(link, data.resetForm);\n        isBound = true;\n      } else if (this.isTooltipOnly && !isBound) {\n        this._bindLink(link, \"\");\n        isBound = true;\n      }\n    }\n    this.container.classList.add(\"linkAnnotation\");\n    if (isBound) {\n      this.container.append(link);\n    }\n    return this.container;\n  }\n  #setInternalLink() {\n    this.container.setAttribute(\"data-internal-link\", \"\");\n  }\n  _bindLink(link, destination) {\n    link.href = this.linkService.getDestinationHash(destination);\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.goToDestination(destination);\n      }\n      return false;\n    };\n    if (destination || destination === \"\") {\n      this.#setInternalLink();\n    }\n  }\n  _bindNamedAction(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  #bindAttachment(link, attachment, dest = null) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    if (attachment.description) {\n      link.title = attachment.description;\n    }\n    link.onclick = () => {\n      this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  #bindSetOCGState(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeSetOCGState(action);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  _bindJSAction(link, data) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n    for (const name of Object.keys(data.actions)) {\n      const jsName = map.get(name);\n      if (!jsName) {\n        continue;\n      }\n      link[jsName] = () => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: data.id,\n            name\n          }\n        });\n        return false;\n      };\n    }\n    if (!link.onclick) {\n      link.onclick = () => false;\n    }\n    this.#setInternalLink();\n  }\n  _bindResetFormAction(link, resetForm) {\n    const otherClickAction = link.onclick;\n    if (!otherClickAction) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n    }\n    this.#setInternalLink();\n    if (!this._fieldObjects) {\n      warn(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n      if (!otherClickAction) {\n        link.onclick = () => false;\n      }\n      return;\n    }\n    link.onclick = () => {\n      otherClickAction?.();\n      const {\n        fields: resetFormFields,\n        refs: resetFormRefs,\n        include\n      } = resetForm;\n      const allFields = [];\n      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n        const fieldIds = new Set(resetFormRefs);\n        for (const fieldName of resetFormFields) {\n          const fields = this._fieldObjects[fieldName] || [];\n          for (const {\n            id\n          } of fields) {\n            fieldIds.add(id);\n          }\n        }\n        for (const fields of Object.values(this._fieldObjects)) {\n          for (const field of fields) {\n            if (fieldIds.has(field.id) === include) {\n              allFields.push(field);\n            }\n          }\n        }\n      } else {\n        for (const fields of Object.values(this._fieldObjects)) {\n          allFields.push(...fields);\n        }\n      }\n      const storage = this.annotationStorage;\n      const allIds = [];\n      for (const field of allFields) {\n        const {\n          id\n        } = field;\n        allIds.push(id);\n        switch (field.type) {\n          case \"text\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          case \"checkbox\":\n          case \"radiobutton\":\n            {\n              const value = field.defaultValue === field.exportValues;\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          case \"combobox\":\n          case \"listbox\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          default:\n            continue;\n        }\n        const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n        if (!domElement) {\n          continue;\n        } else if (!GetElementsByNameSet.has(domElement)) {\n          warn(`_bindResetFormAction - element not allowed: ${id}`);\n          continue;\n        }\n        domElement.dispatchEvent(new Event(\"resetform\"));\n      }\n      if (this.enableScripting) {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: \"app\",\n            ids: allIds,\n            name: \"ResetForm\"\n          }\n        });\n      }\n      return false;\n    };\n  }\n}\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"textAnnotation\");\n    const image = document.createElement(\"img\");\n    image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n    image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n    image.setAttribute(\"data-l10n-args\", JSON.stringify({\n      type: this.data.name\n    }));\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.append(image);\n    return this.container;\n  }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    return this.container;\n  }\n  showElementAndHideCanvas(element) {\n    if (this.data.hasOwnCanvas) {\n      if (element.previousSibling?.nodeName === \"CANVAS\") {\n        element.previousSibling.hidden = true;\n      }\n      element.hidden = false;\n    }\n  }\n  _getKeyModifier(event) {\n    return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n  }\n  _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n    if (baseName.includes(\"mouse\")) {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event),\n            shift: event.shiftKey,\n            modifier: this._getKeyModifier(event)\n          }\n        });\n      });\n    } else {\n      element.addEventListener(baseName, event => {\n        if (baseName === \"blur\") {\n          if (!elementData.focused || !event.relatedTarget) {\n            return;\n          }\n          elementData.focused = false;\n        } else if (baseName === \"focus\") {\n          if (elementData.focused) {\n            return;\n          }\n          elementData.focused = true;\n        }\n        if (!valueGetter) {\n          return;\n        }\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event)\n          }\n        });\n      });\n    }\n  }\n  _setEventListeners(element, elementData, names, getter) {\n    for (const [baseName, eventName] of names) {\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n        if (eventName === \"Focus\" || eventName === \"Blur\") {\n          elementData ||= {\n            focused: false\n          };\n        }\n        this._setEventListener(element, elementData, baseName, eventName, getter);\n        if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n          this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n        } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n          this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n        }\n      }\n    }\n  }\n  _setBackgroundColor(element) {\n    const color = this.data.backgroundColor || null;\n    element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n  }\n  _setTextStyle(element) {\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n    const {\n      fontColor\n    } = this.data.defaultAppearanceData;\n    const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n    const style = element.style;\n    let computedFontSize;\n    const BORDER_SIZE = 2;\n    const roundToOneDecimal = x => Math.round(10 * x) / 10;\n    if (this.data.multiLine) {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n      const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n      const lineHeight = height / numberOfLines;\n      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n    } else {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n    }\n    style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n    style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n    if (this.data.textAlignment !== null) {\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n  }\n  _setRequired(element, isRequired) {\n    if (isRequired) {\n      element.setAttribute(\"required\", true);\n    } else {\n      element.removeAttribute(\"required\");\n    }\n    element.setAttribute(\"aria-required\", isRequired);\n  }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    super(parameters, {\n      isRenderable\n    });\n  }\n  setPropertyOnSiblings(base, key, value, keyInStorage) {\n    const storage = this.annotationStorage;\n    for (const element of this._getElementsByName(base.name, base.id)) {\n      if (element.domElement) {\n        element.domElement[key] = value;\n      }\n      storage.setValue(element.id, {\n        [keyInStorage]: value\n      });\n    }\n  }\n  render() {\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    this.container.classList.add(\"textWidgetAnnotation\");\n    let element = null;\n    if (this.renderForms) {\n      const storedData = storage.getValue(id, {\n        value: this.data.fieldValue\n      });\n      let textContent = storedData.value || \"\";\n      const maxLen = storage.getValue(id, {\n        charLimit: this.data.maxLen\n      }).charLimit;\n      if (maxLen && textContent.length > maxLen) {\n        textContent = textContent.slice(0, maxLen);\n      }\n      let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n      if (fieldFormattedValues && this.data.comb) {\n        fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n      }\n      const elementData = {\n        userValue: textContent,\n        formattedValue: fieldFormattedValues,\n        lastCommittedValue: null,\n        commitKey: 1,\n        focused: false\n      };\n      if (this.data.multiLine) {\n        element = document.createElement(\"textarea\");\n        element.textContent = fieldFormattedValues ?? textContent;\n        if (this.data.doNotScroll) {\n          element.style.overflowY = \"hidden\";\n        }\n      } else {\n        element = document.createElement(\"input\");\n        element.type = \"text\";\n        element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n        if (this.data.doNotScroll) {\n          element.style.overflowX = \"hidden\";\n        }\n      }\n      if (this.data.hasOwnCanvas) {\n        element.hidden = true;\n      }\n      GetElementsByNameSet.add(element);\n      element.setAttribute(\"data-element-id\", id);\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n      element.tabIndex = DEFAULT_TAB_INDEX;\n      this._setRequired(element, this.data.required);\n      if (maxLen) {\n        element.maxLength = maxLen;\n      }\n      element.addEventListener(\"input\", event => {\n        storage.setValue(id, {\n          value: event.target.value\n        });\n        this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n        elementData.formattedValue = null;\n      });\n      element.addEventListener(\"resetform\", event => {\n        const defaultValue = this.data.defaultFieldValue ?? \"\";\n        element.value = elementData.userValue = defaultValue;\n        elementData.formattedValue = null;\n      });\n      let blurListener = event => {\n        const {\n          formattedValue\n        } = elementData;\n        if (formattedValue !== null && formattedValue !== undefined) {\n          event.target.value = formattedValue;\n        }\n        event.target.scrollLeft = 0;\n      };\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"focus\", event => {\n          if (elementData.focused) {\n            return;\n          }\n          const {\n            target\n          } = event;\n          if (elementData.userValue) {\n            target.value = elementData.userValue;\n          }\n          elementData.lastCommittedValue = target.value;\n          elementData.commitKey = 1;\n          if (!this.data.actions?.Focus) {\n            elementData.focused = true;\n          }\n        });\n        element.addEventListener(\"updatefromsandbox\", jsEvent => {\n          this.showElementAndHideCanvas(jsEvent.target);\n          const actions = {\n            value(event) {\n              elementData.userValue = event.detail.value ?? \"\";\n              storage.setValue(id, {\n                value: elementData.userValue.toString()\n              });\n              event.target.value = elementData.userValue;\n            },\n            formattedValue(event) {\n              const {\n                formattedValue\n              } = event.detail;\n              elementData.formattedValue = formattedValue;\n              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                event.target.value = formattedValue;\n              }\n              storage.setValue(id, {\n                formattedValue\n              });\n            },\n            selRange(event) {\n              event.target.setSelectionRange(...event.detail.selRange);\n            },\n            charLimit: event => {\n              const {\n                charLimit\n              } = event.detail;\n              const {\n                target\n              } = event;\n              if (charLimit === 0) {\n                target.removeAttribute(\"maxLength\");\n                return;\n              }\n              target.setAttribute(\"maxLength\", charLimit);\n              let value = elementData.userValue;\n              if (!value || value.length <= charLimit) {\n                return;\n              }\n              value = value.slice(0, charLimit);\n              target.value = elementData.userValue = value;\n              storage.setValue(id, {\n                value\n              });\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id,\n                  name: \"Keystroke\",\n                  value,\n                  willCommit: true,\n                  commitKey: 1,\n                  selStart: target.selectionStart,\n                  selEnd: target.selectionEnd\n                }\n              });\n            }\n          };\n          this._dispatchEventFromSandbox(actions, jsEvent);\n        });\n        element.addEventListener(\"keydown\", event => {\n          elementData.commitKey = 1;\n          let commitKey = -1;\n          if (event.key === \"Escape\") {\n            commitKey = 0;\n          } else if (event.key === \"Enter\" && !this.data.multiLine) {\n            commitKey = 2;\n          } else if (event.key === \"Tab\") {\n            elementData.commitKey = 3;\n          }\n          if (commitKey === -1) {\n            return;\n          }\n          const {\n            value\n          } = event.target;\n          if (elementData.lastCommittedValue === value) {\n            return;\n          }\n          elementData.lastCommittedValue = value;\n          elementData.userValue = value;\n          this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              value,\n              willCommit: true,\n              commitKey,\n              selStart: event.target.selectionStart,\n              selEnd: event.target.selectionEnd\n            }\n          });\n        });\n        const _blurListener = blurListener;\n        blurListener = null;\n        element.addEventListener(\"blur\", event => {\n          if (!elementData.focused || !event.relatedTarget) {\n            return;\n          }\n          if (!this.data.actions?.Blur) {\n            elementData.focused = false;\n          }\n          const {\n            value\n          } = event.target;\n          elementData.userValue = value;\n          if (elementData.lastCommittedValue !== value) {\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                willCommit: true,\n                commitKey: elementData.commitKey,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd\n              }\n            });\n          }\n          _blurListener(event);\n        });\n        if (this.data.actions?.Keystroke) {\n          element.addEventListener(\"beforeinput\", event => {\n            elementData.lastCommittedValue = null;\n            const {\n              data,\n              target\n            } = event;\n            const {\n              value,\n              selectionStart,\n              selectionEnd\n            } = target;\n            let selStart = selectionStart,\n              selEnd = selectionEnd;\n            switch (event.inputType) {\n              case \"deleteWordBackward\":\n                {\n                  const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                  if (match) {\n                    selStart -= match[0].length;\n                  }\n                  break;\n                }\n              case \"deleteWordForward\":\n                {\n                  const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                  if (match) {\n                    selEnd += match[0].length;\n                  }\n                  break;\n                }\n              case \"deleteContentBackward\":\n                if (selectionStart === selectionEnd) {\n                  selStart -= 1;\n                }\n                break;\n              case \"deleteContentForward\":\n                if (selectionStart === selectionEnd) {\n                  selEnd += 1;\n                }\n                break;\n            }\n            event.preventDefault();\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                change: data || \"\",\n                willCommit: false,\n                selStart,\n                selEnd\n              }\n            });\n          });\n        }\n        this._setEventListeners(element, elementData, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n      }\n      if (blurListener) {\n        element.addEventListener(\"blur\", blurListener);\n      }\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / maxLen;\n        element.classList.add(\"comb\");\n        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n      }\n    } else {\n      element = document.createElement(\"div\");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = \"middle\";\n      element.style.display = \"table-cell\";\n      if (this.data.hasOwnCanvas) {\n        element.hidden = true;\n      }\n    }\n    this._setTextStyle(element);\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: !!parameters.data.hasOwnCanvas\n    });\n  }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.exportValue === data.fieldValue\n    }).value;\n    if (typeof value === \"string\") {\n      value = value !== \"Off\";\n      storage.setValue(id, {\n        value\n      });\n    }\n    this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n    this._setRequired(element, this.data.required);\n    element.type = \"checkbox\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.setAttribute(\"exportValue\", data.exportValue);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n      for (const checkbox of this._getElementsByName(name, id)) {\n        const curChecked = checked && checkbox.exportValue === data.exportValue;\n        if (checkbox.domElement) {\n          checkbox.domElement.checked = curChecked;\n        }\n        storage.setValue(checkbox.id, {\n          value: curChecked\n        });\n      }\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue || \"Off\";\n      event.target.checked = defaultValue === data.exportValue;\n    });\n    if (this.enableScripting && this.hasJSActions) {\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            event.target.checked = event.detail.value !== \"Off\";\n            storage.setValue(id, {\n              value: event.target.checked\n            });\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      this._setEventListeners(element, null, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.fieldValue === data.buttonValue\n    }).value;\n    if (typeof value === \"string\") {\n      value = value !== data.buttonValue;\n      storage.setValue(id, {\n        value\n      });\n    }\n    if (value) {\n      for (const radio of this._getElementsByName(data.fieldName, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n    }\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n    this._setRequired(element, this.data.required);\n    element.type = \"radio\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n      for (const radio of this._getElementsByName(name, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue;\n      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n    });\n    if (this.enableScripting && this.hasJSActions) {\n      const pdfButtonValue = data.buttonValue;\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value: event => {\n            const checked = pdfButtonValue === event.detail.value;\n            for (const radio of this._getElementsByName(event.target.name)) {\n              const curChecked = checked && radio.id === id;\n              if (radio.domElement) {\n                radio.domElement.checked = curChecked;\n              }\n              storage.setValue(radio.id, {\n                value: curChecked\n              });\n            }\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      this._setEventListeners(element, null, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      ignoreBorder: parameters.data.hasAppearance\n    });\n  }\n  render() {\n    const container = super.render();\n    container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n    const linkElement = container.lastChild;\n    if (this.enableScripting && this.hasJSActions && linkElement) {\n      this._setDefaultPropertiesFromJS(linkElement);\n      linkElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        this._dispatchEventFromSandbox({}, jsEvent);\n      });\n    }\n    return container;\n  }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    this.container.classList.add(\"choiceWidgetAnnotation\");\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    const storedData = storage.getValue(id, {\n      value: this.data.fieldValue\n    });\n    const selectElement = document.createElement(\"select\");\n    GetElementsByNameSet.add(selectElement);\n    selectElement.setAttribute(\"data-element-id\", id);\n    selectElement.disabled = this.data.readOnly;\n    this._setRequired(selectElement, this.data.required);\n    selectElement.name = this.data.fieldName;\n    selectElement.tabIndex = DEFAULT_TAB_INDEX;\n    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n    if (!this.data.combo) {\n      selectElement.size = this.data.options.length;\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n    selectElement.addEventListener(\"resetform\", event => {\n      const defaultValue = this.data.defaultFieldValue;\n      for (const option of selectElement.options) {\n        option.selected = option.value === defaultValue;\n      }\n    });\n    for (const option of this.data.options) {\n      const optionElement = document.createElement(\"option\");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n      if (storedData.value.includes(option.exportValue)) {\n        optionElement.setAttribute(\"selected\", true);\n        addAnEmptyEntry = false;\n      }\n      selectElement.append(optionElement);\n    }\n    let removeEmptyEntry = null;\n    if (addAnEmptyEntry) {\n      const noneOptionElement = document.createElement(\"option\");\n      noneOptionElement.value = \" \";\n      noneOptionElement.setAttribute(\"hidden\", true);\n      noneOptionElement.setAttribute(\"selected\", true);\n      selectElement.prepend(noneOptionElement);\n      removeEmptyEntry = () => {\n        noneOptionElement.remove();\n        selectElement.removeEventListener(\"input\", removeEmptyEntry);\n        removeEmptyEntry = null;\n      };\n      selectElement.addEventListener(\"input\", removeEmptyEntry);\n    }\n    const getValue = isExport => {\n      const name = isExport ? \"value\" : \"textContent\";\n      const {\n        options,\n        multiple\n      } = selectElement;\n      if (!multiple) {\n        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n      }\n      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);\n    };\n    let selectedValues = getValue(false);\n    const getItems = event => {\n      const options = event.target.options;\n      return Array.prototype.map.call(options, option => ({\n        displayValue: option.textContent,\n        exportValue: option.value\n      }));\n    };\n    if (this.enableScripting && this.hasJSActions) {\n      selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            removeEmptyEntry?.();\n            const value = event.detail.value;\n            const values = new Set(Array.isArray(value) ? value : [value]);\n            for (const option of selectElement.options) {\n              option.selected = values.has(option.value);\n            }\n            storage.setValue(id, {\n              value: getValue(true)\n            });\n            selectedValues = getValue(false);\n          },\n          multipleSelection(event) {\n            selectElement.multiple = true;\n          },\n          remove(event) {\n            const options = selectElement.options;\n            const index = event.detail.remove;\n            options[index].selected = false;\n            selectElement.remove(index);\n            if (options.length > 0) {\n              const i = Array.prototype.findIndex.call(options, option => option.selected);\n              if (i === -1) {\n                options[0].selected = true;\n              }\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          clear(event) {\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            storage.setValue(id, {\n              value: null,\n              items: []\n            });\n            selectedValues = getValue(false);\n          },\n          insert(event) {\n            const {\n              index,\n              displayValue,\n              exportValue\n            } = event.detail.insert;\n            const selectChild = selectElement.children[index];\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = displayValue;\n            optionElement.value = exportValue;\n            if (selectChild) {\n              selectChild.before(optionElement);\n            } else {\n              selectElement.append(optionElement);\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          items(event) {\n            const {\n              items\n            } = event.detail;\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            for (const item of items) {\n              const {\n                displayValue,\n                exportValue\n              } = item;\n              const optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.append(optionElement);\n            }\n            if (selectElement.options.length > 0) {\n              selectElement.options[0].selected = true;\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          indices(event) {\n            const indices = new Set(event.detail.indices);\n            for (const option of event.target.options) {\n              option.selected = indices.has(option.index);\n            }\n            storage.setValue(id, {\n              value: getValue(true)\n            });\n            selectedValues = getValue(false);\n          },\n          editable(event) {\n            event.target.disabled = !event.detail.editable;\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      selectElement.addEventListener(\"input\", event => {\n        const exportValue = getValue(true);\n        const change = getValue(false);\n        storage.setValue(id, {\n          value: exportValue\n        });\n        event.preventDefault();\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id,\n            name: \"Keystroke\",\n            value: selectedValues,\n            change,\n            changeEx: exportValue,\n            willCommit: false,\n            commitKey: 1,\n            keyDown: false\n          }\n        });\n      });\n      this._setEventListeners(selectElement, null, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"], [\"input\", \"Validate\"]], event => event.target.value);\n    } else {\n      selectElement.addEventListener(\"input\", function (event) {\n        storage.setValue(id, {\n          value: getValue(true)\n        });\n      });\n    }\n    if (this.data.combo) {\n      this._setTextStyle(selectElement);\n    } else {}\n    this._setBackgroundColor(selectElement);\n    this._setDefaultPropertiesFromJS(selectElement);\n    this.container.append(selectElement);\n    return this.container;\n  }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const {\n      data,\n      elements\n    } = parameters;\n    super(parameters, {\n      isRenderable: AnnotationElement._hasPopupData(data)\n    });\n    this.elements = elements;\n    this.popup = null;\n  }\n  render() {\n    this.container.classList.add(\"popupAnnotation\");\n    const popup = this.popup = new PopupElement({\n      container: this.container,\n      color: this.data.color,\n      titleObj: this.data.titleObj,\n      modificationDate: this.data.modificationDate,\n      contentsObj: this.data.contentsObj,\n      richText: this.data.richText,\n      rect: this.data.rect,\n      parentRect: this.data.parentRect || null,\n      parent: this.parent,\n      elements: this.elements,\n      open: this.data.open\n    });\n    const elementIds = [];\n    for (const element of this.elements) {\n      element.popup = popup;\n      element.container.ariaHasPopup = \"dialog\";\n      elementIds.push(element.data.id);\n      element.addHighlightArea();\n    }\n    this.container.setAttribute(\"aria-controls\", elementIds.map(id => `${AnnotationPrefix}${id}`).join(\",\"));\n    return this.container;\n  }\n}\nclass PopupElement {\n  #boundKeyDown = this.#keyDown.bind(this);\n  #boundHide = this.#hide.bind(this);\n  #boundShow = this.#show.bind(this);\n  #boundToggle = this.#toggle.bind(this);\n  #color = null;\n  #container = null;\n  #contentsObj = null;\n  #dateObj = null;\n  #elements = null;\n  #parent = null;\n  #parentRect = null;\n  #pinned = false;\n  #popup = null;\n  #position = null;\n  #rect = null;\n  #richText = null;\n  #titleObj = null;\n  #updates = null;\n  #wasVisible = false;\n  constructor({\n    container,\n    color,\n    elements,\n    titleObj,\n    modificationDate,\n    contentsObj,\n    richText,\n    parent,\n    rect,\n    parentRect,\n    open\n  }) {\n    this.#container = container;\n    this.#titleObj = titleObj;\n    this.#contentsObj = contentsObj;\n    this.#richText = richText;\n    this.#parent = parent;\n    this.#color = color;\n    this.#rect = rect;\n    this.#parentRect = parentRect;\n    this.#elements = elements;\n    this.#dateObj = PDFDateString.toDateObject(modificationDate);\n    this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());\n    for (const element of this.trigger) {\n      element.addEventListener(\"click\", this.#boundToggle);\n      element.addEventListener(\"mouseenter\", this.#boundShow);\n      element.addEventListener(\"mouseleave\", this.#boundHide);\n      element.classList.add(\"popupTriggerArea\");\n    }\n    for (const element of elements) {\n      element.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n    }\n    this.#container.hidden = true;\n    if (open) {\n      this.#toggle();\n    }\n  }\n  render() {\n    if (this.#popup) {\n      return;\n    }\n    const popup = this.#popup = document.createElement(\"div\");\n    popup.className = \"popup\";\n    if (this.#color) {\n      const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n      if (CSS.supports(\"background-color\", \"color-mix(in srgb, red 30%, white)\")) {\n        popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n      } else {\n        const BACKGROUND_ENLIGHT = 0.7;\n        popup.style.backgroundColor = Util.makeHexColor(...this.#color.map(c => Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));\n      }\n    }\n    const header = document.createElement(\"span\");\n    header.className = \"header\";\n    const title = document.createElement(\"h1\");\n    header.append(title);\n    ({\n      dir: title.dir,\n      str: title.textContent\n    } = this.#titleObj);\n    popup.append(header);\n    if (this.#dateObj) {\n      const modificationDate = document.createElement(\"span\");\n      modificationDate.classList.add(\"popupDate\");\n      modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n      modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n        dateObj: this.#dateObj.valueOf()\n      }));\n      header.append(modificationDate);\n    }\n    const html = this.#html;\n    if (html) {\n      XfaLayer.render({\n        xfaHtml: html,\n        intent: \"richText\",\n        div: popup\n      });\n      popup.lastChild.classList.add(\"richText\", \"popupContent\");\n    } else {\n      const contents = this._formatContents(this.#contentsObj);\n      popup.append(contents);\n    }\n    this.#container.append(popup);\n  }\n  get #html() {\n    const richText = this.#richText;\n    const contentsObj = this.#contentsObj;\n    if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n      return this.#richText.html || null;\n    }\n    return null;\n  }\n  get #fontSize() {\n    return this.#html?.attributes?.style?.fontSize || 0;\n  }\n  get #fontColor() {\n    return this.#html?.attributes?.style?.color || null;\n  }\n  #makePopupContent(text) {\n    const popupLines = [];\n    const popupContent = {\n      str: text,\n      html: {\n        name: \"div\",\n        attributes: {\n          dir: \"auto\"\n        },\n        children: [{\n          name: \"p\",\n          children: popupLines\n        }]\n      }\n    };\n    const lineAttributes = {\n      style: {\n        color: this.#fontColor,\n        fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--scale-factor))` : \"\"\n      }\n    };\n    for (const line of text.split(\"\\n\")) {\n      popupLines.push({\n        name: \"span\",\n        value: line,\n        attributes: lineAttributes\n      });\n    }\n    return popupContent;\n  }\n  _formatContents({\n    str,\n    dir\n  }) {\n    const p = document.createElement(\"p\");\n    p.classList.add(\"popupContent\");\n    p.dir = dir;\n    const lines = str.split(/(?:\\r\\n?|\\n)/);\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.append(document.createTextNode(line));\n      if (i < ii - 1) {\n        p.append(document.createElement(\"br\"));\n      }\n    }\n    return p;\n  }\n  #keyDown(event) {\n    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n      return;\n    }\n    if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n      this.#toggle();\n    }\n  }\n  updateEdited({\n    rect,\n    popupContent\n  }) {\n    this.#updates ||= {\n      contentsObj: this.#contentsObj,\n      richText: this.#richText\n    };\n    if (rect) {\n      this.#position = null;\n    }\n    if (popupContent) {\n      this.#richText = this.#makePopupContent(popupContent);\n      this.#contentsObj = null;\n    }\n    this.#popup?.remove();\n    this.#popup = null;\n  }\n  resetEdited() {\n    if (!this.#updates) {\n      return;\n    }\n    ({\n      contentsObj: this.#contentsObj,\n      richText: this.#richText\n    } = this.#updates);\n    this.#updates = null;\n    this.#popup?.remove();\n    this.#popup = null;\n    this.#position = null;\n  }\n  #setPosition() {\n    if (this.#position !== null) {\n      return;\n    }\n    const {\n      page: {\n        view\n      },\n      viewport: {\n        rawDims: {\n          pageWidth,\n          pageHeight,\n          pageX,\n          pageY\n        }\n      }\n    } = this.#parent;\n    let useParentRect = !!this.#parentRect;\n    let rect = useParentRect ? this.#parentRect : this.#rect;\n    for (const element of this.#elements) {\n      if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n        rect = element.data.rect;\n        useParentRect = true;\n        break;\n      }\n    }\n    const normalizedRect = Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);\n    const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n    const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n    const popupLeft = normalizedRect[0] + parentWidth;\n    const popupTop = normalizedRect[1];\n    this.#position = [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight];\n    const {\n      style\n    } = this.#container;\n    style.left = `${this.#position[0]}%`;\n    style.top = `${this.#position[1]}%`;\n  }\n  #toggle() {\n    this.#pinned = !this.#pinned;\n    if (this.#pinned) {\n      this.#show();\n      this.#container.addEventListener(\"click\", this.#boundToggle);\n      this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n    } else {\n      this.#hide();\n      this.#container.removeEventListener(\"click\", this.#boundToggle);\n      this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n    }\n  }\n  #show() {\n    if (!this.#popup) {\n      this.render();\n    }\n    if (!this.isVisible) {\n      this.#setPosition();\n      this.#container.hidden = false;\n      this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n    } else if (this.#pinned) {\n      this.#container.classList.add(\"focused\");\n    }\n  }\n  #hide() {\n    this.#container.classList.remove(\"focused\");\n    if (this.#pinned || !this.isVisible) {\n      return;\n    }\n    this.#container.hidden = true;\n    this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n  }\n  forceHide() {\n    this.#wasVisible = this.isVisible;\n    if (!this.#wasVisible) {\n      return;\n    }\n    this.#container.hidden = true;\n  }\n  maybeShow() {\n    if (!this.#wasVisible) {\n      return;\n    }\n    if (!this.#popup) {\n      this.#show();\n    }\n    this.#wasVisible = false;\n    this.#container.hidden = false;\n  }\n  get isVisible() {\n    return this.#container.hidden === false;\n  }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.textContent = parameters.data.textContent;\n    this.textPosition = parameters.data.textPosition;\n    this.annotationEditorType = AnnotationEditorType.FREETEXT;\n  }\n  render() {\n    this.container.classList.add(\"freeTextAnnotation\");\n    if (this.textContent) {\n      const content = document.createElement(\"div\");\n      content.classList.add(\"annotationTextContent\");\n      content.setAttribute(\"role\", \"comment\");\n      for (const line of this.textContent) {\n        const lineSpan = document.createElement(\"span\");\n        lineSpan.textContent = line;\n        content.append(lineSpan);\n      }\n      this.container.append(content);\n    }\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this._editOnDoubleClick();\n    return this.container;\n  }\n}\nclass LineAnnotationElement extends AnnotationElement {\n  #line = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"lineAnnotation\");\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    line.setAttribute(\"stroke\", \"transparent\");\n    line.setAttribute(\"fill\", \"transparent\");\n    svg.append(line);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#line;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n  #square = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"squareAnnotation\");\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n    square.setAttribute(\"x\", borderWidth / 2);\n    square.setAttribute(\"y\", borderWidth / 2);\n    square.setAttribute(\"width\", width - borderWidth);\n    square.setAttribute(\"height\", height - borderWidth);\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\n    square.setAttribute(\"stroke\", \"transparent\");\n    square.setAttribute(\"fill\", \"transparent\");\n    svg.append(square);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#square;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n  #circle = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"circleAnnotation\");\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n    circle.setAttribute(\"cx\", width / 2);\n    circle.setAttribute(\"cy\", height / 2);\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    svg.append(circle);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#circle;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n  #polyline = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"polylineAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n  render() {\n    this.container.classList.add(this.containerClassName);\n    const {\n      data: {\n        rect,\n        vertices,\n        borderStyle,\n        popupRef\n      }\n    } = this;\n    if (!vertices) {\n      return this.container;\n    }\n    const {\n      width,\n      height\n    } = getRectDims(rect);\n    const svg = this.svgFactory.create(width, height, true);\n    let points = [];\n    for (let i = 0, ii = vertices.length; i < ii; i += 2) {\n      const x = vertices[i] - rect[0];\n      const y = rect[3] - vertices[i + 1];\n      points.push(`${x},${y}`);\n    }\n    points = points.join(\" \");\n    const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute(\"points\", points);\n    polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n    polyline.setAttribute(\"stroke\", \"transparent\");\n    polyline.setAttribute(\"fill\", \"transparent\");\n    svg.append(polyline);\n    this.container.append(svg);\n    if (!popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#polyline;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    super(parameters);\n    this.containerClassName = \"polygonAnnotation\";\n    this.svgElementName = \"svg:polygon\";\n  }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"caretAnnotation\");\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n}\nclass InkAnnotationElement extends AnnotationElement {\n  #polylines = [];\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"inkAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n    this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n  }\n  render() {\n    this.container.classList.add(this.containerClassName);\n    const {\n      data: {\n        rect,\n        inkLists,\n        borderStyle,\n        popupRef\n      }\n    } = this;\n    const {\n      width,\n      height\n    } = getRectDims(rect);\n    const svg = this.svgFactory.create(width, height, true);\n    for (const inkList of inkLists) {\n      let points = [];\n      for (let i = 0, ii = inkList.length; i < ii; i += 2) {\n        const x = inkList[i] - rect[0];\n        const y = rect[3] - inkList[i + 1];\n        points.push(`${x},${y}`);\n      }\n      points = points.join(\" \");\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      this.#polylines.push(polyline);\n      polyline.setAttribute(\"points\", points);\n      polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"transparent\");\n      svg.append(polyline);\n    }\n    if (!popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.append(svg);\n    this._editOnDoubleClick();\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#polylines;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n    this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"highlightAnnotation\");\n    this._editOnDoubleClick();\n    return this.container;\n  }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"underlineAnnotation\");\n    return this.container;\n  }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"squigglyAnnotation\");\n    return this.container;\n  }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"strikeoutAnnotation\");\n    return this.container;\n  }\n}\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.annotationEditorType = AnnotationEditorType.STAMP;\n  }\n  render() {\n    this.container.classList.add(\"stampAnnotation\");\n    this.container.setAttribute(\"role\", \"img\");\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this._editOnDoubleClick();\n    return this.container;\n  }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  #trigger = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n    const {\n      file\n    } = this.data;\n    this.filename = file.filename;\n    this.content = file.content;\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n      source: this,\n      ...file\n    });\n  }\n  render() {\n    this.container.classList.add(\"fileAttachmentAnnotation\");\n    const {\n      container,\n      data\n    } = this;\n    let trigger;\n    if (data.hasAppearance || data.fillAlpha === 0) {\n      trigger = document.createElement(\"div\");\n    } else {\n      trigger = document.createElement(\"img\");\n      trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n      if (data.fillAlpha && data.fillAlpha < 1) {\n        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n      }\n    }\n    trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n    this.#trigger = trigger;\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    container.addEventListener(\"keydown\", evt => {\n      if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n        this.#download();\n      }\n    });\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    } else {\n      trigger.classList.add(\"popupTriggerArea\");\n    }\n    container.append(trigger);\n    return container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#trigger;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n  #download() {\n    this.downloadManager?.openOrDownloadData(this.content, this.filename);\n  }\n}\nclass AnnotationLayer {\n  #accessibilityManager = null;\n  #annotationCanvasMap = null;\n  #editableAnnotations = new Map();\n  #structTreeLayer = null;\n  constructor({\n    div,\n    accessibilityManager,\n    annotationCanvasMap,\n    annotationEditorUIManager,\n    page,\n    viewport,\n    structTreeLayer\n  }) {\n    this.div = div;\n    this.#accessibilityManager = accessibilityManager;\n    this.#annotationCanvasMap = annotationCanvasMap;\n    this.#structTreeLayer = structTreeLayer || null;\n    this.page = page;\n    this.viewport = viewport;\n    this.zIndex = 0;\n    this._annotationEditorUIManager = annotationEditorUIManager;\n  }\n  hasEditableAnnotations() {\n    return this.#editableAnnotations.size > 0;\n  }\n  async #appendElement(element, id) {\n    const contentElement = element.firstChild || element;\n    const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n    const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);\n    if (ariaAttributes) {\n      for (const [key, value] of ariaAttributes) {\n        contentElement.setAttribute(key, value);\n      }\n    }\n    this.div.append(element);\n    this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n  }\n  async render(params) {\n    const {\n      annotations\n    } = params;\n    const layer = this.div;\n    setLayerDimensions(layer, this.viewport);\n    const popupToElements = new Map();\n    const elementParams = {\n      data: null,\n      layer,\n      linkService: params.linkService,\n      downloadManager: params.downloadManager,\n      imageResourcesPath: params.imageResourcesPath || \"\",\n      renderForms: params.renderForms !== false,\n      svgFactory: new DOMSVGFactory(),\n      annotationStorage: params.annotationStorage || new AnnotationStorage(),\n      enableScripting: params.enableScripting === true,\n      hasJSActions: params.hasJSActions,\n      fieldObjects: params.fieldObjects,\n      parent: this,\n      elements: null\n    };\n    for (const data of annotations) {\n      if (data.noHTML) {\n        continue;\n      }\n      const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n      if (!isPopupAnnotation) {\n        const {\n          width,\n          height\n        } = getRectDims(data.rect);\n        if (width <= 0 || height <= 0) {\n          continue;\n        }\n      } else {\n        const elements = popupToElements.get(data.id);\n        if (!elements) {\n          continue;\n        }\n        elementParams.elements = elements;\n      }\n      elementParams.data = data;\n      const element = AnnotationElementFactory.create(elementParams);\n      if (!element.isRenderable) {\n        continue;\n      }\n      if (!isPopupAnnotation && data.popupRef) {\n        const elements = popupToElements.get(data.popupRef);\n        if (!elements) {\n          popupToElements.set(data.popupRef, [element]);\n        } else {\n          elements.push(element);\n        }\n      }\n      const rendered = element.render();\n      if (data.hidden) {\n        rendered.style.visibility = \"hidden\";\n      }\n      await this.#appendElement(rendered, data.id);\n      if (element._isEditable) {\n        this.#editableAnnotations.set(element.data.id, element);\n        this._annotationEditorUIManager?.renderAnnotationElement(element);\n      }\n    }\n    this.#setAnnotationCanvasMap();\n  }\n  update({\n    viewport\n  }) {\n    const layer = this.div;\n    this.viewport = viewport;\n    setLayerDimensions(layer, {\n      rotation: viewport.rotation\n    });\n    this.#setAnnotationCanvasMap();\n    layer.hidden = false;\n  }\n  #setAnnotationCanvasMap() {\n    if (!this.#annotationCanvasMap) {\n      return;\n    }\n    const layer = this.div;\n    for (const [id, canvas] of this.#annotationCanvasMap) {\n      const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n      if (!element) {\n        continue;\n      }\n      canvas.className = \"annotationContent\";\n      const {\n        firstChild\n      } = element;\n      if (!firstChild) {\n        element.append(canvas);\n      } else if (firstChild.nodeName === \"CANVAS\") {\n        firstChild.replaceWith(canvas);\n      } else if (!firstChild.classList.contains(\"annotationContent\")) {\n        firstChild.before(canvas);\n      } else {\n        firstChild.after(canvas);\n      }\n    }\n    this.#annotationCanvasMap.clear();\n  }\n  getEditableAnnotations() {\n    return Array.from(this.#editableAnnotations.values());\n  }\n  getEditableAnnotation(id) {\n    return this.#editableAnnotations.get(id);\n  }\n}\n\n;// ./src/display/editor/freetext.js\n\n\n\n\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n  #color;\n  #content = \"\";\n  #editorDivId = `${this.id}-editor`;\n  #editModeAC = null;\n  #fontSize;\n  static _freeTextDefaultContent = \"\";\n  static _internalPadding = 0;\n  static _defaultColor = null;\n  static _defaultFontSize = 10;\n  static get _keyboardManager() {\n    const proto = FreeTextEditor.prototype;\n    const arrowChecker = self => self.isEmpty();\n    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n    const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"ctrl+s\", \"mac+meta+s\", \"ctrl+p\", \"mac+meta+p\"], proto.commitOrRemove, {\n      bubbles: true\n    }], [[\"ctrl+Enter\", \"mac+meta+Enter\", \"Escape\", \"mac+Escape\"], proto.commitOrRemove], [[\"ArrowLeft\", \"mac+ArrowLeft\"], proto._translateEmpty, {\n      args: [-small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], proto._translateEmpty, {\n      args: [-big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto._translateEmpty, {\n      args: [small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], proto._translateEmpty, {\n      args: [big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto._translateEmpty, {\n      args: [0, -small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], proto._translateEmpty, {\n      args: [0, -big],\n      checker: arrowChecker\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto._translateEmpty, {\n      args: [0, small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], proto._translateEmpty, {\n      args: [0, big],\n      checker: arrowChecker\n    }]]));\n  }\n  static _type = \"freetext\";\n  static _editorType = AnnotationEditorType.FREETEXT;\n  constructor(params) {\n    super({\n      ...params,\n      name: \"freeTextEditor\"\n    });\n    this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n    const style = getComputedStyle(document.documentElement);\n    this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.FREETEXT_SIZE:\n        FreeTextEditor._defaultFontSize = value;\n        break;\n      case AnnotationEditorParamsType.FREETEXT_COLOR:\n        FreeTextEditor._defaultColor = value;\n        break;\n    }\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.FREETEXT_SIZE:\n        this.#updateFontSize(value);\n        break;\n      case AnnotationEditorParamsType.FREETEXT_COLOR:\n        this.#updateColor(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];\n  }\n  get propertiesToUpdate() {\n    return [[AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]];\n  }\n  #updateFontSize(fontSize) {\n    const setFontsize = size => {\n      this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n      this.translate(0, -(size - this.#fontSize) * this.parentScale);\n      this.#fontSize = size;\n      this.#setEditorDimensions();\n    };\n    const savedFontsize = this.#fontSize;\n    this.addCommands({\n      cmd: setFontsize.bind(this, fontSize),\n      undo: setFontsize.bind(this, savedFontsize),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.FREETEXT_SIZE,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  #updateColor(color) {\n    const setColor = col => {\n      this.#color = this.editorDiv.style.color = col;\n    };\n    const savedColor = this.#color;\n    this.addCommands({\n      cmd: setColor.bind(this, color),\n      undo: setColor.bind(this, savedColor),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.FREETEXT_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  _translateEmpty(x, y) {\n    this._uiManager.translateSelectedEditors(x, y, true);\n  }\n  getInitialTranslation() {\n    const scale = this.parentScale;\n    return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale];\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  enableEditMode() {\n    if (this.isInEditMode()) {\n      return;\n    }\n    this.parent.setEditingState(false);\n    this.parent.updateToolbar(AnnotationEditorType.FREETEXT);\n    super.enableEditMode();\n    this.overlayDiv.classList.remove(\"enabled\");\n    this.editorDiv.contentEditable = true;\n    this._isDraggable = false;\n    this.div.removeAttribute(\"aria-activedescendant\");\n    this.#editModeAC = new AbortController();\n    const signal = this._uiManager.combinedSignal(this.#editModeAC);\n    this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n      signal\n    });\n  }\n  disableEditMode() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n    this.parent.setEditingState(true);\n    super.disableEditMode();\n    this.overlayDiv.classList.add(\"enabled\");\n    this.editorDiv.contentEditable = false;\n    this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n    this._isDraggable = true;\n    this.#editModeAC?.abort();\n    this.#editModeAC = null;\n    this.div.focus({\n      preventScroll: true\n    });\n    this.isEditing = false;\n    this.parent.div.classList.add(\"freetextEditing\");\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    super.focusin(event);\n    if (event.target !== this.editorDiv) {\n      this.editorDiv.focus();\n    }\n  }\n  onceAdded() {\n    if (this.width) {\n      return;\n    }\n    this.enableEditMode();\n    this.editorDiv.focus();\n    if (this._initialOptions?.isCentered) {\n      this.center();\n    }\n    this._initialOptions = null;\n  }\n  isEmpty() {\n    return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n  }\n  remove() {\n    this.isEditing = false;\n    if (this.parent) {\n      this.parent.setEditingState(true);\n      this.parent.div.classList.add(\"freetextEditing\");\n    }\n    super.remove();\n  }\n  #extractText() {\n    const buffer = [];\n    this.editorDiv.normalize();\n    let prevChild = null;\n    for (const child of this.editorDiv.childNodes) {\n      if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n        continue;\n      }\n      buffer.push(FreeTextEditor.#getNodeContent(child));\n      prevChild = child;\n    }\n    return buffer.join(\"\\n\");\n  }\n  #setEditorDimensions() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    let rect;\n    if (this.isAttachedToDOM) {\n      rect = this.div.getBoundingClientRect();\n    } else {\n      const {\n        currentLayer,\n        div\n      } = this;\n      const savedDisplay = div.style.display;\n      const savedVisibility = div.classList.contains(\"hidden\");\n      div.classList.remove(\"hidden\");\n      div.style.display = \"hidden\";\n      currentLayer.div.append(this.div);\n      rect = div.getBoundingClientRect();\n      div.remove();\n      div.style.display = savedDisplay;\n      div.classList.toggle(\"hidden\", savedVisibility);\n    }\n    if (this.rotation % 180 === this.parentRotation % 180) {\n      this.width = rect.width / parentWidth;\n      this.height = rect.height / parentHeight;\n    } else {\n      this.width = rect.height / parentWidth;\n      this.height = rect.width / parentHeight;\n    }\n    this.fixAndSetPosition();\n  }\n  commit() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n    super.commit();\n    this.disableEditMode();\n    const savedText = this.#content;\n    const newText = this.#content = this.#extractText().trimEnd();\n    if (savedText === newText) {\n      return;\n    }\n    const setText = text => {\n      this.#content = text;\n      if (!text) {\n        this.remove();\n        return;\n      }\n      this.#setContent();\n      this._uiManager.rebuild(this);\n      this.#setEditorDimensions();\n    };\n    this.addCommands({\n      cmd: () => {\n        setText(newText);\n      },\n      undo: () => {\n        setText(savedText);\n      },\n      mustExec: false\n    });\n    this.#setEditorDimensions();\n  }\n  shouldGetKeyboardEvents() {\n    return this.isInEditMode();\n  }\n  enterInEditMode() {\n    this.enableEditMode();\n    this.editorDiv.focus();\n  }\n  dblclick(event) {\n    this.enterInEditMode();\n  }\n  keydown(event) {\n    if (event.target === this.div && event.key === \"Enter\") {\n      this.enterInEditMode();\n      event.preventDefault();\n    }\n  }\n  editorDivKeydown(event) {\n    FreeTextEditor._keyboardManager.exec(this, event);\n  }\n  editorDivFocus(event) {\n    this.isEditing = true;\n  }\n  editorDivBlur(event) {\n    this.isEditing = false;\n  }\n  editorDivInput(event) {\n    this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n  }\n  disableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"comment\");\n    this.editorDiv.removeAttribute(\"aria-multiline\");\n  }\n  enableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"textbox\");\n    this.editorDiv.setAttribute(\"aria-multiline\", true);\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.editorDiv = document.createElement(\"div\");\n    this.editorDiv.className = \"internal\";\n    this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n    this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n    this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n    this.enableEditing();\n    this.editorDiv.contentEditable = true;\n    const {\n      style\n    } = this.editorDiv;\n    style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n    style.color = this.#color;\n    this.div.append(this.editorDiv);\n    this.overlayDiv = document.createElement(\"div\");\n    this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n    this.div.append(this.overlayDiv);\n    bindEvents(this, this.div, [\"dblclick\", \"keydown\"]);\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      if (this.annotationElementId) {\n        const {\n          position\n        } = this._initialData;\n        let [tx, ty] = this.getInitialTranslation();\n        [tx, ty] = this.pageTranslationToScreen(tx, ty);\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        let posX, posY;\n        switch (this.rotation) {\n          case 0:\n            posX = baseX + (position[0] - pageX) / pageWidth;\n            posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n            break;\n          case 90:\n            posX = baseX + (position[0] - pageX) / pageWidth;\n            posY = baseY - (position[1] - pageY) / pageHeight;\n            [tx, ty] = [ty, -tx];\n            break;\n          case 180:\n            posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n            posY = baseY - (position[1] - pageY) / pageHeight;\n            [tx, ty] = [-tx, -ty];\n            break;\n          case 270:\n            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n            [tx, ty] = [-ty, tx];\n            break;\n        }\n        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n      } else {\n        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n      }\n      this.#setContent();\n      this._isDraggable = true;\n      this.editorDiv.contentEditable = false;\n    } else {\n      this._isDraggable = false;\n      this.editorDiv.contentEditable = true;\n    }\n    return this.div;\n  }\n  static #getNodeContent(node) {\n    return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n  }\n  editorDivPaste(event) {\n    const clipboardData = event.clipboardData || window.clipboardData;\n    const {\n      types\n    } = clipboardData;\n    if (types.length === 1 && types[0] === \"text/plain\") {\n      return;\n    }\n    event.preventDefault();\n    const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n    if (!paste) {\n      return;\n    }\n    const selection = window.getSelection();\n    if (!selection.rangeCount) {\n      return;\n    }\n    this.editorDiv.normalize();\n    selection.deleteFromDocument();\n    const range = selection.getRangeAt(0);\n    if (!paste.includes(\"\\n\")) {\n      range.insertNode(document.createTextNode(paste));\n      this.editorDiv.normalize();\n      selection.collapseToStart();\n      return;\n    }\n    const {\n      startContainer,\n      startOffset\n    } = range;\n    const bufferBefore = [];\n    const bufferAfter = [];\n    if (startContainer.nodeType === Node.TEXT_NODE) {\n      const parent = startContainer.parentElement;\n      bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n      if (parent !== this.editorDiv) {\n        let buffer = bufferBefore;\n        for (const child of this.editorDiv.childNodes) {\n          if (child === parent) {\n            buffer = bufferAfter;\n            continue;\n          }\n          buffer.push(FreeTextEditor.#getNodeContent(child));\n        }\n      }\n      bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n    } else if (startContainer === this.editorDiv) {\n      let buffer = bufferBefore;\n      let i = 0;\n      for (const child of this.editorDiv.childNodes) {\n        if (i++ === startOffset) {\n          buffer = bufferAfter;\n        }\n        buffer.push(FreeTextEditor.#getNodeContent(child));\n      }\n    }\n    this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n    this.#setContent();\n    const newRange = new Range();\n    let beforeLength = bufferBefore.reduce((acc, line) => acc + line.length, 0);\n    for (const {\n      firstChild\n    } of this.editorDiv.childNodes) {\n      if (firstChild.nodeType === Node.TEXT_NODE) {\n        const length = firstChild.nodeValue.length;\n        if (beforeLength <= length) {\n          newRange.setStart(firstChild, beforeLength);\n          newRange.setEnd(firstChild, beforeLength);\n          break;\n        }\n        beforeLength -= length;\n      }\n    }\n    selection.removeAllRanges();\n    selection.addRange(newRange);\n  }\n  #setContent() {\n    this.editorDiv.replaceChildren();\n    if (!this.#content) {\n      return;\n    }\n    for (const line of this.#content.split(\"\\n\")) {\n      const div = document.createElement(\"div\");\n      div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n      this.editorDiv.append(div);\n    }\n  }\n  #serializeContent() {\n    return this.#content.replaceAll(\"\\xa0\", \" \");\n  }\n  static #deserializeContent(content) {\n    return content.replaceAll(\" \", \"\\xa0\");\n  }\n  get contentDiv() {\n    return this.editorDiv;\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof FreeTextAnnotationElement) {\n      const {\n        data: {\n          defaultAppearanceData: {\n            fontSize,\n            fontColor\n          },\n          rect,\n          rotation,\n          id,\n          popupRef\n        },\n        textContent,\n        textPosition,\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      if (!textContent || textContent.length === 0) {\n        return null;\n      }\n      initialData = data = {\n        annotationType: AnnotationEditorType.FREETEXT,\n        color: Array.from(fontColor),\n        fontSize,\n        value: textContent.join(\"\\n\"),\n        position: textPosition,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        id,\n        deleted: false,\n        popupRef\n      };\n    }\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.#fontSize = data.fontSize;\n    editor.#color = Util.makeHexColor(...data.color);\n    editor.#content = FreeTextEditor.#deserializeContent(data.value);\n    editor.annotationElementId = data.id || null;\n    editor._initialData = initialData;\n    return editor;\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const padding = FreeTextEditor._internalPadding * this.parentScale;\n    const rect = this.getRect(padding, padding);\n    const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n    const serialized = {\n      annotationType: AnnotationEditorType.FREETEXT,\n      color,\n      fontSize: this.#fontSize,\n      value: this.#serializeContent(),\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.rotation,\n      structTreeParentId: this._structTreeParentId\n    };\n    if (isForCopying) {\n      return serialized;\n    }\n    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n      return null;\n    }\n    serialized.id = this.annotationElementId;\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      value,\n      fontSize,\n      color,\n      pageIndex\n    } = this._initialData;\n    return this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;\n  }\n  renderAnnotationElement(annotation) {\n    const content = super.renderAnnotationElement(annotation);\n    if (this.deleted) {\n      return content;\n    }\n    const {\n      style\n    } = content;\n    style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n    style.color = this.#color;\n    content.replaceChildren();\n    for (const line of this.#content.split(\"\\n\")) {\n      const div = document.createElement(\"div\");\n      div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n      content.append(div);\n    }\n    const padding = FreeTextEditor._internalPadding * this.parentScale;\n    annotation.updateEdited({\n      rect: this.getRect(padding, padding),\n      popupContent: this.#content\n    });\n    return content;\n  }\n  resetAnnotationElement(annotation) {\n    super.resetAnnotationElement(annotation);\n    annotation.resetEdited();\n  }\n}\n\n;// ./src/display/editor/drawers/outline.js\n\nclass Outline {\n  toSVGPath() {\n    unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n  }\n  get box() {\n    unreachable(\"Abstract getter `box` must be implemented.\");\n  }\n  serialize(_bbox, _rotation) {\n    unreachable(\"Abstract method `serialize` must be implemented.\");\n  }\n  get classNamesForDrawing() {\n    unreachable(\"Abstract getter `classNamesForDrawing` must be implemented.\");\n  }\n  get classNamesForOutlining() {\n    unreachable(\"Abstract getter `classNamesForOutlining` must be implemented.\");\n  }\n  get mustRemoveSelfIntersections() {\n    return false;\n  }\n}\n\n;// ./src/display/editor/drawers/freedraw.js\n\n\nclass FreeDrawOutliner {\n  #box;\n  #bottom = [];\n  #innerMargin;\n  #isLTR;\n  #top = [];\n  #last = new Float64Array(18);\n  #lastX;\n  #lastY;\n  #min;\n  #min_dist;\n  #scaleFactor;\n  #thickness;\n  #points = [];\n  static #MIN_DIST = 8;\n  static #MIN_DIFF = 2;\n  static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n  constructor({\n    x,\n    y\n  }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n    this.#box = box;\n    this.#thickness = thickness * scaleFactor;\n    this.#isLTR = isLTR;\n    this.#last.set([NaN, NaN, NaN, NaN, x, y], 6);\n    this.#innerMargin = innerMargin;\n    this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n    this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n    this.#scaleFactor = scaleFactor;\n    this.#points.push(x, y);\n  }\n  isEmpty() {\n    return isNaN(this.#last[8]);\n  }\n  #getLastCoords() {\n    const lastTop = this.#last.subarray(4, 6);\n    const lastBottom = this.#last.subarray(16, 18);\n    const [x, y, width, height] = this.#box;\n    return [(this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width, (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height, (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width, (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height];\n  }\n  add({\n    x,\n    y\n  }) {\n    this.#lastX = x;\n    this.#lastY = y;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n    const diffX = x - x2;\n    const diffY = y - y2;\n    const d = Math.hypot(diffX, diffY);\n    if (d < this.#min) {\n      return false;\n    }\n    const diffD = d - this.#min_dist;\n    const K = diffD / d;\n    const shiftX = K * diffX;\n    const shiftY = K * diffY;\n    let x0 = x1;\n    let y0 = y1;\n    x1 = x2;\n    y1 = y2;\n    x2 += shiftX;\n    y2 += shiftY;\n    this.#points?.push(x, y);\n    const nX = -shiftY / diffD;\n    const nY = shiftX / diffD;\n    const thX = nX * this.#thickness;\n    const thY = nY * this.#thickness;\n    this.#last.set(this.#last.subarray(2, 8), 0);\n    this.#last.set([x2 + thX, y2 + thY], 4);\n    this.#last.set(this.#last.subarray(14, 18), 12);\n    this.#last.set([x2 - thX, y2 - thY], 16);\n    if (isNaN(this.#last[6])) {\n      if (this.#top.length === 0) {\n        this.#last.set([x1 + thX, y1 + thY], 2);\n        this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n        this.#last.set([x1 - thX, y1 - thY], 14);\n        this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n      }\n      this.#last.set([x0, y0, x1, y1, x2, y2], 6);\n      return !this.isEmpty();\n    }\n    this.#last.set([x0, y0, x1, y1, x2, y2], 6);\n    const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n    if (angle < Math.PI / 2) {\n      [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n      this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n      [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n      this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n      return true;\n    }\n    [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n    this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n    [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n    this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n    return true;\n  }\n  toSVGPath() {\n    if (this.isEmpty()) {\n      return \"\";\n    }\n    const top = this.#top;\n    const bottom = this.#bottom;\n    if (isNaN(this.#last[6]) && !this.isEmpty()) {\n      return this.#toSVGPathTwoPoints();\n    }\n    const buffer = [];\n    buffer.push(`M${top[4]} ${top[5]}`);\n    for (let i = 6; i < top.length; i += 6) {\n      if (isNaN(top[i])) {\n        buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n      } else {\n        buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n      }\n    }\n    this.#toSVGPathEnd(buffer);\n    for (let i = bottom.length - 6; i >= 6; i -= 6) {\n      if (isNaN(bottom[i])) {\n        buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n      } else {\n        buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n      }\n    }\n    this.#toSVGPathStart(buffer);\n    return buffer.join(\" \");\n  }\n  #toSVGPathTwoPoints() {\n    const [x, y, width, height] = this.#box;\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n  }\n  #toSVGPathStart(buffer) {\n    const bottom = this.#bottom;\n    buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n  }\n  #toSVGPathEnd(buffer) {\n    const [x, y, width, height] = this.#box;\n    const lastTop = this.#last.subarray(4, 6);\n    const lastBottom = this.#last.subarray(16, 18);\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n  }\n  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n    return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n  }\n  getOutlines() {\n    const top = this.#top;\n    const bottom = this.#bottom;\n    const last = this.#last;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const points = new Float64Array((this.#points?.length ?? 0) + 2);\n    for (let i = 0, ii = points.length - 2; i < ii; i += 2) {\n      points[i] = (this.#points[i] - layerX) / layerWidth;\n      points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n    }\n    points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n    points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n    if (isNaN(last[6]) && !this.isEmpty()) {\n      return this.#getOutlineTwoPoints(points);\n    }\n    const outline = new Float64Array(this.#top.length + 24 + this.#bottom.length);\n    let N = top.length;\n    for (let i = 0; i < N; i += 2) {\n      if (isNaN(top[i])) {\n        outline[i] = outline[i + 1] = NaN;\n        continue;\n      }\n      outline[i] = top[i];\n      outline[i + 1] = top[i + 1];\n    }\n    N = this.#getOutlineEnd(outline, N);\n    for (let i = bottom.length - 6; i >= 6; i -= 6) {\n      for (let j = 0; j < 6; j += 2) {\n        if (isNaN(bottom[i + j])) {\n          outline[N] = outline[N + 1] = NaN;\n          N += 2;\n          continue;\n        }\n        outline[N] = bottom[i + j];\n        outline[N + 1] = bottom[i + j + 1];\n        N += 2;\n      }\n    }\n    this.#getOutlineStart(outline, N);\n    return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n  }\n  #getOutlineTwoPoints(points) {\n    const last = this.#last;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    const outline = new Float64Array(36);\n    outline.set([NaN, NaN, NaN, NaN, (last[2] - layerX) / layerWidth, (last[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[4] - layerX) / layerWidth, (last[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last[16] - layerX) / layerWidth, (last[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[14] - layerX) / layerWidth, (last[15] - layerY) / layerHeight], 0);\n    return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n  }\n  #getOutlineStart(outline, pos) {\n    const bottom = this.#bottom;\n    outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], pos);\n    return pos += 6;\n  }\n  #getOutlineEnd(outline, pos) {\n    const lastTop = this.#last.subarray(4, 6);\n    const lastBottom = this.#last.subarray(16, 18);\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], pos);\n    return pos += 24;\n  }\n}\nclass FreeDrawOutline extends Outline {\n  #box;\n  #bbox = null;\n  #innerMargin;\n  #isLTR;\n  #points;\n  #scaleFactor;\n  #outline;\n  constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {\n    super();\n    this.#outline = outline;\n    this.#points = points;\n    this.#box = box;\n    this.#scaleFactor = scaleFactor;\n    this.#innerMargin = innerMargin;\n    this.#isLTR = isLTR;\n    this.#computeMinMax(isLTR);\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.#bbox;\n    for (let i = 0, ii = outline.length; i < ii; i += 2) {\n      outline[i] = (outline[i] - x) / width;\n      outline[i + 1] = (outline[i + 1] - y) / height;\n    }\n    for (let i = 0, ii = points.length; i < ii; i += 2) {\n      points[i] = (points[i] - x) / width;\n      points[i + 1] = (points[i + 1] - y) / height;\n    }\n  }\n  toSVGPath() {\n    const buffer = [`M${this.#outline[4]} ${this.#outline[5]}`];\n    for (let i = 6, ii = this.#outline.length; i < ii; i += 6) {\n      if (isNaN(this.#outline[i])) {\n        buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        continue;\n      }\n      buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n    }\n    buffer.push(\"Z\");\n    return buffer.join(\" \");\n  }\n  serialize([blX, blY, trX, trY], rotation) {\n    const width = trX - blX;\n    const height = trY - blY;\n    let outline;\n    let points;\n    switch (rotation) {\n      case 0:\n        outline = this.#rescale(this.#outline, blX, trY, width, -height);\n        points = this.#rescale(this.#points, blX, trY, width, -height);\n        break;\n      case 90:\n        outline = this.#rescaleAndSwap(this.#outline, blX, blY, width, height);\n        points = this.#rescaleAndSwap(this.#points, blX, blY, width, height);\n        break;\n      case 180:\n        outline = this.#rescale(this.#outline, trX, blY, -width, height);\n        points = this.#rescale(this.#points, trX, blY, -width, height);\n        break;\n      case 270:\n        outline = this.#rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n        points = this.#rescaleAndSwap(this.#points, trX, trY, -width, -height);\n        break;\n    }\n    return {\n      outline: Array.from(outline),\n      points: [Array.from(points)]\n    };\n  }\n  #rescale(src, tx, ty, sx, sy) {\n    const dest = new Float64Array(src.length);\n    for (let i = 0, ii = src.length; i < ii; i += 2) {\n      dest[i] = tx + src[i] * sx;\n      dest[i + 1] = ty + src[i + 1] * sy;\n    }\n    return dest;\n  }\n  #rescaleAndSwap(src, tx, ty, sx, sy) {\n    const dest = new Float64Array(src.length);\n    for (let i = 0, ii = src.length; i < ii; i += 2) {\n      dest[i] = tx + src[i + 1] * sx;\n      dest[i + 1] = ty + src[i] * sy;\n    }\n    return dest;\n  }\n  #computeMinMax(isLTR) {\n    const outline = this.#outline;\n    let lastX = outline[4];\n    let lastY = outline[5];\n    let minX = lastX;\n    let minY = lastY;\n    let maxX = lastX;\n    let maxY = lastY;\n    let lastPointX = lastX;\n    let lastPointY = lastY;\n    const ltrCallback = isLTR ? Math.max : Math.min;\n    for (let i = 6, ii = outline.length; i < ii; i += 6) {\n      if (isNaN(outline[i])) {\n        minX = Math.min(minX, outline[i + 4]);\n        minY = Math.min(minY, outline[i + 5]);\n        maxX = Math.max(maxX, outline[i + 4]);\n        maxY = Math.max(maxY, outline[i + 5]);\n        if (lastPointY < outline[i + 5]) {\n          lastPointX = outline[i + 4];\n          lastPointY = outline[i + 5];\n        } else if (lastPointY === outline[i + 5]) {\n          lastPointX = ltrCallback(lastPointX, outline[i + 4]);\n        }\n      } else {\n        const bbox = Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6));\n        minX = Math.min(minX, bbox[0]);\n        minY = Math.min(minY, bbox[1]);\n        maxX = Math.max(maxX, bbox[2]);\n        maxY = Math.max(maxY, bbox[3]);\n        if (lastPointY < bbox[3]) {\n          lastPointX = bbox[2];\n          lastPointY = bbox[3];\n        } else if (lastPointY === bbox[3]) {\n          lastPointX = ltrCallback(lastPointX, bbox[2]);\n        }\n      }\n      lastX = outline[i + 4];\n      lastY = outline[i + 5];\n    }\n    const x = minX - this.#innerMargin,\n      y = minY - this.#innerMargin,\n      width = maxX - minX + 2 * this.#innerMargin,\n      height = maxY - minY + 2 * this.#innerMargin;\n    this.#bbox = {\n      x,\n      y,\n      width,\n      height,\n      lastPoint: [lastPointX, lastPointY]\n    };\n  }\n  get box() {\n    return this.#bbox;\n  }\n  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n    return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n  }\n  getNewOutline(thickness, innerMargin) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.#bbox;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const sx = width * layerWidth;\n    const sy = height * layerHeight;\n    const tx = x * layerWidth + layerX;\n    const ty = y * layerHeight + layerY;\n    const outliner = this.newOutliner({\n      x: this.#points[0] * sx + tx,\n      y: this.#points[1] * sy + ty\n    }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n    for (let i = 2; i < this.#points.length; i += 2) {\n      outliner.add({\n        x: this.#points[i] * sx + tx,\n        y: this.#points[i + 1] * sy + ty\n      });\n    }\n    return outliner.getOutlines();\n  }\n  get mustRemoveSelfIntersections() {\n    return true;\n  }\n}\n\n;// ./src/display/editor/drawers/highlight.js\n\n\nclass HighlightOutliner {\n  #box;\n  #verticalEdges = [];\n  #intervals = [];\n  constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    const NUMBER_OF_DIGITS = 4;\n    const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n    for (const {\n      x,\n      y,\n      width,\n      height\n    } of boxes) {\n      const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n      const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n      const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n      const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n      const left = [x1, y1, y2, true];\n      const right = [x2, y1, y2, false];\n      this.#verticalEdges.push(left, right);\n      minX = Math.min(minX, x1);\n      maxX = Math.max(maxX, x2);\n      minY = Math.min(minY, y1);\n      maxY = Math.max(maxY, y2);\n    }\n    const bboxWidth = maxX - minX + 2 * innerMargin;\n    const bboxHeight = maxY - minY + 2 * innerMargin;\n    const shiftedMinX = minX - innerMargin;\n    const shiftedMinY = minY - innerMargin;\n    const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n    const lastPoint = [lastEdge[0], lastEdge[2]];\n    for (const edge of this.#verticalEdges) {\n      const [x, y1, y2] = edge;\n      edge[0] = (x - shiftedMinX) / bboxWidth;\n      edge[1] = (y1 - shiftedMinY) / bboxHeight;\n      edge[2] = (y2 - shiftedMinY) / bboxHeight;\n    }\n    this.#box = {\n      x: shiftedMinX,\n      y: shiftedMinY,\n      width: bboxWidth,\n      height: bboxHeight,\n      lastPoint\n    };\n  }\n  getOutlines() {\n    this.#verticalEdges.sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n    const outlineVerticalEdges = [];\n    for (const edge of this.#verticalEdges) {\n      if (edge[3]) {\n        outlineVerticalEdges.push(...this.#breakEdge(edge));\n        this.#insert(edge);\n      } else {\n        this.#remove(edge);\n        outlineVerticalEdges.push(...this.#breakEdge(edge));\n      }\n    }\n    return this.#getOutlines(outlineVerticalEdges);\n  }\n  #getOutlines(outlineVerticalEdges) {\n    const edges = [];\n    const allEdges = new Set();\n    for (const edge of outlineVerticalEdges) {\n      const [x, y1, y2] = edge;\n      edges.push([x, y1, edge], [x, y2, edge]);\n    }\n    edges.sort((a, b) => a[1] - b[1] || a[0] - b[0]);\n    for (let i = 0, ii = edges.length; i < ii; i += 2) {\n      const edge1 = edges[i][2];\n      const edge2 = edges[i + 1][2];\n      edge1.push(edge2);\n      edge2.push(edge1);\n      allEdges.add(edge1);\n      allEdges.add(edge2);\n    }\n    const outlines = [];\n    let outline;\n    while (allEdges.size > 0) {\n      const edge = allEdges.values().next().value;\n      let [x, y1, y2, edge1, edge2] = edge;\n      allEdges.delete(edge);\n      let lastPointX = x;\n      let lastPointY = y1;\n      outline = [x, y2];\n      outlines.push(outline);\n      while (true) {\n        let e;\n        if (allEdges.has(edge1)) {\n          e = edge1;\n        } else if (allEdges.has(edge2)) {\n          e = edge2;\n        } else {\n          break;\n        }\n        allEdges.delete(e);\n        [x, y1, y2, edge1, edge2] = e;\n        if (lastPointX !== x) {\n          outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n          lastPointX = x;\n        }\n        lastPointY = lastPointY === y1 ? y2 : y1;\n      }\n      outline.push(lastPointX, lastPointY);\n    }\n    return new HighlightOutline(outlines, this.#box);\n  }\n  #binarySearch(y) {\n    const array = this.#intervals;\n    let start = 0;\n    let end = array.length - 1;\n    while (start <= end) {\n      const middle = start + end >> 1;\n      const y1 = array[middle][0];\n      if (y1 === y) {\n        return middle;\n      }\n      if (y1 < y) {\n        start = middle + 1;\n      } else {\n        end = middle - 1;\n      }\n    }\n    return end + 1;\n  }\n  #insert([, y1, y2]) {\n    const index = this.#binarySearch(y1);\n    this.#intervals.splice(index, 0, [y1, y2]);\n  }\n  #remove([, y1, y2]) {\n    const index = this.#binarySearch(y1);\n    for (let i = index; i < this.#intervals.length; i++) {\n      const [start, end] = this.#intervals[i];\n      if (start !== y1) {\n        break;\n      }\n      if (start === y1 && end === y2) {\n        this.#intervals.splice(i, 1);\n        return;\n      }\n    }\n    for (let i = index - 1; i >= 0; i--) {\n      const [start, end] = this.#intervals[i];\n      if (start !== y1) {\n        break;\n      }\n      if (start === y1 && end === y2) {\n        this.#intervals.splice(i, 1);\n        return;\n      }\n    }\n  }\n  #breakEdge(edge) {\n    const [x, y1, y2] = edge;\n    const results = [[x, y1, y2]];\n    const index = this.#binarySearch(y2);\n    for (let i = 0; i < index; i++) {\n      const [start, end] = this.#intervals[i];\n      for (let j = 0, jj = results.length; j < jj; j++) {\n        const [, y3, y4] = results[j];\n        if (end <= y3 || y4 <= start) {\n          continue;\n        }\n        if (y3 >= start) {\n          if (y4 > end) {\n            results[j][1] = end;\n          } else {\n            if (jj === 1) {\n              return [];\n            }\n            results.splice(j, 1);\n            j--;\n            jj--;\n          }\n          continue;\n        }\n        results[j][2] = start;\n        if (y4 > end) {\n          results.push([x, end, y4]);\n        }\n      }\n    }\n    return results;\n  }\n}\nclass HighlightOutline extends Outline {\n  #box;\n  #outlines;\n  constructor(outlines, box) {\n    super();\n    this.#outlines = outlines;\n    this.#box = box;\n  }\n  toSVGPath() {\n    const buffer = [];\n    for (const polygon of this.#outlines) {\n      let [prevX, prevY] = polygon;\n      buffer.push(`M${prevX} ${prevY}`);\n      for (let i = 2; i < polygon.length; i += 2) {\n        const x = polygon[i];\n        const y = polygon[i + 1];\n        if (x === prevX) {\n          buffer.push(`V${y}`);\n          prevY = y;\n        } else if (y === prevY) {\n          buffer.push(`H${x}`);\n          prevX = x;\n        }\n      }\n      buffer.push(\"Z\");\n    }\n    return buffer.join(\" \");\n  }\n  serialize([blX, blY, trX, trY], _rotation) {\n    const outlines = [];\n    const width = trX - blX;\n    const height = trY - blY;\n    for (const outline of this.#outlines) {\n      const points = new Array(outline.length);\n      for (let i = 0; i < outline.length; i += 2) {\n        points[i] = blX + outline[i] * width;\n        points[i + 1] = trY - outline[i + 1] * height;\n      }\n      outlines.push(points);\n    }\n    return outlines;\n  }\n  get box() {\n    return this.#box;\n  }\n  get classNamesForDrawing() {\n    return [\"highlight\"];\n  }\n  get classNamesForOutlining() {\n    return [\"highlightOutline\"];\n  }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n    return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n  }\n  get classNamesForDrawing() {\n    return [\"highlight\", \"free\"];\n  }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n  get classNamesForDrawing() {\n    return [\"highlight\", \"free\"];\n  }\n  get classNamesForOutlining() {\n    return [\"highlightOutline\", \"free\"];\n  }\n  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n    return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n  }\n}\n\n;// ./src/display/editor/color_picker.js\n\n\n\nclass ColorPicker {\n  #button = null;\n  #buttonSwatch = null;\n  #defaultColor;\n  #dropdown = null;\n  #dropdownWasFromKeyboard = false;\n  #isMainColorPicker = false;\n  #editor = null;\n  #eventBus;\n  #openDropdownAC = null;\n  #uiManager = null;\n  #type;\n  static #l10nColor = null;\n  static get _keyboardManager() {\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"Escape\", \"mac+Escape\"], ColorPicker.prototype._hideDropdownFromKeyboard], [[\" \", \"mac+ \"], ColorPicker.prototype._colorSelectFromKeyboard], [[\"ArrowDown\", \"ArrowRight\", \"mac+ArrowDown\", \"mac+ArrowRight\"], ColorPicker.prototype._moveToNext], [[\"ArrowUp\", \"ArrowLeft\", \"mac+ArrowUp\", \"mac+ArrowLeft\"], ColorPicker.prototype._moveToPrevious], [[\"Home\", \"mac+Home\"], ColorPicker.prototype._moveToBeginning], [[\"End\", \"mac+End\"], ColorPicker.prototype._moveToEnd]]));\n  }\n  constructor({\n    editor = null,\n    uiManager = null\n  }) {\n    if (editor) {\n      this.#isMainColorPicker = false;\n      this.#type = AnnotationEditorParamsType.HIGHLIGHT_COLOR;\n      this.#editor = editor;\n    } else {\n      this.#isMainColorPicker = true;\n      this.#type = AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR;\n    }\n    this.#uiManager = editor?._uiManager || uiManager;\n    this.#eventBus = this.#uiManager._eventBus;\n    this.#defaultColor = editor?.color || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n    ColorPicker.#l10nColor ||= Object.freeze({\n      blue: \"pdfjs-editor-colorpicker-blue\",\n      green: \"pdfjs-editor-colorpicker-green\",\n      pink: \"pdfjs-editor-colorpicker-pink\",\n      red: \"pdfjs-editor-colorpicker-red\",\n      yellow: \"pdfjs-editor-colorpicker-yellow\"\n    });\n  }\n  renderButton() {\n    const button = this.#button = document.createElement(\"button\");\n    button.className = \"colorPicker\";\n    button.tabIndex = \"0\";\n    button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n    button.setAttribute(\"aria-haspopup\", true);\n    const signal = this.#uiManager._signal;\n    button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n      signal\n    });\n    button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n      signal\n    });\n    const swatch = this.#buttonSwatch = document.createElement(\"span\");\n    swatch.className = \"swatch\";\n    swatch.setAttribute(\"aria-hidden\", true);\n    swatch.style.backgroundColor = this.#defaultColor;\n    button.append(swatch);\n    return button;\n  }\n  renderMainDropdown() {\n    const dropdown = this.#dropdown = this.#getDropdownRoot();\n    dropdown.setAttribute(\"aria-orientation\", \"horizontal\");\n    dropdown.setAttribute(\"aria-labelledby\", \"highlightColorPickerLabel\");\n    return dropdown;\n  }\n  #getDropdownRoot() {\n    const div = document.createElement(\"div\");\n    const signal = this.#uiManager._signal;\n    div.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    div.className = \"dropdown\";\n    div.role = \"listbox\";\n    div.setAttribute(\"aria-multiselectable\", false);\n    div.setAttribute(\"aria-orientation\", \"vertical\");\n    div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n    for (const [name, color] of this.#uiManager.highlightColors) {\n      const button = document.createElement(\"button\");\n      button.tabIndex = \"0\";\n      button.role = \"option\";\n      button.setAttribute(\"data-color\", color);\n      button.title = name;\n      button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n      const swatch = document.createElement(\"span\");\n      button.append(swatch);\n      swatch.className = \"swatch\";\n      swatch.style.backgroundColor = color;\n      button.setAttribute(\"aria-selected\", color === this.#defaultColor);\n      button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n        signal\n      });\n      div.append(button);\n    }\n    div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n      signal\n    });\n    return div;\n  }\n  #colorSelect(color, event) {\n    event.stopPropagation();\n    this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n      source: this,\n      type: this.#type,\n      value: color\n    });\n  }\n  _colorSelectFromKeyboard(event) {\n    if (event.target === this.#button) {\n      this.#openDropdown(event);\n      return;\n    }\n    const color = event.target.getAttribute(\"data-color\");\n    if (!color) {\n      return;\n    }\n    this.#colorSelect(color, event);\n  }\n  _moveToNext(event) {\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n      return;\n    }\n    if (event.target === this.#button) {\n      this.#dropdown.firstChild?.focus();\n      return;\n    }\n    event.target.nextSibling?.focus();\n  }\n  _moveToPrevious(event) {\n    if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {\n      if (this.#isDropdownVisible) {\n        this._hideDropdownFromKeyboard();\n      }\n      return;\n    }\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n    }\n    event.target.previousSibling?.focus();\n  }\n  _moveToBeginning(event) {\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n      return;\n    }\n    this.#dropdown.firstChild?.focus();\n  }\n  _moveToEnd(event) {\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n      return;\n    }\n    this.#dropdown.lastChild?.focus();\n  }\n  #keyDown(event) {\n    ColorPicker._keyboardManager.exec(this, event);\n  }\n  #openDropdown(event) {\n    if (this.#isDropdownVisible) {\n      this.hideDropdown();\n      return;\n    }\n    this.#dropdownWasFromKeyboard = event.detail === 0;\n    if (!this.#openDropdownAC) {\n      this.#openDropdownAC = new AbortController();\n      window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n        signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n      });\n    }\n    if (this.#dropdown) {\n      this.#dropdown.classList.remove(\"hidden\");\n      return;\n    }\n    const root = this.#dropdown = this.#getDropdownRoot();\n    this.#button.append(root);\n  }\n  #pointerDown(event) {\n    if (this.#dropdown?.contains(event.target)) {\n      return;\n    }\n    this.hideDropdown();\n  }\n  hideDropdown() {\n    this.#dropdown?.classList.add(\"hidden\");\n    this.#openDropdownAC?.abort();\n    this.#openDropdownAC = null;\n  }\n  get #isDropdownVisible() {\n    return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n  }\n  _hideDropdownFromKeyboard() {\n    if (this.#isMainColorPicker) {\n      return;\n    }\n    if (!this.#isDropdownVisible) {\n      this.#editor?.unselect();\n      return;\n    }\n    this.hideDropdown();\n    this.#button.focus({\n      preventScroll: true,\n      focusVisible: this.#dropdownWasFromKeyboard\n    });\n  }\n  updateColor(color) {\n    if (this.#buttonSwatch) {\n      this.#buttonSwatch.style.backgroundColor = color;\n    }\n    if (!this.#dropdown) {\n      return;\n    }\n    const i = this.#uiManager.highlightColors.values();\n    for (const child of this.#dropdown.children) {\n      child.setAttribute(\"aria-selected\", i.next().value === color);\n    }\n  }\n  destroy() {\n    this.#button?.remove();\n    this.#button = null;\n    this.#buttonSwatch = null;\n    this.#dropdown?.remove();\n    this.#dropdown = null;\n  }\n}\n\n;// ./src/display/editor/highlight.js\n\n\n\n\n\n\n\nclass HighlightEditor extends AnnotationEditor {\n  #anchorNode = null;\n  #anchorOffset = 0;\n  #boxes;\n  #clipPathId = null;\n  #colorPicker = null;\n  #focusOutlines = null;\n  #focusNode = null;\n  #focusOffset = 0;\n  #highlightDiv = null;\n  #highlightOutlines = null;\n  #id = null;\n  #isFreeHighlight = false;\n  #lastPoint = null;\n  #opacity;\n  #outlineId = null;\n  #text = \"\";\n  #thickness;\n  #methodOfCreation = \"\";\n  static _defaultColor = null;\n  static _defaultOpacity = 1;\n  static _defaultThickness = 12;\n  static _type = \"highlight\";\n  static _editorType = AnnotationEditorType.HIGHLIGHT;\n  static _freeHighlightId = -1;\n  static _freeHighlight = null;\n  static _freeHighlightClipId = \"\";\n  static get _keyboardManager() {\n    const proto = HighlightEditor.prototype;\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"ArrowLeft\", \"mac+ArrowLeft\"], proto._moveCaret, {\n      args: [0]\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto._moveCaret, {\n      args: [1]\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto._moveCaret, {\n      args: [2]\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto._moveCaret, {\n      args: [3]\n    }]]));\n  }\n  constructor(params) {\n    super({\n      ...params,\n      name: \"highlightEditor\"\n    });\n    this.color = params.color || HighlightEditor._defaultColor;\n    this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n    this.#opacity = params.opacity || HighlightEditor._defaultOpacity;\n    this.#boxes = params.boxes || null;\n    this.#methodOfCreation = params.methodOfCreation || \"\";\n    this.#text = params.text || \"\";\n    this._isDraggable = false;\n    if (params.highlightId > -1) {\n      this.#isFreeHighlight = true;\n      this.#createFreeOutlines(params);\n      this.#addToDrawLayer();\n    } else if (this.#boxes) {\n      this.#anchorNode = params.anchorNode;\n      this.#anchorOffset = params.anchorOffset;\n      this.#focusNode = params.focusNode;\n      this.#focusOffset = params.focusOffset;\n      this.#createOutlines();\n      this.#addToDrawLayer();\n      this.rotate(this.rotation);\n    }\n  }\n  get telemetryInitialData() {\n    return {\n      action: \"added\",\n      type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n      color: this._uiManager.highlightColorNames.get(this.color),\n      thickness: this.#thickness,\n      methodOfCreation: this.#methodOfCreation\n    };\n  }\n  get telemetryFinalData() {\n    return {\n      type: \"highlight\",\n      color: this._uiManager.highlightColorNames.get(this.color)\n    };\n  }\n  static computeTelemetryFinalData(data) {\n    return {\n      numberOfColors: data.get(\"color\").size\n    };\n  }\n  #createOutlines() {\n    const outliner = new HighlightOutliner(this.#boxes, 0.001);\n    this.#highlightOutlines = outliner.getOutlines();\n    ({\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    } = this.#highlightOutlines.box);\n    const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n    this.#focusOutlines = outlinerForOutline.getOutlines();\n    const {\n      lastPoint\n    } = this.#focusOutlines.box;\n    this.#lastPoint = [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height];\n  }\n  #createFreeOutlines({\n    highlightOutlines,\n    highlightId,\n    clipPathId\n  }) {\n    this.#highlightOutlines = highlightOutlines;\n    const extraThickness = 1.5;\n    this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);\n    if (highlightId >= 0) {\n      this.#id = highlightId;\n      this.#clipPathId = clipPathId;\n      this.parent.drawLayer.finalizeLine(highlightId, highlightOutlines);\n      this.#outlineId = this.parent.drawLayer.drawOutline(this.#focusOutlines);\n    } else if (this.parent) {\n      const angle = this.parent.viewport.rotation;\n      this.parent.drawLayer.updateLine(this.#id, highlightOutlines);\n      this.parent.drawLayer.updateBox(this.#id, HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360));\n      this.parent.drawLayer.updateLine(this.#outlineId, this.#focusOutlines);\n      this.parent.drawLayer.updateBox(this.#outlineId, HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle));\n    }\n    const {\n      x,\n      y,\n      width,\n      height\n    } = highlightOutlines.box;\n    switch (this.rotation) {\n      case 0:\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        break;\n      case 90:\n        {\n          const [pageWidth, pageHeight] = this.parentDimensions;\n          this.x = y;\n          this.y = 1 - x;\n          this.width = width * pageHeight / pageWidth;\n          this.height = height * pageWidth / pageHeight;\n          break;\n        }\n      case 180:\n        this.x = 1 - x;\n        this.y = 1 - y;\n        this.width = width;\n        this.height = height;\n        break;\n      case 270:\n        {\n          const [pageWidth, pageHeight] = this.parentDimensions;\n          this.x = 1 - y;\n          this.y = x;\n          this.width = width * pageHeight / pageWidth;\n          this.height = height * pageWidth / pageHeight;\n          break;\n        }\n    }\n    const {\n      lastPoint\n    } = this.#focusOutlines.box;\n    this.#lastPoint = [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height];\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n    HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n        HighlightEditor._defaultColor = value;\n        break;\n      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n        HighlightEditor._defaultThickness = value;\n        break;\n    }\n  }\n  translateInPage(x, y) {}\n  get toolbarPosition() {\n    return this.#lastPoint;\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n        this.#updateColor(value);\n        break;\n      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n        this.#updateThickness(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR, HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, HighlightEditor._defaultThickness]];\n  }\n  get propertiesToUpdate() {\n    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, this.#thickness || HighlightEditor._defaultThickness], [AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#isFreeHighlight]];\n  }\n  #updateColor(color) {\n    const setColorAndOpacity = (col, opa) => {\n      this.color = col;\n      this.parent?.drawLayer.changeColor(this.#id, col);\n      this.#colorPicker?.updateColor(col);\n      this.#opacity = opa;\n      this.parent?.drawLayer.changeOpacity(this.#id, opa);\n    };\n    const savedColor = this.color;\n    const savedOpacity = this.#opacity;\n    this.addCommands({\n      cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n      undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n    this._reportTelemetry({\n      action: \"color_changed\",\n      color: this._uiManager.highlightColorNames.get(color)\n    }, true);\n  }\n  #updateThickness(thickness) {\n    const savedThickness = this.#thickness;\n    const setThickness = th => {\n      this.#thickness = th;\n      this.#changeThickness(th);\n    };\n    this.addCommands({\n      cmd: setThickness.bind(this, thickness),\n      undo: setThickness.bind(this, savedThickness),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.INK_THICKNESS,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n    this._reportTelemetry({\n      action: \"thickness_changed\",\n      thickness\n    }, true);\n  }\n  async addEditToolbar() {\n    const toolbar = await super.addEditToolbar();\n    if (!toolbar) {\n      return null;\n    }\n    if (this._uiManager.highlightColors) {\n      this.#colorPicker = new ColorPicker({\n        editor: this\n      });\n      toolbar.addColorPicker(this.#colorPicker);\n    }\n    return toolbar;\n  }\n  disableEditing() {\n    super.disableEditing();\n    this.div.classList.toggle(\"disabled\", true);\n  }\n  enableEditing() {\n    super.enableEditing();\n    this.div.classList.toggle(\"disabled\", false);\n  }\n  fixAndSetPosition() {\n    return super.fixAndSetPosition(this.#getRotation());\n  }\n  getBaseTranslation() {\n    return [0, 0];\n  }\n  getRect(tx, ty) {\n    return super.getRect(tx, ty, this.#getRotation());\n  }\n  onceAdded() {\n    if (!this.annotationElementId) {\n      this.parent.addUndoableEditor(this);\n    }\n    this.div.focus();\n  }\n  remove() {\n    this.#cleanDrawLayer();\n    this._reportTelemetry({\n      action: \"deleted\"\n    });\n    super.remove();\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    this.#addToDrawLayer();\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  setParent(parent) {\n    let mustBeSelected = false;\n    if (this.parent && !parent) {\n      this.#cleanDrawLayer();\n    } else if (parent) {\n      this.#addToDrawLayer(parent);\n      mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n    }\n    super.setParent(parent);\n    this.show(this._isVisible);\n    if (mustBeSelected) {\n      this.select();\n    }\n  }\n  #changeThickness(thickness) {\n    if (!this.#isFreeHighlight) {\n      return;\n    }\n    this.#createFreeOutlines({\n      highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n    });\n    this.fixAndSetPosition();\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setDims(this.width * parentWidth, this.height * parentHeight);\n  }\n  #cleanDrawLayer() {\n    if (this.#id === null || !this.parent) {\n      return;\n    }\n    this.parent.drawLayer.remove(this.#id);\n    this.#id = null;\n    this.parent.drawLayer.remove(this.#outlineId);\n    this.#outlineId = null;\n  }\n  #addToDrawLayer(parent = this.parent) {\n    if (this.#id !== null) {\n      return;\n    }\n    ({\n      id: this.#id,\n      clipPathId: this.#clipPathId\n    } = parent.drawLayer.draw(this.#highlightOutlines, this.color, this.#opacity));\n    this.#outlineId = parent.drawLayer.drawOutline(this.#focusOutlines);\n    if (this.#highlightDiv) {\n      this.#highlightDiv.style.clipPath = this.#clipPathId;\n    }\n  }\n  static #rotateBbox({\n    x,\n    y,\n    width,\n    height\n  }, angle) {\n    switch (angle) {\n      case 90:\n        return {\n          x: 1 - y - height,\n          y: x,\n          width: height,\n          height: width\n        };\n      case 180:\n        return {\n          x: 1 - x - width,\n          y: 1 - y - height,\n          width,\n          height\n        };\n      case 270:\n        return {\n          x: y,\n          y: 1 - x - width,\n          width: height,\n          height: width\n        };\n    }\n    return {\n      x,\n      y,\n      width,\n      height\n    };\n  }\n  rotate(angle) {\n    const {\n      drawLayer\n    } = this.parent;\n    let box;\n    if (this.#isFreeHighlight) {\n      angle = (angle - this.rotation + 360) % 360;\n      box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n    } else {\n      box = HighlightEditor.#rotateBbox(this, angle);\n    }\n    drawLayer.rotate(this.#id, angle);\n    drawLayer.rotate(this.#outlineId, angle);\n    drawLayer.updateBox(this.#id, box);\n    drawLayer.updateBox(this.#outlineId, HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle));\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    const div = super.render();\n    if (this.#text) {\n      div.setAttribute(\"aria-label\", this.#text);\n      div.setAttribute(\"role\", \"mark\");\n    }\n    if (this.#isFreeHighlight) {\n      div.classList.add(\"free\");\n    } else {\n      this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n        signal: this._uiManager._signal\n      });\n    }\n    const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n    div.append(highlightDiv);\n    highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n    highlightDiv.className = \"internal\";\n    highlightDiv.style.clipPath = this.#clipPathId;\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setDims(this.width * parentWidth, this.height * parentHeight);\n    bindEvents(this, this.#highlightDiv, [\"pointerover\", \"pointerleave\"]);\n    this.enableEditing();\n    return div;\n  }\n  pointerover() {\n    if (!this.isSelected) {\n      this.parent.drawLayer.addClass(this.#outlineId, \"hovered\");\n    }\n  }\n  pointerleave() {\n    if (!this.isSelected) {\n      this.parent.drawLayer.removeClass(this.#outlineId, \"hovered\");\n    }\n  }\n  #keydown(event) {\n    HighlightEditor._keyboardManager.exec(this, event);\n  }\n  _moveCaret(direction) {\n    this.parent.unselect(this);\n    switch (direction) {\n      case 0:\n      case 2:\n        this.#setCaret(true);\n        break;\n      case 1:\n      case 3:\n        this.#setCaret(false);\n        break;\n    }\n  }\n  #setCaret(start) {\n    if (!this.#anchorNode) {\n      return;\n    }\n    const selection = window.getSelection();\n    if (start) {\n      selection.setPosition(this.#anchorNode, this.#anchorOffset);\n    } else {\n      selection.setPosition(this.#focusNode, this.#focusOffset);\n    }\n  }\n  select() {\n    super.select();\n    if (!this.#outlineId) {\n      return;\n    }\n    this.parent?.drawLayer.removeClass(this.#outlineId, \"hovered\");\n    this.parent?.drawLayer.addClass(this.#outlineId, \"selected\");\n  }\n  unselect() {\n    super.unselect();\n    if (!this.#outlineId) {\n      return;\n    }\n    this.parent?.drawLayer.removeClass(this.#outlineId, \"selected\");\n    if (!this.#isFreeHighlight) {\n      this.#setCaret(false);\n    }\n  }\n  get _mustFixPosition() {\n    return !this.#isFreeHighlight;\n  }\n  show(visible = this._isVisible) {\n    super.show(visible);\n    if (this.parent) {\n      this.parent.drawLayer.show(this.#id, visible);\n      this.parent.drawLayer.show(this.#outlineId, visible);\n    }\n  }\n  #getRotation() {\n    return this.#isFreeHighlight ? this.rotation : 0;\n  }\n  #serializeBoxes() {\n    if (this.#isFreeHighlight) {\n      return null;\n    }\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const [pageX, pageY] = this.pageTranslation;\n    const boxes = this.#boxes;\n    const quadPoints = new Float32Array(boxes.length * 8);\n    let i = 0;\n    for (const {\n      x,\n      y,\n      width,\n      height\n    } of boxes) {\n      const sx = x * pageWidth + pageX;\n      const sy = (1 - y - height) * pageHeight + pageY;\n      quadPoints[i] = quadPoints[i + 4] = sx;\n      quadPoints[i + 1] = quadPoints[i + 3] = sy;\n      quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n      quadPoints[i + 5] = quadPoints[i + 7] = sy + height * pageHeight;\n      i += 8;\n    }\n    return quadPoints;\n  }\n  #serializeOutlines(rect) {\n    return this.#highlightOutlines.serialize(rect, this.#getRotation());\n  }\n  static startHighlighting(parent, isLTR, {\n    target: textLayer,\n    x,\n    y\n  }) {\n    const {\n      x: layerX,\n      y: layerY,\n      width: parentWidth,\n      height: parentHeight\n    } = textLayer.getBoundingClientRect();\n    const ac = new AbortController();\n    const signal = parent.combinedSignal(ac);\n    const pointerDown = e => {\n      e.preventDefault();\n      e.stopPropagation();\n    };\n    const pointerUpCallback = e => {\n      ac.abort();\n      this.#endHighlight(parent, e);\n    };\n    window.addEventListener(\"blur\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"pointerup\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"pointerdown\", pointerDown, {\n      capture: true,\n      passive: false,\n      signal\n    });\n    window.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n      signal\n    });\n    this._freeHighlight = new FreeHighlightOutliner({\n      x,\n      y\n    }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 0.001);\n    ({\n      id: this._freeHighlightId,\n      clipPathId: this._freeHighlightClipId\n    } = parent.drawLayer.draw(this._freeHighlight, this._defaultColor, this._defaultOpacity, true));\n  }\n  static #highlightMove(parent, event) {\n    if (this._freeHighlight.add(event)) {\n      parent.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);\n    }\n  }\n  static #endHighlight(parent, event) {\n    if (!this._freeHighlight.isEmpty()) {\n      parent.createAndAddNewEditor(event, false, {\n        highlightId: this._freeHighlightId,\n        highlightOutlines: this._freeHighlight.getOutlines(),\n        clipPathId: this._freeHighlightClipId,\n        methodOfCreation: \"main_toolbar\"\n      });\n    } else {\n      parent.drawLayer.remove(this._freeHighlightId);\n    }\n    this._freeHighlightId = -1;\n    this._freeHighlight = null;\n    this._freeHighlightClipId = \"\";\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof HighlightAnnotationElement) {\n      const {\n        data: {\n          quadPoints,\n          rect,\n          rotation,\n          id,\n          color,\n          opacity,\n          popupRef\n        },\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      initialData = data = {\n        annotationType: AnnotationEditorType.HIGHLIGHT,\n        color: Array.from(color),\n        opacity,\n        quadPoints,\n        boxes: null,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        id,\n        deleted: false,\n        popupRef\n      };\n    } else if (data instanceof InkAnnotationElement) {\n      const {\n        data: {\n          inkLists,\n          rect,\n          rotation,\n          id,\n          color,\n          borderStyle: {\n            rawWidth: thickness\n          },\n          popupRef\n        },\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      initialData = data = {\n        annotationType: AnnotationEditorType.HIGHLIGHT,\n        color: Array.from(color),\n        thickness,\n        inkLists,\n        boxes: null,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        id,\n        deleted: false,\n        popupRef\n      };\n    }\n    const {\n      color,\n      quadPoints,\n      inkLists,\n      opacity\n    } = data;\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.color = Util.makeHexColor(...color);\n    editor.#opacity = opacity || 1;\n    if (inkLists) {\n      editor.#thickness = data.thickness;\n    }\n    editor.annotationElementId = data.id || null;\n    editor._initialData = initialData;\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const [pageX, pageY] = editor.pageTranslation;\n    if (quadPoints) {\n      const boxes = editor.#boxes = [];\n      for (let i = 0; i < quadPoints.length; i += 8) {\n        boxes.push({\n          x: (quadPoints[i] - pageX) / pageWidth,\n          y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n          width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n          height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n        });\n      }\n      editor.#createOutlines();\n      editor.#addToDrawLayer();\n      editor.rotate(editor.rotation);\n    } else if (inkLists) {\n      editor.#isFreeHighlight = true;\n      const points = inkLists[0];\n      const point = {\n        x: points[0] - pageX,\n        y: pageHeight - (points[1] - pageY)\n      };\n      const outliner = new FreeHighlightOutliner(point, [0, 0, pageWidth, pageHeight], 1, editor.#thickness / 2, true, 0.001);\n      for (let i = 0, ii = points.length; i < ii; i += 2) {\n        point.x = points[i] - pageX;\n        point.y = pageHeight - (points[i + 1] - pageY);\n        outliner.add(point);\n      }\n      const {\n        id,\n        clipPathId\n      } = parent.drawLayer.draw(outliner, editor.color, editor._defaultOpacity, true);\n      editor.#createFreeOutlines({\n        highlightOutlines: outliner.getOutlines(),\n        highlightId: id,\n        clipPathId\n      });\n      editor.#addToDrawLayer();\n    }\n    return editor;\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty() || isForCopying) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const rect = this.getRect(0, 0);\n    const color = AnnotationEditor._colorManager.convert(this.color);\n    const serialized = {\n      annotationType: AnnotationEditorType.HIGHLIGHT,\n      color,\n      opacity: this.#opacity,\n      thickness: this.#thickness,\n      quadPoints: this.#serializeBoxes(),\n      outlines: this.#serializeOutlines(rect),\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.#getRotation(),\n      structTreeParentId: this._structTreeParentId\n    };\n    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n      return null;\n    }\n    serialized.id = this.annotationElementId;\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      color\n    } = this._initialData;\n    return serialized.color.some((c, i) => c !== color[i]);\n  }\n  renderAnnotationElement(annotation) {\n    annotation.updateEdited({\n      rect: this.getRect(0, 0)\n    });\n    return null;\n  }\n  static canCreateNewEmptyEditor() {\n    return false;\n  }\n}\n\n;// ./src/display/editor/ink.js\n\n\n\n\n\nclass InkEditor extends AnnotationEditor {\n  #baseHeight = 0;\n  #baseWidth = 0;\n  #canvasContextMenuTimeoutId = null;\n  #currentPath2D = new Path2D();\n  #disableEditing = false;\n  #drawingAC = null;\n  #hasSomethingToDraw = false;\n  #isCanvasInitialized = false;\n  #observer = null;\n  #pointerdownAC = null;\n  #realWidth = 0;\n  #realHeight = 0;\n  #requestFrameCallback = null;\n  static _defaultColor = null;\n  static _defaultOpacity = 1;\n  static _defaultThickness = 1;\n  static _type = \"ink\";\n  static _editorType = AnnotationEditorType.INK;\n  constructor(params) {\n    super({\n      ...params,\n      name: \"inkEditor\"\n    });\n    this.color = params.color || null;\n    this.thickness = params.thickness || null;\n    this.opacity = params.opacity || null;\n    this.paths = [];\n    this.bezierPath2D = [];\n    this.allRawPaths = [];\n    this.currentPath = [];\n    this.scaleFactor = 1;\n    this.translationX = this.translationY = 0;\n    this.x = 0;\n    this.y = 0;\n    this._willKeepAspectRatio = true;\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.INK_THICKNESS:\n        InkEditor._defaultThickness = value;\n        break;\n      case AnnotationEditorParamsType.INK_COLOR:\n        InkEditor._defaultColor = value;\n        break;\n      case AnnotationEditorParamsType.INK_OPACITY:\n        InkEditor._defaultOpacity = value / 100;\n        break;\n    }\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.INK_THICKNESS:\n        this.#updateThickness(value);\n        break;\n      case AnnotationEditorParamsType.INK_COLOR:\n        this.#updateColor(value);\n        break;\n      case AnnotationEditorParamsType.INK_OPACITY:\n        this.#updateOpacity(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || AnnotationEditor._defaultLineColor], [AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];\n  }\n  get propertiesToUpdate() {\n    return [[AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || AnnotationEditor._defaultLineColor], [AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]];\n  }\n  #updateThickness(thickness) {\n    const setThickness = th => {\n      this.thickness = th;\n      this.#fitToContent();\n    };\n    const savedThickness = this.thickness;\n    this.addCommands({\n      cmd: setThickness.bind(this, thickness),\n      undo: setThickness.bind(this, savedThickness),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.INK_THICKNESS,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  #updateColor(color) {\n    const setColor = col => {\n      this.color = col;\n      this.#redraw();\n    };\n    const savedColor = this.color;\n    this.addCommands({\n      cmd: setColor.bind(this, color),\n      undo: setColor.bind(this, savedColor),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.INK_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  #updateOpacity(opacity) {\n    const setOpacity = op => {\n      this.opacity = op;\n      this.#redraw();\n    };\n    opacity /= 100;\n    const savedOpacity = this.opacity;\n    this.addCommands({\n      cmd: setOpacity.bind(this, opacity),\n      undo: setOpacity.bind(this, savedOpacity),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.INK_OPACITY,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (!this.canvas) {\n      this.#createCanvas();\n      this.#createObserver();\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n      this.#setCanvasDims();\n    }\n    this.#fitToContent();\n  }\n  remove() {\n    if (this.canvas === null) {\n      return;\n    }\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n    this.canvas.width = this.canvas.height = 0;\n    this.canvas.remove();\n    this.canvas = null;\n    if (this.#canvasContextMenuTimeoutId) {\n      clearTimeout(this.#canvasContextMenuTimeoutId);\n      this.#canvasContextMenuTimeoutId = null;\n    }\n    this.#observer?.disconnect();\n    this.#observer = null;\n    super.remove();\n  }\n  setParent(parent) {\n    if (!this.parent && parent) {\n      this._uiManager.removeShouldRescale(this);\n    } else if (this.parent && parent === null) {\n      this._uiManager.addShouldRescale(this);\n    }\n    super.setParent(parent);\n  }\n  onScaleChanging() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const width = this.width * parentWidth;\n    const height = this.height * parentHeight;\n    this.setDimensions(width, height);\n  }\n  enableEditMode() {\n    if (this.#disableEditing || this.canvas === null) {\n      return;\n    }\n    super.enableEditMode();\n    this._isDraggable = false;\n    this.#addPointerdownListener();\n  }\n  disableEditMode() {\n    if (!this.isInEditMode() || this.canvas === null) {\n      return;\n    }\n    super.disableEditMode();\n    this._isDraggable = !this.isEmpty();\n    this.div.classList.remove(\"editing\");\n    this.#removePointerdownListener();\n  }\n  onceAdded() {\n    this._isDraggable = !this.isEmpty();\n  }\n  isEmpty() {\n    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n  }\n  #getInitialBBox() {\n    const {\n      parentRotation,\n      parentDimensions: [width, height]\n    } = this;\n    switch (parentRotation) {\n      case 90:\n        return [0, height, height, width];\n      case 180:\n        return [width, height, width, height];\n      case 270:\n        return [width, 0, height, width];\n      default:\n        return [0, 0, width, height];\n    }\n  }\n  #setStroke() {\n    const {\n      ctx,\n      color,\n      opacity,\n      thickness,\n      parentScale,\n      scaleFactor\n    } = this;\n    ctx.lineWidth = thickness * parentScale / scaleFactor;\n    ctx.lineCap = \"round\";\n    ctx.lineJoin = \"round\";\n    ctx.miterLimit = 10;\n    ctx.strokeStyle = `${color}${opacityToHex(opacity)}`;\n  }\n  #startDrawing(x, y) {\n    this.canvas.addEventListener(\"contextmenu\", noContextMenu, {\n      signal: this._uiManager._signal\n    });\n    this.#removePointerdownListener();\n    this.#drawingAC = new AbortController();\n    const signal = this._uiManager.combinedSignal(this.#drawingAC);\n    this.canvas.addEventListener(\"pointerleave\", this.canvasPointerleave.bind(this), {\n      signal\n    });\n    this.canvas.addEventListener(\"pointermove\", this.canvasPointermove.bind(this), {\n      signal\n    });\n    this.canvas.addEventListener(\"pointerup\", this.canvasPointerup.bind(this), {\n      signal\n    });\n    this.isEditing = true;\n    if (!this.#isCanvasInitialized) {\n      this.#isCanvasInitialized = true;\n      this.#setCanvasDims();\n      this.thickness ||= InkEditor._defaultThickness;\n      this.color ||= InkEditor._defaultColor || AnnotationEditor._defaultLineColor;\n      this.opacity ??= InkEditor._defaultOpacity;\n    }\n    this.currentPath.push([x, y]);\n    this.#hasSomethingToDraw = false;\n    this.#setStroke();\n    this.#requestFrameCallback = () => {\n      this.#drawPoints();\n      if (this.#requestFrameCallback) {\n        window.requestAnimationFrame(this.#requestFrameCallback);\n      }\n    };\n    window.requestAnimationFrame(this.#requestFrameCallback);\n  }\n  #draw(x, y) {\n    const [lastX, lastY] = this.currentPath.at(-1);\n    if (this.currentPath.length > 1 && x === lastX && y === lastY) {\n      return;\n    }\n    const currentPath = this.currentPath;\n    let path2D = this.#currentPath2D;\n    currentPath.push([x, y]);\n    this.#hasSomethingToDraw = true;\n    if (currentPath.length <= 2) {\n      path2D.moveTo(...currentPath[0]);\n      path2D.lineTo(x, y);\n      return;\n    }\n    if (currentPath.length === 3) {\n      this.#currentPath2D = path2D = new Path2D();\n      path2D.moveTo(...currentPath[0]);\n    }\n    this.#makeBezierCurve(path2D, ...currentPath.at(-3), ...currentPath.at(-2), x, y);\n  }\n  #endPath() {\n    if (this.currentPath.length === 0) {\n      return;\n    }\n    const lastPoint = this.currentPath.at(-1);\n    this.#currentPath2D.lineTo(...lastPoint);\n  }\n  #stopDrawing(x, y) {\n    this.#requestFrameCallback = null;\n    x = Math.min(Math.max(x, 0), this.canvas.width);\n    y = Math.min(Math.max(y, 0), this.canvas.height);\n    this.#draw(x, y);\n    this.#endPath();\n    let bezier;\n    if (this.currentPath.length !== 1) {\n      bezier = this.#generateBezierPoints();\n    } else {\n      const xy = [x, y];\n      bezier = [[xy, xy.slice(), xy.slice(), xy]];\n    }\n    const path2D = this.#currentPath2D;\n    const currentPath = this.currentPath;\n    this.currentPath = [];\n    this.#currentPath2D = new Path2D();\n    const cmd = () => {\n      this.allRawPaths.push(currentPath);\n      this.paths.push(bezier);\n      this.bezierPath2D.push(path2D);\n      this._uiManager.rebuild(this);\n    };\n    const undo = () => {\n      this.allRawPaths.pop();\n      this.paths.pop();\n      this.bezierPath2D.pop();\n      if (this.paths.length === 0) {\n        this.remove();\n      } else {\n        if (!this.canvas) {\n          this.#createCanvas();\n          this.#createObserver();\n        }\n        this.#fitToContent();\n      }\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n  #drawPoints() {\n    if (!this.#hasSomethingToDraw) {\n      return;\n    }\n    this.#hasSomethingToDraw = false;\n    const thickness = Math.ceil(this.thickness * this.parentScale);\n    const lastPoints = this.currentPath.slice(-3);\n    const x = lastPoints.map(xy => xy[0]);\n    const y = lastPoints.map(xy => xy[1]);\n    const xMin = Math.min(...x) - thickness;\n    const xMax = Math.max(...x) + thickness;\n    const yMin = Math.min(...y) - thickness;\n    const yMax = Math.max(...y) + thickness;\n    const {\n      ctx\n    } = this;\n    ctx.save();\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    for (const path of this.bezierPath2D) {\n      ctx.stroke(path);\n    }\n    ctx.stroke(this.#currentPath2D);\n    ctx.restore();\n  }\n  #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {\n    const prevX = (x0 + x1) / 2;\n    const prevY = (y0 + y1) / 2;\n    const x3 = (x1 + x2) / 2;\n    const y3 = (y1 + y2) / 2;\n    path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);\n  }\n  #generateBezierPoints() {\n    const path = this.currentPath;\n    if (path.length <= 2) {\n      return [[path[0], path[0], path.at(-1), path.at(-1)]];\n    }\n    const bezierPoints = [];\n    let i;\n    let [x0, y0] = path[0];\n    for (i = 1; i < path.length - 2; i++) {\n      const [x1, y1] = path[i];\n      const [x2, y2] = path[i + 1];\n      const x3 = (x1 + x2) / 2;\n      const y3 = (y1 + y2) / 2;\n      const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];\n      const control2 = [x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3];\n      bezierPoints.push([[x0, y0], control1, control2, [x3, y3]]);\n      [x0, y0] = [x3, y3];\n    }\n    const [x1, y1] = path[i];\n    const [x2, y2] = path[i + 1];\n    const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];\n    const control2 = [x2 + 2 * (x1 - x2) / 3, y2 + 2 * (y1 - y2) / 3];\n    bezierPoints.push([[x0, y0], control1, control2, [x2, y2]]);\n    return bezierPoints;\n  }\n  #redraw() {\n    if (this.isEmpty()) {\n      this.#updateTransform();\n      return;\n    }\n    this.#setStroke();\n    const {\n      canvas,\n      ctx\n    } = this;\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    this.#updateTransform();\n    for (const path of this.bezierPath2D) {\n      ctx.stroke(path);\n    }\n  }\n  commit() {\n    if (this.#disableEditing) {\n      return;\n    }\n    super.commit();\n    this.isEditing = false;\n    this.disableEditMode();\n    this.setInForeground();\n    this.#disableEditing = true;\n    this.div.classList.add(\"disabled\");\n    this.#fitToContent(true);\n    this.select();\n    this.parent.addInkEditorIfNeeded(true);\n    this.moveInDOM();\n    this.div.focus({\n      preventScroll: true\n    });\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    super.focusin(event);\n    this.enableEditMode();\n  }\n  #addPointerdownListener() {\n    if (this.#pointerdownAC) {\n      return;\n    }\n    this.#pointerdownAC = new AbortController();\n    const signal = this._uiManager.combinedSignal(this.#pointerdownAC);\n    this.canvas.addEventListener(\"pointerdown\", this.canvasPointerdown.bind(this), {\n      signal\n    });\n  }\n  #removePointerdownListener() {\n    this.pointerdownAC?.abort();\n    this.pointerdownAC = null;\n  }\n  canvasPointerdown(event) {\n    if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {\n      return;\n    }\n    this.setInForeground();\n    event.preventDefault();\n    if (!this.div.contains(document.activeElement)) {\n      this.div.focus({\n        preventScroll: true\n      });\n    }\n    this.#startDrawing(event.offsetX, event.offsetY);\n  }\n  canvasPointermove(event) {\n    event.preventDefault();\n    this.#draw(event.offsetX, event.offsetY);\n  }\n  canvasPointerup(event) {\n    event.preventDefault();\n    this.#endDrawing(event);\n  }\n  canvasPointerleave(event) {\n    this.#endDrawing(event);\n  }\n  #endDrawing(event) {\n    this.#drawingAC?.abort();\n    this.#drawingAC = null;\n    this.#addPointerdownListener();\n    if (this.#canvasContextMenuTimeoutId) {\n      clearTimeout(this.#canvasContextMenuTimeoutId);\n    }\n    this.#canvasContextMenuTimeoutId = setTimeout(() => {\n      this.#canvasContextMenuTimeoutId = null;\n      this.canvas.removeEventListener(\"contextmenu\", noContextMenu);\n    }, 10);\n    this.#stopDrawing(event.offsetX, event.offsetY);\n    this.addToAnnotationStorage();\n    this.setInBackground();\n  }\n  #createCanvas() {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.width = this.canvas.height = 0;\n    this.canvas.className = \"inkEditorCanvas\";\n    this.canvas.setAttribute(\"data-l10n-id\", \"pdfjs-ink-canvas\");\n    this.div.append(this.canvas);\n    this.ctx = this.canvas.getContext(\"2d\");\n  }\n  #createObserver() {\n    this.#observer = new ResizeObserver(entries => {\n      const rect = entries[0].contentRect;\n      if (rect.width && rect.height) {\n        this.setDimensions(rect.width, rect.height);\n      }\n    });\n    this.#observer.observe(this.div);\n    this._uiManager._signal.addEventListener(\"abort\", () => {\n      this.#observer?.disconnect();\n      this.#observer = null;\n    }, {\n      once: true\n    });\n  }\n  get isResizable() {\n    return !this.isEmpty() && this.#disableEditing;\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.div.setAttribute(\"data-l10n-id\", \"pdfjs-ink\");\n    const [x, y, w, h] = this.#getInitialBBox();\n    this.setAt(x, y, 0, 0);\n    this.setDims(w, h);\n    this.#createCanvas();\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);\n      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n      this.#isCanvasInitialized = true;\n      this.#setCanvasDims();\n      this.setDims(this.width * parentWidth, this.height * parentHeight);\n      this.#redraw();\n      this.div.classList.add(\"disabled\");\n    } else {\n      this.div.classList.add(\"editing\");\n      this.enableEditMode();\n    }\n    this.#createObserver();\n    return this.div;\n  }\n  #setCanvasDims() {\n    if (!this.#isCanvasInitialized) {\n      return;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.canvas.width = Math.ceil(this.width * parentWidth);\n    this.canvas.height = Math.ceil(this.height * parentHeight);\n    this.#updateTransform();\n  }\n  setDimensions(width, height) {\n    const roundedWidth = Math.round(width);\n    const roundedHeight = Math.round(height);\n    if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {\n      return;\n    }\n    this.#realWidth = roundedWidth;\n    this.#realHeight = roundedHeight;\n    this.canvas.style.visibility = \"hidden\";\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    this.fixAndSetPosition();\n    if (this.#disableEditing) {\n      this.#setScaleFactor(width, height);\n    }\n    this.#setCanvasDims();\n    this.#redraw();\n    this.canvas.style.visibility = \"visible\";\n    this.fixDims();\n  }\n  #setScaleFactor(width, height) {\n    const padding = this.#getPadding();\n    const scaleFactorW = (width - padding) / this.#baseWidth;\n    const scaleFactorH = (height - padding) / this.#baseHeight;\n    this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);\n  }\n  #updateTransform() {\n    const padding = this.#getPadding() / 2;\n    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);\n  }\n  static #buildPath2D(bezier) {\n    const path2D = new Path2D();\n    for (let i = 0, ii = bezier.length; i < ii; i++) {\n      const [first, control1, control2, second] = bezier[i];\n      if (i === 0) {\n        path2D.moveTo(...first);\n      }\n      path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);\n    }\n    return path2D;\n  }\n  static #toPDFCoordinates(points, rect, rotation) {\n    const [blX, blY, trX, trY] = rect;\n    switch (rotation) {\n      case 0:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] += blX;\n          points[i + 1] = trY - points[i + 1];\n        }\n        break;\n      case 90:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = points[i + 1] + blX;\n          points[i + 1] = x + blY;\n        }\n        break;\n      case 180:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] = trX - points[i];\n          points[i + 1] += blY;\n        }\n        break;\n      case 270:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = trX - points[i + 1];\n          points[i + 1] = trY - x;\n        }\n        break;\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n    return points;\n  }\n  static #fromPDFCoordinates(points, rect, rotation) {\n    const [blX, blY, trX, trY] = rect;\n    switch (rotation) {\n      case 0:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] -= blX;\n          points[i + 1] = trY - points[i + 1];\n        }\n        break;\n      case 90:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = points[i + 1] - blY;\n          points[i + 1] = x - blX;\n        }\n        break;\n      case 180:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] = trX - points[i];\n          points[i + 1] -= blY;\n        }\n        break;\n      case 270:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = trY - points[i + 1];\n          points[i + 1] = trX - x;\n        }\n        break;\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n    return points;\n  }\n  #serializePaths(s, tx, ty, rect) {\n    const paths = [];\n    const padding = this.thickness / 2;\n    const shiftX = s * tx + padding;\n    const shiftY = s * ty + padding;\n    for (const bezier of this.paths) {\n      const buffer = [];\n      const points = [];\n      for (let j = 0, jj = bezier.length; j < jj; j++) {\n        const [first, control1, control2, second] = bezier[j];\n        if (first[0] === second[0] && first[1] === second[1] && jj === 1) {\n          const p0 = s * first[0] + shiftX;\n          const p1 = s * first[1] + shiftY;\n          buffer.push(p0, p1);\n          points.push(p0, p1);\n          break;\n        }\n        const p10 = s * first[0] + shiftX;\n        const p11 = s * first[1] + shiftY;\n        const p20 = s * control1[0] + shiftX;\n        const p21 = s * control1[1] + shiftY;\n        const p30 = s * control2[0] + shiftX;\n        const p31 = s * control2[1] + shiftY;\n        const p40 = s * second[0] + shiftX;\n        const p41 = s * second[1] + shiftY;\n        if (j === 0) {\n          buffer.push(p10, p11);\n          points.push(p10, p11);\n        }\n        buffer.push(p20, p21, p30, p31, p40, p41);\n        points.push(p20, p21);\n        if (j === jj - 1) {\n          points.push(p40, p41);\n        }\n      }\n      paths.push({\n        bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),\n        points: InkEditor.#toPDFCoordinates(points, rect, this.rotation)\n      });\n    }\n    return paths;\n  }\n  #getBbox() {\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n    for (const path of this.paths) {\n      for (const [first, control1, control2, second] of path) {\n        const bbox = Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);\n        xMin = Math.min(xMin, bbox[0]);\n        yMin = Math.min(yMin, bbox[1]);\n        xMax = Math.max(xMax, bbox[2]);\n        yMax = Math.max(yMax, bbox[3]);\n      }\n    }\n    return [xMin, yMin, xMax, yMax];\n  }\n  #getPadding() {\n    return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;\n  }\n  #fitToContent(firstTime = false) {\n    if (this.isEmpty()) {\n      return;\n    }\n    if (!this.#disableEditing) {\n      this.#redraw();\n      return;\n    }\n    const bbox = this.#getBbox();\n    const padding = this.#getPadding();\n    this.#baseWidth = Math.max(AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n    this.#baseHeight = Math.max(AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n    const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);\n    const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    this.setAspectRatio(width, height);\n    const prevTranslationX = this.translationX;\n    const prevTranslationY = this.translationY;\n    this.translationX = -bbox[0];\n    this.translationY = -bbox[1];\n    this.#setCanvasDims();\n    this.#redraw();\n    this.#realWidth = width;\n    this.#realHeight = height;\n    this.setDims(width, height);\n    const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;\n    this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);\n  }\n  static async deserialize(data, parent, uiManager) {\n    if (data instanceof InkAnnotationElement) {\n      return null;\n    }\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.thickness = data.thickness;\n    editor.color = Util.makeHexColor(...data.color);\n    editor.opacity = data.opacity;\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const width = editor.width * pageWidth;\n    const height = editor.height * pageHeight;\n    const scaleFactor = editor.parentScale;\n    const padding = data.thickness / 2;\n    editor.#disableEditing = true;\n    editor.#realWidth = Math.round(width);\n    editor.#realHeight = Math.round(height);\n    const {\n      paths,\n      rect,\n      rotation\n    } = data;\n    for (let {\n      bezier\n    } of paths) {\n      bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);\n      const path = [];\n      editor.paths.push(path);\n      let p0 = scaleFactor * (bezier[0] - padding);\n      let p1 = scaleFactor * (bezier[1] - padding);\n      for (let i = 2, ii = bezier.length; i < ii; i += 6) {\n        const p10 = scaleFactor * (bezier[i] - padding);\n        const p11 = scaleFactor * (bezier[i + 1] - padding);\n        const p20 = scaleFactor * (bezier[i + 2] - padding);\n        const p21 = scaleFactor * (bezier[i + 3] - padding);\n        const p30 = scaleFactor * (bezier[i + 4] - padding);\n        const p31 = scaleFactor * (bezier[i + 5] - padding);\n        path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);\n        p0 = p30;\n        p1 = p31;\n      }\n      const path2D = this.#buildPath2D(path);\n      editor.bezierPath2D.push(path2D);\n    }\n    const bbox = editor.#getBbox();\n    editor.#baseWidth = Math.max(AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n    editor.#baseHeight = Math.max(AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n    editor.#setScaleFactor(width, height);\n    return editor;\n  }\n  serialize() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const rect = this.getRect(0, 0);\n    const color = AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n    return {\n      annotationType: AnnotationEditorType.INK,\n      color,\n      thickness: this.thickness,\n      opacity: this.opacity,\n      paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.rotation,\n      structTreeParentId: this._structTreeParentId\n    };\n  }\n}\n\n;// ./src/display/editor/stamp.js\n\n\n\n\nclass StampEditor extends AnnotationEditor {\n  #bitmap = null;\n  #bitmapId = null;\n  #bitmapPromise = null;\n  #bitmapUrl = null;\n  #bitmapFile = null;\n  #bitmapFileName = \"\";\n  #canvas = null;\n  #observer = null;\n  #resizeTimeoutId = null;\n  #isSvg = false;\n  #hasBeenAddedInUndoStack = false;\n  static _type = \"stamp\";\n  static _editorType = AnnotationEditorType.STAMP;\n  constructor(params) {\n    super({\n      ...params,\n      name: \"stampEditor\"\n    });\n    this.#bitmapUrl = params.bitmapUrl;\n    this.#bitmapFile = params.bitmapFile;\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n  }\n  static get supportedTypes() {\n    const types = [\"apng\", \"avif\", \"bmp\", \"gif\", \"jpeg\", \"png\", \"svg+xml\", \"webp\", \"x-icon\"];\n    return shadow(this, \"supportedTypes\", types.map(type => `image/${type}`));\n  }\n  static get supportedTypesStr() {\n    return shadow(this, \"supportedTypesStr\", this.supportedTypes.join(\",\"));\n  }\n  static isHandlingMimeForPasting(mime) {\n    return this.supportedTypes.includes(mime);\n  }\n  static paste(item, parent) {\n    parent.pasteEditor(AnnotationEditorType.STAMP, {\n      bitmapFile: item.getAsFile()\n    });\n  }\n  altTextFinish() {\n    if (this._uiManager.useNewAltTextFlow) {\n      this.div.hidden = false;\n    }\n    super.altTextFinish();\n  }\n  get telemetryFinalData() {\n    return {\n      type: \"stamp\",\n      hasAltText: !!this.altTextData?.altText\n    };\n  }\n  static computeTelemetryFinalData(data) {\n    const hasAltTextStats = data.get(\"hasAltText\");\n    return {\n      hasAltText: hasAltTextStats.get(true) ?? 0,\n      hasNoAltText: hasAltTextStats.get(false) ?? 0\n    };\n  }\n  #getBitmapFetched(data, fromId = false) {\n    if (!data) {\n      this.remove();\n      return;\n    }\n    this.#bitmap = data.bitmap;\n    if (!fromId) {\n      this.#bitmapId = data.id;\n      this.#isSvg = data.isSvg;\n    }\n    if (data.file) {\n      this.#bitmapFileName = data.file.name;\n    }\n    this.#createCanvas();\n  }\n  #getBitmapDone() {\n    this.#bitmapPromise = null;\n    this._uiManager.enableWaiting(false);\n    if (!this.#canvas) {\n      return;\n    }\n    if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n      this._editToolbar.hide();\n      this._uiManager.editAltText(this, true);\n      return;\n    }\n    if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n      this._reportTelemetry({\n        action: \"pdfjs.image.image_added\",\n        data: {\n          alt_text_modal: false,\n          alt_text_type: \"empty\"\n        }\n      });\n      try {\n        this.mlGuessAltText();\n      } catch {}\n    }\n    this.div.focus();\n  }\n  async mlGuessAltText(imageData = null, updateAltTextData = true) {\n    if (this.hasAltTextData()) {\n      return null;\n    }\n    const {\n      mlManager\n    } = this._uiManager;\n    if (!mlManager) {\n      throw new Error(\"No ML.\");\n    }\n    if (!(await mlManager.isEnabledFor(\"altText\"))) {\n      throw new Error(\"ML isn't enabled for alt text.\");\n    }\n    const {\n      data,\n      width,\n      height\n    } = imageData || this.copyCanvas(null, null, true).imageData;\n    const response = await mlManager.guess({\n      name: \"altText\",\n      request: {\n        data,\n        width,\n        height,\n        channels: data.length / (width * height)\n      }\n    });\n    if (!response) {\n      throw new Error(\"No response from the AI service.\");\n    }\n    if (response.error) {\n      throw new Error(\"Error from the AI service.\");\n    }\n    if (response.cancel) {\n      return null;\n    }\n    if (!response.output) {\n      throw new Error(\"No valid response from the AI service.\");\n    }\n    const altText = response.output;\n    await this.setGuessedAltText(altText);\n    if (updateAltTextData && !this.hasAltTextData()) {\n      this.altTextData = {\n        alt: altText,\n        decorative: false\n      };\n    }\n    return altText;\n  }\n  #getBitmap() {\n    if (this.#bitmapId) {\n      this._uiManager.enableWaiting(true);\n      this._uiManager.imageManager.getFromId(this.#bitmapId).then(data => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    if (this.#bitmapUrl) {\n      const url = this.#bitmapUrl;\n      this.#bitmapUrl = null;\n      this._uiManager.enableWaiting(true);\n      this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    if (this.#bitmapFile) {\n      const file = this.#bitmapFile;\n      this.#bitmapFile = null;\n      this._uiManager.enableWaiting(true);\n      this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = StampEditor.supportedTypesStr;\n    const signal = this._uiManager._signal;\n    this.#bitmapPromise = new Promise(resolve => {\n      input.addEventListener(\"change\", async () => {\n        if (!input.files || input.files.length === 0) {\n          this.remove();\n        } else {\n          this._uiManager.enableWaiting(true);\n          const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n          this._reportTelemetry({\n            action: \"pdfjs.image.image_selected\",\n            data: {\n              alt_text_modal: this._uiManager.useNewAltTextFlow\n            }\n          });\n          this.#getBitmapFetched(data);\n        }\n        resolve();\n      }, {\n        signal\n      });\n      input.addEventListener(\"cancel\", () => {\n        this.remove();\n        resolve();\n      }, {\n        signal\n      });\n    }).finally(() => this.#getBitmapDone());\n    input.click();\n  }\n  remove() {\n    if (this.#bitmapId) {\n      this.#bitmap = null;\n      this._uiManager.imageManager.deleteId(this.#bitmapId);\n      this.#canvas?.remove();\n      this.#canvas = null;\n      this.#observer?.disconnect();\n      this.#observer = null;\n      if (this.#resizeTimeoutId) {\n        clearTimeout(this.#resizeTimeoutId);\n        this.#resizeTimeoutId = null;\n      }\n    }\n    super.remove();\n  }\n  rebuild() {\n    if (!this.parent) {\n      if (this.#bitmapId) {\n        this.#getBitmap();\n      }\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (this.#bitmapId && this.#canvas === null) {\n      this.#getBitmap();\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  onceAdded() {\n    this._isDraggable = true;\n    this.div.focus();\n  }\n  isEmpty() {\n    return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId);\n  }\n  get isResizable() {\n    return true;\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.div.hidden = true;\n    this.div.setAttribute(\"role\", \"figure\");\n    this.addAltTextButton();\n    if (this.#bitmap) {\n      this.#createCanvas();\n    } else {\n      this.#getBitmap();\n    }\n    if (this.width && !this.annotationElementId) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n    }\n    return this.div;\n  }\n  #createCanvas() {\n    const {\n      div\n    } = this;\n    let {\n      width,\n      height\n    } = this.#bitmap;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const MAX_RATIO = 0.75;\n    if (this.width) {\n      width = this.width * pageWidth;\n      height = this.height * pageHeight;\n    } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n      const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n      width *= factor;\n      height *= factor;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n    this._uiManager.enableWaiting(false);\n    const canvas = this.#canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\"role\", \"img\");\n    this.addContainer(canvas);\n    if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n      div.hidden = false;\n    }\n    this.#drawBitmap(width, height);\n    this.#createObserver();\n    if (!this.#hasBeenAddedInUndoStack) {\n      this.parent.addUndoableEditor(this);\n      this.#hasBeenAddedInUndoStack = true;\n    }\n    this._reportTelemetry({\n      action: \"inserted_image\"\n    });\n    if (this.#bitmapFileName) {\n      canvas.setAttribute(\"aria-label\", this.#bitmapFileName);\n    }\n  }\n  copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n    if (!maxDataDimension) {\n      maxDataDimension = 224;\n    }\n    const {\n      width: bitmapWidth,\n      height: bitmapHeight\n    } = this.#bitmap;\n    const outputScale = new OutputScale();\n    let bitmap = this.#bitmap;\n    let width = bitmapWidth,\n      height = bitmapHeight;\n    let canvas = null;\n    if (maxPreviewDimension) {\n      if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n        const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n        width = Math.floor(bitmapWidth * ratio);\n        height = Math.floor(bitmapHeight * ratio);\n      }\n      canvas = document.createElement(\"canvas\");\n      const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n      const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n      if (!this.#isSvg) {\n        bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n      }\n      const ctx = canvas.getContext(\"2d\");\n      ctx.filter = this._uiManager.hcmFilter;\n      let white = \"white\",\n        black = \"#cfcfd8\";\n      if (this._uiManager.hcmFilter !== \"none\") {\n        black = \"black\";\n      } else if (window.matchMedia?.(\"(prefers-color-scheme: dark)\").matches) {\n        white = \"#8f8f9d\";\n        black = \"#42414d\";\n      }\n      const boxDim = 15;\n      const boxDimWidth = boxDim * outputScale.sx;\n      const boxDimHeight = boxDim * outputScale.sy;\n      const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n      const patternCtx = pattern.getContext(\"2d\");\n      patternCtx.fillStyle = white;\n      patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n      patternCtx.fillStyle = black;\n      patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n      patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n      ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n      ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n      ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    let imageData = null;\n    if (createImageData) {\n      let dataWidth, dataHeight;\n      if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n        dataWidth = bitmap.width;\n        dataHeight = bitmap.height;\n      } else {\n        bitmap = this.#bitmap;\n        if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n          const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n          dataWidth = Math.floor(bitmapWidth * ratio);\n          dataHeight = Math.floor(bitmapHeight * ratio);\n          if (!this.#isSvg) {\n            bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n          }\n        }\n      }\n      const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n      const offscreenCtx = offscreen.getContext(\"2d\", {\n        willReadFrequently: true\n      });\n      offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n      imageData = {\n        width: dataWidth,\n        height: dataHeight,\n        data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n      };\n    }\n    return {\n      canvas,\n      width,\n      height,\n      imageData\n    };\n  }\n  #setDimensions(width, height) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    if (this._initialOptions?.isCentered) {\n      this.center();\n    } else {\n      this.fixAndSetPosition();\n    }\n    this._initialOptions = null;\n    if (this.#resizeTimeoutId !== null) {\n      clearTimeout(this.#resizeTimeoutId);\n    }\n    const TIME_TO_WAIT = 200;\n    this.#resizeTimeoutId = setTimeout(() => {\n      this.#resizeTimeoutId = null;\n      this.#drawBitmap(width, height);\n    }, TIME_TO_WAIT);\n  }\n  #scaleBitmap(width, height) {\n    const {\n      width: bitmapWidth,\n      height: bitmapHeight\n    } = this.#bitmap;\n    let newWidth = bitmapWidth;\n    let newHeight = bitmapHeight;\n    let bitmap = this.#bitmap;\n    while (newWidth > 2 * width || newHeight > 2 * height) {\n      const prevWidth = newWidth;\n      const prevHeight = newHeight;\n      if (newWidth > 2 * width) {\n        newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n      }\n      if (newHeight > 2 * height) {\n        newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n      }\n      const offscreen = new OffscreenCanvas(newWidth, newHeight);\n      const ctx = offscreen.getContext(\"2d\");\n      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n      bitmap = offscreen.transferToImageBitmap();\n    }\n    return bitmap;\n  }\n  #drawBitmap(width, height) {\n    const outputScale = new OutputScale();\n    const scaledWidth = Math.ceil(width * outputScale.sx);\n    const scaledHeight = Math.ceil(height * outputScale.sy);\n    const canvas = this.#canvas;\n    if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n      return;\n    }\n    canvas.width = scaledWidth;\n    canvas.height = scaledHeight;\n    const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n    const ctx = canvas.getContext(\"2d\");\n    ctx.filter = this._uiManager.hcmFilter;\n    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n  }\n  getImageForAltText() {\n    return this.#canvas;\n  }\n  #serializeBitmap(toUrl) {\n    if (toUrl) {\n      if (this.#isSvg) {\n        const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n        if (url) {\n          return url;\n        }\n      }\n      const canvas = document.createElement(\"canvas\");\n      ({\n        width: canvas.width,\n        height: canvas.height\n      } = this.#bitmap);\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(this.#bitmap, 0, 0);\n      return canvas.toDataURL();\n    }\n    if (this.#isSvg) {\n      const [pageWidth, pageHeight] = this.pageDimensions;\n      const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n      const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n      const offscreen = new OffscreenCanvas(width, height);\n      const ctx = offscreen.getContext(\"2d\");\n      ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n      return offscreen.transferToImageBitmap();\n    }\n    return structuredClone(this.#bitmap);\n  }\n  #createObserver() {\n    if (!this._uiManager._signal) {\n      return;\n    }\n    this.#observer = new ResizeObserver(entries => {\n      const rect = entries[0].contentRect;\n      if (rect.width && rect.height) {\n        this.#setDimensions(rect.width, rect.height);\n      }\n    });\n    this.#observer.observe(this.div);\n    this._uiManager._signal.addEventListener(\"abort\", () => {\n      this.#observer?.disconnect();\n      this.#observer = null;\n    }, {\n      once: true\n    });\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof StampAnnotationElement) {\n      const {\n        data: {\n          rect,\n          rotation,\n          id,\n          structParent,\n          popupRef\n        },\n        container,\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      const canvas = container.querySelector(\"canvas\");\n      const imageData = uiManager.imageManager.getFromCanvas(container.id, canvas);\n      canvas.remove();\n      const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n      initialData = data = {\n        annotationType: AnnotationEditorType.STAMP,\n        bitmapId: imageData.id,\n        bitmap: imageData.bitmap,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        id,\n        deleted: false,\n        accessibilityData: {\n          decorative: false,\n          altText\n        },\n        isSvg: false,\n        structParent,\n        popupRef\n      };\n    }\n    const editor = await super.deserialize(data, parent, uiManager);\n    const {\n      rect,\n      bitmap,\n      bitmapUrl,\n      bitmapId,\n      isSvg,\n      accessibilityData\n    } = data;\n    if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n      editor.#bitmapId = bitmapId;\n      if (bitmap) {\n        editor.#bitmap = bitmap;\n      }\n    } else {\n      editor.#bitmapUrl = bitmapUrl;\n    }\n    editor.#isSvg = isSvg;\n    const [parentWidth, parentHeight] = editor.pageDimensions;\n    editor.width = (rect[2] - rect[0]) / parentWidth;\n    editor.height = (rect[3] - rect[1]) / parentHeight;\n    editor.annotationElementId = data.id || null;\n    if (accessibilityData) {\n      editor.altTextData = accessibilityData;\n    }\n    editor._initialData = initialData;\n    editor.#hasBeenAddedInUndoStack = !!initialData;\n    return editor;\n  }\n  serialize(isForCopying = false, context = null) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const serialized = {\n      annotationType: AnnotationEditorType.STAMP,\n      bitmapId: this.#bitmapId,\n      pageIndex: this.pageIndex,\n      rect: this.getRect(0, 0),\n      rotation: this.rotation,\n      isSvg: this.#isSvg,\n      structTreeParentId: this._structTreeParentId\n    };\n    if (isForCopying) {\n      serialized.bitmapUrl = this.#serializeBitmap(true);\n      serialized.accessibilityData = this.serializeAltText(true);\n      return serialized;\n    }\n    const {\n      decorative,\n      altText\n    } = this.serializeAltText(false);\n    if (!decorative && altText) {\n      serialized.accessibilityData = {\n        type: \"Figure\",\n        alt: altText\n      };\n    }\n    if (this.annotationElementId) {\n      const changes = this.#hasElementChanged(serialized);\n      if (changes.isSame) {\n        return null;\n      }\n      if (changes.isSameAltText) {\n        delete serialized.accessibilityData;\n      } else {\n        serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n      }\n    }\n    serialized.id = this.annotationElementId;\n    if (context === null) {\n      return serialized;\n    }\n    context.stamps ||= new Map();\n    const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n    if (!context.stamps.has(this.#bitmapId)) {\n      context.stamps.set(this.#bitmapId, {\n        area,\n        serialized\n      });\n      serialized.bitmap = this.#serializeBitmap(false);\n    } else if (this.#isSvg) {\n      const prevData = context.stamps.get(this.#bitmapId);\n      if (area > prevData.area) {\n        prevData.area = area;\n        prevData.serialized.bitmap.close();\n        prevData.serialized.bitmap = this.#serializeBitmap(false);\n      }\n    }\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      rect,\n      pageIndex,\n      accessibilityData: {\n        altText\n      }\n    } = this._initialData;\n    const isSameRect = serialized.rect.every((x, i) => Math.abs(x - rect[i]) < 1);\n    const isSamePageIndex = serialized.pageIndex === pageIndex;\n    const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n    return {\n      isSame: isSameRect && isSamePageIndex && isSameAltText,\n      isSameAltText\n    };\n  }\n  renderAnnotationElement(annotation) {\n    annotation.updateEdited({\n      rect: this.getRect(0, 0)\n    });\n    return null;\n  }\n}\n\n;// ./src/display/editor/annotation_editor_layer.js\n\n\n\n\n\n\n\nclass AnnotationEditorLayer {\n  #accessibilityManager;\n  #allowClick = false;\n  #annotationLayer = null;\n  #clickAC = null;\n  #editorFocusTimeoutId = null;\n  #editors = new Map();\n  #hadPointerDown = false;\n  #isCleaningUp = false;\n  #isDisabling = false;\n  #textLayer = null;\n  #textSelectionAC = null;\n  #uiManager;\n  static _initialized = false;\n  static #editorTypes = new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor].map(type => [type._editorType, type]));\n  constructor({\n    uiManager,\n    pageIndex,\n    div,\n    structTreeLayer,\n    accessibilityManager,\n    annotationLayer,\n    drawLayer,\n    textLayer,\n    viewport,\n    l10n\n  }) {\n    const editorTypes = [...AnnotationEditorLayer.#editorTypes.values()];\n    if (!AnnotationEditorLayer._initialized) {\n      AnnotationEditorLayer._initialized = true;\n      for (const editorType of editorTypes) {\n        editorType.initialize(l10n, uiManager);\n      }\n    }\n    uiManager.registerEditorTypes(editorTypes);\n    this.#uiManager = uiManager;\n    this.pageIndex = pageIndex;\n    this.div = div;\n    this.#accessibilityManager = accessibilityManager;\n    this.#annotationLayer = annotationLayer;\n    this.viewport = viewport;\n    this.#textLayer = textLayer;\n    this.drawLayer = drawLayer;\n    this._structTree = structTreeLayer;\n    this.#uiManager.addLayer(this);\n  }\n  get isEmpty() {\n    return this.#editors.size === 0;\n  }\n  get isInvisible() {\n    return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n  }\n  updateToolbar(mode) {\n    this.#uiManager.updateToolbar(mode);\n  }\n  updateMode(mode = this.#uiManager.getMode()) {\n    this.#cleanup();\n    switch (mode) {\n      case AnnotationEditorType.NONE:\n        this.disableTextSelection();\n        this.togglePointerEvents(false);\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.disableClick();\n        return;\n      case AnnotationEditorType.INK:\n        this.addInkEditorIfNeeded(false);\n        this.disableTextSelection();\n        this.togglePointerEvents(true);\n        this.disableClick();\n        break;\n      case AnnotationEditorType.HIGHLIGHT:\n        this.enableTextSelection();\n        this.togglePointerEvents(false);\n        this.disableClick();\n        break;\n      default:\n        this.disableTextSelection();\n        this.togglePointerEvents(true);\n        this.enableClick();\n    }\n    this.toggleAnnotationLayerPointerEvents(false);\n    const {\n      classList\n    } = this.div;\n    for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {\n      classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n    }\n    this.div.hidden = false;\n  }\n  hasTextLayer(textLayer) {\n    return textLayer === this.#textLayer?.div;\n  }\n  addInkEditorIfNeeded(isCommitting) {\n    if (this.#uiManager.getMode() !== AnnotationEditorType.INK) {\n      return;\n    }\n    if (!isCommitting) {\n      for (const editor of this.#editors.values()) {\n        if (editor.isEmpty()) {\n          editor.setInBackground();\n          return;\n        }\n      }\n    }\n    const editor = this.createAndAddNewEditor({\n      offsetX: 0,\n      offsetY: 0\n    }, false);\n    editor.setInBackground();\n  }\n  setEditingState(isEditing) {\n    this.#uiManager.setEditingState(isEditing);\n  }\n  addCommands(params) {\n    this.#uiManager.addCommands(params);\n  }\n  toggleDrawing(enabled = false) {\n    this.div.classList.toggle(\"drawing\", !enabled);\n  }\n  togglePointerEvents(enabled = false) {\n    this.div.classList.toggle(\"disabled\", !enabled);\n  }\n  toggleAnnotationLayerPointerEvents(enabled = false) {\n    this.#annotationLayer?.div.classList.toggle(\"disabled\", !enabled);\n  }\n  async enable() {\n    this.div.tabIndex = 0;\n    this.togglePointerEvents(true);\n    const annotationElementIds = new Set();\n    for (const editor of this.#editors.values()) {\n      editor.enableEditing();\n      editor.show(true);\n      if (editor.annotationElementId) {\n        this.#uiManager.removeChangedExistingAnnotation(editor);\n        annotationElementIds.add(editor.annotationElementId);\n      }\n    }\n    if (!this.#annotationLayer) {\n      return;\n    }\n    const editables = this.#annotationLayer.getEditableAnnotations();\n    for (const editable of editables) {\n      editable.hide();\n      if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n        continue;\n      }\n      if (annotationElementIds.has(editable.data.id)) {\n        continue;\n      }\n      const editor = await this.deserialize(editable);\n      if (!editor) {\n        continue;\n      }\n      this.addOrRebuild(editor);\n      editor.enableEditing();\n    }\n  }\n  disable() {\n    this.#isDisabling = true;\n    this.div.tabIndex = -1;\n    this.togglePointerEvents(false);\n    const changedAnnotations = new Map();\n    const resetAnnotations = new Map();\n    for (const editor of this.#editors.values()) {\n      editor.disableEditing();\n      if (!editor.annotationElementId) {\n        continue;\n      }\n      if (editor.serialize() !== null) {\n        changedAnnotations.set(editor.annotationElementId, editor);\n        continue;\n      } else {\n        resetAnnotations.set(editor.annotationElementId, editor);\n      }\n      this.getEditableAnnotation(editor.annotationElementId)?.show();\n      editor.remove();\n    }\n    if (this.#annotationLayer) {\n      const editables = this.#annotationLayer.getEditableAnnotations();\n      for (const editable of editables) {\n        const {\n          id\n        } = editable.data;\n        if (this.#uiManager.isDeletedAnnotationElement(id)) {\n          continue;\n        }\n        let editor = resetAnnotations.get(id);\n        if (editor) {\n          editor.resetAnnotationElement(editable);\n          editor.show(false);\n          editable.show();\n          continue;\n        }\n        editor = changedAnnotations.get(id);\n        if (editor) {\n          this.#uiManager.addChangedExistingAnnotation(editor);\n          if (editor.renderAnnotationElement(editable)) {\n            editor.show(false);\n          }\n        }\n        editable.show();\n      }\n    }\n    this.#cleanup();\n    if (this.isEmpty) {\n      this.div.hidden = true;\n    }\n    const {\n      classList\n    } = this.div;\n    for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {\n      classList.remove(`${editorType._type}Editing`);\n    }\n    this.disableTextSelection();\n    this.toggleAnnotationLayerPointerEvents(true);\n    this.#isDisabling = false;\n  }\n  getEditableAnnotation(id) {\n    return this.#annotationLayer?.getEditableAnnotation(id) || null;\n  }\n  setActiveEditor(editor) {\n    const currentActive = this.#uiManager.getActive();\n    if (currentActive === editor) {\n      return;\n    }\n    this.#uiManager.setActiveEditor(editor);\n  }\n  enableTextSelection() {\n    this.div.tabIndex = -1;\n    if (this.#textLayer?.div && !this.#textSelectionAC) {\n      this.#textSelectionAC = new AbortController();\n      const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n      this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n        signal\n      });\n      this.#textLayer.div.classList.add(\"highlighting\");\n    }\n  }\n  disableTextSelection() {\n    this.div.tabIndex = 0;\n    if (this.#textLayer?.div && this.#textSelectionAC) {\n      this.#textSelectionAC.abort();\n      this.#textSelectionAC = null;\n      this.#textLayer.div.classList.remove(\"highlighting\");\n    }\n  }\n  #textLayerPointerDown(event) {\n    this.#uiManager.unselectAll();\n    const {\n      target\n    } = event;\n    if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n      const {\n        isMac\n      } = util_FeatureTest.platform;\n      if (event.button !== 0 || event.ctrlKey && isMac) {\n        return;\n      }\n      this.#uiManager.showAllEditors(\"highlight\", true, true);\n      this.#textLayer.div.classList.add(\"free\");\n      this.toggleDrawing();\n      HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n        target: this.#textLayer.div,\n        x: event.x,\n        y: event.y\n      });\n      this.#textLayer.div.addEventListener(\"pointerup\", () => {\n        this.#textLayer.div.classList.remove(\"free\");\n        this.toggleDrawing(true);\n      }, {\n        once: true,\n        signal: this.#uiManager._signal\n      });\n      event.preventDefault();\n    }\n  }\n  enableClick() {\n    if (this.#clickAC) {\n      return;\n    }\n    this.#clickAC = new AbortController();\n    const signal = this.#uiManager.combinedSignal(this.#clickAC);\n    this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n      signal\n    });\n    this.div.addEventListener(\"pointerup\", this.pointerup.bind(this), {\n      signal\n    });\n  }\n  disableClick() {\n    this.#clickAC?.abort();\n    this.#clickAC = null;\n  }\n  attach(editor) {\n    this.#editors.set(editor.id, editor);\n    const {\n      annotationElementId\n    } = editor;\n    if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n      this.#uiManager.removeDeletedAnnotationElement(editor);\n    }\n  }\n  detach(editor) {\n    this.#editors.delete(editor.id);\n    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n    if (!this.#isDisabling && editor.annotationElementId) {\n      this.#uiManager.addDeletedAnnotationElement(editor);\n    }\n  }\n  remove(editor) {\n    this.detach(editor);\n    this.#uiManager.removeEditor(editor);\n    editor.div.remove();\n    editor.isAttachedToDOM = false;\n    if (!this.#isCleaningUp) {\n      this.addInkEditorIfNeeded(false);\n    }\n  }\n  changeParent(editor) {\n    if (editor.parent === this) {\n      return;\n    }\n    if (editor.parent && editor.annotationElementId) {\n      this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n      AnnotationEditor.deleteAnnotationElement(editor);\n      editor.annotationElementId = null;\n    }\n    this.attach(editor);\n    editor.parent?.detach(editor);\n    editor.setParent(this);\n    if (editor.div && editor.isAttachedToDOM) {\n      editor.div.remove();\n      this.div.append(editor.div);\n    }\n  }\n  add(editor) {\n    if (editor.parent === this && editor.isAttachedToDOM) {\n      return;\n    }\n    this.changeParent(editor);\n    this.#uiManager.addEditor(editor);\n    this.attach(editor);\n    if (!editor.isAttachedToDOM) {\n      const div = editor.render();\n      this.div.append(div);\n      editor.isAttachedToDOM = true;\n    }\n    editor.fixAndSetPosition();\n    editor.onceAdded();\n    this.#uiManager.addToAnnotationStorage(editor);\n    editor._reportTelemetry(editor.telemetryInitialData);\n  }\n  moveEditorInDOM(editor) {\n    if (!editor.isAttachedToDOM) {\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n      editor._focusEventsAllowed = false;\n      this.#editorFocusTimeoutId = setTimeout(() => {\n        this.#editorFocusTimeoutId = null;\n        if (!editor.div.contains(document.activeElement)) {\n          editor.div.addEventListener(\"focusin\", () => {\n            editor._focusEventsAllowed = true;\n          }, {\n            once: true,\n            signal: this.#uiManager._signal\n          });\n          activeElement.focus();\n        } else {\n          editor._focusEventsAllowed = true;\n        }\n      }, 0);\n    }\n    editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n  }\n  addOrRebuild(editor) {\n    if (editor.needsToBeRebuilt()) {\n      editor.parent ||= this;\n      editor.rebuild();\n      editor.show();\n    } else {\n      this.add(editor);\n    }\n  }\n  addUndoableEditor(editor) {\n    const cmd = () => editor._uiManager.rebuild(editor);\n    const undo = () => {\n      editor.remove();\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: false\n    });\n  }\n  getNextId() {\n    return this.#uiManager.getId();\n  }\n  get #currentEditorType() {\n    return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n  }\n  combinedSignal(ac) {\n    return this.#uiManager.combinedSignal(ac);\n  }\n  #createNewEditor(params) {\n    const editorType = this.#currentEditorType;\n    return editorType ? new editorType.prototype.constructor(params) : null;\n  }\n  canCreateNewEmptyEditor() {\n    return this.#currentEditorType?.canCreateNewEmptyEditor();\n  }\n  pasteEditor(mode, params) {\n    this.#uiManager.updateToolbar(mode);\n    this.#uiManager.updateMode(mode);\n    const {\n      offsetX,\n      offsetY\n    } = this.#getCenterPoint();\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: offsetX,\n      y: offsetY,\n      uiManager: this.#uiManager,\n      isCentered: true,\n      ...params\n    });\n    if (editor) {\n      this.add(editor);\n    }\n  }\n  async deserialize(data) {\n    return (await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager)) || null;\n  }\n  createAndAddNewEditor(event, isCentered, data = {}) {\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: event.offsetX,\n      y: event.offsetY,\n      uiManager: this.#uiManager,\n      isCentered,\n      ...data\n    });\n    if (editor) {\n      this.add(editor);\n    }\n    return editor;\n  }\n  #getCenterPoint() {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.div.getBoundingClientRect();\n    const tlX = Math.max(0, x);\n    const tlY = Math.max(0, y);\n    const brX = Math.min(window.innerWidth, x + width);\n    const brY = Math.min(window.innerHeight, y + height);\n    const centerX = (tlX + brX) / 2 - x;\n    const centerY = (tlY + brY) / 2 - y;\n    const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];\n    return {\n      offsetX,\n      offsetY\n    };\n  }\n  addNewEditor() {\n    this.createAndAddNewEditor(this.#getCenterPoint(), true);\n  }\n  setSelected(editor) {\n    this.#uiManager.setSelected(editor);\n  }\n  toggleSelected(editor) {\n    this.#uiManager.toggleSelected(editor);\n  }\n  unselect(editor) {\n    this.#uiManager.unselect(editor);\n  }\n  pointerup(event) {\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    if (event.target !== this.div) {\n      return;\n    }\n    if (!this.#hadPointerDown) {\n      return;\n    }\n    this.#hadPointerDown = false;\n    if (!this.#allowClick) {\n      this.#allowClick = true;\n      return;\n    }\n    if (this.#uiManager.getMode() === AnnotationEditorType.STAMP) {\n      this.#uiManager.unselectAll();\n      return;\n    }\n    this.createAndAddNewEditor(event, false);\n  }\n  pointerdown(event) {\n    if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n      this.enableTextSelection();\n    }\n    if (this.#hadPointerDown) {\n      this.#hadPointerDown = false;\n      return;\n    }\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    if (event.target !== this.div) {\n      return;\n    }\n    this.#hadPointerDown = true;\n    const editor = this.#uiManager.getActive();\n    this.#allowClick = !editor || editor.isEmpty();\n  }\n  findNewParent(editor, x, y) {\n    const layer = this.#uiManager.findParent(x, y);\n    if (layer === null || layer === this) {\n      return false;\n    }\n    layer.changeParent(editor);\n    return true;\n  }\n  destroy() {\n    if (this.#uiManager.getActive()?.parent === this) {\n      this.#uiManager.commitOrRemove();\n      this.#uiManager.setActiveEditor(null);\n    }\n    if (this.#editorFocusTimeoutId) {\n      clearTimeout(this.#editorFocusTimeoutId);\n      this.#editorFocusTimeoutId = null;\n    }\n    for (const editor of this.#editors.values()) {\n      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n      editor.setParent(null);\n      editor.isAttachedToDOM = false;\n      editor.div.remove();\n    }\n    this.div = null;\n    this.#editors.clear();\n    this.#uiManager.removeLayer(this);\n  }\n  #cleanup() {\n    this.#isCleaningUp = true;\n    for (const editor of this.#editors.values()) {\n      if (editor.isEmpty()) {\n        editor.remove();\n      }\n    }\n    this.#isCleaningUp = false;\n  }\n  render({\n    viewport\n  }) {\n    this.viewport = viewport;\n    setLayerDimensions(this.div, viewport);\n    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {\n      this.add(editor);\n      editor.rebuild();\n    }\n    this.updateMode();\n  }\n  update({\n    viewport\n  }) {\n    this.#uiManager.commitOrRemove();\n    this.#cleanup();\n    const oldRotation = this.viewport.rotation;\n    const rotation = viewport.rotation;\n    this.viewport = viewport;\n    setLayerDimensions(this.div, {\n      rotation\n    });\n    if (oldRotation !== rotation) {\n      for (const editor of this.#editors.values()) {\n        editor.rotate(rotation);\n      }\n    }\n    this.addInkEditorIfNeeded(false);\n  }\n  get pageDimensions() {\n    const {\n      pageWidth,\n      pageHeight\n    } = this.viewport.rawDims;\n    return [pageWidth, pageHeight];\n  }\n  get scale() {\n    return this.#uiManager.viewParameters.realScale;\n  }\n}\n\n;// ./src/display/draw_layer.js\n\n\nclass DrawLayer {\n  #parent = null;\n  #id = 0;\n  #mapping = new Map();\n  #toUpdate = new Map();\n  constructor({\n    pageIndex\n  }) {\n    this.pageIndex = pageIndex;\n  }\n  setParent(parent) {\n    if (!this.#parent) {\n      this.#parent = parent;\n      return;\n    }\n    if (this.#parent !== parent) {\n      if (this.#mapping.size > 0) {\n        for (const root of this.#mapping.values()) {\n          root.remove();\n          parent.append(root);\n        }\n      }\n      this.#parent = parent;\n    }\n  }\n  static get _svgFactory() {\n    return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n  }\n  static #setBox(element, {\n    x = 0,\n    y = 0,\n    width = 1,\n    height = 1\n  } = {}) {\n    const {\n      style\n    } = element;\n    style.top = `${100 * y}%`;\n    style.left = `${100 * x}%`;\n    style.width = `${100 * width}%`;\n    style.height = `${100 * height}%`;\n  }\n  #createSVG(box) {\n    const svg = DrawLayer._svgFactory.create(1, 1, true);\n    this.#parent.append(svg);\n    svg.setAttribute(\"aria-hidden\", true);\n    DrawLayer.#setBox(svg, box);\n    return svg;\n  }\n  #createClipPath(defs, pathId) {\n    const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n    defs.append(clipPath);\n    const clipPathId = `clip_${pathId}`;\n    clipPath.setAttribute(\"id\", clipPathId);\n    clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n    const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n    clipPath.append(clipPathUse);\n    clipPathUse.setAttribute(\"href\", `#${pathId}`);\n    clipPathUse.classList.add(\"clip\");\n    return clipPathId;\n  }\n  draw(outlines, color, opacity, isPathUpdatable = false) {\n    const id = this.#id++;\n    const root = this.#createSVG(outlines.box);\n    root.classList.add(...outlines.classNamesForDrawing);\n    const defs = DrawLayer._svgFactory.createElement(\"defs\");\n    root.append(defs);\n    const path = DrawLayer._svgFactory.createElement(\"path\");\n    defs.append(path);\n    const pathId = `path_p${this.pageIndex}_${id}`;\n    path.setAttribute(\"id\", pathId);\n    path.setAttribute(\"d\", outlines.toSVGPath());\n    if (isPathUpdatable) {\n      this.#toUpdate.set(id, path);\n    }\n    const clipPathId = this.#createClipPath(defs, pathId);\n    const use = DrawLayer._svgFactory.createElement(\"use\");\n    root.append(use);\n    root.setAttribute(\"fill\", color);\n    root.setAttribute(\"fill-opacity\", opacity);\n    use.setAttribute(\"href\", `#${pathId}`);\n    this.#mapping.set(id, root);\n    return {\n      id,\n      clipPathId: `url(#${clipPathId})`\n    };\n  }\n  drawOutline(outlines) {\n    const id = this.#id++;\n    const root = this.#createSVG(outlines.box);\n    root.classList.add(...outlines.classNamesForOutlining);\n    const defs = DrawLayer._svgFactory.createElement(\"defs\");\n    root.append(defs);\n    const path = DrawLayer._svgFactory.createElement(\"path\");\n    defs.append(path);\n    const pathId = `path_p${this.pageIndex}_${id}`;\n    path.setAttribute(\"id\", pathId);\n    path.setAttribute(\"d\", outlines.toSVGPath());\n    path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n    let maskId;\n    if (outlines.mustRemoveSelfIntersections) {\n      const mask = DrawLayer._svgFactory.createElement(\"mask\");\n      defs.append(mask);\n      maskId = `mask_p${this.pageIndex}_${id}`;\n      mask.setAttribute(\"id\", maskId);\n      mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n      const rect = DrawLayer._svgFactory.createElement(\"rect\");\n      mask.append(rect);\n      rect.setAttribute(\"width\", \"1\");\n      rect.setAttribute(\"height\", \"1\");\n      rect.setAttribute(\"fill\", \"white\");\n      const use = DrawLayer._svgFactory.createElement(\"use\");\n      mask.append(use);\n      use.setAttribute(\"href\", `#${pathId}`);\n      use.setAttribute(\"stroke\", \"none\");\n      use.setAttribute(\"fill\", \"black\");\n      use.setAttribute(\"fill-rule\", \"nonzero\");\n      use.classList.add(\"mask\");\n    }\n    const use1 = DrawLayer._svgFactory.createElement(\"use\");\n    root.append(use1);\n    use1.setAttribute(\"href\", `#${pathId}`);\n    if (maskId) {\n      use1.setAttribute(\"mask\", `url(#${maskId})`);\n    }\n    const use2 = use1.cloneNode();\n    root.append(use2);\n    use1.classList.add(\"mainOutline\");\n    use2.classList.add(\"secondaryOutline\");\n    this.#mapping.set(id, root);\n    return id;\n  }\n  finalizeLine(id, line) {\n    const path = this.#toUpdate.get(id);\n    this.#toUpdate.delete(id);\n    this.updateBox(id, line.box);\n    path.setAttribute(\"d\", line.toSVGPath());\n  }\n  updateLine(id, line) {\n    const root = this.#mapping.get(id);\n    const defs = root.firstChild;\n    const path = defs.firstChild;\n    path.setAttribute(\"d\", line.toSVGPath());\n  }\n  updatePath(id, line) {\n    this.#toUpdate.get(id).setAttribute(\"d\", line.toSVGPath());\n  }\n  updateBox(id, box) {\n    DrawLayer.#setBox(this.#mapping.get(id), box);\n  }\n  show(id, visible) {\n    this.#mapping.get(id).classList.toggle(\"hidden\", !visible);\n  }\n  rotate(id, angle) {\n    this.#mapping.get(id).setAttribute(\"data-main-rotation\", angle);\n  }\n  changeColor(id, color) {\n    this.#mapping.get(id).setAttribute(\"fill\", color);\n  }\n  changeOpacity(id, opacity) {\n    this.#mapping.get(id).setAttribute(\"fill-opacity\", opacity);\n  }\n  addClass(id, className) {\n    this.#mapping.get(id).classList.add(className);\n  }\n  removeClass(id, className) {\n    this.#mapping.get(id).classList.remove(className);\n  }\n  getSVGRoot(id) {\n    return this.#mapping.get(id);\n  }\n  remove(id) {\n    this.#toUpdate.delete(id);\n    if (this.#parent === null) {\n      return;\n    }\n    this.#mapping.get(id).remove();\n    this.#mapping.delete(id);\n  }\n  destroy() {\n    this.#parent = null;\n    for (const root of this.#mapping.values()) {\n      root.remove();\n    }\n    this.#mapping.clear();\n    this.#toUpdate.clear();\n  }\n}\n\n;// ./src/pdf.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst pdfjsVersion = \"4.8.69\";\nconst pdfjsBuild = \"3634dab10\";\n\nvar __webpack_exports__AbortException = __nested_webpack_exports__.AbortException;\nvar __webpack_exports__AnnotationEditorLayer = __nested_webpack_exports__.AnnotationEditorLayer;\nvar __webpack_exports__AnnotationEditorParamsType = __nested_webpack_exports__.AnnotationEditorParamsType;\nvar __webpack_exports__AnnotationEditorType = __nested_webpack_exports__.AnnotationEditorType;\nvar __webpack_exports__AnnotationEditorUIManager = __nested_webpack_exports__.AnnotationEditorUIManager;\nvar __webpack_exports__AnnotationLayer = __nested_webpack_exports__.AnnotationLayer;\nvar __webpack_exports__AnnotationMode = __nested_webpack_exports__.AnnotationMode;\nvar __webpack_exports__ColorPicker = __nested_webpack_exports__.ColorPicker;\nvar __webpack_exports__DOMSVGFactory = __nested_webpack_exports__.DOMSVGFactory;\nvar __webpack_exports__DrawLayer = __nested_webpack_exports__.DrawLayer;\nvar __webpack_exports__FeatureTest = __nested_webpack_exports__.FeatureTest;\nvar __webpack_exports__GlobalWorkerOptions = __nested_webpack_exports__.GlobalWorkerOptions;\nvar __webpack_exports__ImageKind = __nested_webpack_exports__.ImageKind;\nvar __webpack_exports__InvalidPDFException = __nested_webpack_exports__.InvalidPDFException;\nvar __webpack_exports__MissingPDFException = __nested_webpack_exports__.MissingPDFException;\nvar __webpack_exports__OPS = __nested_webpack_exports__.OPS;\nvar __webpack_exports__OutputScale = __nested_webpack_exports__.OutputScale;\nvar __webpack_exports__PDFDataRangeTransport = __nested_webpack_exports__.PDFDataRangeTransport;\nvar __webpack_exports__PDFDateString = __nested_webpack_exports__.PDFDateString;\nvar __webpack_exports__PDFWorker = __nested_webpack_exports__.PDFWorker;\nvar __webpack_exports__PasswordResponses = __nested_webpack_exports__.PasswordResponses;\nvar __webpack_exports__PermissionFlag = __nested_webpack_exports__.PermissionFlag;\nvar __webpack_exports__PixelsPerInch = __nested_webpack_exports__.PixelsPerInch;\nvar __webpack_exports__RenderingCancelledException = __nested_webpack_exports__.RenderingCancelledException;\nvar __webpack_exports__TextLayer = __nested_webpack_exports__.TextLayer;\nvar __webpack_exports__UnexpectedResponseException = __nested_webpack_exports__.UnexpectedResponseException;\nvar __webpack_exports__Util = __nested_webpack_exports__.Util;\nvar __webpack_exports__VerbosityLevel = __nested_webpack_exports__.VerbosityLevel;\nvar __webpack_exports__XfaLayer = __nested_webpack_exports__.XfaLayer;\nvar __webpack_exports__build = __nested_webpack_exports__.build;\nvar __webpack_exports__createValidAbsoluteUrl = __nested_webpack_exports__.createValidAbsoluteUrl;\nvar __webpack_exports__fetchData = __nested_webpack_exports__.fetchData;\nvar __webpack_exports__getDocument = __nested_webpack_exports__.getDocument;\nvar __webpack_exports__getFilenameFromUrl = __nested_webpack_exports__.getFilenameFromUrl;\nvar __webpack_exports__getPdfFilenameFromUrl = __nested_webpack_exports__.getPdfFilenameFromUrl;\nvar __webpack_exports__getXfaPageViewport = __nested_webpack_exports__.getXfaPageViewport;\nvar __webpack_exports__isDataScheme = __nested_webpack_exports__.isDataScheme;\nvar __webpack_exports__isPdfFile = __nested_webpack_exports__.isPdfFile;\nvar __webpack_exports__noContextMenu = __nested_webpack_exports__.noContextMenu;\nvar __webpack_exports__normalizeUnicode = __nested_webpack_exports__.normalizeUnicode;\nvar __webpack_exports__setLayerDimensions = __nested_webpack_exports__.setLayerDimensions;\nvar __webpack_exports__shadow = __nested_webpack_exports__.shadow;\nvar __webpack_exports__version = __nested_webpack_exports__.version;\n\n\n//# sourceMappingURL=pdf.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wZGZqcy1kaXN0L2J1aWxkL3BkZi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw4QkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0EsZUFBZSw4QkFBbUIsd0JBQXdCLDhCQUFtQjtBQUM3RSxtREFBbUQsd0NBQXdDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixVQUFVO0FBQ1Y7QUFDQTtBQUNBLElBQUksMEJBQW1COztBQUV2QjtBQUNBLDhCQUFtQixHQUFHLDBCQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQztBQUNELHdCQUF3QixPQUFPLGlCQUFpQixPQUFPLGlDQUFpQyxPQUFPLGtCQUFrQixPQUFPLHNCQUFzQixPQUFPLFNBQVMsT0FBTztBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLENBQXdwQjtBQUN4dUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9DQUFvQyxHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scUJBQXFCLHNCQUFzQixFQUFFLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLDJCQUEyQixFQUFFLG1CQUFtQixFQUFFO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQsbUNBQW1DLFdBQVc7QUFDOUMsK0NBQStDLEVBQUUsd0NBQXdDLEVBQUU7QUFDM0YsNENBQTRDLEVBQUUsd0NBQXdDLEVBQUU7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEMsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw4QkFBOEIsUUFBUTtBQUN0Qyx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCLEVBQUUsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3SUFBd0k7QUFDNUs7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWEsR0FBRyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsSUFBSTtBQUM3RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0IsYUFBYSxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLEdBQUcsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsWUFBWTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7OztBQU1EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRCw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixxQkFBcUI7QUFDekMsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUNBQXVDO0FBQ3JFO0FBQ0EsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtREFBbUQ7QUFDMUU7QUFDQTtBQUNBLHdCQUF3QixxREFBcUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4Q0FBOEM7QUFDakYsb0NBQW9DLDhDQUE4QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3Qix1Q0FBdUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJLEdBQUcsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix1Q0FBdUMsc0JBQXNCLE1BQU0sR0FBRztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLEVBQUUsc0JBQXNCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTLFdBQVcsRUFBRTtBQUM5RCw4QkFBOEIsZUFBZSxlQUFlLEVBQUUsTUFBTSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWUsU0FBUyx3QkFBd0IsRUFBRTtBQUM5RTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsZ0JBQWdCLEVBQUUsTUFBTSxLQUFLO0FBQ3RFLE1BQU07QUFDTixnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0Esc0NBQXNDLDZCQUE2QixJQUFJO0FBQ3ZFO0FBQ0EsMEJBQTBCLGVBQWUsNEJBQTRCLEVBQUUsRUFBRSxJQUFJLE1BQU0sS0FBSztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNEQUFzRCxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsbUNBQW1DLFdBQVcsSUFBSTtBQUMxRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYyxHQUFHLEdBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSxnQkFBZ0IsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsR0FBRyxRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVksYUFBYSxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZLGtCQUFrQixXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUSxHQUFHLFFBQVEsR0FBRyxXQUFXLEdBQUcsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSxPQUFPLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsRUFBRSxTQUFTO0FBQzNDO0FBQ0Esc0RBQXNELElBQUk7QUFDMUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7O0FBTUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBLElBQUk7QUFDSixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBLElBQUk7QUFDSixxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSyxLQUFLLHFCQUFxQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixLQUFLLFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1Isa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEdBQUc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzREFBc0QsR0FBRztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0RBQXNELEdBQUc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEdBQUc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsR0FBRyxHQUFHLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBcUQsT0FBTztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE9BQU8sMEJBQTBCLElBQUk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU0sR0FBRyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVyxHQUFHLGFBQWE7QUFDeEU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU0sR0FBRyxRQUFRO0FBQzlDO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnQkFBZ0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvRUFBb0UsMENBQTBDLCtCQUErQixpREFBaUQ7QUFDOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMENBQTBDO0FBQ25FLHdCQUF3QiwwQ0FBMEM7QUFDbEUsTUFBTTtBQUNOLHlCQUF5QixlQUFlLEVBQUUsZ0JBQWdCO0FBQzFELHdCQUF3QixlQUFlLEVBQUUsZUFBZTtBQUN4RDtBQUNBLDJCQUEyQixlQUFlLEVBQUUsaURBQWlEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDhCQUE4QixrQ0FBa0MsSUFBSSxVQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUIsT0FBTyxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSyxLQUFLLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNLG1DQUFtQyxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSSxHQUFHO0FBQzlDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnRkFBZ0YsZUFBZTtBQUMvRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxlQUFlO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEtBQUs7QUFDakU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVEsUUFBUSxRQUFRLEdBQUcsUUFBUTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE1BQU07QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLG9CQUFvQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekMsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBLHVDQUF1QyxPQUFPLEVBQUUsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0IsR0FBRyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3Q0FBd0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7QUFPRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixvQ0FBb0M7QUFDeEQsbUJBQW1CLGtEQUFrRDtBQUNyRTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0Msd0JBQXdCLDBCQUEwQjtBQUNsRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQixtQ0FBbUMsZUFBZTtBQUNsRztBQUNBLFFBQVE7QUFDUiwrQkFBK0IsTUFBTSxtQ0FBbUMsT0FBTztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0JBQW9CLG9DQUFvQztBQUN4RCxtQkFBbUIscUNBQXFDO0FBQ3hEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DLHdCQUF3QiwwQkFBMEI7QUFDbEQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVU7QUFDbkU7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw0Q0FBNEMsc0lBQXNJLFlBQVksa0JBQWtCLFlBQVk7QUFDNU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFLE9BQU8sRUFBRSxXQUFXLFVBQVUsWUFBWSxXQUFXO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxHQUFHO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxHQUFHO0FBQzVFO0FBQ0EsOERBQThELEdBQUc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEdBQUc7QUFDMUU7QUFDQTtBQUNBLFVBQVU7QUFDViw4REFBOEQsR0FBRztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxpQkFBaUIsRUFBRSxHQUFHO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixrQkFBa0I7QUFDdEMsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRSxHQUFHLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBLHVCQUF1QixFQUFFLEdBQUcsRUFBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1Qix3QkFBd0IsYUFBYSx1REFBdUQ7QUFDbkg7QUFDQSwyQ0FBMkMsaUNBQWlDLEdBQUc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUIsRUFBRSxHQUFHO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QixFQUFFLE1BQU0sRUFBRSx1QkFBdUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRLEVBQUUsT0FBTztBQUNyQyxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0Esd0JBQXdCLFlBQVksRUFBRSxXQUFXO0FBQ2pELFFBQVE7QUFDUix3QkFBd0IsUUFBUSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxXQUFXO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0Esd0JBQXdCLGVBQWUsRUFBRSxjQUFjO0FBQ3ZELFFBQVE7QUFDUix3QkFBd0IsV0FBVyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxjQUFjO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QixFQUFFLDhCQUE4QixHQUFHLDZCQUE2QixFQUFFLDhCQUE4QixHQUFHLFVBQVUsRUFBRSxVQUFVLEdBQUcsYUFBYSxFQUFFLGFBQWEsR0FBRyw4QkFBOEIsRUFBRSwrQkFBK0IsR0FBRyw4QkFBOEIsRUFBRSwrQkFBK0I7QUFDeFU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVcsRUFBRSxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEIsRUFBRSwyQkFBMkIsR0FBRyxVQUFVLEVBQUUsVUFBVSxHQUFHLGFBQWEsRUFBRSxhQUFhLEdBQUcsNkJBQTZCLEVBQUUsNkJBQTZCO0FBQ2xNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUMsc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCLEVBQUUsaUJBQWlCO0FBQzdELCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0Esd0JBQXdCLHNCQUFzQixFQUFFLHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUFFLHFCQUFxQjtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPLEVBQUUsTUFBTTtBQUNyQyxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7O0FBUUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7OztBQU1EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTSxFQUFFLHNCQUFzQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEtBQUs7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGlCQUFpQixFQUFFLEdBQUc7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUIscUJBQXFCLFlBQVk7QUFDakMsc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlLEdBQUcsR0FBRztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWUsR0FBRyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWUsR0FBRyxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7Ozs7OztBQWNEO0FBQ0E7O0FBRUEsd0NBQXdDLDBCQUFtQjtBQUMzRCwrQ0FBK0MsMEJBQW1CO0FBQ2xFLG9EQUFvRCwwQkFBbUI7QUFDdkUsOENBQThDLDBCQUFtQjtBQUNqRSxtREFBbUQsMEJBQW1CO0FBQ3RFLHlDQUF5QywwQkFBbUI7QUFDNUQsd0NBQXdDLDBCQUFtQjtBQUMzRCxxQ0FBcUMsMEJBQW1CO0FBQ3hELHVDQUF1QywwQkFBbUI7QUFDMUQsbUNBQW1DLDBCQUFtQjtBQUN0RCxxQ0FBcUMsMEJBQW1CO0FBQ3hELDZDQUE2QywwQkFBbUI7QUFDaEUsbUNBQW1DLDBCQUFtQjtBQUN0RCw2Q0FBNkMsMEJBQW1CO0FBQ2hFLDZDQUE2QywwQkFBbUI7QUFDaEUsNkJBQTZCLDBCQUFtQjtBQUNoRCxxQ0FBcUMsMEJBQW1CO0FBQ3hELCtDQUErQywwQkFBbUI7QUFDbEUsdUNBQXVDLDBCQUFtQjtBQUMxRCxtQ0FBbUMsMEJBQW1CO0FBQ3RELDJDQUEyQywwQkFBbUI7QUFDOUQsd0NBQXdDLDBCQUFtQjtBQUMzRCx1Q0FBdUMsMEJBQW1CO0FBQzFELHFEQUFxRCwwQkFBbUI7QUFDeEUsbUNBQW1DLDBCQUFtQjtBQUN0RCxxREFBcUQsMEJBQW1CO0FBQ3hFLDhCQUE4QiwwQkFBbUI7QUFDakQsd0NBQXdDLDBCQUFtQjtBQUMzRCxrQ0FBa0MsMEJBQW1CO0FBQ3JELCtCQUErQiwwQkFBbUI7QUFDbEQsZ0RBQWdELDBCQUFtQjtBQUNuRSxtQ0FBbUMsMEJBQW1CO0FBQ3RELHFDQUFxQywwQkFBbUI7QUFDeEQsNENBQTRDLDBCQUFtQjtBQUMvRCwrQ0FBK0MsMEJBQW1CO0FBQ2xFLDRDQUE0QywwQkFBbUI7QUFDL0Qsc0NBQXNDLDBCQUFtQjtBQUN6RCxtQ0FBbUMsMEJBQW1CO0FBQ3RELHVDQUF1QywwQkFBbUI7QUFDMUQsMENBQTBDLDBCQUFtQjtBQUM3RCw0Q0FBNEMsMEJBQW1CO0FBQy9ELGdDQUFnQywwQkFBbUI7QUFDbkQsaUNBQWlDLDBCQUFtQjtBQUNpdUU7O0FBRXJ4RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzPzNhZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljc3RhcnQgVGhlIGZvbGxvd2luZyBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAyNCBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGxpY2VuZCBUaGUgYWJvdmUgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKi9cblxuLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgc2NvcGVcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfcmVxdWlyZV9fID0ge307XG4vKioqKioqLyBcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqLyB9KSgpO1xuLyoqKioqKi8gXG4vKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyAoKCkgPT4ge1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyB9KSgpO1xuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBnbG9iYWxUaGlzLnBkZmpzTGliID0ge307XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIEFib3J0RXhjZXB0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWJvcnRFeGNlcHRpb24pLFxuICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIpLFxuICBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlKSxcbiAgQW5ub3RhdGlvbkVkaXRvclR5cGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uRWRpdG9yVHlwZSksXG4gIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyKSxcbiAgQW5ub3RhdGlvbkxheWVyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQW5ub3RhdGlvbkxheWVyKSxcbiAgQW5ub3RhdGlvbk1vZGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uTW9kZSksXG4gIENvbG9yUGlja2VyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sb3JQaWNrZXIpLFxuICBET01TVkdGYWN0b3J5OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRE9NU1ZHRmFjdG9yeSksXG4gIERyYXdMYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERyYXdMYXllciksXG4gIEZlYXR1cmVUZXN0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdXRpbF9GZWF0dXJlVGVzdCksXG4gIEdsb2JhbFdvcmtlck9wdGlvbnM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHbG9iYWxXb3JrZXJPcHRpb25zKSxcbiAgSW1hZ2VLaW5kOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdXRpbF9JbWFnZUtpbmQpLFxuICBJbnZhbGlkUERGRXhjZXB0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSW52YWxpZFBERkV4Y2VwdGlvbiksXG4gIE1pc3NpbmdQREZFeGNlcHRpb246ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNaXNzaW5nUERGRXhjZXB0aW9uKSxcbiAgT1BTOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gT1BTKSxcbiAgT3V0cHV0U2NhbGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBPdXRwdXRTY2FsZSksXG4gIFBERkRhdGFSYW5nZVRyYW5zcG9ydDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBERkRhdGFSYW5nZVRyYW5zcG9ydCksXG4gIFBERkRhdGVTdHJpbmc6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQREZEYXRlU3RyaW5nKSxcbiAgUERGV29ya2VyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUERGV29ya2VyKSxcbiAgUGFzc3dvcmRSZXNwb25zZXM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQYXNzd29yZFJlc3BvbnNlcyksXG4gIFBlcm1pc3Npb25GbGFnOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGVybWlzc2lvbkZsYWcpLFxuICBQaXhlbHNQZXJJbmNoOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGl4ZWxzUGVySW5jaCksXG4gIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiksXG4gIFRleHRMYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRleHRMYXllciksXG4gIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiksXG4gIFV0aWw6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBVdGlsKSxcbiAgVmVyYm9zaXR5TGV2ZWw6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBWZXJib3NpdHlMZXZlbCksXG4gIFhmYUxheWVyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gWGZhTGF5ZXIpLFxuICBidWlsZDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGJ1aWxkKSxcbiAgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwpLFxuICBmZXRjaERhdGE6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBmZXRjaERhdGEpLFxuICBnZXREb2N1bWVudDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGdldERvY3VtZW50KSxcbiAgZ2V0RmlsZW5hbWVGcm9tVXJsOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZ2V0RmlsZW5hbWVGcm9tVXJsKSxcbiAgZ2V0UGRmRmlsZW5hbWVGcm9tVXJsOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsKSxcbiAgZ2V0WGZhUGFnZVZpZXdwb3J0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZ2V0WGZhUGFnZVZpZXdwb3J0KSxcbiAgaXNEYXRhU2NoZW1lOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaXNEYXRhU2NoZW1lKSxcbiAgaXNQZGZGaWxlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaXNQZGZGaWxlKSxcbiAgbm9Db250ZXh0TWVudTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIG5vQ29udGV4dE1lbnUpLFxuICBub3JtYWxpemVVbmljb2RlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gbm9ybWFsaXplVW5pY29kZSksXG4gIHNldExheWVyRGltZW5zaW9uczogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHNldExheWVyRGltZW5zaW9ucyksXG4gIHNoYWRvdzogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHNoYWRvdyksXG4gIHZlcnNpb246ICgpID0+ICgvKiByZWV4cG9ydCAqLyB2ZXJzaW9uKVxufSk7XG5cbjsvLyAuL3NyYy9zaGFyZWQvdXRpbC5qc1xuY29uc3QgaXNOb2RlSlMgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICsgXCJcIiA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgIXByb2Nlc3MudmVyc2lvbnMubncgJiYgIShwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICYmIHByb2Nlc3MudHlwZSAmJiBwcm9jZXNzLnR5cGUgIT09IFwiYnJvd3NlclwiKTtcbmNvbnN0IElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbmNvbnN0IEZPTlRfSURFTlRJVFlfTUFUUklYID0gWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF07XG5jb25zdCBNQVhfSU1BR0VfU0laRV9UT19DQUNIRSA9IDEwZTY7XG5jb25zdCBMSU5FX0ZBQ1RPUiA9IDEuMzU7XG5jb25zdCBMSU5FX0RFU0NFTlRfRkFDVE9SID0gMC4zNTtcbmNvbnN0IEJBU0VMSU5FX0ZBQ1RPUiA9IExJTkVfREVTQ0VOVF9GQUNUT1IgLyBMSU5FX0ZBQ1RPUjtcbmNvbnN0IFJlbmRlcmluZ0ludGVudEZsYWcgPSB7XG4gIEFOWTogMHgwMSxcbiAgRElTUExBWTogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIFNBVkU6IDB4MDgsXG4gIEFOTk9UQVRJT05TX0ZPUk1TOiAweDEwLFxuICBBTk5PVEFUSU9OU19TVE9SQUdFOiAweDIwLFxuICBBTk5PVEFUSU9OU19ESVNBQkxFOiAweDQwLFxuICBJU19FRElUSU5HOiAweDgwLFxuICBPUExJU1Q6IDB4MTAwXG59O1xuY29uc3QgQW5ub3RhdGlvbk1vZGUgPSB7XG4gIERJU0FCTEU6IDAsXG4gIEVOQUJMRTogMSxcbiAgRU5BQkxFX0ZPUk1TOiAyLFxuICBFTkFCTEVfU1RPUkFHRTogM1xufTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2VkaXRvcl9cIjtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JUeXBlID0ge1xuICBESVNBQkxFOiAtMSxcbiAgTk9ORTogMCxcbiAgRlJFRVRFWFQ6IDMsXG4gIEhJR0hMSUdIVDogOSxcbiAgU1RBTVA6IDEzLFxuICBJTks6IDE1XG59O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSB7XG4gIFJFU0laRTogMSxcbiAgQ1JFQVRFOiAyLFxuICBGUkVFVEVYVF9TSVpFOiAxMSxcbiAgRlJFRVRFWFRfQ09MT1I6IDEyLFxuICBGUkVFVEVYVF9PUEFDSVRZOiAxMyxcbiAgSU5LX0NPTE9SOiAyMSxcbiAgSU5LX1RISUNLTkVTUzogMjIsXG4gIElOS19PUEFDSVRZOiAyMyxcbiAgSElHSExJR0hUX0NPTE9SOiAzMSxcbiAgSElHSExJR0hUX0RFRkFVTFRfQ09MT1I6IDMyLFxuICBISUdITElHSFRfVEhJQ0tORVNTOiAzMyxcbiAgSElHSExJR0hUX0ZSRUU6IDM0LFxuICBISUdITElHSFRfU0hPV19BTEw6IDM1XG59O1xuY29uc3QgUGVybWlzc2lvbkZsYWcgPSB7XG4gIFBSSU5UOiAweDA0LFxuICBNT0RJRllfQ09OVEVOVFM6IDB4MDgsXG4gIENPUFk6IDB4MTAsXG4gIE1PRElGWV9BTk5PVEFUSU9OUzogMHgyMCxcbiAgRklMTF9JTlRFUkFDVElWRV9GT1JNUzogMHgxMDAsXG4gIENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6IDB4MjAwLFxuICBBU1NFTUJMRTogMHg0MDAsXG4gIFBSSU5UX0hJR0hfUVVBTElUWTogMHg4MDBcbn07XG5jb25zdCBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcbiAgRklMTDogMCxcbiAgU1RST0tFOiAxLFxuICBGSUxMX1NUUk9LRTogMixcbiAgSU5WSVNJQkxFOiAzLFxuICBGSUxMX0FERF9UT19QQVRIOiA0LFxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxuICBBRERfVE9fUEFUSDogNyxcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxufTtcbmNvbnN0IHV0aWxfSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFRFWFQ6IDEsXG4gIExJTks6IDIsXG4gIEZSRUVURVhUOiAzLFxuICBMSU5FOiA0LFxuICBTUVVBUkU6IDUsXG4gIENJUkNMRTogNixcbiAgUE9MWUdPTjogNyxcbiAgUE9MWUxJTkU6IDgsXG4gIEhJR0hMSUdIVDogOSxcbiAgVU5ERVJMSU5FOiAxMCxcbiAgU1FVSUdHTFk6IDExLFxuICBTVFJJS0VPVVQ6IDEyLFxuICBTVEFNUDogMTMsXG4gIENBUkVUOiAxNCxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBGSUxFQVRUQUNITUVOVDogMTcsXG4gIFNPVU5EOiAxOCxcbiAgTU9WSUU6IDE5LFxuICBXSURHRVQ6IDIwLFxuICBTQ1JFRU46IDIxLFxuICBQUklOVEVSTUFSSzogMjIsXG4gIFRSQVBORVQ6IDIzLFxuICBXQVRFUk1BUks6IDI0LFxuICBUSFJFRUQ6IDI1LFxuICBSRURBQ1Q6IDI2XG59O1xuY29uc3QgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuY29uc3QgQW5ub3RhdGlvbkZsYWcgPSB7XG4gIElOVklTSUJMRTogMHgwMSxcbiAgSElEREVOOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgTk9aT09NOiAweDA4LFxuICBOT1JPVEFURTogMHgxMCxcbiAgTk9WSUVXOiAweDIwLFxuICBSRUFET05MWTogMHg0MCxcbiAgTE9DS0VEOiAweDgwLFxuICBUT0dHTEVOT1ZJRVc6IDB4MTAwLFxuICBMT0NLRURDT05URU5UUzogMHgyMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uRmllbGRGbGFnID0ge1xuICBSRUFET05MWTogMHgwMDAwMDAxLFxuICBSRVFVSVJFRDogMHgwMDAwMDAyLFxuICBOT0VYUE9SVDogMHgwMDAwMDA0LFxuICBNVUxUSUxJTkU6IDB4MDAwMTAwMCxcbiAgUEFTU1dPUkQ6IDB4MDAwMjAwMCxcbiAgTk9UT0dHTEVUT09GRjogMHgwMDA0MDAwLFxuICBSQURJTzogMHgwMDA4MDAwLFxuICBQVVNIQlVUVE9OOiAweDAwMTAwMDAsXG4gIENPTUJPOiAweDAwMjAwMDAsXG4gIEVESVQ6IDB4MDA0MDAwMCxcbiAgU09SVDogMHgwMDgwMDAwLFxuICBGSUxFU0VMRUNUOiAweDAxMDAwMDAsXG4gIE1VTFRJU0VMRUNUOiAweDAyMDAwMDAsXG4gIERPTk9UU1BFTExDSEVDSzogMHgwNDAwMDAwLFxuICBET05PVFNDUk9MTDogMHgwODAwMDAwLFxuICBDT01COiAweDEwMDAwMDAsXG4gIFJJQ0hURVhUOiAweDIwMDAwMDAsXG4gIFJBRElPU0lOVU5JU09OOiAweDIwMDAwMDAsXG4gIENPTU1JVE9OU0VMQ0hBTkdFOiAweDQwMDAwMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0ge1xuICBTT0xJRDogMSxcbiAgREFTSEVEOiAyLFxuICBCRVZFTEVEOiAzLFxuICBJTlNFVDogNCxcbiAgVU5ERVJMSU5FOiA1XG59O1xuY29uc3QgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgRTogXCJNb3VzZSBFbnRlclwiLFxuICBYOiBcIk1vdXNlIEV4aXRcIixcbiAgRDogXCJNb3VzZSBEb3duXCIsXG4gIFU6IFwiTW91c2UgVXBcIixcbiAgRm86IFwiRm9jdXNcIixcbiAgQmw6IFwiQmx1clwiLFxuICBQTzogXCJQYWdlT3BlblwiLFxuICBQQzogXCJQYWdlQ2xvc2VcIixcbiAgUFY6IFwiUGFnZVZpc2libGVcIixcbiAgUEk6IFwiUGFnZUludmlzaWJsZVwiLFxuICBLOiBcIktleXN0cm9rZVwiLFxuICBGOiBcIkZvcm1hdFwiLFxuICBWOiBcIlZhbGlkYXRlXCIsXG4gIEM6IFwiQ2FsY3VsYXRlXCJcbn07XG5jb25zdCBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgV0M6IFwiV2lsbENsb3NlXCIsXG4gIFdTOiBcIldpbGxTYXZlXCIsXG4gIERTOiBcIkRpZFNhdmVcIixcbiAgV1A6IFwiV2lsbFByaW50XCIsXG4gIERQOiBcIkRpZFByaW50XCJcbn07XG5jb25zdCBQYWdlQWN0aW9uRXZlbnRUeXBlID0ge1xuICBPOiBcIlBhZ2VPcGVuXCIsXG4gIEM6IFwiUGFnZUNsb3NlXCJcbn07XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTEsXG4gIHNldFN0cm9rZVRyYW5zcGFyZW50OiA5MixcbiAgc2V0RmlsbFRyYW5zcGFyZW50OiA5M1xufTtcbmNvbnN0IFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5sZXQgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChsZXZlbCkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcihsZXZlbCkpIHtcbiAgICB2ZXJib3NpdHkgPSBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKSB7XG4gIHJldHVybiB2ZXJib3NpdHk7XG59XG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5sb2coYEluZm86ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTKSB7XG4gICAgY29uc29sZS5sb2coYFdhcm5pbmc6ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB1bnJlYWNoYWJsZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkge1xuICAgIHVucmVhY2hhYmxlKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIHN3aXRjaCAodXJsPy5wcm90b2NvbCkge1xuICAgIGNhc2UgXCJodHRwOlwiOlxuICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICBjYXNlIFwiZnRwOlwiOlxuICAgIGNhc2UgXCJtYWlsdG86XCI6XG4gICAgY2FzZSBcInRlbDpcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwodXJsLCBiYXNlVXJsID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmFkZERlZmF1bHRQcm90b2NvbCAmJiB1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICAgICAgY29uc3QgZG90cyA9IHVybC5tYXRjaCgvXFwuL2cpO1xuICAgICAgICBpZiAoZG90cz8ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICB1cmwgPSBgaHR0cDovLyR7dXJsfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyeUNvbnZlcnRFbmNvZGluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IHN0cmluZ1RvVVRGOFN0cmluZyh1cmwpO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFic29sdXRlVXJsID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKTtcbiAgICBpZiAoX2lzVmFsaWRQcm90b2NvbChhYnNvbHV0ZVVybCkpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0ZVVybDtcbiAgICB9XG4gIH0gY2F0Y2gge31cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzaGFkb3cob2JqLCBwcm9wLCB2YWx1ZSwgbm9uU2VyaWFsaXphYmxlID0gZmFsc2UpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIHZhbHVlLFxuICAgIGVudW1lcmFibGU6ICFub25TZXJpYWxpemFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgQmFzZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uIEJhc2VFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgQmFzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgQmFzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb247XG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSgpO1xuY2xhc3MgUGFzc3dvcmRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBjb2RlKSB7XG4gICAgc3VwZXIobXNnLCBcIlBhc3N3b3JkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cbmNsYXNzIFVua25vd25FcnJvckV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGRldGFpbHMpIHtcbiAgICBzdXBlcihtc2csIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cbmNsYXNzIEludmFsaWRQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkludmFsaWRQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmNsYXNzIE1pc3NpbmdQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIk1pc3NpbmdQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmNsYXNzIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIHN0YXR1cykge1xuICAgIHN1cGVyKG1zZywgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIik7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cbn1cbmNsYXNzIEZvcm1hdEVycm9yIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJGb3JtYXRFcnJvclwiKTtcbiAgfVxufVxuY2xhc3MgQWJvcnRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkFib3J0RXhjZXB0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgIT09IFwib2JqZWN0XCIgfHwgYnl0ZXM/Lmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBieXRlc1RvU3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgY29uc3QgTUFYX0FSR1VNRU5UX0NPVU5UID0gODE5MjtcbiAgaWYgKGxlbmd0aCA8IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgY29uc3QgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xuICAgIGNvbnN0IGNodW5rID0gYnl0ZXMuc3ViYXJyYXkoaSwgY2h1bmtFbmQpO1xuICAgIHN0ckJ1Zi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2h1bmspKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3Igc3RyaW5nVG9CeXRlc1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBieXRlc1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBzdHJpbmczMih2YWx1ZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSA+PiAyNCAmIDB4ZmYsIHZhbHVlID4+IDE2ICYgMHhmZiwgdmFsdWUgPj4gOCAmIDB4ZmYsIHZhbHVlICYgMHhmZik7XG59XG5mdW5jdGlvbiBvYmplY3RTaXplKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBvYmplY3RGcm9tTWFwKG1hcCkge1xuICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgY29uc3QgYnVmZmVyOCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBidWZmZXI4WzBdID0gMTtcbiAgY29uc3QgdmlldzMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcjguYnVmZmVyLCAwLCAxKTtcbiAgcmV0dXJuIHZpZXczMlswXSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzRXZhbFN1cHBvcnRlZCgpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oXCJcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY2xhc3MgdXRpbF9GZWF0dXJlVGVzdCB7XG4gIHN0YXRpYyBnZXQgaXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzTGl0dGxlRW5kaWFuXCIsIGlzTGl0dGxlRW5kaWFuKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNFdmFsU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0V2YWxTdXBwb3J0ZWRcIiwgaXNFdmFsU3VwcG9ydGVkKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkXCIsIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgcGxhdGZvcm0oKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvcj8ucGxhdGZvcm0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICAgIGlzTWFjOiBuYXZpZ2F0b3IucGxhdGZvcm0uaW5jbHVkZXMoXCJNYWNcIiksXG4gICAgICAgIGlzV2luZG93czogbmF2aWdhdG9yLnBsYXRmb3JtLmluY2x1ZGVzKFwiV2luXCIpLFxuICAgICAgICBpc0ZpcmVmb3g6IHR5cGVvZiBuYXZpZ2F0b3I/LnVzZXJBZ2VudCA9PT0gXCJzdHJpbmdcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveFwiKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICBpc01hYzogZmFsc2UsXG4gICAgICBpc1dpbmRvd3M6IGZhbHNlLFxuICAgICAgaXNGaXJlZm94OiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNDU1NSb3VuZFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNDU1NSb3VuZFN1cHBvcnRlZFwiLCBnbG9iYWxUaGlzLkNTUz8uc3VwcG9ydHM/LihcIndpZHRoOiByb3VuZCgxLjVweCwgMXB4KVwiKSk7XG4gIH1cbn1cbmNvbnN0IGhleE51bWJlcnMgPSBBcnJheS5mcm9tKEFycmF5KDI1Nikua2V5cygpLCBuID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5jbGFzcyBVdGlsIHtcbiAgc3RhdGljIG1ha2VIZXhDb2xvcihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIGAjJHtoZXhOdW1iZXJzW3JdfSR7aGV4TnVtYmVyc1tnXX0ke2hleE51bWJlcnNbYl19YDtcbiAgfVxuICBzdGF0aWMgc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpIHtcbiAgICBsZXQgdGVtcDtcbiAgICBpZiAodHJhbnNmb3JtWzBdKSB7XG4gICAgICBpZiAodHJhbnNmb3JtWzBdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bM10gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgbWluTWF4WzBdID0gbWluTWF4WzFdO1xuICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMl07XG4gICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgaWYgKHRyYW5zZm9ybVsxXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBpZiAodHJhbnNmb3JtWzJdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzJdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVsyXTtcbiAgICB9XG4gICAgbWluTWF4WzBdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbMV0gKz0gdHJhbnNmb3JtWzVdO1xuICAgIG1pbk1heFsyXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzNdICs9IHRyYW5zZm9ybVs1XTtcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtKG0xLCBtMikge1xuICAgIHJldHVybiBbbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sIG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdLCBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXSwgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sIG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF0sIG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV1dO1xuICB9XG4gIHN0YXRpYyBhcHBseVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgeHQgPSBwWzBdICogbVswXSArIHBbMV0gKiBtWzJdICsgbVs0XTtcbiAgICBjb25zdCB5dCA9IHBbMF0gKiBtWzFdICsgcFsxXSAqIG1bM10gKyBtWzVdO1xuICAgIHJldHVybiBbeHQsIHl0XTtcbiAgfVxuICBzdGF0aWMgYXBwbHlJbnZlcnNlVHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICBjb25zdCB4dCA9IChwWzBdICogbVszXSAtIHBbMV0gKiBtWzJdICsgbVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkO1xuICAgIGNvbnN0IHl0ID0gKC1wWzBdICogbVsxXSArIHBbMV0gKiBtWzBdICsgbVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkO1xuICAgIHJldHVybiBbeHQsIHl0XTtcbiAgfVxuICBzdGF0aWMgZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3gociwgbSkge1xuICAgIGNvbnN0IHAxID0gdGhpcy5hcHBseVRyYW5zZm9ybShyLCBtKTtcbiAgICBjb25zdCBwMiA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oci5zbGljZSgyLCA0KSwgbSk7XG4gICAgY29uc3QgcDMgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKFtyWzBdLCByWzNdXSwgbSk7XG4gICAgY29uc3QgcDQgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKFtyWzJdLCByWzFdXSwgbSk7XG4gICAgcmV0dXJuIFtNYXRoLm1pbihwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWluKHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKSwgTWF0aC5tYXgocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLCBNYXRoLm1heChwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSldO1xuICB9XG4gIHN0YXRpYyBpbnZlcnNlVHJhbnNmb3JtKG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICByZXR1cm4gW21bM10gLyBkLCAtbVsxXSAvIGQsIC1tWzJdIC8gZCwgbVswXSAvIGQsIChtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQsIChtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGRdO1xuICB9XG4gIHN0YXRpYyBzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtKSB7XG4gICAgY29uc3QgdHJhbnNwb3NlID0gW21bMF0sIG1bMl0sIG1bMV0sIG1bM11dO1xuICAgIGNvbnN0IGEgPSBtWzBdICogdHJhbnNwb3NlWzBdICsgbVsxXSAqIHRyYW5zcG9zZVsyXTtcbiAgICBjb25zdCBiID0gbVswXSAqIHRyYW5zcG9zZVsxXSArIG1bMV0gKiB0cmFuc3Bvc2VbM107XG4gICAgY29uc3QgYyA9IG1bMl0gKiB0cmFuc3Bvc2VbMF0gKyBtWzNdICogdHJhbnNwb3NlWzJdO1xuICAgIGNvbnN0IGQgPSBtWzJdICogdHJhbnNwb3NlWzFdICsgbVszXSAqIHRyYW5zcG9zZVszXTtcbiAgICBjb25zdCBmaXJzdCA9IChhICsgZCkgLyAyO1xuICAgIGNvbnN0IHNlY29uZCA9IE1hdGguc3FydCgoYSArIGQpICoqIDIgLSA0ICogKGEgKiBkIC0gYyAqIGIpKSAvIDI7XG4gICAgY29uc3Qgc3ggPSBmaXJzdCArIHNlY29uZCB8fCAxO1xuICAgIGNvbnN0IHN5ID0gZmlyc3QgLSBzZWNvbmQgfHwgMTtcbiAgICByZXR1cm4gW01hdGguc3FydChzeCksIE1hdGguc3FydChzeSldO1xuICB9XG4gIHN0YXRpYyBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICBjb25zdCByID0gcmVjdC5zbGljZSgwKTtcbiAgICBpZiAocmVjdFswXSA+IHJlY3RbMl0pIHtcbiAgICAgIHJbMF0gPSByZWN0WzJdO1xuICAgICAgclsyXSA9IHJlY3RbMF07XG4gICAgfVxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xuICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICByWzNdID0gcmVjdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc3RhdGljIGludGVyc2VjdChyZWN0MSwgcmVjdDIpIHtcbiAgICBjb25zdCB4TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5taW4ocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgY29uc3QgeEhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1heChyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBpZiAoeExvdyA+IHhIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeUxvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWluKHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGNvbnN0IHlIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5tYXgocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgaWYgKHlMb3cgPiB5SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBbeExvdywgeUxvdywgeEhpZ2gsIHlIaWdoXTtcbiAgfVxuICBzdGF0aWMgI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIHQsIG1pbk1heCkge1xuICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG10ID0gMSAtIHQ7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB0dHQgPSB0dCAqIHQ7XG4gICAgY29uc3QgeCA9IG10ICogKG10ICogKG10ICogeDAgKyAzICogdCAqIHgxKSArIDMgKiB0dCAqIHgyKSArIHR0dCAqIHgzO1xuICAgIGNvbnN0IHkgPSBtdCAqIChtdCAqIChtdCAqIHkwICsgMyAqIHQgKiB5MSkgKyAzICogdHQgKiB5MikgKyB0dHQgKiB5MztcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4KTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkpO1xuICB9XG4gIHN0YXRpYyAjZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCBhLCBiLCBjLCBtaW5NYXgpIHtcbiAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgaWYgKE1hdGguYWJzKGIpID49IDFlLTEyKSB7XG4gICAgICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIC1jIC8gYiwgbWluTWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBiICoqIDIgLSA0ICogYyAqIGE7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzcXJ0RGVsdGEgPSBNYXRoLnNxcnQoZGVsdGEpO1xuICAgIGNvbnN0IGEyID0gMiAqIGE7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgKC1iICsgc3FydERlbHRhKSAvIGEyLCBtaW5NYXgpO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsICgtYiAtIHNxcnREZWx0YSkgLyBhMiwgbWluTWF4KTtcbiAgfVxuICBzdGF0aWMgYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpIHtcbiAgICBpZiAobWluTWF4KSB7XG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgwLCB4Myk7XG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkwLCB5Myk7XG4gICAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgwLCB4Myk7XG4gICAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkwLCB5Myk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbk1heCA9IFtNYXRoLm1pbih4MCwgeDMpLCBNYXRoLm1pbih5MCwgeTMpLCBNYXRoLm1heCh4MCwgeDMpLCBNYXRoLm1heCh5MCwgeTMpXTtcbiAgICB9XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC14MCArIDMgKiAoeDEgLSB4MikgKyB4MyksIDYgKiAoeDAgLSAyICogeDEgKyB4MiksIDMgKiAoeDEgLSB4MCksIG1pbk1heCk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC15MCArIDMgKiAoeTEgLSB5MikgKyB5MyksIDYgKiAoeTAgLSAyICogeTEgKyB5MiksIDMgKiAoeTEgLSB5MCksIG1pbk1heCk7XG4gICAgcmV0dXJuIG1pbk1heDtcbiAgfVxufVxuY29uc3QgUERGU3RyaW5nVHJhbnNsYXRlVGFibGUgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyZDgsIDB4MmM3LCAweDJjNiwgMHgyZDksIDB4MmRkLCAweDJkYiwgMHgyZGEsIDB4MmRjLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDIwMjIsIDB4MjAyMCwgMHgyMDIxLCAweDIwMjYsIDB4MjAxNCwgMHgyMDEzLCAweDE5MiwgMHgyMDQ0LCAweDIwMzksIDB4MjAzYSwgMHgyMjEyLCAweDIwMzAsIDB4MjAxZSwgMHgyMDFjLCAweDIwMWQsIDB4MjAxOCwgMHgyMDE5LCAweDIwMWEsIDB4MjEyMiwgMHhmYjAxLCAweGZiMDIsIDB4MTQxLCAweDE1MiwgMHgxNjAsIDB4MTc4LCAweDE3ZCwgMHgxMzEsIDB4MTQyLCAweDE1MywgMHgxNjEsIDB4MTdlLCAwLCAweDIwYWNdKSk7XG5mdW5jdGlvbiBzdHJpbmdUb1BERlN0cmluZyhzdHIpIHtcbiAgaWYgKHN0clswXSA+PSBcIlxceEVGXCIpIHtcbiAgICBsZXQgZW5jb2Rpbmc7XG4gICAgaWYgKHN0clswXSA9PT0gXCJcXHhGRVwiICYmIHN0clsxXSA9PT0gXCJcXHhGRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2YmVcIjtcbiAgICAgIGlmIChzdHIubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyWzBdID09PSBcIlxceEZGXCIgJiYgc3RyWzFdID09PSBcIlxceEZFXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZsZVwiO1xuICAgICAgaWYgKHN0ci5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RUZcIiAmJiBzdHJbMV0gPT09IFwiXFx4QkJcIiAmJiBzdHJbMl0gPT09IFwiXFx4QkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi04XCI7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHN0cik7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBpZiAoIWRlY29kZWQuaW5jbHVkZXMoXCJcXHgxYlwiKSkge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvZGVkLnJlcGxhY2VBbGwoL1xceDFiW15cXHgxYl0qKD86XFx4MWJ8JCkvZywgXCJcIik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB3YXJuKGBzdHJpbmdUb1BERlN0cmluZzogXCIke2V4fVwiLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3RyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBjb25zdCBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjaGFyQ29kZSA9PT0gMHgxYikge1xuICAgICAgd2hpbGUgKCsraSA8IGlpICYmIHN0ci5jaGFyQ29kZUF0KGkpICE9PSAweDFiKSB7fVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZVtjaGFyQ29kZV07XG4gICAgc3RyQnVmLnB1c2goY29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgOiBzdHIuY2hhckF0KGkpKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1VURjhTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xufVxuZnVuY3Rpb24gdXRmOFN0cmluZ1RvU3RyaW5nKHN0cikge1xuICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuZnVuY3Rpb24gaXNBcnJheUVxdWFsKGFycjEsIGFycjIpIHtcbiAgaWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE1vZGlmaWNhdGlvbkRhdGUoZGF0ZSA9IG5ldyBEYXRlKCkpIHtcbiAgY29uc3QgYnVmZmVyID0gW2RhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKV07XG4gIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbn1cbmxldCBOb3JtYWxpemVSZWdleCA9IG51bGw7XG5sZXQgTm9ybWFsaXphdGlvbk1hcCA9IG51bGw7XG5mdW5jdGlvbiBub3JtYWxpemVVbmljb2RlKHN0cikge1xuICBpZiAoIU5vcm1hbGl6ZVJlZ2V4KSB7XG4gICAgTm9ybWFsaXplUmVnZXggPSAvKFtcXHUwMGEwXFx1MDBiNVxcdTAzN2VcXHUwZWIzXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIxMjZcXHVmYjAwLVxcdWZiMDRcXHVmYjA2XFx1ZmIyMC1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmJhMVxcdWZiYTQtXFx1ZmJhOVxcdWZiYWUtXFx1ZmJiMVxcdWZiZDMtXFx1ZmJkY1xcdWZiZGUtXFx1ZmJlN1xcdWZiZWEtXFx1ZmJmOFxcdWZiZmMtXFx1ZmJmZFxcdWZjMDAtXFx1ZmM1ZFxcdWZjNjQtXFx1ZmNmMVxcdWZjZjUtXFx1ZmQzZFxcdWZkODhcXHVmZGY0XFx1ZmRmYS1cXHVmZGZiXFx1ZmU3MVxcdWZlNzdcXHVmZTc5XFx1ZmU3YlxcdWZlN2RdKyl8KFxcdWZiMDUrKS9ndTtcbiAgICBOb3JtYWxpemF0aW9uTWFwID0gbmV3IE1hcChbW1wi76yFXCIsIFwixb90XCJdXSk7XG4gIH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlQWxsKE5vcm1hbGl6ZVJlZ2V4LCAoXywgcDEsIHAyKSA9PiBwMSA/IHAxLm5vcm1hbGl6ZShcIk5GS0NcIikgOiBOb3JtYWxpemF0aW9uTWFwLmdldChwMikpO1xufVxuZnVuY3Rpb24gZ2V0VXVpZCgpIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNyeXB0bz8ucmFuZG9tVVVJRCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH1cbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY3J5cHRvPy5nZXRSYW5kb21WYWx1ZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlc1RvU3RyaW5nKGJ1Zik7XG59XG5jb25zdCBBbm5vdGF0aW9uUHJlZml4ID0gXCJwZGZqc19pbnRlcm5hbF9pZF9cIjtcbmNvbnN0IEZvbnRSZW5kZXJPcHMgPSB7XG4gIEJFWklFUl9DVVJWRV9UTzogMCxcbiAgTU9WRV9UTzogMSxcbiAgTElORV9UTzogMixcbiAgUVVBRFJBVElDX0NVUlZFX1RPOiAzLFxuICBSRVNUT1JFOiA0LFxuICBTQVZFOiA1LFxuICBTQ0FMRTogNixcbiAgVFJBTlNGT1JNOiA3LFxuICBUUkFOU0xBVEU6IDhcbn07XG5mdW5jdGlvbiB0b0hleFV0aWwoYXJyKSB7XG4gIGlmIChVaW50OEFycmF5LnByb3RvdHlwZS50b0hleCkge1xuICAgIHJldHVybiBhcnIudG9IZXgoKTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShhcnIsIG51bSA9PiBoZXhOdW1iZXJzW251bV0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiB0b0Jhc2U2NFV0aWwoYXJyKSB7XG4gIGlmIChVaW50OEFycmF5LnByb3RvdHlwZS50b0Jhc2U2NCkge1xuICAgIHJldHVybiBhcnIudG9CYXNlNjQoKTtcbiAgfVxuICByZXR1cm4gYnRvYShieXRlc1RvU3RyaW5nKGFycikpO1xufVxuZnVuY3Rpb24gZnJvbUJhc2U2NFV0aWwoc3RyKSB7XG4gIGlmIChVaW50OEFycmF5LmZyb21CYXNlNjQpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tQmFzZTY0KHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1RvQnl0ZXMoYXRvYihzdHIpKTtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZGlzcGxheV91dGlscy5qc1xuXG5jb25zdCBTVkdfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jbGFzcyBQaXhlbHNQZXJJbmNoIHtcbiAgc3RhdGljIENTUyA9IDk2LjA7XG4gIHN0YXRpYyBQREYgPSA3Mi4wO1xuICBzdGF0aWMgUERGX1RPX0NTU19VTklUUyA9IHRoaXMuQ1NTIC8gdGhpcy5QREY7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaERhdGEodXJsLCB0eXBlID0gXCJ0ZXh0XCIpIHtcbiAgaWYgKGlzVmFsaWRGZXRjaFVybCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHR5cGU7XG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgfTtcbiAgICByZXF1ZXN0LnNlbmQobnVsbCk7XG4gIH0pO1xufVxuY2xhc3MgUGFnZVZpZXdwb3J0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHZpZXdCb3gsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy52aWV3Qm94ID0gdmlld0JveDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WTtcbiAgICBjb25zdCBjZW50ZXJYID0gKHZpZXdCb3hbMl0gKyB2aWV3Qm94WzBdKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9ICh2aWV3Qm94WzNdICsgdmlld0JveFsxXSkgLyAyO1xuICAgIGxldCByb3RhdGVBLCByb3RhdGVCLCByb3RhdGVDLCByb3RhdGVEO1xuICAgIHJvdGF0aW9uICU9IDM2MDtcbiAgICBpZiAocm90YXRpb24gPCAwKSB7XG4gICAgICByb3RhdGlvbiArPSAzNjA7XG4gICAgfVxuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByb3RhdGVBID0gLTE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAxO1xuICAgICAgICByb3RhdGVDID0gMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gLTE7XG4gICAgICAgIHJvdGF0ZUMgPSAtMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByb3RhdGVBID0gMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFnZVZpZXdwb3J0OiBJbnZhbGlkIHJvdGF0aW9uLCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOTAgZGVncmVlcy5cIik7XG4gICAgfVxuICAgIGlmIChkb250RmxpcCkge1xuICAgICAgcm90YXRlQyA9IC1yb3RhdGVDO1xuICAgICAgcm90YXRlRCA9IC1yb3RhdGVEO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0Q2FudmFzWCwgb2Zmc2V0Q2FudmFzWTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAocm90YXRlQSA9PT0gMCkge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9ICh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9ICh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9ICh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9ICh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbcm90YXRlQSAqIHNjYWxlLCByb3RhdGVCICogc2NhbGUsIHJvdGF0ZUMgKiBzY2FsZSwgcm90YXRlRCAqIHNjYWxlLCBvZmZzZXRDYW52YXNYIC0gcm90YXRlQSAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUMgKiBzY2FsZSAqIGNlbnRlclksIG9mZnNldENhbnZhc1kgLSByb3RhdGVCICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlRCAqIHNjYWxlICogY2VudGVyWV07XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGdldCByYXdEaW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZpZXdCb3hcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwicmF3RGltc1wiLCB7XG4gICAgICBwYWdlV2lkdGg6IHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdLFxuICAgICAgcGFnZUhlaWdodDogdmlld0JveFszXSAtIHZpZXdCb3hbMV0sXG4gICAgICBwYWdlWDogdmlld0JveFswXSxcbiAgICAgIHBhZ2VZOiB2aWV3Qm94WzFdXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoe1xuICAgIHNjYWxlID0gdGhpcy5zY2FsZSxcbiAgICByb3RhdGlvbiA9IHRoaXMucm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IHRoaXMub2Zmc2V0WCxcbiAgICBvZmZzZXRZID0gdGhpcy5vZmZzZXRZLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94LnNsaWNlKCksXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG4gIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBVdGlsLmFwcGx5VHJhbnNmb3JtKFt4LCB5XSwgdGhpcy50cmFuc2Zvcm0pO1xuICB9XG4gIGNvbnZlcnRUb1ZpZXdwb3J0UmVjdGFuZ2xlKHJlY3QpIHtcbiAgICBjb25zdCB0b3BMZWZ0ID0gVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFswXSwgcmVjdFsxXV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICBjb25zdCBib3R0b21SaWdodCA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMl0sIHJlY3RbM11dLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIFt0b3BMZWZ0WzBdLCB0b3BMZWZ0WzFdLCBib3R0b21SaWdodFswXSwgYm90dG9tUmlnaHRbMV1dO1xuICB9XG4gIGNvbnZlcnRUb1BkZlBvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gVXRpbC5hcHBseUludmVyc2VUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XG4gIH1cbn1cbmNsYXNzIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgc3VwZXIobXNnLCBcIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmV4dHJhRGVsYXkgPSBleHRyYURlbGF5O1xuICB9XG59XG5mdW5jdGlvbiBpc0RhdGFTY2hlbWUodXJsKSB7XG4gIGNvbnN0IGlpID0gdXJsLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGlpICYmIHVybFtpXS50cmltKCkgPT09IFwiXCIpIHtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoaSwgaSArIDUpLnRvTG93ZXJDYXNlKCkgPT09IFwiZGF0YTpcIjtcbn1cbmZ1bmN0aW9uIGlzUGRmRmlsZShmaWxlbmFtZSkge1xuICByZXR1cm4gdHlwZW9mIGZpbGVuYW1lID09PSBcInN0cmluZ1wiICYmIC9cXC5wZGYkL2kudGVzdChmaWxlbmFtZSk7XG59XG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21VcmwodXJsKSB7XG4gIFt1cmxdID0gdXJsLnNwbGl0KC9bIz9dLywgMSk7XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbn1cbmZ1bmN0aW9uIGdldFBkZkZpbGVuYW1lRnJvbVVybCh1cmwsIGRlZmF1bHRGaWxlbmFtZSA9IFwiZG9jdW1lbnQucGRmXCIpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGlmIChpc0RhdGFTY2hlbWUodXJsKSkge1xuICAgIHdhcm4oJ2dldFBkZkZpbGVuYW1lRnJvbVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBjb25zdCByZVVSSSA9IC9eKD86KD86W146XSs6KT9cXC9cXC9bXi9dKyk/KFtePyNdKikoXFw/W14jXSopPygjLiopPyQvO1xuICBjb25zdCByZUZpbGVuYW1lID0gL1teLz8jPV0rXFwucGRmXFxiKD8hLipcXC5wZGZcXGIpL2k7XG4gIGNvbnN0IHNwbGl0VVJJID0gcmVVUkkuZXhlYyh1cmwpO1xuICBsZXQgc3VnZ2VzdGVkRmlsZW5hbWUgPSByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbMV0pIHx8IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVsyXSkgfHwgcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzNdKTtcbiAgaWYgKHN1Z2dlc3RlZEZpbGVuYW1lKSB7XG4gICAgc3VnZ2VzdGVkRmlsZW5hbWUgPSBzdWdnZXN0ZWRGaWxlbmFtZVswXTtcbiAgICBpZiAoc3VnZ2VzdGVkRmlsZW5hbWUuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhkZWNvZGVVUklDb21wb25lbnQoc3VnZ2VzdGVkRmlsZW5hbWUpKVswXTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1Z2dlc3RlZEZpbGVuYW1lIHx8IGRlZmF1bHRGaWxlbmFtZTtcbn1cbmNsYXNzIFN0YXRUaW1lciB7XG4gIHN0YXJ0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aW1lcyA9IFtdO1xuICB0aW1lKG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHdhcm4oYFRpbWVyIGlzIGFscmVhZHkgcnVubmluZyBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnN0YXJ0ZWRbbmFtZV0gPSBEYXRlLm5vdygpO1xuICB9XG4gIHRpbWVFbmQobmFtZSkge1xuICAgIGlmICghKG5hbWUgaW4gdGhpcy5zdGFydGVkKSkge1xuICAgICAgd2FybihgVGltZXIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy50aW1lcy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydDogdGhpcy5zdGFydGVkW25hbWVdLFxuICAgICAgZW5kOiBEYXRlLm5vdygpXG4gICAgfSk7XG4gICAgZGVsZXRlIHRoaXMuc3RhcnRlZFtuYW1lXTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBvdXRCdWYgPSBbXTtcbiAgICBsZXQgbG9uZ2VzdCA9IDA7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBuYW1lXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBsb25nZXN0ID0gTWF0aC5tYXgobmFtZS5sZW5ndGgsIGxvbmdlc3QpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gb2YgdGhpcy50aW1lcykge1xuICAgICAgb3V0QnVmLnB1c2goYCR7bmFtZS5wYWRFbmQobG9uZ2VzdCl9ICR7ZW5kIC0gc3RhcnR9bXNcXG5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dEJ1Zi5qb2luKFwiXCIpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkRmV0Y2hVcmwodXJsLCBiYXNlVXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJvdG9jb2xcbiAgICB9ID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKTtcbiAgICByZXR1cm4gcHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCBwcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBub0NvbnRleHRNZW51KGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gZGVwcmVjYXRlZChkZXRhaWxzKSB7XG4gIGNvbnNvbGUubG9nKFwiRGVwcmVjYXRlZCBBUEkgdXNhZ2U6IFwiICsgZGV0YWlscyk7XG59XG5jbGFzcyBQREZEYXRlU3RyaW5nIHtcbiAgc3RhdGljICNyZWdleDtcbiAgc3RhdGljIHRvRGF0ZU9iamVjdChpbnB1dCkge1xuICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jcmVnZXggfHw9IG5ldyBSZWdFeHAoXCJeRDpcIiArIFwiKFxcXFxkezR9KVwiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoW1p8K3wtXSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIic/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIic/XCIpO1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLiNyZWdleC5leGVjKGlucHV0KTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApO1xuICAgIGxldCBtb250aCA9IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKTtcbiAgICBtb250aCA9IG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIgPyBtb250aCAtIDEgOiAwO1xuICAgIGxldCBkYXkgPSBwYXJzZUludChtYXRjaGVzWzNdLCAxMCk7XG4gICAgZGF5ID0gZGF5ID49IDEgJiYgZGF5IDw9IDMxID8gZGF5IDogMTtcbiAgICBsZXQgaG91ciA9IHBhcnNlSW50KG1hdGNoZXNbNF0sIDEwKTtcbiAgICBob3VyID0gaG91ciA+PSAwICYmIGhvdXIgPD0gMjMgPyBob3VyIDogMDtcbiAgICBsZXQgbWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgIG1pbnV0ZSA9IG1pbnV0ZSA+PSAwICYmIG1pbnV0ZSA8PSA1OSA/IG1pbnV0ZSA6IDA7XG4gICAgbGV0IHNlY29uZCA9IHBhcnNlSW50KG1hdGNoZXNbNl0sIDEwKTtcbiAgICBzZWNvbmQgPSBzZWNvbmQgPj0gMCAmJiBzZWNvbmQgPD0gNTkgPyBzZWNvbmQgOiAwO1xuICAgIGNvbnN0IHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9IG1hdGNoZXNbN10gfHwgXCJaXCI7XG4gICAgbGV0IG9mZnNldEhvdXIgPSBwYXJzZUludChtYXRjaGVzWzhdLCAxMCk7XG4gICAgb2Zmc2V0SG91ciA9IG9mZnNldEhvdXIgPj0gMCAmJiBvZmZzZXRIb3VyIDw9IDIzID8gb2Zmc2V0SG91ciA6IDA7XG4gICAgbGV0IG9mZnNldE1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbOV0sIDEwKSB8fCAwO1xuICAgIG9mZnNldE1pbnV0ZSA9IG9mZnNldE1pbnV0ZSA+PSAwICYmIG9mZnNldE1pbnV0ZSA8PSA1OSA/IG9mZnNldE1pbnV0ZSA6IDA7XG4gICAgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCItXCIpIHtcbiAgICAgIGhvdXIgKz0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSArPSBvZmZzZXRNaW51dGU7XG4gICAgfSBlbHNlIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiK1wiKSB7XG4gICAgICBob3VyIC09IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgLT0gb2Zmc2V0TWludXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0WGZhUGFnZVZpZXdwb3J0KHhmYVBhZ2UsIHtcbiAgc2NhbGUgPSAxLFxuICByb3RhdGlvbiA9IDBcbn0pIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0geGZhUGFnZS5hdHRyaWJ1dGVzLnN0eWxlO1xuICBjb25zdCB2aWV3Qm94ID0gWzAsIDAsIHBhcnNlSW50KHdpZHRoKSwgcGFyc2VJbnQoaGVpZ2h0KV07XG4gIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICB2aWV3Qm94LFxuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UkdCKGNvbG9yKSB7XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgIGNvbnN0IGNvbG9yUkdCID0gcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSksIDE2KTtcbiAgICByZXR1cm4gWyhjb2xvclJHQiAmIDB4ZmYwMDAwKSA+PiAxNiwgKGNvbG9yUkdCICYgMHgwMGZmMDApID4+IDgsIGNvbG9yUkdCICYgMHgwMDAwZmZdO1xuICB9XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg0LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYmEoXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnNsaWNlKDUsIC0xKS5zcGxpdChcIixcIikubWFwKHggPT4gcGFyc2VJbnQoeCkpLnNsaWNlKDAsIDMpO1xuICB9XG4gIHdhcm4oYE5vdCBhIHZhbGlkIGNvbG9yIGZvcm1hdDogXCIke2NvbG9yfVwiYCk7XG4gIHJldHVybiBbMCwgMCwgMF07XG59XG5mdW5jdGlvbiBnZXRDb2xvclZhbHVlcyhjb2xvcnMpIHtcbiAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICBzcGFuLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZChzcGFuKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGNvbG9ycy5rZXlzKCkpIHtcbiAgICBzcGFuLnN0eWxlLmNvbG9yID0gbmFtZTtcbiAgICBjb25zdCBjb21wdXRlZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuY29sb3I7XG4gICAgY29sb3JzLnNldChuYW1lLCBnZXRSR0IoY29tcHV0ZWRDb2xvcikpO1xuICB9XG4gIHNwYW4ucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBzZXRMYXllckRpbWVuc2lvbnMoZGl2LCB2aWV3cG9ydCwgbXVzdEZsaXAgPSBmYWxzZSwgbXVzdFJvdGF0ZSA9IHRydWUpIHtcbiAgaWYgKHZpZXdwb3J0IGluc3RhbmNlb2YgUGFnZVZpZXdwb3J0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBjb25zdCB1c2VSb3VuZCA9IHV0aWxfRmVhdHVyZVRlc3QuaXNDU1NSb3VuZFN1cHBvcnRlZDtcbiAgICBjb25zdCB3ID0gYHZhcigtLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VXaWR0aH1weGAsXG4gICAgICBoID0gYHZhcigtLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VIZWlnaHR9cHhgO1xuICAgIGNvbnN0IHdpZHRoU3RyID0gdXNlUm91bmQgPyBgcm91bmQoZG93biwgJHt3fSwgdmFyKC0tc2NhbGUtcm91bmQteCwgMXB4KSlgIDogYGNhbGMoJHt3fSlgLFxuICAgICAgaGVpZ2h0U3RyID0gdXNlUm91bmQgPyBgcm91bmQoZG93biwgJHtofSwgdmFyKC0tc2NhbGUtcm91bmQteSwgMXB4KSlgIDogYGNhbGMoJHtofSlgO1xuICAgIGlmICghbXVzdEZsaXAgfHwgdmlld3BvcnQucm90YXRpb24gJSAxODAgPT09IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gd2lkdGhTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHRTdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLndpZHRoID0gaGVpZ2h0U3RyO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gd2lkdGhTdHI7XG4gICAgfVxuICB9XG4gIGlmIChtdXN0Um90YXRlKSB7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCB2aWV3cG9ydC5yb3RhdGlvbik7XG4gIH1cbn1cbmNsYXNzIE91dHB1dFNjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgdGhpcy5zeCA9IHBpeGVsUmF0aW87XG4gICAgdGhpcy5zeSA9IHBpeGVsUmF0aW87XG4gIH1cbiAgZ2V0IHNjYWxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zeCAhPT0gMSB8fCB0aGlzLnN5ICE9PSAxO1xuICB9XG4gIGdldCBzeW1tZXRyaWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ggPT09IHRoaXMuc3k7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3Rvb2xiYXIuanNcblxuY2xhc3MgRWRpdG9yVG9vbGJhciB7XG4gICN0b29sYmFyID0gbnVsbDtcbiAgI2NvbG9yUGlja2VyID0gbnVsbDtcbiAgI2VkaXRvcjtcbiAgI2J1dHRvbnMgPSBudWxsO1xuICAjYWx0VGV4dCA9IG51bGw7XG4gIHN0YXRpYyAjbDEwblJlbW92ZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICBFZGl0b3JUb29sYmFyLiNsMTBuUmVtb3ZlIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGZyZWV0ZXh0OiBcInBkZmpzLWVkaXRvci1yZW1vdmUtZnJlZXRleHQtYnV0dG9uXCIsXG4gICAgICBoaWdobGlnaHQ6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1oaWdobGlnaHQtYnV0dG9uXCIsXG4gICAgICBpbms6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1pbmstYnV0dG9uXCIsXG4gICAgICBzdGFtcDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLXN0YW1wLWJ1dHRvblwiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGVkaXRUb29sYmFyID0gdGhpcy4jdG9vbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZWRpdFRvb2xiYXIuY2xhc3NMaXN0LmFkZChcImVkaXRUb29sYmFyXCIsIFwiaGlkZGVuXCIpO1xuICAgIGVkaXRUb29sYmFyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sYmFyXCIpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGVkaXRUb29sYmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBFZGl0b3JUb29sYmFyLiNwb2ludGVyRG93biwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuI2J1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbnMuY2xhc3NOYW1lID0gXCJidXR0b25zXCI7XG4gICAgZWRpdFRvb2xiYXIuYXBwZW5kKGJ1dHRvbnMpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy4jZWRpdG9yLnRvb2xiYXJQb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBlZGl0VG9vbGJhcjtcbiAgICAgIGNvbnN0IHggPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIgPyAxIC0gcG9zaXRpb25bMF0gOiBwb3NpdGlvblswXTtcbiAgICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYCR7MTAwICogeH0lYDtcbiAgICAgIHN0eWxlLnRvcCA9IGBjYWxjKCR7MTAwICogcG9zaXRpb25bMV19JSArIHZhcigtLWVkaXRvci10b29sYmFyLXZlcnQtb2Zmc2V0KSlgO1xuICAgIH1cbiAgICB0aGlzLiNhZGREZWxldGVCdXR0b24oKTtcbiAgICByZXR1cm4gZWRpdFRvb2xiYXI7XG4gIH1cbiAgZ2V0IGRpdigpIHtcbiAgICByZXR1cm4gdGhpcy4jdG9vbGJhcjtcbiAgfVxuICBzdGF0aWMgI3BvaW50ZXJEb3duKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gICNmb2N1c0luKGUpIHtcbiAgICB0aGlzLiNlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gICNmb2N1c091dChlKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gICNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLiNmb2N1c0luLmJpbmQodGhpcyksIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNmb2N1c091dC5iaW5kKHRoaXMpLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLiN0b29sYmFyLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jY29sb3JQaWNrZXI/LmhpZGVEcm9wZG93bigpO1xuICB9XG4gIHNob3coKSB7XG4gICAgdGhpcy4jdG9vbGJhci5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI2FsdFRleHQ/LnNob3duKCk7XG4gIH1cbiAgI2FkZERlbGV0ZUJ1dHRvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3JUeXBlLFxuICAgICAgX3VpTWFuYWdlclxuICAgIH0gPSB0aGlzLiNlZGl0b3I7XG4gICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gXCJkZWxldGVcIjtcbiAgICBidXR0b24udGFiSW5kZXggPSAwO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgRWRpdG9yVG9vbGJhci4jbDEwblJlbW92ZVtlZGl0b3JUeXBlXSk7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlID0+IHtcbiAgICAgIF91aU1hbmFnZXIuZGVsZXRlKCk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsOiBfdWlNYW5hZ2VyLl9zaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24pO1xuICB9XG4gIGdldCAjZGl2aWRlcigpIHtcbiAgICBjb25zdCBkaXZpZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXZpZGVyLmNsYXNzTmFtZSA9IFwiZGl2aWRlclwiO1xuICAgIHJldHVybiBkaXZpZGVyO1xuICB9XG4gIGFzeW5jIGFkZEFsdFRleHQoYWx0VGV4dCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGF3YWl0IGFsdFRleHQucmVuZGVyKCk7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5wcmVwZW5kKGJ1dHRvbiwgdGhpcy4jZGl2aWRlcik7XG4gICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gIH1cbiAgYWRkQ29sb3JQaWNrZXIoY29sb3JQaWNrZXIpIHtcbiAgICB0aGlzLiNjb2xvclBpY2tlciA9IGNvbG9yUGlja2VyO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGNvbG9yUGlja2VyLnJlbmRlckJ1dHRvbigpO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIHRoaXMuI2J1dHRvbnMucHJlcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiN0b29sYmFyLnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXIgPSBudWxsO1xuICB9XG59XG5jbGFzcyBIaWdobGlnaHRUb29sYmFyIHtcbiAgI2J1dHRvbnMgPSBudWxsO1xuICAjdG9vbGJhciA9IG51bGw7XG4gICN1aU1hbmFnZXI7XG4gIGNvbnN0cnVjdG9yKHVpTWFuYWdlcikge1xuICAgIHRoaXMuI3VpTWFuYWdlciA9IHVpTWFuYWdlcjtcbiAgfVxuICAjcmVuZGVyKCkge1xuICAgIGNvbnN0IGVkaXRUb29sYmFyID0gdGhpcy4jdG9vbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZWRpdFRvb2xiYXIuY2xhc3NOYW1lID0gXCJlZGl0VG9vbGJhclwiO1xuICAgIGVkaXRUb29sYmFyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sYmFyXCIpO1xuICAgIGVkaXRUb29sYmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuI2J1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbnMuY2xhc3NOYW1lID0gXCJidXR0b25zXCI7XG4gICAgZWRpdFRvb2xiYXIuYXBwZW5kKGJ1dHRvbnMpO1xuICAgIHRoaXMuI2FkZEhpZ2hsaWdodEJ1dHRvbigpO1xuICAgIHJldHVybiBlZGl0VG9vbGJhcjtcbiAgfVxuICAjZ2V0TGFzdFBvaW50KGJveGVzLCBpc0xUUikge1xuICAgIGxldCBsYXN0WSA9IDA7XG4gICAgbGV0IGxhc3RYID0gMDtcbiAgICBmb3IgKGNvbnN0IGJveCBvZiBib3hlcykge1xuICAgICAgY29uc3QgeSA9IGJveC55ICsgYm94LmhlaWdodDtcbiAgICAgIGlmICh5IDwgbGFzdFkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gYm94LnggKyAoaXNMVFIgPyBib3gud2lkdGggOiAwKTtcbiAgICAgIGlmICh5ID4gbGFzdFkpIHtcbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICBsYXN0WSA9IHk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgIGlmICh4ID4gbGFzdFgpIHtcbiAgICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoeCA8IGxhc3RYKSB7XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtpc0xUUiA/IDEgLSBsYXN0WCA6IGxhc3RYLCBsYXN0WV07XG4gIH1cbiAgc2hvdyhwYXJlbnQsIGJveGVzLCBpc0xUUikge1xuICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuI2dldExhc3RQb2ludChib3hlcywgaXNMVFIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuI3Rvb2xiYXIgfHw9IHRoaXMuI3JlbmRlcigpO1xuICAgIHBhcmVudC5hcHBlbmQodGhpcy4jdG9vbGJhcik7XG4gICAgc3R5bGUuaW5zZXRJbmxpbmVFbmQgPSBgJHsxMDAgKiB4fSVgO1xuICAgIHN0eWxlLnRvcCA9IGBjYWxjKCR7MTAwICogeX0lICsgdmFyKC0tZWRpdG9yLXRvb2xiYXItdmVydC1vZmZzZXQpKWA7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLiN0b29sYmFyLnJlbW92ZSgpO1xuICB9XG4gICNhZGRIaWdobGlnaHRCdXR0b24oKSB7XG4gICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gXCJoaWdobGlnaHRCdXR0b25cIjtcbiAgICBidXR0b24udGFiSW5kZXggPSAwO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgYHBkZmpzLWhpZ2hsaWdodC1mbG9hdGluZy1idXR0b24xYCk7XG4gICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGJ1dHRvbi5hcHBlbmQoc3Bhbik7XG4gICAgc3Bhbi5jbGFzc05hbWUgPSBcInZpc3VhbGx5SGlkZGVuXCI7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1oaWdobGlnaHQtZmxvYXRpbmctYnV0dG9uLWxhYmVsXCIpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0U2VsZWN0aW9uKFwiZmxvYXRpbmdfYnV0dG9uXCIpO1xuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3Rvb2xzLmpzXG5cblxuXG5mdW5jdGlvbiBiaW5kRXZlbnRzKG9iaiwgZWxlbWVudCwgbmFtZXMpIHtcbiAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIG9ialtuYW1lXS5iaW5kKG9iaikpO1xuICB9XG59XG5mdW5jdGlvbiBvcGFjaXR5VG9IZXgob3BhY2l0eSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1pbigyNTUsIE1hdGgubWF4KDEsIDI1NSAqIG9wYWNpdHkpKSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn1cbmNsYXNzIElkTWFuYWdlciB7XG4gICNpZCA9IDA7XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gYCR7QW5ub3RhdGlvbkVkaXRvclByZWZpeH0ke3RoaXMuI2lkKyt9YDtcbiAgfVxufVxuY2xhc3MgSW1hZ2VNYW5hZ2VyIHtcbiAgI2Jhc2VJZCA9IGdldFV1aWQoKTtcbiAgI2lkID0gMDtcbiAgI2NhY2hlID0gbnVsbDtcbiAgc3RhdGljIGdldCBfaXNTVkdGaXR0aW5nQ2FudmFzKCkge1xuICAgIGNvbnN0IHN2ZyA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD1VVEYtOCw8c3ZnIHZpZXdCb3g9XCIwIDAgMSAxXCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cmVjdCB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgc3R5bGU9XCJmaWxsOnJlZDtcIi8+PC9zdmc+YDtcbiAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDMpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5zcmMgPSBzdmc7XG4gICAgY29uc3QgcHJvbWlzZSA9IGltYWdlLmRlY29kZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMyk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5idWZmZXIpWzBdID09PSAwO1xuICAgIH0pO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfaXNTVkdGaXR0aW5nQ2FudmFzXCIsIHByb21pc2UpO1xuICB9XG4gIGFzeW5jICNnZXQoa2V5LCByYXdEYXRhKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBsZXQgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGE/LmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgfHw9IHtcbiAgICAgICAgYml0bWFwOiBudWxsLFxuICAgICAgICBpZDogYGltYWdlXyR7dGhpcy4jYmFzZUlkfV8ke3RoaXMuI2lkKyt9YCxcbiAgICAgICAgcmVmQ291bnRlcjogMCxcbiAgICAgICAgaXNTdmc6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbGV0IGltYWdlO1xuICAgICAgaWYgKHR5cGVvZiByYXdEYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEudXJsID0gcmF3RGF0YTtcbiAgICAgICAgaW1hZ2UgPSBhd2FpdCBmZXRjaERhdGEocmF3RGF0YSwgXCJibG9iXCIpO1xuICAgICAgfSBlbHNlIGlmIChyYXdEYXRhIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICBpbWFnZSA9IGRhdGEuZmlsZSA9IHJhd0RhdGE7XG4gICAgICB9IGVsc2UgaWYgKHJhd0RhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGltYWdlID0gcmF3RGF0YTtcbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZS50eXBlID09PSBcImltYWdlL3N2Zyt4bWxcIikge1xuICAgICAgICBjb25zdCBtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlID0gSW1hZ2VNYW5hZ2VyLl9pc1NWR0ZpdHRpbmdDYW52YXM7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBjb25zdCBpbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkYXRhLmJpdG1hcCA9IGltYWdlRWxlbWVudDtcbiAgICAgICAgICAgIGRhdGEuaXNTdmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBkYXRhLnN2Z1VybCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IChhd2FpdCBtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlKSA/IGAke3VybH0jc3ZnVmlldyhwcmVzZXJ2ZUFzcGVjdFJhdGlvKG5vbmUpKWAgOiB1cmw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpbWFnZUVsZW1lbnQub25lcnJvciA9IGZpbGVSZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChpbWFnZSk7XG4gICAgICAgIGF3YWl0IGltYWdlUHJvbWlzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2UpO1xuICAgICAgfVxuICAgICAgZGF0YS5yZWZDb3VudGVyID0gMTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIGRhdGEpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQoZGF0YS5pZCwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGFzeW5jIGdldEZyb21GaWxlKGZpbGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYXN0TW9kaWZpZWQsXG4gICAgICBuYW1lLFxuICAgICAgc2l6ZSxcbiAgICAgIHR5cGVcbiAgICB9ID0gZmlsZTtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KGAke2xhc3RNb2RpZmllZH1fJHtuYW1lfV8ke3NpemV9XyR7dHlwZX1gLCBmaWxlKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tVXJsKHVybCkge1xuICAgIHJldHVybiB0aGlzLiNnZXQodXJsLCB1cmwpO1xuICB9XG4gIGFzeW5jIGdldEZyb21CbG9iKGlkLCBibG9iUHJvbWlzZSkge1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBibG9iUHJvbWlzZTtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KGlkLCBibG9iKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tSWQoaWQpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhLmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RnJvbUZpbGUoZGF0YS5maWxlKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYmxvYlByb21pc2UpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYmxvYlByb21pc2VcbiAgICAgIH0gPSBkYXRhO1xuICAgICAgZGVsZXRlIGRhdGEuYmxvYlByb21pc2U7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGcm9tQmxvYihkYXRhLmlkLCBibG9iUHJvbWlzZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZyb21VcmwoZGF0YS51cmwpO1xuICB9XG4gIGdldEZyb21DYW52YXMoaWQsIGNhbnZhcykge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgbGV0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmIChkYXRhPy5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcbiAgICBkYXRhID0ge1xuICAgICAgYml0bWFwOiBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCksXG4gICAgICBpZDogYGltYWdlXyR7dGhpcy4jYmFzZUlkfV8ke3RoaXMuI2lkKyt9YCxcbiAgICAgIHJlZkNvdW50ZXI6IDEsXG4gICAgICBpc1N2ZzogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuI2NhY2hlLnNldChpZCwgZGF0YSk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGRhdGEuaWQsIGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGdldFN2Z1VybChpZCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YT8uaXNTdmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5zdmdVcmw7XG4gIH1cbiAgZGVsZXRlSWQoaWQpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnJlZkNvdW50ZXIgLT0gMTtcbiAgICBpZiAoZGF0YS5yZWZDb3VudGVyICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGJpdG1hcFxuICAgIH0gPSBkYXRhO1xuICAgIGlmICghZGF0YS51cmwgJiYgIWRhdGEuZmlsZSkge1xuICAgICAgY29uc3QgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCJiaXRtYXByZW5kZXJlclwiKTtcbiAgICAgIGN0eC50cmFuc2ZlckZyb21JbWFnZUJpdG1hcChiaXRtYXApO1xuICAgICAgZGF0YS5ibG9iUHJvbWlzZSA9IGNhbnZhcy5jb252ZXJ0VG9CbG9iKCk7XG4gICAgfVxuICAgIGJpdG1hcC5jbG9zZT8uKCk7XG4gICAgZGF0YS5iaXRtYXAgPSBudWxsO1xuICB9XG4gIGlzVmFsaWRJZChpZCkge1xuICAgIHJldHVybiBpZC5zdGFydHNXaXRoKGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fYCk7XG4gIH1cbn1cbmNsYXNzIENvbW1hbmRNYW5hZ2VyIHtcbiAgI2NvbW1hbmRzID0gW107XG4gICNsb2NrZWQgPSBmYWxzZTtcbiAgI21heFNpemU7XG4gICNwb3NpdGlvbiA9IC0xO1xuICBjb25zdHJ1Y3RvcihtYXhTaXplID0gMTI4KSB7XG4gICAgdGhpcy4jbWF4U2l6ZSA9IG1heFNpemU7XG4gIH1cbiAgYWRkKHtcbiAgICBjbWQsXG4gICAgdW5kbyxcbiAgICBwb3N0LFxuICAgIG11c3RFeGVjLFxuICAgIHR5cGUgPSBOYU4sXG4gICAgb3ZlcndyaXRlSWZTYW1lVHlwZSA9IGZhbHNlLFxuICAgIGtlZXBVbmRvID0gZmFsc2VcbiAgfSkge1xuICAgIGlmIChtdXN0RXhlYykge1xuICAgICAgY21kKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNsb2NrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2F2ZSA9IHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBwb3N0LFxuICAgICAgdHlwZVxuICAgIH07XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgaWYgKHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gMDtcbiAgICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvdmVyd3JpdGVJZlNhbWVUeXBlICYmIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS50eXBlID09PSB0eXBlKSB7XG4gICAgICBpZiAoa2VlcFVuZG8pIHtcbiAgICAgICAgc2F2ZS51bmRvID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnVuZG87XG4gICAgICB9XG4gICAgICB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0gPSBzYXZlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gdGhpcy4jcG9zaXRpb24gKyAxO1xuICAgIGlmIChuZXh0ID09PSB0aGlzLiNtYXhTaXplKSB7XG4gICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UoMCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gbmV4dDtcbiAgICAgIGlmIChuZXh0IDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZShuZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY29tbWFuZHMucHVzaChzYXZlKTtcbiAgfVxuICB1bmRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbG9ja2VkID0gdHJ1ZTtcbiAgICBjb25zdCB7XG4gICAgICB1bmRvLFxuICAgICAgcG9zdFxuICAgIH0gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl07XG4gICAgdW5kbygpO1xuICAgIHBvc3Q/LigpO1xuICAgIHRoaXMuI2xvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuI3Bvc2l0aW9uIC09IDE7XG4gIH1cbiAgcmVkbygpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiArPSAxO1xuICAgICAgdGhpcy4jbG9ja2VkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY21kLFxuICAgICAgICBwb3N0XG4gICAgICB9ID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dO1xuICAgICAgY21kKCk7XG4gICAgICBwb3N0Py4oKTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBoYXNTb21ldGhpbmdUb1VuZG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uICE9PSAtMTtcbiAgfVxuICBoYXNTb21ldGhpbmdUb1JlZG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2NvbW1hbmRzID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgS2V5Ym9hcmRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFsbEtleXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBmb3IgKGNvbnN0IFtrZXlzLCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9XSBvZiBjYWxsYmFja3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgaXNNYWNLZXkgPSBrZXkuc3RhcnRzV2l0aChcIm1hYytcIik7XG4gICAgICAgIGlmIChpc01hYyAmJiBpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXkuc2xpY2UoNCksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc01hYyAmJiAhaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImFsdFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJjdHJsXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQubWV0YUtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcIm1ldGFcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcInNoaWZ0XCIpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGV2ZW50LmtleSk7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5idWZmZXIuam9pbihcIitcIik7XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGV4ZWMoc2VsZiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuYWxsS2V5cy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gdGhpcy5jYWxsYmFja3MuZ2V0KHRoaXMuI3NlcmlhbGl6ZShldmVudCkpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYnViYmxlcyA9IGZhbHNlLFxuICAgICAgICBhcmdzID0gW10sXG4gICAgICAgIGNoZWNrZXIgPSBudWxsXG4gICAgICB9XG4gICAgfSA9IGluZm87XG4gICAgaWYgKGNoZWNrZXIgJiYgIWNoZWNrZXIoc2VsZiwgZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrLmJpbmQoc2VsZiwgLi4uYXJncywgZXZlbnQpKCk7XG4gICAgaWYgKCFidWJibGVzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBDb2xvck1hbmFnZXIge1xuICBzdGF0aWMgX2NvbG9yc01hcHBpbmcgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIFswLCAwLCAwXV0sIFtcIkNhbnZhc1wiLCBbMjU1LCAyNTUsIDI1NV1dXSk7XG4gIGdldCBfY29sb3JzKCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgbnVsbF0sIFtcIkNhbnZhc1wiLCBudWxsXV0pO1xuICAgIGdldENvbG9yVmFsdWVzKGNvbG9ycyk7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9jb2xvcnNcIiwgY29sb3JzKTtcbiAgfVxuICBjb252ZXJ0KGNvbG9yKSB7XG4gICAgY29uc3QgcmdiID0gZ2V0UkdCKGNvbG9yKTtcbiAgICBpZiAoIXdpbmRvdy5tYXRjaE1lZGlhKFwiKGZvcmNlZC1jb2xvcnM6IGFjdGl2ZSlcIikubWF0Y2hlcykge1xuICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbbmFtZSwgUkdCXSBvZiB0aGlzLl9jb2xvcnMpIHtcbiAgICAgIGlmIChSR0IuZXZlcnkoKHgsIGkpID0+IHggPT09IHJnYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yTWFuYWdlci5fY29sb3JzTWFwcGluZy5nZXQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZ2I7XG4gIH1cbiAgZ2V0SGV4Q29kZShuYW1lKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fY29sb3JzLmdldChuYW1lKTtcbiAgICBpZiAoIXJnYikge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBVdGlsLm1ha2VIZXhDb2xvciguLi5yZ2IpO1xuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIHtcbiAgI2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgI2FjdGl2ZUVkaXRvciA9IG51bGw7XG4gICNhbGxFZGl0b3JzID0gbmV3IE1hcCgpO1xuICAjYWxsTGF5ZXJzID0gbmV3IE1hcCgpO1xuICAjYWx0VGV4dE1hbmFnZXIgPSBudWxsO1xuICAjYW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsO1xuICAjY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMgPSBudWxsO1xuICAjY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoKTtcbiAgI2NvcHlQYXN0ZUFDID0gbnVsbDtcbiAgI2N1cnJlbnRQYWdlSW5kZXggPSAwO1xuICAjZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgI2RyYWdnaW5nRWRpdG9ycyA9IG51bGw7XG4gICNlZGl0b3JUeXBlcyA9IG51bGw7XG4gICNlZGl0b3JzVG9SZXNjYWxlID0gbmV3IFNldCgpO1xuICAjZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24gPSBmYWxzZTtcbiAgI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZSA9IGZhbHNlO1xuICAjZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IGZhbHNlO1xuICAjZmlsdGVyRmFjdG9yeSA9IG51bGw7XG4gICNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBudWxsO1xuICAjZm9jdXNNYW5hZ2VyQUMgPSBudWxsO1xuICAjaGlnaGxpZ2h0Q29sb3JzID0gbnVsbDtcbiAgI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gZmFsc2U7XG4gICNoaWdobGlnaHRUb29sYmFyID0gbnVsbDtcbiAgI2lkTWFuYWdlciA9IG5ldyBJZE1hbmFnZXIoKTtcbiAgI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAjaXNXYWl0aW5nID0gZmFsc2U7XG4gICNrZXlib2FyZE1hbmFnZXJBQyA9IG51bGw7XG4gICNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIgPSBudWxsO1xuICAjbWxNYW5hZ2VyID0gbnVsbDtcbiAgI21vZGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICAjc2VsZWN0ZWRFZGl0b3JzID0gbmV3IFNldCgpO1xuICAjc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICNwYWdlQ29sb3JzID0gbnVsbDtcbiAgI3Nob3dBbGxTdGF0ZXMgPSBudWxsO1xuICAjcHJldmlvdXNTdGF0ZXMgPSB7XG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcbiAgICBpc0VtcHR5OiB0cnVlLFxuICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogZmFsc2UsXG4gICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2UsXG4gICAgaGFzU2VsZWN0ZWRUZXh0OiBmYWxzZVxuICB9O1xuICAjdHJhbnNsYXRpb24gPSBbMCwgMF07XG4gICN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjdmlld2VyID0gbnVsbDtcbiAgI3VwZGF0ZU1vZGVDYXBhYmlsaXR5ID0gbnVsbDtcbiAgc3RhdGljIFRSQU5TTEFURV9TTUFMTCA9IDE7XG4gIHN0YXRpYyBUUkFOU0xBVEVfQklHID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IHNlbGYgPT4gc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudGFnTmFtZSAhPT0gXCJCVVRUT05cIiAmJiBzZWxmLmhhc1NvbWV0aGluZ1RvQ29udHJvbCgpO1xuICAgIGNvbnN0IHRleHRJbnB1dENoZWNrZXIgPSAoX3NlbGYsIHtcbiAgICAgIHRhcmdldDogZWxcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0gPSBlbDtcbiAgICAgICAgcmV0dXJuIHR5cGUgIT09IFwidGV4dFwiICYmIHR5cGUgIT09IFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IHNtYWxsID0gdGhpcy5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gdGhpcy5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK2FcIiwgXCJtYWMrbWV0YSthXCJdLCBwcm90by5zZWxlY3RBbGwsIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrelwiLCBcIm1hYyttZXRhK3pcIl0sIHByb3RvLnVuZG8sIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwreVwiLCBcImN0cmwrc2hpZnQrelwiLCBcIm1hYyttZXRhK3NoaWZ0K3pcIiwgXCJjdHJsK3NoaWZ0K1pcIiwgXCJtYWMrbWV0YStzaGlmdCtaXCJdLCBwcm90by5yZWRvLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJCYWNrc3BhY2VcIiwgXCJhbHQrQmFja3NwYWNlXCIsIFwiY3RybCtCYWNrc3BhY2VcIiwgXCJzaGlmdCtCYWNrc3BhY2VcIiwgXCJtYWMrQmFja3NwYWNlXCIsIFwibWFjK2FsdCtCYWNrc3BhY2VcIiwgXCJtYWMrY3RybCtCYWNrc3BhY2VcIiwgXCJEZWxldGVcIiwgXCJjdHJsK0RlbGV0ZVwiLCBcInNoaWZ0K0RlbGV0ZVwiLCBcIm1hYytEZWxldGVcIl0sIHByb3RvLmRlbGV0ZSwge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiRW50ZXJcIiwgXCJtYWMrRW50ZXJcIl0sIHByb3RvLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCwge1xuICAgICAgY2hlY2tlcjogKHNlbGYsIHtcbiAgICAgICAgdGFyZ2V0OiBlbFxuICAgICAgfSkgPT4gIShlbCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSAmJiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoZWwpICYmICFzZWxmLmlzRW50ZXJIYW5kbGVkXG4gICAgfV0sIFtbXCIgXCIsIFwibWFjKyBcIl0sIHByb3RvLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCwge1xuICAgICAgY2hlY2tlcjogKHNlbGYsIHtcbiAgICAgICAgdGFyZ2V0OiBlbFxuICAgICAgfSkgPT4gIShlbCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSAmJiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICB9XSwgW1tcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLnVuc2VsZWN0QWxsXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCB2aWV3ZXIsIGFsdFRleHRNYW5hZ2VyLCBldmVudEJ1cywgcGRmRG9jdW1lbnQsIHBhZ2VDb2xvcnMsIGhpZ2hsaWdodENvbG9ycywgZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24sIGVuYWJsZVVwZGF0ZWRBZGRJbWFnZSwgZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSwgbWxNYW5hZ2VyKSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fc2lnbmFsID0gdGhpcy4jYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdmlld2VyID0gdmlld2VyO1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyID0gYWx0VGV4dE1hbmFnZXI7XG4gICAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgICBldmVudEJ1cy5fb24oXCJlZGl0aW5nYWN0aW9uXCIsIHRoaXMub25FZGl0aW5nQWN0aW9uLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInBhZ2VjaGFuZ2luZ1wiLCB0aGlzLm9uUGFnZUNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInNjYWxlY2hhbmdpbmdcIiwgdGhpcy5vblNjYWxlQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwicm90YXRpb25jaGFuZ2luZ1wiLCB0aGlzLm9uUm90YXRpb25DaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJzZXRwcmVmZXJlbmNlXCIsIHRoaXMub25TZXRQcmVmZXJlbmNlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInN3aXRjaGFubm90YXRpb25lZGl0b3JwYXJhbXNcIiwgZXZ0ID0+IHRoaXMudXBkYXRlUGFyYW1zKGV2dC50eXBlLCBldnQudmFsdWUpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNhZGRTZWxlY3Rpb25MaXN0ZW5lcigpO1xuICAgIHRoaXMuI2FkZERyYWdBbmREcm9wTGlzdGVuZXJzKCk7XG4gICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UgPSBwZGZEb2N1bWVudC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLiNmaWx0ZXJGYWN0b3J5ID0gcGRmRG9jdW1lbnQuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLiNwYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLiNoaWdobGlnaHRDb2xvcnMgPSBoaWdobGlnaHRDb2xvcnMgfHwgbnVsbDtcbiAgICB0aGlzLiNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiA9IGVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uO1xuICAgIHRoaXMuI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZSA9IGVuYWJsZVVwZGF0ZWRBZGRJbWFnZTtcbiAgICB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZTtcbiAgICB0aGlzLiNtbE1hbmFnZXIgPSBtbE1hbmFnZXIgfHwgbnVsbDtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzID0ge1xuICAgICAgcmVhbFNjYWxlOiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMsXG4gICAgICByb3RhdGlvbjogMFxuICAgIH07XG4gICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHk/LnJlc29sdmUoKTtcbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy4jYWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgIHRoaXMuI2Fib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5fc2lnbmFsID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLiNhbGxMYXllcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5jbGVhcigpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IG51bGw7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXIgPSBudWxsO1xuICAgIGlmICh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBjb21iaW5lZFNpZ25hbChhYykge1xuICAgIHJldHVybiBBYm9ydFNpZ25hbC5hbnkoW3RoaXMuX3NpZ25hbCwgYWMuc2lnbmFsXSk7XG4gIH1cbiAgZ2V0IG1sTWFuYWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jbWxNYW5hZ2VyO1xuICB9XG4gIGdldCB1c2VOZXdBbHRUZXh0RmxvdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZW5hYmxlVXBkYXRlZEFkZEltYWdlO1xuICB9XG4gIGdldCB1c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlO1xuICB9XG4gIGdldCBoY21GaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhjbUZpbHRlclwiLCB0aGlzLiNwYWdlQ29sb3JzID8gdGhpcy4jZmlsdGVyRmFjdG9yeS5hZGRIQ01GaWx0ZXIodGhpcy4jcGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLiNwYWdlQ29sb3JzLmJhY2tncm91bmQpIDogXCJub25lXCIpO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImRpcmVjdGlvblwiLCBnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2NvbnRhaW5lcikuZGlyZWN0aW9uKTtcbiAgfVxuICBnZXQgaGlnaGxpZ2h0Q29sb3JzKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoaWdobGlnaHRDb2xvcnNcIiwgdGhpcy4jaGlnaGxpZ2h0Q29sb3JzID8gbmV3IE1hcCh0aGlzLiNoaWdobGlnaHRDb2xvcnMuc3BsaXQoXCIsXCIpLm1hcChwYWlyID0+IHBhaXIuc3BsaXQoXCI9XCIpLm1hcCh4ID0+IHgudHJpbSgpKSkpIDogbnVsbCk7XG4gIH1cbiAgZ2V0IGhpZ2hsaWdodENvbG9yTmFtZXMoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhpZ2hsaWdodENvbG9yTmFtZXNcIiwgdGhpcy5oaWdobGlnaHRDb2xvcnMgPyBuZXcgTWFwKEFycmF5LmZyb20odGhpcy5oaWdobGlnaHRDb2xvcnMsIGUgPT4gZS5yZXZlcnNlKCkpKSA6IG51bGwpO1xuICB9XG4gIHNldE1haW5IaWdobGlnaHRDb2xvclBpY2tlcihjb2xvclBpY2tlcikge1xuICAgIHRoaXMuI21haW5IaWdobGlnaHRDb2xvclBpY2tlciA9IGNvbG9yUGlja2VyO1xuICB9XG4gIGVkaXRBbHRUZXh0KGVkaXRvciwgZmlyc3RUaW1lID0gZmFsc2UpIHtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlcj8uZWRpdEFsdFRleHQodGhpcywgZWRpdG9yLCBmaXJzdFRpbWUpO1xuICB9XG4gIHN3aXRjaFRvTW9kZShtb2RlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2V2ZW50QnVzLm9uKFwiYW5ub3RhdGlvbmVkaXRvcm1vZGVjaGFuZ2VkXCIsIGNhbGxiYWNrLCB7XG4gICAgICBvbmNlOiB0cnVlLFxuICAgICAgc2lnbmFsOiB0aGlzLl9zaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcInNob3dhbm5vdGF0aW9uZWRpdG9ydWlcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgbW9kZVxuICAgIH0pO1xuICB9XG4gIHNldFByZWZlcmVuY2UobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcInNldHByZWZlcmVuY2VcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH1cbiAgb25TZXRQcmVmZXJlbmNlKHtcbiAgICBuYW1lLFxuICAgIHZhbHVlXG4gIH0pIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlXCI6XG4gICAgICAgIHRoaXMuI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIG9uUGFnZUNoYW5naW5nKHtcbiAgICBwYWdlTnVtYmVyXG4gIH0pIHtcbiAgICB0aGlzLiNjdXJyZW50UGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDE7XG4gIH1cbiAgZm9jdXNNYWluQ29udGFpbmVyKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5mb2N1cygpO1xuICB9XG4gIGZpbmRQYXJlbnQoeCwgeSkge1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHg6IGxheWVyWCxcbiAgICAgICAgeTogbGF5ZXJZLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gbGF5ZXIuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHggPj0gbGF5ZXJYICYmIHggPD0gbGF5ZXJYICsgd2lkdGggJiYgeSA+PSBsYXllclkgJiYgeSA8PSBsYXllclkgKyBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkaXNhYmxlVXNlclNlbGVjdCh2YWx1ZSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jdmlld2VyLmNsYXNzTGlzdC50b2dnbGUoXCJub1VzZXJTZWxlY3RcIiwgdmFsdWUpO1xuICB9XG4gIGFkZFNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5hZGQoZWRpdG9yKTtcbiAgfVxuICByZW1vdmVTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuZGVsZXRlKGVkaXRvcik7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKHtcbiAgICBzY2FsZVxuICB9KSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlID0gc2NhbGUgKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFM7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZSkge1xuICAgICAgZWRpdG9yLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIH1cbiAgfVxuICBvblJvdGF0aW9uQ2hhbmdpbmcoe1xuICAgIHBhZ2VzUm90YXRpb25cbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uID0gcGFnZXNSb3RhdGlvbjtcbiAgfVxuICAjZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbih7XG4gICAgYW5jaG9yTm9kZVxuICB9KSB7XG4gICAgcmV0dXJuIGFuY2hvck5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50IDogYW5jaG9yTm9kZTtcbiAgfVxuICAjZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudExheWVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGN1cnJlbnRMYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRMYXllcjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChsYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uID0gXCJcIikge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXRcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IHRleHQgPSBzZWxlY3Rpb24udG9TdHJpbmcoKTtcbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcik7XG4gICAgaWYgKCFib3hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uZW1wdHkoKTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2dldExheWVyRm9yVGV4dExheWVyKHRleHRMYXllcik7XG4gICAgY29uc3QgaXNOb25lTW9kZSA9IHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBsYXllcj8uY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwgZmFsc2UsIHtcbiAgICAgICAgbWV0aG9kT2ZDcmVhdGlvbixcbiAgICAgICAgYm94ZXMsXG4gICAgICAgIGFuY2hvck5vZGUsXG4gICAgICAgIGFuY2hvck9mZnNldCxcbiAgICAgICAgZm9jdXNOb2RlLFxuICAgICAgICBmb2N1c09mZnNldCxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNOb25lTW9kZSkge1xuICAgICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHRydWUsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzTm9uZU1vZGUpIHtcbiAgICAgIHRoaXMuc3dpdGNoVG9Nb2RlKEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9XG4gICNkaXNwbGF5SGlnaGxpZ2h0VG9vbGJhcigpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yRWxlbWVudCA9IHRoaXMuI2dldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCB0ZXh0TGF5ZXIgPSBhbmNob3JFbGVtZW50LmNsb3Nlc3QoXCIudGV4dExheWVyXCIpO1xuICAgIGNvbnN0IGJveGVzID0gdGhpcy5nZXRTZWxlY3Rpb25Cb3hlcyh0ZXh0TGF5ZXIpO1xuICAgIGlmICghYm94ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhciB8fD0gbmV3IEhpZ2hsaWdodFRvb2xiYXIodGhpcyk7XG4gICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhci5zaG93KHRleHRMYXllciwgYm94ZXMsIHRoaXMuZGlyZWN0aW9uID09PSBcImx0clwiKTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzRW1wdHkoKSAmJiB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSAmJiAhdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgI3NlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIGlmICh0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXI/LmhpZGUoKTtcbiAgICAgICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JOb2RlXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBpZiAoYW5jaG9yTm9kZSA9PT0gdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgaWYgKCF0ZXh0TGF5ZXIpIHtcbiAgICAgIGlmICh0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXI/LmhpZGUoKTtcbiAgICAgICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IGFuY2hvck5vZGU7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRUZXh0OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCAmJiB0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gdGhpcy5pc1NoaWZ0S2V5RG93bjtcbiAgICBpZiAoIXRoaXMuaXNTaGlmdEtleURvd24pIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUxheWVyID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUID8gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSA6IG51bGw7XG4gICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZygpO1xuICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICAgIGNvbnN0IHBvaW50ZXJ1cCA9IGUgPT4ge1xuICAgICAgICBpZiAoZS50eXBlID09PSBcInBvaW50ZXJ1cFwiICYmIGUuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGFjdGl2ZUxheWVyPy50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgICAgICBpZiAoZS50eXBlID09PSBcInBvaW50ZXJ1cFwiKSB7XG4gICAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVydXAsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVydXAsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI29uU2VsZWN0RW5kKG1ldGhvZE9mQ3JlYXRpb24gPSBcIlwiKSB7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCkge1xuICAgICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24obWV0aG9kT2ZDcmVhdGlvbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbikge1xuICAgICAgdGhpcy4jZGlzcGxheUhpZ2hsaWdodFRvb2xiYXIoKTtcbiAgICB9XG4gIH1cbiAgI2FkZFNlbGVjdGlvbkxpc3RlbmVyKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy4jc2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI2FkZEZvY3VzTWFuYWdlcigpIHtcbiAgICBpZiAodGhpcy4jZm9jdXNNYW5hZ2VyQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNmb2N1c01hbmFnZXJBQyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmZvY3VzLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmJsdXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUZvY3VzTWFuYWdlcigpIHtcbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQyA9IG51bGw7XG4gIH1cbiAgYmx1cigpIHtcbiAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwKSB7XG4gICAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gW2VkaXRvciwgYWN0aXZlRWxlbWVudF07XG4gICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb2N1cygpIHtcbiAgICBpZiAoIXRoaXMuI2xhc3RBY3RpdmVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtsYXN0RWRpdG9yLCBsYXN0QWN0aXZlRWxlbWVudF0gPSB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudDtcbiAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgbGFzdEVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICB9LCB7XG4gICAgICBvbmNlOiB0cnVlLFxuICAgICAgc2lnbmFsOiB0aGlzLl9zaWduYWxcbiAgICB9KTtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG4gICNhZGRLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgaWYgKHRoaXMuI2tleWJvYXJkTWFuYWdlckFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmtleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmtleXVwLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMgPSBudWxsO1xuICB9XG4gICNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2NvcHlQYXN0ZUFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvcHlQYXN0ZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4jY29weVBhc3RlQUMpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIHRoaXMuY29weS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuY3V0LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLnBhc3RlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jY29weVBhc3RlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jY29weVBhc3RlQUMgPSBudWxsO1xuICB9XG4gICNhZGREcmFnQW5kRHJvcExpc3RlbmVycygpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9zaWduYWw7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIHRoaXMuZHJhZ092ZXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5kcm9wLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFkZEVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jYWRkQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVtb3ZlRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICBkcmFnT3ZlcihldmVudCkge1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gb2YgZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKHR5cGUpKSB7XG4gICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcImNvcHlcIjtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcm9wKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29weShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IGVkaXRvci5zZXJpYWxpemUodHJ1ZSk7XG4gICAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgICBlZGl0b3JzLnB1c2goc2VyaWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZGl0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiLCBKU09OLnN0cmluZ2lmeShlZGl0b3JzKSk7XG4gIH1cbiAgY3V0KGV2ZW50KSB7XG4gICAgdGhpcy5jb3B5KGV2ZW50KTtcbiAgICB0aGlzLmRlbGV0ZSgpO1xuICB9XG4gIGFzeW5jIHBhc3RlKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGlwYm9hcmREYXRhXG4gICAgfSA9IGV2ZW50O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjbGlwYm9hcmREYXRhLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICBlZGl0b3JUeXBlLnBhc3RlKGl0ZW0sIHRoaXMuY3VycmVudExheWVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhdGEgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRMYXllcjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3RWRpdG9ycyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZGF0YSkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRFZGl0b3IgPSBhd2FpdCBsYXllci5kZXNlcmlhbGl6ZShlZGl0b3IpO1xuICAgICAgICBpZiAoIWRlc2VyaWFsaXplZEVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXdFZGl0b3JzLnB1c2goZGVzZXJpYWxpemVkRWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKG5ld0VkaXRvcnMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kLFxuICAgICAgICB1bmRvLFxuICAgICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICB9XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1NoaWZ0S2V5RG93biAmJiBldmVudC5rZXkgPT09IFwiU2hpZnRcIikge1xuICAgICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FICYmICF0aGlzLmlzRWRpdG9ySGFuZGxpbmdLZXlib2FyZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBrZXl1cChldmVudCkge1xuICAgIGlmICh0aGlzLmlzU2hpZnRLZXlEb3duICYmIGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXApIHtcbiAgICAgICAgdGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uRWRpdGluZ0FjdGlvbih7XG4gICAgbmFtZVxuICB9KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidW5kb1wiOlxuICAgICAgY2FzZSBcInJlZG9cIjpcbiAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgIGNhc2UgXCJzZWxlY3RBbGxcIjpcbiAgICAgICAgdGhpc1tuYW1lXSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoaWdobGlnaHRTZWxlY3Rpb25cIjpcbiAgICAgICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24oXCJjb250ZXh0X21lbnVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoZGV0YWlscykge1xuICAgIGNvbnN0IGhhc0NoYW5nZWQgPSBPYmplY3QuZW50cmllcyhkZXRhaWxzKS5zb21lKChba2V5LCB2YWx1ZV0pID0+IHRoaXMuI3ByZXZpb3VzU3RhdGVzW2tleV0gIT09IHZhbHVlKTtcbiAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJhbm5vdGF0aW9uZWRpdG9yc3RhdGVzY2hhbmdlZFwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgZGV0YWlsczogT2JqZWN0LmFzc2lnbih0aGlzLiNwcmV2aW91c1N0YXRlcywgZGV0YWlscylcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCAmJiBkZXRhaWxzLmhhc1NlbGVjdGVkRWRpdG9yID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0ZSRUUsIHRydWVdXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVVJKGRldGFpbHMpIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JwYXJhbXNjaGFuZ2VkXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHNcbiAgICB9KTtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgaWYgKGlzRWRpdGluZykge1xuICAgICAgdGhpcy4jYWRkRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiB0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FLFxuICAgICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KCksXG4gICAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9VbmRvKCksXG4gICAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9SZWRvKCksXG4gICAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3JlbW92ZUZvY3VzTWFuYWdlcigpO1xuICAgICAgdGhpcy4jcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGlzRWRpdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRWRpdG9yVHlwZXModHlwZXMpIHtcbiAgICBpZiAodGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZWRpdG9yVHlwZXMgPSB0eXBlcztcbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yVHlwZS5kZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lkTWFuYWdlci5pZDtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHRoaXMuI2N1cnJlbnRQYWdlSW5kZXgpO1xuICB9XG4gIGdldExheWVyKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQYWdlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXg7XG4gIH1cbiAgYWRkTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuc2V0KGxheWVyLnBhZ2VJbmRleCwgbGF5ZXIpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIGxheWVyLmVuYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmRlbGV0ZShsYXllci5wYWdlSW5kZXgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1vZGUobW9kZSwgZWRpdElkID0gbnVsbCwgaXNGcm9tS2V5Ym9hcmQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSkge1xuICAgICAgYXdhaXQgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIGlmICghdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuI21vZGUgPSBtb2RlO1xuICAgIGlmIChtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgICB0aGlzLiNkaXNhYmxlQWxsKCk7XG4gICAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIGF3YWl0IHRoaXMuI2VuYWJsZUFsbCgpO1xuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICB9XG4gICAgaWYgKCFlZGl0SWQpIHtcbiAgICAgIGlmIChpc0Zyb21LZXlib2FyZCkge1xuICAgICAgICB0aGlzLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPT09IGVkaXRJZCkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRMYXllci5jYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihtb2RlKSB7XG4gICAgaWYgKG1vZGUgPT09IHRoaXMuI21vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuQ1JFQVRFOlxuICAgICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfREVGQVVMVF9DT0xPUjpcbiAgICAgICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyPy51cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEw6XG4gICAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJ0b2dnbGVfdmlzaWJpbGl0eVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKHRoaXMuI3Nob3dBbGxTdGF0ZXMgfHw9IG5ldyBNYXAoKSkuc2V0KHR5cGUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIGVkaXRvclR5cGUudXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHNob3dBbGxFZGl0b3JzKHR5cGUsIHZpc2libGUsIHVwZGF0ZUJ1dHRvbiA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5lZGl0b3JUeXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVkaXRvci5zaG93KHZpc2libGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI3Nob3dBbGxTdGF0ZXM/LmdldChBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEwpID8/IHRydWU7XG4gICAgaWYgKHN0YXRlICE9PSB2aXNpYmxlKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1NIT1dfQUxMLCB2aXNpYmxlXV0pO1xuICAgIH1cbiAgfVxuICBlbmFibGVXYWl0aW5nKG11c3RXYWl0ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jaXNXYWl0aW5nID09PSBtdXN0V2FpdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNpc1dhaXRpbmcgPSBtdXN0V2FpdDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICAgIGxheWVyLmRpc2FibGVDbGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIuZW5hYmxlQ2xpY2soKTtcbiAgICAgIH1cbiAgICAgIGxheWVyLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwid2FpdGluZ1wiLCBtdXN0V2FpdCk7XG4gICAgfVxuICB9XG4gIGFzeW5jICNlbmFibGVBbGwoKSB7XG4gICAgaWYgKCF0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IHRydWU7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChsYXllci5lbmFibGUoKSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc2FibGVBbGwoKSB7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3IuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRFZGl0b3JzKHBhZ2VJbmRleCkge1xuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4KSB7XG4gICAgICAgIGVkaXRvcnMucHVzaChlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWRpdG9ycztcbiAgfVxuICBnZXRFZGl0b3IoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsRWRpdG9ycy5nZXQoaWQpO1xuICB9XG4gIGFkZEVkaXRvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlRWRpdG9yKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZm9jdXNNYWluQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICB0aGlzLnVuc2VsZWN0KGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCAhdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpKSB7XG4gICAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZT8ucmVtb3ZlKGVkaXRvci5pZCk7XG4gICAgfVxuICB9XG4gIGFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgdGhpcy5hZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIGlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gIH1cbiAgcmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuZGVsZXRlKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB0aGlzLnJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gICNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jYWxsTGF5ZXJzLmdldChlZGl0b3IucGFnZUluZGV4KTtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIGdldCAjbGFzdFNlbGVjdGVkRWRpdG9yKCkge1xuICAgIGxldCBlZCA9IG51bGw7XG4gICAgZm9yIChlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHt9XG4gICAgcmV0dXJuIGVkO1xuICB9XG4gIHVwZGF0ZVVJKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNsYXN0U2VsZWN0ZWRFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKSkge1xuICAgICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHNldFNlbGVjdGVkKGVkaXRvcikge1xuICAgIGZvciAoY29uc3QgZWQgb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBpZiAoZWQgIT09IGVkaXRvcikge1xuICAgICAgICBlZC51bnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpc1NlbGVjdGVkKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcik7XG4gIH1cbiAgZ2V0IGZpcnN0U2VsZWN0ZWRFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gIH1cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgIH0pO1xuICB9XG4gIGdldCBoYXNTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplICE9PSAwO1xuICB9XG4gIGdldCBpc0VudGVySGFuZGxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgPT09IDEgJiYgdGhpcy5maXJzdFNlbGVjdGVkRWRpdG9yLmlzRW50ZXJIYW5kbGVkO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIudW5kbygpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9VbmRvKCksXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRydWUsXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICByZWRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnJlZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuYWRkKHBhcmFtcyk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gICNpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAxKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuaXNFbXB0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVsZXRlKCkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBbLi4udGhpcy4jc2VsZWN0ZWRFZGl0b3JzXTtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvQ29udHJvbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yIHx8IHRoaXMuaGFzU2VsZWN0aW9uO1xuICB9XG4gICNzZWxlY3RFZGl0b3JzKGVkaXRvcnMpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0QWxsKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpO1xuICB9XG4gIHVuc2VsZWN0QWxsKCkge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVkaXRvci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyh4LCB5LCBub0NvbW1pdCA9IGZhbHNlKSB7XG4gICAgaWYgKCFub0NvbW1pdCkge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdICs9IHg7XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMV0gKz0geTtcbiAgICBjb25zdCBbdG90YWxYLCB0b3RhbFldID0gdGhpcy4jdHJhbnNsYXRpb247XG4gICAgY29uc3QgZWRpdG9ycyA9IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDEwMDA7XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gPSB0aGlzLiN0cmFuc2xhdGlvblsxXSA9IDA7XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSh0b3RhbFgsIHRvdGFsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSgtdG90YWxYLCAtdG90YWxZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHgsIHkpO1xuICAgIH1cbiAgfVxuICBzZXRVcERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdCh0cnVlKTtcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMuc2V0KGVkaXRvciwge1xuICAgICAgICBzYXZlZFg6IGVkaXRvci54LFxuICAgICAgICBzYXZlZFk6IGVkaXRvci55LFxuICAgICAgICBzYXZlZFBhZ2VJbmRleDogZWRpdG9yLnBhZ2VJbmRleCxcbiAgICAgICAgbmV3WDogMCxcbiAgICAgICAgbmV3WTogMCxcbiAgICAgICAgbmV3UGFnZUluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuZERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuI2RyYWdnaW5nRWRpdG9ycztcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAgIGxldCBtdXN0QmVBZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwYWdlSW5kZXhcbiAgICB9LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgICB2YWx1ZS5uZXdYID0geDtcbiAgICAgIHZhbHVlLm5ld1kgPSB5O1xuICAgICAgdmFsdWUubmV3UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgbXVzdEJlQWRkZWRJblVuZG9TdGFjayB8fD0geCAhPT0gdmFsdWUuc2F2ZWRYIHx8IHkgIT09IHZhbHVlLnNhdmVkWSB8fCBwYWdlSW5kZXggIT09IHZhbHVlLnNhdmVkUGFnZUluZGV4O1xuICAgIH1cbiAgICBpZiAoIW11c3RCZUFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbW92ZSA9IChlZGl0b3IsIHgsIHksIHBhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgZWRpdG9yLl9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICAgICAgZWRpdG9yLnggPSB4O1xuICAgICAgICAgIGVkaXRvci55ID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgbmV3WCxcbiAgICAgICAgICBuZXdZLFxuICAgICAgICAgIG5ld1BhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgbmV3WCwgbmV3WSwgbmV3UGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgc2F2ZWRYLFxuICAgICAgICAgIHNhdmVkWSxcbiAgICAgICAgICBzYXZlZFBhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgc2F2ZWRYLCBzYXZlZFksIHNhdmVkUGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMua2V5cygpKSB7XG4gICAgICBlZGl0b3IuZHJhZyh0eCwgdHkpO1xuICAgIH1cbiAgfVxuICByZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExheWVyKGVkaXRvci5wYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgICAgIHBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IucGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkKCkge1xuICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZSgpPy5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHx8IHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplID09PSAxICYmIHRoaXMuZmlyc3RTZWxlY3RlZEVkaXRvci5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpO1xuICB9XG4gIGlzQWN0aXZlKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcjtcbiAgfVxuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvcjtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNtb2RlO1xuICB9XG4gIGdldCBpbWFnZU1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImltYWdlTWFuYWdlclwiLCBuZXcgSW1hZ2VNYW5hZ2VyKCkpO1xuICB9XG4gIGdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcikge1xuICAgIGlmICghdGV4dExheWVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2VsZWN0aW9uLnJhbmdlQ291bnQ7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoIXRleHRMYXllci5jb250YWlucyhzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHg6IGxheWVyWCxcbiAgICAgIHk6IGxheWVyWSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcm90YXRvcjtcbiAgICBzd2l0Y2ggKHRleHRMYXllci5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIikpIHtcbiAgICAgIGNhc2UgXCI5MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogKHkgLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6IDEgLSAoeCArIHcgLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgd2lkdGg6IGggLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0OiB3IC8gcGFyZW50V2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjE4MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogdyAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaCAvIHBhcmVudEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMjcwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB5OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogaCAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHcgLyBwYXJlbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogKHggLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgeTogKHkgLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3IC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoIC8gcGFyZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7XG4gICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gb2YgcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSkge1xuICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYm94ZXMucHVzaChyb3RhdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJveGVzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBib3hlcztcbiAgfVxuICBhZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkLFxuICAgIGlkXG4gIH0pIHtcbiAgICAodGhpcy4jY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMgfHw9IG5ldyBNYXAoKSkuc2V0KGFubm90YXRpb25FbGVtZW50SWQsIGlkKTtcbiAgfVxuICByZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gIH0pIHtcbiAgICB0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucz8uZGVsZXRlKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCBlZGl0b3JJZCA9IHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zPy5nZXQoYW5ub3RhdGlvbi5kYXRhLmlkKTtcbiAgICBpZiAoIWVkaXRvcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGVkaXRvcklkKTtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSAmJiAhZWRpdG9yLmhhc0JlZW5Nb2RpZmllZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3IucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2FsdF90ZXh0LmpzXG5cbmNsYXNzIEFsdFRleHQge1xuICAjYWx0VGV4dCA9IG51bGw7XG4gICNhbHRUZXh0RGVjb3JhdGl2ZSA9IGZhbHNlO1xuICAjYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICNhbHRUZXh0QnV0dG9uTGFiZWwgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgI2JhZGdlID0gbnVsbDtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNndWVzc2VkVGV4dCA9IG51bGw7XG4gICN0ZXh0V2l0aERpc2NsYWltZXIgPSBudWxsO1xuICAjdXNlTmV3QWx0VGV4dEZsb3cgPSBmYWxzZTtcbiAgc3RhdGljICNsMTBuTmV3QnV0dG9uID0gbnVsbDtcbiAgc3RhdGljIF9sMTBuID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuI3VzZU5ld0FsdFRleHRGbG93ID0gZWRpdG9yLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3c7XG4gICAgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbiB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBhZGRlZDogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LWFkZGVkLWJ1dHRvblwiLFxuICAgICAgXCJhZGRlZC1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtYWRkZWQtYnV0dG9uLWxhYmVsXCIsXG4gICAgICBtaXNzaW5nOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtbWlzc2luZy1idXR0b25cIixcbiAgICAgIFwibWlzc2luZy1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtbWlzc2luZy1idXR0b24tbGFiZWxcIixcbiAgICAgIHJldmlldzogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LXRvLXJldmlldy1idXR0b25cIixcbiAgICAgIFwicmV2aWV3LWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC10by1yZXZpZXctYnV0dG9uLWxhYmVsXCJcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgQWx0VGV4dC5fbDEwbiA/Pz0gbDEwbjtcbiAgfVxuICBhc3luYyByZW5kZXIoKSB7XG4gICAgY29uc3QgYWx0VGV4dCA9IHRoaXMuI2FsdFRleHRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGFsdFRleHQuY2xhc3NOYW1lID0gXCJhbHRUZXh0XCI7XG4gICAgYWx0VGV4dC50YWJJbmRleCA9IFwiMFwiO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgYWx0VGV4dC5hcHBlbmQobGFiZWwpO1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgYWx0VGV4dC5jbGFzc0xpc3QuYWRkKFwibmV3XCIpO1xuICAgICAgYWx0VGV4dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbi5taXNzaW5nKTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW1wibWlzc2luZy1sYWJlbFwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsdFRleHQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWJ1dHRvblwiKTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1idXR0b24tbGFiZWxcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZXZlbnQgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcy4jZWRpdG9yKTtcbiAgICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmFsdF90ZXh0LmltYWdlX3N0YXR1c19sYWJlbF9jbGlja2VkXCIsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbGFiZWw6IHRoaXMuI2xhYmVsXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGFsdFRleHQgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IHRydWU7XG4gICAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuI3NldFN0YXRlKCk7XG4gICAgcmV0dXJuIGFsdFRleHQ7XG4gIH1cbiAgZ2V0ICNsYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCAmJiBcImFkZGVkXCIgfHwgdGhpcy4jYWx0VGV4dCA9PT0gbnVsbCAmJiB0aGlzLmd1ZXNzZWRUZXh0ICYmIFwicmV2aWV3XCIgfHwgXCJtaXNzaW5nXCI7XG4gIH1cbiAgZmluaXNoKCkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZFxuICAgIH0pO1xuICAgIHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSBmYWxzZTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgPT09IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dERlY29yYXRpdmU7XG4gIH1cbiAgaGFzRGF0YSgpIHtcbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ICE9PSBudWxsIHx8ICEhdGhpcy4jZ3Vlc3NlZFRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKTtcbiAgfVxuICBnZXQgZ3Vlc3NlZFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2d1ZXNzZWRUZXh0O1xuICB9XG4gIGFzeW5jIHNldEd1ZXNzZWRUZXh0KGd1ZXNzZWRUZXh0KSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZ3Vlc3NlZFRleHQgPSBndWVzc2VkVGV4dDtcbiAgICB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXIgPSBhd2FpdCBBbHRUZXh0Ll9sMTBuLmdldChcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtZ2VuZXJhdGVkLWFsdC10ZXh0LXdpdGgtZGlzY2xhaW1lclwiLCB7XG4gICAgICBnZW5lcmF0ZWRBbHRUZXh0OiBndWVzc2VkVGV4dFxuICAgIH0pO1xuICAgIHRoaXMuI3NldFN0YXRlKCk7XG4gIH1cbiAgdG9nZ2xlQWx0VGV4dEJhZGdlKHZpc2liaWxpdHkgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cgfHwgdGhpcy4jYWx0VGV4dCkge1xuICAgICAgdGhpcy4jYmFkZ2U/LnJlbW92ZSgpO1xuICAgICAgdGhpcy4jYmFkZ2UgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2JhZGdlKSB7XG4gICAgICBjb25zdCBiYWRnZSA9IHRoaXMuI2JhZGdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGJhZGdlLmNsYXNzTmFtZSA9IFwibm9BbHRUZXh0QmFkZ2VcIjtcbiAgICAgIHRoaXMuI2VkaXRvci5kaXYuYXBwZW5kKGJhZGdlKTtcbiAgICB9XG4gICAgdGhpcy4jYmFkZ2UuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCAhdmlzaWJpbGl0eSk7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZykge1xuICAgIGxldCBhbHRUZXh0ID0gdGhpcy4jYWx0VGV4dDtcbiAgICBpZiAoIWlzRm9yQ29weWluZyAmJiB0aGlzLiNndWVzc2VkVGV4dCA9PT0gYWx0VGV4dCkge1xuICAgICAgYWx0VGV4dCA9IHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsdFRleHQsXG4gICAgICBkZWNvcmF0aXZlOiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSxcbiAgICAgIGd1ZXNzZWRUZXh0OiB0aGlzLiNndWVzc2VkVGV4dCxcbiAgICAgIHRleHRXaXRoRGlzY2xhaW1lcjogdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyXG4gICAgfTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dDogdGhpcy4jYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlXG4gICAgfTtcbiAgfVxuICBzZXQgZGF0YSh7XG4gICAgYWx0VGV4dCxcbiAgICBkZWNvcmF0aXZlLFxuICAgIGd1ZXNzZWRUZXh0LFxuICAgIHRleHRXaXRoRGlzY2xhaW1lcixcbiAgICBjYW5jZWwgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKGd1ZXNzZWRUZXh0KSB7XG4gICAgICB0aGlzLiNndWVzc2VkVGV4dCA9IGd1ZXNzZWRUZXh0O1xuICAgICAgdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyID0gdGV4dFdpdGhEaXNjbGFpbWVyO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWx0VGV4dCA9PT0gYWx0VGV4dCAmJiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA9PT0gZGVjb3JhdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gICAgICB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA9IGRlY29yYXRpdmU7XG4gICAgfVxuICAgIHRoaXMuI3NldFN0YXRlKCk7XG4gIH1cbiAgdG9nZ2xlKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQgJiYgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24uZGlzYWJsZWQgPSAhZW5hYmxlZDtcbiAgfVxuICBzaG93bigpIHtcbiAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuYWx0X3RleHQuaW1hZ2Vfc3RhdHVzX2xhYmVsX2Rpc3BsYXllZFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBsYWJlbDogdGhpcy4jbGFiZWxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b25MYWJlbCA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAgIHRoaXMuI2JhZGdlPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNiYWRnZSA9IG51bGw7XG4gIH1cbiAgYXN5bmMgI3NldFN0YXRlKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2FsdFRleHRCdXR0b247XG4gICAgaWYgKCFidXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcImRvbmVcIiwgISF0aGlzLiNhbHRUZXh0KTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvblt0aGlzLiNsYWJlbF0pO1xuICAgICAgdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsPy5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbltgJHt0aGlzLiNsYWJlbH0tbGFiZWxgXSk7XG4gICAgICBpZiAoIXRoaXMuI2FsdFRleHQpIHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dERlY29yYXRpdmUpIHtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkb25lXCIpO1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZG9uZVwiKTtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtZWRpdC1idXR0b25cIik7XG4gICAgfVxuICAgIGxldCB0b29sdGlwID0gdGhpcy4jYWx0VGV4dFRvb2x0aXA7XG4gICAgaWYgKCF0b29sdGlwKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcCA9IHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHRvb2x0aXAuY2xhc3NOYW1lID0gXCJ0b29sdGlwXCI7XG4gICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sdGlwXCIpO1xuICAgICAgdG9vbHRpcC5pZCA9IGBhbHQtdGV4dC10b29sdGlwLSR7dGhpcy4jZWRpdG9yLmlkfWA7XG4gICAgICBjb25zdCBERUxBWV9UT19TSE9XX1RPT0xUSVAgPSAxMDA7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgfSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAuY2xhc3NMaXN0LmFkZChcInNob3dcIik7XG4gICAgICAgICAgdGhpcy4jZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgICAgYWN0aW9uOiBcImFsdF90ZXh0X3Rvb2x0aXBcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBERUxBWV9UT19TSE9XX1RPT0xUSVApO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWx0VGV4dERlY29yYXRpdmUpIHtcbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWRlY29yYXRpdmUtdG9vbHRpcFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9vbHRpcC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIik7XG4gICAgICB0b29sdGlwLnRleHRDb250ZW50ID0gdGhpcy4jYWx0VGV4dDtcbiAgICB9XG4gICAgaWYgKCF0b29sdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmQodG9vbHRpcCk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLiNlZGl0b3IuZ2V0SW1hZ2VGb3JBbHRUZXh0KCk7XG4gICAgZWxlbWVudD8uc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCB0b29sdGlwLmlkKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZWRpdG9yLmpzXG5cblxuXG5cblxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhY2Nlc3NpYmlsaXR5RGF0YSA9IG51bGw7XG4gICNhbGxSZXNpemVyRGl2cyA9IG51bGw7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgI2Rpc2FibGVkID0gZmFsc2U7XG4gICNrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgI3Jlc2l6ZXJzRGl2ID0gbnVsbDtcbiAgI3NhdmVkRGltZW5zaW9ucyA9IG51bGw7XG4gICNmb2N1c0FDID0gbnVsbDtcbiAgI2ZvY3VzZWRSZXNpemVyTmFtZSA9IFwiXCI7XG4gICNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAjaW5pdGlhbFBvc2l0aW9uID0gbnVsbDtcbiAgI2lzRWRpdGluZyA9IGZhbHNlO1xuICAjaXNJbkVkaXRNb2RlID0gZmFsc2U7XG4gICNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPSBmYWxzZTtcbiAgI21vdmVJbkRPTVRpbWVvdXQgPSBudWxsO1xuICAjcHJldkRyYWdYID0gMDtcbiAgI3ByZXZEcmFnWSA9IDA7XG4gICN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gIF9lZGl0VG9vbGJhciA9IG51bGw7XG4gIF9pbml0aWFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIF9pbml0aWFsRGF0YSA9IG51bGw7XG4gIF9pc1Zpc2libGUgPSB0cnVlO1xuICBfdWlNYW5hZ2VyID0gbnVsbDtcbiAgX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gIHN0YXRpYyBfbDEwbiA9IG51bGw7XG4gIHN0YXRpYyBfbDEwblJlc2l6ZXIgPSBudWxsO1xuICAjaXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgI3pJbmRleCA9IEFubm90YXRpb25FZGl0b3IuX3pJbmRleCsrO1xuICBzdGF0aWMgX2JvcmRlckxpbmVXaWR0aCA9IC0xO1xuICBzdGF0aWMgX2NvbG9yTWFuYWdlciA9IG5ldyBDb2xvck1hbmFnZXIoKTtcbiAgc3RhdGljIF96SW5kZXggPSAxO1xuICBzdGF0aWMgX3RlbGVtZXRyeVRpbWVvdXQgPSAxMDAwO1xuICBzdGF0aWMgZ2V0IF9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHJlc2l6ZSA9IEFubm90YXRpb25FZGl0b3IucHJvdG90eXBlLl9yZXNpemVXaXRoS2V5Ym9hcmQ7XG4gICAgY29uc3Qgc21hbGwgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW2JpZywgMF1cbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIC1iaWddXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXVxuICAgIH1dLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQW5ub3RhdGlvbkVkaXRvci5wcm90b3R5cGUuX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZF1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgdGhpcy5pZCA9IHBhcmFtZXRlcnMuaWQ7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmFtZXRlcnMucGFyZW50LnBhZ2VJbmRleDtcbiAgICB0aGlzLm5hbWUgPSBwYXJhbWV0ZXJzLm5hbWU7XG4gICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIHRoaXMuX3VpTWFuYWdlciA9IHBhcmFtZXRlcnMudWlNYW5hZ2VyO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zLmlzQ2VudGVyZWQgPSBwYXJhbWV0ZXJzLmlzQ2VudGVyZWQ7XG4gICAgdGhpcy5fc3RydWN0VHJlZVBhcmVudElkID0gbnVsbDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMucGFnZVJvdGF0aW9uID0gKDM2MCArIHJvdGF0aW9uIC0gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uKSAlIDM2MDtcbiAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gICAgdGhpcy5wYWdlVHJhbnNsYXRpb24gPSBbcGFnZVgsIHBhZ2VZXTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ID0gcGFyYW1ldGVycy54IC8gd2lkdGg7XG4gICAgdGhpcy55ID0gcGFyYW1ldGVycy55IC8gaGVpZ2h0O1xuICAgIHRoaXMuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvci5fdHlwZTtcbiAgfVxuICBzdGF0aWMgZ2V0IF9kZWZhdWx0TGluZUNvbG9yKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfZGVmYXVsdExpbmVDb2xvclwiLCB0aGlzLl9jb2xvck1hbmFnZXIuZ2V0SGV4Q29kZShcIkNhbnZhc1RleHRcIikpO1xuICB9XG4gIHN0YXRpYyBkZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICBjb25zdCBmYWtlRWRpdG9yID0gbmV3IEZha2VFZGl0b3Ioe1xuICAgICAgaWQ6IGVkaXRvci5wYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICBwYXJlbnQ6IGVkaXRvci5wYXJlbnQsXG4gICAgICB1aU1hbmFnZXI6IGVkaXRvci5fdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZmFrZUVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgZmFrZUVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgICBmYWtlRWRpdG9yLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShmYWtlRWRpdG9yKTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCBfdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwbiA/Pz0gbDEwbjtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplciB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICB0b3BMZWZ0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLXRvcC1sZWZ0XCIsXG4gICAgICB0b3BNaWRkbGU6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLW1pZGRsZVwiLFxuICAgICAgdG9wUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLXJpZ2h0XCIsXG4gICAgICBtaWRkbGVSaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1taWRkbGUtcmlnaHRcIixcbiAgICAgIGJvdHRvbVJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1yaWdodFwiLFxuICAgICAgYm90dG9tTWlkZGxlOiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1taWRkbGVcIixcbiAgICAgIGJvdHRvbUxlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLWxlZnRcIixcbiAgICAgIG1pZGRsZUxlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItbWlkZGxlLWxlZnRcIlxuICAgIH0pO1xuICAgIGlmIChBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tb3V0bGluZS13aWR0aFwiKSkgfHwgMDtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyhfdHlwZSwgX3ZhbHVlKSB7fVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IF9pc0RyYWdnYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNEcmFnZ2FibGU7XG4gIH1cbiAgc2V0IF9pc0RyYWdnYWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRHJhZ2dhYmxlID0gdmFsdWU7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC50b2dnbGUoXCJkcmFnZ2FibGVcIiwgdmFsdWUpO1xuICB9XG4gIGdldCBpc0VudGVySGFuZGxlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjZW50ZXIoKSB7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnggLT0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllcjtcbiAgfVxuICBzZXRJbkJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gMDtcbiAgfVxuICBzZXRJbkZvcmVncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gdGhpcy4jekluZGV4O1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmVudC5wYWdlSW5kZXg7XG4gICAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gcGFyZW50LnBhZ2VEaW1lbnNpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFzQmVlbkNsaWNrZWQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb2N1c291dChldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAodGFyZ2V0Py5jbG9zZXN0KGAjJHt0aGlzLmlkfWApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudD8uaXNNdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIHNldEF0KHgsIHksIHR4LCB0eSkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24odHgsIHR5KTtcbiAgICB0aGlzLnggPSAoeCArIHR4KSAvIHdpZHRoO1xuICAgIHRoaXMueSA9ICh5ICsgdHkpIC8gaGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICAjdHJhbnNsYXRlKFt3aWR0aCwgaGVpZ2h0XSwgeCwgeSkge1xuICAgIFt4LCB5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSk7XG4gICAgdGhpcy54ICs9IHggLyB3aWR0aDtcbiAgICB0aGlzLnkgKz0geSAvIGhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYXJlbnREaW1lbnNpb25zLCB4LCB5KTtcbiAgfVxuICB0cmFuc2xhdGVJblBhZ2UoeCwgeSkge1xuICAgIHRoaXMuI2luaXRpYWxQb3NpdGlvbiB8fD0gW3RoaXMueCwgdGhpcy55XTtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYWdlRGltZW5zaW9ucywgeCwgeSk7XG4gICAgdGhpcy5kaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgZHJhZyh0eCwgdHkpIHtcbiAgICB0aGlzLiNpbml0aWFsUG9zaXRpb24gfHw9IFt0aGlzLngsIHRoaXMueV07XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMueCArPSB0eCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMueSArPSB0eSAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgKHRoaXMueCA8IDAgfHwgdGhpcy54ID4gMSB8fCB0aGlzLnkgPCAwIHx8IHRoaXMueSA+IDEpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh0aGlzLnBhcmVudC5maW5kTmV3UGFyZW50KHRoaXMsIHgsIHkpKSB7XG4gICAgICAgIHRoaXMueCAtPSBNYXRoLmZsb29yKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSAtPSBNYXRoLmZsb29yKHRoaXMueSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy5nZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgdGhpcy5kaXYuc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuZGl2LnN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gIGdldCBfaGFzQmVlbk1vdmVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuI2luaXRpYWxQb3NpdGlvbiAmJiAodGhpcy4jaW5pdGlhbFBvc2l0aW9uWzBdICE9PSB0aGlzLnggfHwgdGhpcy4jaW5pdGlhbFBvc2l0aW9uWzFdICE9PSB0aGlzLnkpO1xuICB9XG4gIGdldEJhc2VUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qge1xuICAgICAgX2JvcmRlckxpbmVXaWR0aFxuICAgIH0gPSBBbm5vdGF0aW9uRWRpdG9yO1xuICAgIGNvbnN0IHggPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgeSA9IF9ib3JkZXJMaW5lV2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWy14LCB5XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCwgLXldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgIH1cbiAgfVxuICBnZXQgX211c3RGaXhQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmaXhBbmRTZXRQb3NpdGlvbihyb3RhdGlvbiA9IHRoaXMucm90YXRpb24pIHtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICB3aWR0aCAqPSBwYWdlV2lkdGg7XG4gICAgaGVpZ2h0ICo9IHBhZ2VIZWlnaHQ7XG4gICAgeCAqPSBwYWdlV2lkdGg7XG4gICAgeSAqPSBwYWdlSGVpZ2h0O1xuICAgIGlmICh0aGlzLl9tdXN0Rml4UG9zaXRpb24pIHtcbiAgICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlV2lkdGggLSB3aWR0aCwgeCkpO1xuICAgICAgICAgIHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSGVpZ2h0IC0gaGVpZ2h0LCB5KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VXaWR0aCAtIGhlaWdodCwgeCkpO1xuICAgICAgICAgIHkgPSBNYXRoLm1pbihwYWdlSGVpZ2h0LCBNYXRoLm1heCh3aWR0aCwgeSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICB4ID0gTWF0aC5taW4ocGFnZVdpZHRoLCBNYXRoLm1heCh3aWR0aCwgeCkpO1xuICAgICAgICAgIHkgPSBNYXRoLm1pbihwYWdlSGVpZ2h0LCBNYXRoLm1heChoZWlnaHQsIHkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgeCA9IE1hdGgubWluKHBhZ2VXaWR0aCwgTWF0aC5tYXgoaGVpZ2h0LCB4KSk7XG4gICAgICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VIZWlnaHQgLSB3aWR0aCwgeSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnggPSB4IC89IHBhZ2VXaWR0aDtcbiAgICB0aGlzLnkgPSB5IC89IHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLmdldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5tb3ZlSW5ET00oKTtcbiAgfVxuICBzdGF0aWMgI3JvdGF0ZVBvaW50KHgsIHksIGFuZ2xlKSB7XG4gICAgc3dpdGNoIChhbmdsZSkge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAteF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbLXksIHhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gIH1cbiAgc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yLiNyb3RhdGVQb2ludCh4LCB5LCB0aGlzLnBhcmVudFJvdGF0aW9uKTtcbiAgfVxuICBwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIDM2MCAtIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gICNnZXRSb3RhdGlvbk1hdHJpeChyb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgICAgcmV0dXJuIFswLCAtcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgcGFnZUhlaWdodCAvIHBhZ2VXaWR0aCwgMF07XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy0xLCAwLCAwLCAtMV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQsIC1wYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxXTtcbiAgICB9XG4gIH1cbiAgZ2V0IHBhcmVudFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG4gIGdldCBwYXJlbnRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbiArIHRoaXMucGFnZVJvdGF0aW9uKSAlIDM2MDtcbiAgfVxuICBnZXQgcGFyZW50RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRTY2FsZSxcbiAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBbcGFnZVdpZHRoICogcGFyZW50U2NhbGUsIHBhZ2VIZWlnaHQgKiBwYXJlbnRTY2FsZV07XG4gIH1cbiAgc2V0RGltcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHdpZHRoIC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgaWYgKCF0aGlzLiNrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBoZWlnaHQgLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICB9XG4gIGZpeERpbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGhcbiAgICB9ID0gc3R5bGU7XG4gICAgY29uc3Qgd2lkdGhQZXJjZW50ID0gd2lkdGguZW5kc1dpdGgoXCIlXCIpO1xuICAgIGNvbnN0IGhlaWdodFBlcmNlbnQgPSAhdGhpcy4ja2VlcEFzcGVjdFJhdGlvICYmIGhlaWdodC5lbmRzV2l0aChcIiVcIik7XG4gICAgaWYgKHdpZHRoUGVyY2VudCAmJiBoZWlnaHRQZXJjZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAoIXdpZHRoUGVyY2VudCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsoMTAwICogcGFyc2VGbG9hdCh3aWR0aCkgLyBwYXJlbnRXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNrZWVwQXNwZWN0UmF0aW8gJiYgIWhlaWdodFBlcmNlbnQpIHtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBwYXJzZUZsb2F0KGhlaWdodCkgLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICB9XG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gICNjcmVhdGVSZXNpemVycygpIHtcbiAgICBpZiAodGhpcy4jcmVzaXplcnNEaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVzaXplcnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmNsYXNzTGlzdC5hZGQoXCJyZXNpemVyc1wiKTtcbiAgICBjb25zdCBjbGFzc2VzID0gdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA/IFtcInRvcExlZnRcIiwgXCJ0b3BSaWdodFwiLCBcImJvdHRvbVJpZ2h0XCIsIFwiYm90dG9tTGVmdFwiXSA6IFtcInRvcExlZnRcIiwgXCJ0b3BNaWRkbGVcIiwgXCJ0b3BSaWdodFwiLCBcIm1pZGRsZVJpZ2h0XCIsIFwiYm90dG9tUmlnaHRcIiwgXCJib3R0b21NaWRkbGVcIiwgXCJib3R0b21MZWZ0XCIsIFwibWlkZGxlTGVmdFwiXTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgY2xhc3Nlcykge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmFwcGVuZChkaXYpO1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJyZXNpemVyXCIsIG5hbWUpO1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIsIG5hbWUpO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNyZXNpemVyUG9pbnRlcmRvd24uYmluZCh0aGlzLCBuYW1lKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBkaXYudGFiSW5kZXggPSAtMTtcbiAgICB9XG4gICAgdGhpcy5kaXYucHJlcGVuZCh0aGlzLiNyZXNpemVyc0Rpdik7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVyZG93bihuYW1lLCBldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKGZhbHNlKTtcbiAgICBjb25zdCBzYXZlZERyYWdnYWJsZSA9IHRoaXMuX2lzRHJhZ2dhYmxlO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI3Jlc2l6ZXJQb2ludGVybW92ZS5iaW5kKHRoaXMsIG5hbWUpLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IHNhdmVkUGFyZW50Q3Vyc29yID0gdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICBjb25zdCBzYXZlZEN1cnNvciA9IHRoaXMuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZSh0cnVlKTtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gc2F2ZWREcmFnZ2FibGU7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gc2F2ZWRQYXJlbnRDdXJzb3I7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZEN1cnNvcjtcbiAgICAgIHRoaXMuI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKHNhdmVkWCwgc2F2ZWRZLCBzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjYWRkUmVzaXplVG9VbmRvU3RhY2soc2F2ZWRYLCBzYXZlZFksIHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KSB7XG4gICAgY29uc3QgbmV3WCA9IHRoaXMueDtcbiAgICBjb25zdCBuZXdZID0gdGhpcy55O1xuICAgIGNvbnN0IG5ld1dpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBpZiAobmV3WCA9PT0gc2F2ZWRYICYmIG5ld1kgPT09IHNhdmVkWSAmJiBuZXdXaWR0aCA9PT0gc2F2ZWRXaWR0aCAmJiBuZXdIZWlnaHQgPT09IHNhdmVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgIHRoaXMueCA9IG5ld1g7XG4gICAgICAgIHRoaXMueSA9IG5ld1k7XG4gICAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogbmV3V2lkdGgsIHBhcmVudEhlaWdodCAqIG5ld0hlaWdodCk7XG4gICAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHRoaXMud2lkdGggPSBzYXZlZFdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNhdmVkSGVpZ2h0O1xuICAgICAgICB0aGlzLnggPSBzYXZlZFg7XG4gICAgICAgIHRoaXMueSA9IHNhdmVkWTtcbiAgICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiBzYXZlZFdpZHRoLCBwYXJlbnRIZWlnaHQgKiBzYXZlZEhlaWdodCk7XG4gICAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcm1vdmUobmFtZSwgZXZlbnQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pbldpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IG1pbkhlaWdodCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRIZWlnaHQ7XG4gICAgY29uc3Qgcm91bmQgPSB4ID0+IE1hdGgucm91bmQoeCAqIDEwMDAwKSAvIDEwMDAwO1xuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgodGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgdHJhbnNmID0gKHgsIHkpID0+IFtyb3RhdGlvbk1hdHJpeFswXSAqIHggKyByb3RhdGlvbk1hdHJpeFsyXSAqIHksIHJvdGF0aW9uTWF0cml4WzFdICogeCArIHJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgY29uc3QgaW52Um90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCgzNjAgLSB0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCBpbnZUcmFuc2YgPSAoeCwgeSkgPT4gW2ludlJvdGF0aW9uTWF0cml4WzBdICogeCArIGludlJvdGF0aW9uTWF0cml4WzJdICogeSwgaW52Um90YXRpb25NYXRyaXhbMV0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBsZXQgZ2V0UG9pbnQ7XG4gICAgbGV0IGdldE9wcG9zaXRlO1xuICAgIGxldCBpc0RpYWdvbmFsID0gZmFsc2U7XG4gICAgbGV0IGlzSG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcInRvcExlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BNaWRkbGVcIjpcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3cgLyAyLCAwXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3cgLyAyLCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wUmlnaHRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCAwXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVSaWdodFwiOlxuICAgICAgICBpc0hvcml6b250YWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaCAvIDJdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaCAvIDJdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21SaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbU1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21MZWZ0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlkZGxlTGVmdFwiOlxuICAgICAgICBpc0hvcml6b250YWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgaCAvIDJdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaCAvIDJdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgcG9pbnQgPSBnZXRQb2ludChzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgY29uc3Qgb3Bwb3NpdGVQb2ludCA9IGdldE9wcG9zaXRlKHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBsZXQgdHJhbnNmT3Bwb3NpdGVQb2ludCA9IHRyYW5zZiguLi5vcHBvc2l0ZVBvaW50KTtcbiAgICBjb25zdCBvcHBvc2l0ZVggPSByb3VuZChzYXZlZFggKyB0cmFuc2ZPcHBvc2l0ZVBvaW50WzBdKTtcbiAgICBjb25zdCBvcHBvc2l0ZVkgPSByb3VuZChzYXZlZFkgKyB0cmFuc2ZPcHBvc2l0ZVBvaW50WzFdKTtcbiAgICBsZXQgcmF0aW9YID0gMTtcbiAgICBsZXQgcmF0aW9ZID0gMTtcbiAgICBsZXQgW2RlbHRhWCwgZGVsdGFZXSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oZXZlbnQubW92ZW1lbnRYLCBldmVudC5tb3ZlbWVudFkpO1xuICAgIFtkZWx0YVgsIGRlbHRhWV0gPSBpbnZUcmFuc2YoZGVsdGFYIC8gcGFyZW50V2lkdGgsIGRlbHRhWSAvIHBhcmVudEhlaWdodCk7XG4gICAgaWYgKGlzRGlhZ29uYWwpIHtcbiAgICAgIGNvbnN0IG9sZERpYWcgPSBNYXRoLmh5cG90KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICAgIHJhdGlvWCA9IHJhdGlvWSA9IE1hdGgubWF4KE1hdGgubWluKE1hdGguaHlwb3Qob3Bwb3NpdGVQb2ludFswXSAtIHBvaW50WzBdIC0gZGVsdGFYLCBvcHBvc2l0ZVBvaW50WzFdIC0gcG9pbnRbMV0gLSBkZWx0YVkpIC8gb2xkRGlhZywgMSAvIHNhdmVkV2lkdGgsIDEgLyBzYXZlZEhlaWdodCksIG1pbldpZHRoIC8gc2F2ZWRXaWR0aCwgbWluSGVpZ2h0IC8gc2F2ZWRIZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICByYXRpb1ggPSBNYXRoLm1heChtaW5XaWR0aCwgTWF0aC5taW4oMSwgTWF0aC5hYnMob3Bwb3NpdGVQb2ludFswXSAtIHBvaW50WzBdIC0gZGVsdGFYKSkpIC8gc2F2ZWRXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF0aW9ZID0gTWF0aC5tYXgobWluSGVpZ2h0LCBNYXRoLm1pbigxLCBNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzFdIC0gcG9pbnRbMV0gLSBkZWx0YVkpKSkgLyBzYXZlZEhlaWdodDtcbiAgICB9XG4gICAgY29uc3QgbmV3V2lkdGggPSByb3VuZChzYXZlZFdpZHRoICogcmF0aW9YKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSByb3VuZChzYXZlZEhlaWdodCAqIHJhdGlvWSk7XG4gICAgdHJhbnNmT3Bwb3NpdGVQb2ludCA9IHRyYW5zZiguLi5nZXRPcHBvc2l0ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSk7XG4gICAgY29uc3QgbmV3WCA9IG9wcG9zaXRlWCAtIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF07XG4gICAgY29uc3QgbmV3WSA9IG9wcG9zaXRlWSAtIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV07XG4gICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMueCA9IG5ld1g7XG4gICAgdGhpcy55ID0gbmV3WTtcbiAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiBuZXdXaWR0aCwgcGFyZW50SGVpZ2h0ICogbmV3SGVpZ2h0KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgYWx0VGV4dEZpbmlzaCgpIHtcbiAgICB0aGlzLiNhbHRUZXh0Py5maW5pc2goKTtcbiAgfVxuICBhc3luYyBhZGRFZGl0VG9vbGJhcigpIHtcbiAgICBpZiAodGhpcy5fZWRpdFRvb2xiYXIgfHwgdGhpcy4jaXNJbkVkaXRNb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWRpdFRvb2xiYXI7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyID0gbmV3IEVkaXRvclRvb2xiYXIodGhpcyk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuX2VkaXRUb29sYmFyLnJlbmRlcigpKTtcbiAgICBpZiAodGhpcy4jYWx0VGV4dCkge1xuICAgICAgYXdhaXQgdGhpcy5fZWRpdFRvb2xiYXIuYWRkQWx0VGV4dCh0aGlzLiNhbHRUZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRUb29sYmFyO1xuICB9XG4gIHJlbW92ZUVkaXRUb29sYmFyKCkge1xuICAgIGlmICghdGhpcy5fZWRpdFRvb2xiYXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIucmVtb3ZlKCk7XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIgPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHQ/LmRlc3Ryb3koKTtcbiAgfVxuICBhZGRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXJEaXYgPSB0aGlzLl9lZGl0VG9vbGJhcj8uZGl2O1xuICAgIGlmIChlZGl0VG9vbGJhckRpdikge1xuICAgICAgZWRpdFRvb2xiYXJEaXYuYmVmb3JlKGNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChjb250YWluZXIpO1xuICAgIH1cbiAgfVxuICBnZXRDbGllbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBhc3luYyBhZGRBbHRUZXh0QnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEFsdFRleHQuaW5pdGlhbGl6ZShBbm5vdGF0aW9uRWRpdG9yLl9sMTBuKTtcbiAgICB0aGlzLiNhbHRUZXh0ID0gbmV3IEFsdFRleHQodGhpcyk7XG4gICAgaWYgKHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0LmRhdGEgPSB0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5hZGRFZGl0VG9vbGJhcigpO1xuICB9XG4gIGdldCBhbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uZGF0YTtcbiAgfVxuICBzZXQgYWx0VGV4dERhdGEoZGF0YSkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0LmRhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBndWVzc2VkQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uZ3Vlc3NlZFRleHQ7XG4gIH1cbiAgYXN5bmMgc2V0R3Vlc3NlZEFsdFRleHQodGV4dCkge1xuICAgIGF3YWl0IHRoaXMuI2FsdFRleHQ/LnNldEd1ZXNzZWRUZXh0KHRleHQpO1xuICB9XG4gIHNlcmlhbGl6ZUFsdFRleHQoaXNGb3JDb3B5aW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/LnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpO1xuICB9XG4gIGhhc0FsdFRleHQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dC5pc0VtcHR5KCk7XG4gIH1cbiAgaGFzQWx0VGV4dERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/Lmhhc0RhdGEoKSA/PyBmYWxzZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtZWRpdG9yLXJvdGF0aW9uXCIsICgzNjAgLSB0aGlzLnJvdGF0aW9uKSAlIDM2MCk7XG4gICAgdGhpcy5kaXYuY2xhc3NOYW1lID0gdGhpcy5uYW1lO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHRoaXMuaWQpO1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gdGhpcy4jZGlzYWJsZWQgPyAtMSA6IDA7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUpIHtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgfVxuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgdGhpcy4jYWRkRm9jdXNMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKHRoaXMucGFyZW50Um90YXRpb24gJSAxODAgIT09IDApIHtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLm1heFdpZHRoID0gYCR7KDEwMCAqIHBhcmVudEhlaWdodCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgdGhpcy5kaXYuc3R5bGUubWF4SGVpZ2h0ID0gYCR7KDEwMCAqIHBhcmVudFdpZHRoIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgdGhpcy50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBiaW5kRXZlbnRzKHRoaXMsIHRoaXMuZGl2LCBbXCJwb2ludGVyZG93blwiXSk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RPblBvaW50ZXJFdmVudChldmVudCk7XG4gIH1cbiAgZ2V0IGlzU2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci5pc1NlbGVjdGVkKHRoaXMpO1xuICB9XG4gICNzZWxlY3RPblBvaW50ZXJFdmVudChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgIWlzTWFjIHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHRoaXMucGFyZW50LnRvZ2dsZVNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1NlbGVjdGVkXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnNldFVwRHJhZ1Nlc3Npb24oKTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QuYWRkKFwibW92aW5nXCIpO1xuICAgICAgdGhpcy4jcHJldkRyYWdYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIHRoaXMuI3ByZXZEcmFnWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBjb25zdCBwb2ludGVyTW92ZUNhbGxiYWNrID0gZSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjbGllbnRYOiB4LFxuICAgICAgICAgIGNsaWVudFk6IHlcbiAgICAgICAgfSA9IGU7XG4gICAgICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4IC0gdGhpcy4jcHJldkRyYWdYLCB5IC0gdGhpcy4jcHJldkRyYWdZKTtcbiAgICAgICAgdGhpcy4jcHJldkRyYWdYID0geDtcbiAgICAgICAgdGhpcy4jcHJldkRyYWdZID0geTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmRyYWdTZWxlY3RlZEVkaXRvcnModHgsIHR5KTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHBvaW50ZXJNb3ZlQ2FsbGJhY2ssIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LnJlbW92ZShcIm1vdmluZ1wiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuX3VpTWFuYWdlci5lbmREcmFnU2Vzc2lvbigpKSB7XG4gICAgICAgIHRoaXMuI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIG1vdmVJbkRPTSgpIHtcbiAgICBpZiAodGhpcy4jbW92ZUluRE9NVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpO1xuICAgIH1cbiAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMucGFyZW50Py5tb3ZlRWRpdG9ySW5ET00odGhpcyk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSkge1xuICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQodGhpcyk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBnZXRSZWN0KHR4LCB0eSwgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IHNoaWZ0WCA9IHR4IC8gc2NhbGU7XG4gICAgY29uc3Qgc2hpZnRZID0gdHkgLyBzY2FsZTtcbiAgICBjb25zdCB4ID0gdGhpcy54ICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IHkgPSB0aGlzLnkgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWSwgeCArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZICsgcGFnZVldO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgcGFnZVksIHggKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIHBhZ2VZLCB4IC0gc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVksIHggLSBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggKyBwYWdlWV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBnZXRSZWN0SW5DdXJyZW50Q29vcmRzKHJlY3QsIHBhZ2VIZWlnaHQpIHtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gcmVjdDtcbiAgICBjb25zdCB3aWR0aCA9IHgyIC0geDE7XG4gICAgY29uc3QgaGVpZ2h0ID0geTIgLSB5MTtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkyLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5MSwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkxLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTIsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKCkge31cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgdGhpcy4jaXNJbkVkaXRNb2RlID0gdHJ1ZTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgdGhpcy4jaXNJbkVkaXRNb2RlID0gZmFsc2U7XG4gIH1cbiAgaXNJbkVkaXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0luRWRpdE1vZGU7XG4gIH1cbiAgc2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZDtcbiAgfVxuICBuZWVkc1RvQmVSZWJ1aWx0KCkge1xuICAgIHJldHVybiB0aGlzLmRpdiAmJiAhdGhpcy5pc0F0dGFjaGVkVG9ET007XG4gIH1cbiAgI2FkZEZvY3VzTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLiNmb2N1c0FDIHx8ICF0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmb2N1c0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNmb2N1c0FDKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLmZvY3VzaW4uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuZm9jdXNvdXQuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICB0aGlzLiNhZGRGb2N1c0xpc3RlbmVycygpO1xuICB9XG4gIHJvdGF0ZShfYW5nbGUpIHt9XG4gIHNlcmlhbGl6ZURlbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmFubm90YXRpb25FbGVtZW50SWQsXG4gICAgICBkZWxldGVkOiB0cnVlLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHBvcHVwUmVmOiB0aGlzLl9pbml0aWFsRGF0YT8ucG9wdXBSZWYgfHwgXCJcIlxuICAgIH07XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIHVucmVhY2hhYmxlKFwiQW4gZWRpdG9yIG11c3QgYmUgc2VyaWFsaXphYmxlXCIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IGVkaXRvciA9IG5ldyB0aGlzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcih7XG4gICAgICBwYXJlbnQsXG4gICAgICBpZDogcGFyZW50LmdldE5leHRJZCgpLFxuICAgICAgdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZWRpdG9yLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcbiAgICBlZGl0b3IuI2FjY2Vzc2liaWxpdHlEYXRhID0gZGF0YS5hY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBlZGl0b3IuZ2V0UmVjdEluQ3VycmVudENvb3JkcyhkYXRhLnJlY3QsIHBhZ2VIZWlnaHQpO1xuICAgIGVkaXRvci54ID0geCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IueSA9IHkgLyBwYWdlSGVpZ2h0O1xuICAgIGVkaXRvci53aWR0aCA9IHdpZHRoIC8gcGFnZVdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgZ2V0IGhhc0JlZW5Nb2RpZmllZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgKHRoaXMuZGVsZXRlZCB8fCB0aGlzLnNlcmlhbGl6ZSgpICE9PSBudWxsKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jZm9jdXNBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNmb2N1c0FDID0gbnVsbDtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KTtcbiAgICAgIHRoaXMuI21vdmVJbkRPTVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB0aGlzLnJlbW92ZUVkaXRUb29sYmFyKCk7XG4gICAgaWYgKHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzKSB7XG4gICAgICBmb3IgKGNvbnN0IHRpbWVvdXQgb2YgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMudmFsdWVzKCkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYWtlUmVzaXphYmxlKCkge1xuICAgIGlmICh0aGlzLmlzUmVzaXphYmxlKSB7XG4gICAgICB0aGlzLiNjcmVhdGVSZXNpemVycygpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIGJpbmRFdmVudHModGhpcywgdGhpcy5kaXYsIFtcImtleWRvd25cIl0pO1xuICAgIH1cbiAgfVxuICBnZXQgdG9vbGJhclBvc2l0aW9uKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNSZXNpemFibGUgfHwgZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdiB8fCBldmVudC5rZXkgIT09IFwiRW50ZXJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0ge1xuICAgICAgc2F2ZWRYOiB0aGlzLngsXG4gICAgICBzYXZlZFk6IHRoaXMueSxcbiAgICAgIHNhdmVkV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBzYXZlZEhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy4jcmVzaXplcnNEaXYuY2hpbGRyZW47XG4gICAgaWYgKCF0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgdGhpcy4jYWxsUmVzaXplckRpdnMgPSBBcnJheS5mcm9tKGNoaWxkcmVuKTtcbiAgICAgIGNvbnN0IGJvdW5kUmVzaXplcktleWRvd24gPSB0aGlzLiNyZXNpemVyS2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgICAgY29uc3QgYm91bmRSZXNpemVyQmx1ciA9IHRoaXMuI3Jlc2l6ZXJCbHVyLmJpbmQodGhpcyk7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICAgIGZvciAoY29uc3QgZGl2IG9mIHRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkaXYuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIik7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic3BpbmJ1dHRvblwiKTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGJvdW5kUmVzaXplcktleWRvd24sIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBib3VuZFJlc2l6ZXJCbHVyLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI3Jlc2l6ZXJGb2N1cy5iaW5kKHRoaXMsIG5hbWUpLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFubm90YXRpb25FZGl0b3IuX2wxMG5SZXNpemVyW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLiNhbGxSZXNpemVyRGl2c1swXTtcbiAgICBsZXQgZmlyc3RQb3NpdGlvbiA9IDA7XG4gICAgZm9yIChjb25zdCBkaXYgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChkaXYgPT09IGZpcnN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZmlyc3RQb3NpdGlvbisrO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Rmlyc3RQb3NpdGlvbiA9ICgzNjAgLSB0aGlzLnJvdGF0aW9uICsgdGhpcy5wYXJlbnRSb3RhdGlvbikgJSAzNjAgLyA5MCAqICh0aGlzLiNhbGxSZXNpemVyRGl2cy5sZW5ndGggLyA0KTtcbiAgICBpZiAobmV4dEZpcnN0UG9zaXRpb24gIT09IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiA8IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaXJzdFBvc2l0aW9uIC0gbmV4dEZpcnN0UG9zaXRpb247IGkrKykge1xuICAgICAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmFwcGVuZCh0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiA+IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0Rmlyc3RQb3NpdGlvbiAtIGZpcnN0UG9zaXRpb247IGkrKykge1xuICAgICAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQuYmVmb3JlKHRoaXMuI3Jlc2l6ZXJzRGl2Lmxhc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgZGl2ID0gdGhpcy4jYWxsUmVzaXplckRpdnNbaSsrXTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRpdi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiKTtcbiAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFubm90YXRpb25FZGl0b3IuX2wxMG5SZXNpemVyW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2V0UmVzaXplclRhYkluZGV4KDApO1xuICAgIHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IHRydWU7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZC5mb2N1cyh7XG4gICAgICBmb2N1c1Zpc2libGU6IHRydWVcbiAgICB9KTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICB9XG4gICNyZXNpemVyS2V5ZG93bihldmVudCkge1xuICAgIEFubm90YXRpb25FZGl0b3IuX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgI3Jlc2l6ZXJCbHVyKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCAmJiBldmVudC5yZWxhdGVkVGFyZ2V0Py5wYXJlbnROb2RlICE9PSB0aGlzLiNyZXNpemVyc0Rpdikge1xuICAgICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgfVxuICB9XG4gICNyZXNpemVyRm9jdXMobmFtZSkge1xuICAgIHRoaXMuI2ZvY3VzZWRSZXNpemVyTmFtZSA9IHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA/IG5hbWUgOiBcIlwiO1xuICB9XG4gICNzZXRSZXNpemVyVGFiSW5kZXgodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZGl2IG9mIHRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICBkaXYudGFiSW5kZXggPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgX3Jlc2l6ZVdpdGhLZXlib2FyZCh4LCB5KSB7XG4gICAgaWYgKCF0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVzaXplclBvaW50ZXJtb3ZlKHRoaXMuI2ZvY3VzZWRSZXNpemVyTmFtZSwge1xuICAgICAgbW92ZW1lbnRYOiB4LFxuICAgICAgbW92ZW1lbnRZOiB5XG4gICAgfSk7XG4gIH1cbiAgI3N0b3BSZXNpemluZygpIHtcbiAgICB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPSBmYWxzZTtcbiAgICB0aGlzLiNzZXRSZXNpemVyVGFiSW5kZXgoLTEpO1xuICAgIGlmICh0aGlzLiNzYXZlZERpbWVuc2lvbnMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2F2ZWRYLFxuICAgICAgICBzYXZlZFksXG4gICAgICAgIHNhdmVkV2lkdGgsXG4gICAgICAgIHNhdmVkSGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jc2F2ZWREaW1lbnNpb25zO1xuICAgICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soc2F2ZWRYLCBzYXZlZFksIHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IG51bGw7XG4gICAgfVxuICB9XG4gIF9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQoKSB7XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgdGhpcy5tYWtlUmVzaXphYmxlKCk7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICBpZiAoIXRoaXMuX2VkaXRUb29sYmFyKSB7XG4gICAgICB0aGlzLmFkZEVkaXRUb29sYmFyKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRpdj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRFZGl0b3JcIikpIHtcbiAgICAgICAgICB0aGlzLl9lZGl0VG9vbGJhcj8uc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXI/LnNob3coKTtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGVBbHRUZXh0QmFkZ2UoZmFsc2UpO1xuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2Py5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKHRoaXMuZGl2Py5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllci5kaXYuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXI/LmhpZGUoKTtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGVBbHRUZXh0QmFkZ2UodHJ1ZSk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7fVxuICBkaXNhYmxlRWRpdGluZygpIHt9XG4gIGVuYWJsZUVkaXRpbmcoKSB7fVxuICBlbnRlckluRWRpdE1vZGUoKSB7fVxuICBnZXRJbWFnZUZvckFsdFRleHQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIGdldCBpc0VkaXRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRWRpdGluZztcbiAgfVxuICBzZXQgaXNFZGl0aW5nKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNFZGl0aW5nID0gdmFsdWU7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHNldEFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLiNrZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgc3R5bGUuYXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpbztcbiAgICBzdHlsZS5oZWlnaHQgPSBcImF1dG9cIjtcbiAgfVxuICBzdGF0aWMgZ2V0IE1JTl9TSVpFKCkge1xuICAgIHJldHVybiAxNjtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUluaXRpYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IFwiYWRkZWRcIlxuICAgIH07XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfcmVwb3J0VGVsZW1ldHJ5KGRhdGEsIG11c3RXYWl0ID0gZmFsc2UpIHtcbiAgICBpZiAobXVzdFdhaXQpIHtcbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzIHx8PSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGlvblxuICAgICAgfSA9IGRhdGE7XG4gICAgICBsZXQgdGltZW91dCA9IHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLmdldChhY3Rpb24pO1xuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoZGF0YSk7XG4gICAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLmRlbGV0ZShhY3Rpb24pO1xuICAgICAgICBpZiAodGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwgQW5ub3RhdGlvbkVkaXRvci5fdGVsZW1ldHJ5VGltZW91dCk7XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5zZXQoYWN0aW9uLCB0aW1lb3V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS50eXBlIHx8PSB0aGlzLmVkaXRvclR5cGU7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLl9ldmVudEJ1cy5kaXNwYXRjaChcInJlcG9ydHRlbGVtZXRyeVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBkZXRhaWxzOiB7XG4gICAgICAgIHR5cGU6IFwiZWRpdGluZ1wiLFxuICAgICAgICBkYXRhXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2hvdyh2aXNpYmxlID0gdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCAhdmlzaWJsZSk7XG4gICAgdGhpcy5faXNWaXNpYmxlID0gdmlzaWJsZTtcbiAgfVxuICBlbmFibGUoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmRpdi50YWJJbmRleCA9IDA7XG4gICAgfVxuICAgIHRoaXMuI2Rpc2FibGVkID0gZmFsc2U7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgfVxuICAgIHRoaXMuI2Rpc2FibGVkID0gdHJ1ZTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBhbm5vdGF0aW9uLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLmFubm90YXRpb25Db250ZW50XCIpO1xuICAgIGlmICghY29udGVudCkge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uQ29udGVudFwiLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgYW5ub3RhdGlvbi5jb250YWluZXIucHJlcGVuZChjb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRlbnQubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRlbnQ7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25Db250ZW50XCIsIHRoaXMuZWRpdG9yVHlwZSk7XG4gICAgICBjYW52YXMuYmVmb3JlKGNvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICByZXNldEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBmaXJzdENoaWxkXG4gICAgfSA9IGFubm90YXRpb24uY29udGFpbmVyO1xuICAgIGlmIChmaXJzdENoaWxkPy5ub2RlTmFtZSA9PT0gXCJESVZcIiAmJiBmaXJzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcImFubm90YXRpb25Db250ZW50XCIpKSB7XG4gICAgICBmaXJzdENoaWxkLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgRmFrZUVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcihwYXJhbXMpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IHBhcmFtcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHRoaXMuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvc2hhcmVkL211cm11cmhhc2gzLmpzXG5jb25zdCBTRUVEID0gMHhjM2QyZTFmMDtcbmNvbnN0IE1BU0tfSElHSCA9IDB4ZmZmZjAwMDA7XG5jb25zdCBNQVNLX0xPVyA9IDB4ZmZmZjtcbmNsYXNzIE11cm11ckhhc2gzXzY0IHtcbiAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgIHRoaXMuaDEgPSBzZWVkID8gc2VlZCAmIDB4ZmZmZmZmZmYgOiBTRUVEO1xuICAgIHRoaXMuaDIgPSBzZWVkID8gc2VlZCAmIDB4ZmZmZmZmZmYgOiBTRUVEO1xuICB9XG4gIHVwZGF0ZShpbnB1dCkge1xuICAgIGxldCBkYXRhLCBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCAqIDIpO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlIDw9IDB4ZmYpIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlID4+PiA4O1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhpbnB1dCkpIHtcbiAgICAgIGRhdGEgPSBpbnB1dC5zbGljZSgpO1xuICAgICAgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgZm9ybWF0LCBtdXN0IGJlIGEgc3RyaW5nIG9yIFR5cGVkQXJyYXkuXCIpO1xuICAgIH1cbiAgICBjb25zdCBibG9ja0NvdW50cyA9IGxlbmd0aCA+PiAyO1xuICAgIGNvbnN0IHRhaWxMZW5ndGggPSBsZW5ndGggLSBibG9ja0NvdW50cyAqIDQ7XG4gICAgY29uc3QgZGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgMCwgYmxvY2tDb3VudHMpO1xuICAgIGxldCBrMSA9IDAsXG4gICAgICBrMiA9IDA7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBjb25zdCBDMSA9IDB4Y2M5ZTJkNTEsXG4gICAgICBDMiA9IDB4MWI4NzM1OTM7XG4gICAgY29uc3QgQzFfTE9XID0gQzEgJiBNQVNLX0xPVyxcbiAgICAgIEMyX0xPVyA9IEMyICYgTUFTS19MT1c7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja0NvdW50czsgaSsrKSB7XG4gICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgazEgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSBoMSA8PCAxMyB8IGgxID4+PiAxOTtcbiAgICAgICAgaDEgPSBoMSAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgazIgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMiA9IGsyICogQzEgJiBNQVNLX0hJR0ggfCBrMiAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMiA9IGsyIDw8IDE1IHwgazIgPj4+IDE3O1xuICAgICAgICBrMiA9IGsyICogQzIgJiBNQVNLX0hJR0ggfCBrMiAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMiBePSBrMjtcbiAgICAgICAgaDIgPSBoMiA8PCAxMyB8IGgyID4+PiAxOTtcbiAgICAgICAgaDIgPSBoMiAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfVxuICAgIH1cbiAgICBrMSA9IDA7XG4gICAgc3dpdGNoICh0YWlsTGVuZ3RoKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMl0gPDwgMTY7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMV0gPDwgODtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDRdO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBpZiAoYmxvY2tDb3VudHMgJiAxKSB7XG4gICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaDIgXj0gazE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5oMSA9IGgxO1xuICAgIHRoaXMuaDIgPSBoMjtcbiAgfVxuICBoZXhkaWdlc3QoKSB7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHhlZDU1OGNjZCAmIE1BU0tfSElHSCB8IGgxICogMHg4Y2NkICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4ZmY1MWFmZDcgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YWZkN2VkNTUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHgxYTg1ZWM1MyAmIE1BU0tfSElHSCB8IGgxICogMHhlYzUzICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4YzRjZWI5ZmUgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YjlmZTFhODUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICByZXR1cm4gKGgxID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpICsgKGgyID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2Fubm90YXRpb25fc3RvcmFnZS5qc1xuXG5cblxuY29uc3QgU2VyaWFsaXphYmxlRW1wdHkgPSBPYmplY3QuZnJlZXplKHtcbiAgbWFwOiBudWxsLFxuICBoYXNoOiBcIlwiLFxuICB0cmFuc2ZlcjogdW5kZWZpbmVkXG59KTtcbmNsYXNzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI21vZGlmaWVkID0gZmFsc2U7XG4gICNtb2RpZmllZElkcyA9IG51bGw7XG4gICNzdG9yYWdlID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9uU2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25SZXNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9IG51bGw7XG4gIH1cbiAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRWYWx1ZSwgdmFsdWUpO1xuICB9XG4gIGdldFJhd1ZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICB9XG4gIHJlbW92ZShrZXkpIHtcbiAgICB0aGlzLiNzdG9yYWdlLmRlbGV0ZShrZXkpO1xuICAgIGlmICh0aGlzLiNzdG9yYWdlLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy4jc3RvcmFnZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc2V0VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgbGV0IG1vZGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGNvbnN0IFtlbnRyeSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKG9ialtlbnRyeV0gIT09IHZhbCkge1xuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBvYmpbZW50cnldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3N0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI3NldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IgJiYgdHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKHZhbHVlLmNvbnN0cnVjdG9yLl90eXBlKTtcbiAgICB9XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmhhcyhrZXkpO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplID4gMCA/IG9iamVjdEZyb21NYXAodGhpcy4jc3RvcmFnZSkgOiBudWxsO1xuICB9XG4gIHNldEFsbChvYmopIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgICAgdGhpcy5zZXRWYWx1ZShrZXksIHZhbCk7XG4gICAgfVxuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLnNpemU7XG4gIH1cbiAgI3NldE1vZGlmaWVkKCkge1xuICAgIGlmICghdGhpcy4jbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI21vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vblNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0TW9kaWZpZWQoKSB7XG4gICAgaWYgKHRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVzZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25SZXNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICByZXR1cm4gbmV3IFByaW50QW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKSxcbiAgICAgIGhhc2ggPSBuZXcgTXVybXVySGFzaDNfNjQoKSxcbiAgICAgIHRyYW5zZmVyID0gW107XG4gICAgY29uc3QgY29udGV4dCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGhhc0JpdG1hcCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLiNzdG9yYWdlKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gdmFsIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvciA/IHZhbC5zZXJpYWxpemUoZmFsc2UsIGNvbnRleHQpIDogdmFsO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHNlcmlhbGl6ZWQpO1xuICAgICAgICBoYXNoLnVwZGF0ZShgJHtrZXl9OiR7SlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplZCl9YCk7XG4gICAgICAgIGhhc0JpdG1hcCB8fD0gISFzZXJpYWxpemVkLmJpdG1hcDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0JpdG1hcCkge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBtYXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmJpdG1hcCkge1xuICAgICAgICAgIHRyYW5zZmVyLnB1c2godmFsdWUuYml0bWFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwLnNpemUgPiAwID8ge1xuICAgICAgbWFwLFxuICAgICAgaGFzaDogaGFzaC5oZXhkaWdlc3QoKSxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA6IFNlcmlhbGl6YWJsZUVtcHR5O1xuICB9XG4gIGdldCBlZGl0b3JTdGF0cygpIHtcbiAgICBsZXQgc3RhdHMgPSBudWxsO1xuICAgIGNvbnN0IHR5cGVUb0VkaXRvciA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3JTdGF0cyA9IHZhbHVlLnRlbGVtZXRyeUZpbmFsRGF0YTtcbiAgICAgIGlmICghZWRpdG9yU3RhdHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBlZGl0b3JTdGF0cztcbiAgICAgIGlmICghdHlwZVRvRWRpdG9yLmhhcyh0eXBlKSkge1xuICAgICAgICB0eXBlVG9FZGl0b3Iuc2V0KHR5cGUsIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgICAgc3RhdHMgfHw9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBjb25zdCBtYXAgPSBzdGF0c1t0eXBlXSB8fD0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGVkaXRvclN0YXRzKSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcInR5cGVcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb3VudGVycyA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFjb3VudGVycykge1xuICAgICAgICAgIGNvdW50ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCBjb3VudGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY291bnQgPSBjb3VudGVycy5nZXQodmFsKSA/PyAwO1xuICAgICAgICBjb3VudGVycy5zZXQodmFsLCBjb3VudCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBlZGl0b3JdIG9mIHR5cGVUb0VkaXRvcikge1xuICAgICAgc3RhdHNbdHlwZV0gPSBlZGl0b3IuY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShzdGF0c1t0eXBlXSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0cztcbiAgfVxuICByZXNldE1vZGlmaWVkSWRzKCkge1xuICAgIHRoaXMuI21vZGlmaWVkSWRzID0gbnVsbDtcbiAgfVxuICBnZXQgbW9kaWZpZWRJZHMoKSB7XG4gICAgaWYgKHRoaXMuI21vZGlmaWVkSWRzKSB7XG4gICAgICByZXR1cm4gdGhpcy4jbW9kaWZpZWRJZHM7XG4gICAgfVxuICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy4jc3RvcmFnZS52YWx1ZXMoKSkge1xuICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yKSB8fCAhdmFsdWUuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCAhdmFsdWUuc2VyaWFsaXplKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZHMucHVzaCh2YWx1ZS5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI21vZGlmaWVkSWRzID0ge1xuICAgICAgaWRzOiBuZXcgU2V0KGlkcyksXG4gICAgICBoYXNoOiBpZHMuam9pbihcIixcIilcbiAgICB9O1xuICB9XG59XG5jbGFzcyBQcmludEFubm90YXRpb25TdG9yYWdlIGV4dGVuZHMgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICAjc2VyaWFsaXphYmxlO1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlclxuICAgIH0gPSBwYXJlbnQuc2VyaWFsaXphYmxlO1xuICAgIGNvbnN0IGNsb25lID0gc3RydWN0dXJlZENsb25lKG1hcCwgdHJhbnNmZXIgPyB7XG4gICAgICB0cmFuc2ZlclxuICAgIH0gOiBudWxsKTtcbiAgICB0aGlzLiNzZXJpYWxpemFibGUgPSB7XG4gICAgICBtYXA6IGNsb25lLFxuICAgICAgaGFzaCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfTtcbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJTaG91bGQgbm90IGNhbGwgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZS5wcmludFwiKTtcbiAgfVxuICBnZXQgc2VyaWFsaXphYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNzZXJpYWxpemFibGU7XG4gIH1cbiAgZ2V0IG1vZGlmaWVkSWRzKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJtb2RpZmllZElkc1wiLCB7XG4gICAgICBpZHM6IG5ldyBTZXQoKSxcbiAgICAgIGhhc2g6IFwiXCJcbiAgICB9KTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9mb250X2xvYWRlci5qc1xuXG5jbGFzcyBGb250TG9hZGVyIHtcbiAgI3N5c3RlbUZvbnRzID0gbmV3IFNldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgc3R5bGVFbGVtZW50ID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMubG9hZFRlc3RGb250SWQgPSAwO1xuICB9XG4gIGFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIHJlbW92ZU5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICghdGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmQodGhpcy5zdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gdGhpcy5zdHlsZUVsZW1lbnQuc2hlZXQ7XG4gICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG5hdGl2ZUZvbnRGYWNlIG9mIHRoaXMubmF0aXZlRm9udEZhY2VzKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIH1cbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3N5c3RlbUZvbnRzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZFN5c3RlbUZvbnQoe1xuICAgIHN5c3RlbUZvbnRJbmZvOiBpbmZvLFxuICAgIF9pbnNwZWN0Rm9udFxuICB9KSB7XG4gICAgaWYgKCFpbmZvIHx8IHRoaXMuI3N5c3RlbUZvbnRzLmhhcyhpbmZvLmxvYWRlZE5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFzc2VydCghdGhpcy5kaXNhYmxlRm9udEZhY2UsIFwibG9hZFN5c3RlbUZvbnQgc2hvdWxkbid0IGJlIGNhbGxlZCB3aGVuIGBkaXNhYmxlRm9udEZhY2VgIGlzIHNldC5cIik7XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsb2FkZWROYW1lLFxuICAgICAgICBzcmMsXG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gaW5mbztcbiAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGxvYWRlZE5hbWUsIHNyYywgc3R5bGUpO1xuICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShmb250RmFjZSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmb250RmFjZS5sb2FkKCk7XG4gICAgICAgIHRoaXMuI3N5c3RlbUZvbnRzLmFkZChsb2FkZWROYW1lKTtcbiAgICAgICAgX2luc3BlY3RGb250Py4oaW5mbyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgd2FybihgQ2Fubm90IGxvYWQgc3lzdGVtIGZvbnQ6ICR7aW5mby5iYXNlRm9udE5hbWV9LCBpbnN0YWxsaW5nIGl0IGNvdWxkIGhlbHAgdG8gaW1wcm92ZSBQREYgcmVuZGVyaW5nLmApO1xuICAgICAgICB0aGlzLnJlbW92ZU5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWQ6IGxvYWRTeXN0ZW1Gb250IHdpdGhvdXQgdGhlIEZvbnQgTG9hZGluZyBBUEkuXCIpO1xuICB9XG4gIGFzeW5jIGJpbmQoZm9udCkge1xuICAgIGlmIChmb250LmF0dGFjaGVkIHx8IGZvbnQubWlzc2luZ0ZpbGUgJiYgIWZvbnQuc3lzdGVtRm9udEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9udC5hdHRhY2hlZCA9IHRydWU7XG4gICAgaWYgKGZvbnQuc3lzdGVtRm9udEluZm8pIHtcbiAgICAgIGF3YWl0IHRoaXMubG9hZFN5c3RlbUZvbnQoZm9udCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUZvbnRGYWNlID0gZm9udC5jcmVhdGVOYXRpdmVGb250RmFjZSgpO1xuICAgICAgaWYgKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG5hdGl2ZUZvbnRGYWNlLmxvYWRlZDtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9hZCBmb250ICcke25hdGl2ZUZvbnRGYWNlLmZhbWlseX0nOiAnJHtleH0nLmApO1xuICAgICAgICAgIGZvbnQuZGlzYWJsZUZvbnRGYWNlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0gZm9udC5jcmVhdGVGb250RmFjZVJ1bGUoKTtcbiAgICBpZiAocnVsZSkge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgICAgaWYgKHRoaXMuaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9xdWV1ZUxvYWRpbmdDYWxsYmFjayhyZXNvbHZlKTtcbiAgICAgICAgdGhpcy5fcHJlcGFyZUZvbnRMb2FkRXZlbnQoZm9udCwgcmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQoKSB7XG4gICAgY29uc3QgaGFzRm9udHMgPSAhIXRoaXMuX2RvY3VtZW50Py5mb250cztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZFwiLCBoYXNGb250cyk7XG4gIH1cbiAgZ2V0IGlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKCkge1xuICAgIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3I/LnVzZXJBZ2VudCA9PT0gXCJzdHJpbmdcIiAmJiAvTW96aWxsYVxcLzUuMC4qP3J2OlxcZCsuKj8gR2Vja28vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZFwiLCBzdXBwb3J0ZWQpO1xuICB9XG4gIF9xdWV1ZUxvYWRpbmdDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlUmVxdWVzdCgpIHtcbiAgICAgIGFzc2VydCghcmVxdWVzdC5kb25lLCBcImNvbXBsZXRlUmVxdWVzdCgpIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UuXCIpO1xuICAgICAgcmVxdWVzdC5kb25lID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChsb2FkaW5nUmVxdWVzdHMubGVuZ3RoID4gMCAmJiBsb2FkaW5nUmVxdWVzdHNbMF0uZG9uZSkge1xuICAgICAgICBjb25zdCBvdGhlclJlcXVlc3QgPSBsb2FkaW5nUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgc2V0VGltZW91dChvdGhlclJlcXVlc3QuY2FsbGJhY2ssIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsb2FkaW5nUmVxdWVzdHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBjb21wbGV0ZTogY29tcGxldGVSZXF1ZXN0LFxuICAgICAgY2FsbGJhY2tcbiAgICB9O1xuICAgIGxvYWRpbmdSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIGdldCBfbG9hZFRlc3RGb250KCkge1xuICAgIGNvbnN0IHRlc3RGb250ID0gYXRvYihcIlQxUlVUd0FMQUlBQUF3QXdRMFpHSURIdFpnNEFBQU9ZQUFBQWdVWkdWRTFsa3pad0FBQUVIQUFBQUJ4SFJFVkdBQlFBXCIgKyBcIkZRQUFCRGdBQUFBZVQxTXZNbFlOWXdrQUFBRWdBQUFBWUdOdFlYQUJEUUxVQUFBQ05BQUFBVUpvWldGay94VkZEUUFBXCIgKyBcIkFMd0FBQUEyYUdobFlRZGtBK29BQUFEMEFBQUFKR2h0ZEhnRDZBQUFBQUFFV0FBQUFBWnRZWGh3QUFKUUFBQUFBUmdBXCIgKyBcIkFBQUdibUZ0WlZqbWRINEFBQUdBQUFBQXNYQnZjM1QvaGdBekFBQURlQUFBQUNBQUFRQUFBQUVBQUxaUkZzUmZEenoxXCIgKyBcIkFBc0Q2QUFBQUFET0JPVExBQUFBQU00S0hEd0FBQUFBQStnRElRQUFBQWdBQWdBQUFBQUFBQUFCQUFBRElRQUFBRm9EXCIgKyBcIjZBQUFBQUFENkFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQVVBQUFBZ0FBQUFRRDZBSDBBQVVBQUFLS0Fyd0FBQUNNXCIgKyBcIkFvb0N2QUFBQWVBQU1RRUNBQUFDQUFZSkFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBRkJtUldRQXdBQXVBQzREXCIgKyBcIklQODRBRm9ESVFBQUFBQUFBUUFBQUFBQUFBQUFBQ0FBSUFBQkFBQUFEZ0N1QUFFQUFBQUFBQUFBQVFBQUFBRUFBQUFBXCIgKyBcIkFBRUFBUUFBQUFFQUFBQUFBQUlBQVFBQUFBRUFBQUFBQUFNQUFRQUFBQUVBQUFBQUFBUUFBUUFBQUFFQUFBQUFBQVVBXCIgKyBcIkFRQUFBQUVBQUFBQUFBWUFBUUFBQUFNQUFRUUpBQUFBQWdBQkFBTUFBUVFKQUFFQUFnQUJBQU1BQVFRSkFBSUFBZ0FCXCIgKyBcIkFBTUFBUVFKQUFNQUFnQUJBQU1BQVFRSkFBUUFBZ0FCQUFNQUFRUUpBQVVBQWdBQkFBTUFBUVFKQUFZQUFnQUJXQUJZXCIgKyBcIkFBQUFBQUFBQXdBQUFBTUFBQUFjQUFFQUFBQUFBRHdBQXdBQkFBQUFIQUFFQUNBQUFBQUVBQVFBQVFBQUFDNy8vd0FBXCIgKyBcIkFDNy8vLy9UQUFFQUFBQUFBQUFCQmdBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1BQUFBQUFBRC9nd0F5QUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUJBQVFFQUFFQkFRSllBQUVCQVNINER3RDRHd0hFQXZnY0EvZ1hCSXdNQVl1TCtuejV0UVhrRDVqM0NCTG5FUUFDXCIgKyBcIkFRRUJJVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWUFBQUJBUUFBRHdBQ0FRRUVFL3QzXCIgKyBcIkRvdjZmQUg2ZkFUK2ZQcDgrbndIRG9zTUN2bTFDdm0xREF6NmZCUUFBQUFBQUFBQkFBQUFBTW1KYnpFQUFBQUF6Z1RqXCIgKyBcIkZRQUFBQURPQk9RcEFBRUFBQUFBQUFBQURBQVVBQVFBQUFBQkFBQUFBZ0FCQUFBQUFBQUFBQUFENkFBQUFBQUFBQT09XCIpO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfbG9hZFRlc3RGb250XCIsIHRlc3RGb250KTtcbiAgfVxuICBfcHJlcGFyZUZvbnRMb2FkRXZlbnQoZm9udCwgcmVxdWVzdCkge1xuICAgIGZ1bmN0aW9uIGludDMyKGRhdGEsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGRhdGEuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDggfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMykgJiAweGZmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGxpY2VTdHJpbmcocywgb2Zmc2V0LCByZW1vdmUsIGluc2VydCkge1xuICAgICAgY29uc3QgY2h1bmsxID0gcy5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGNodW5rMiA9IHMuc3Vic3RyaW5nKG9mZnNldCArIHJlbW92ZSk7XG4gICAgICByZXR1cm4gY2h1bmsxICsgaW5zZXJ0ICsgY2h1bmsyO1xuICAgIH1cbiAgICBsZXQgaSwgaWk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgbGV0IGNhbGxlZCA9IDA7XG4gICAgZnVuY3Rpb24gaXNGb250UmVhZHkobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICgrK2NhbGxlZCA+IDMwKSB7XG4gICAgICAgIHdhcm4oXCJMb2FkIHRlc3QgZm9udCBuZXZlciBsb2FkZWQuXCIpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguZm9udCA9IFwiMzBweCBcIiArIG5hbWU7XG4gICAgICBjdHguZmlsbFRleHQoXCIuXCIsIDAsIDIwKTtcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICBpZiAoaW1hZ2VEYXRhLmRhdGFbM10gPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoaXNGb250UmVhZHkuYmluZChudWxsLCBuYW1lLCBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkVGVzdEZvbnRJZCA9IGBsdCR7RGF0ZS5ub3coKX0ke3RoaXMubG9hZFRlc3RGb250SWQrK31gO1xuICAgIGxldCBkYXRhID0gdGhpcy5fbG9hZFRlc3RGb250O1xuICAgIGNvbnN0IENPTU1FTlRfT0ZGU0VUID0gOTc2O1xuICAgIGRhdGEgPSBzcGxpY2VTdHJpbmcoZGF0YSwgQ09NTUVOVF9PRkZTRVQsIGxvYWRUZXN0Rm9udElkLmxlbmd0aCwgbG9hZFRlc3RGb250SWQpO1xuICAgIGNvbnN0IENGRl9DSEVDS1NVTV9PRkZTRVQgPSAxNjtcbiAgICBjb25zdCBYWFhYX1ZBTFVFID0gMHg1ODU4NTg1ODtcbiAgICBsZXQgY2hlY2tzdW0gPSBpbnQzMihkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUKTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IGxvYWRUZXN0Rm9udElkLmxlbmd0aCAtIDM7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICBjaGVja3N1bSA9IGNoZWNrc3VtIC0gWFhYWF9WQUxVRSArIGludDMyKGxvYWRUZXN0Rm9udElkLCBpKSB8IDA7XG4gICAgfVxuICAgIGlmIChpIDwgbG9hZFRlc3RGb250SWQubGVuZ3RoKSB7XG4gICAgICBjaGVja3N1bSA9IGNoZWNrc3VtIC0gWFhYWF9WQUxVRSArIGludDMyKGxvYWRUZXN0Rm9udElkICsgXCJYWFhcIiwgaSkgfCAwO1xuICAgIH1cbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQsIDQsIHN0cmluZzMyKGNoZWNrc3VtKSk7XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOmZvbnQvb3BlbnR5cGU7YmFzZTY0LCR7YnRvYShkYXRhKX0pO2A7XG4gICAgY29uc3QgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7bG9hZFRlc3RGb250SWR9XCI7c3JjOiR7dXJsfX1gO1xuICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICBjb25zdCBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gXCIxMHB4XCI7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi5zdHlsZS50b3AgPSBkaXYuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIFtmb250LmxvYWRlZE5hbWUsIGxvYWRUZXN0Rm9udElkXSkge1xuICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiSGlcIjtcbiAgICAgIHNwYW4uc3R5bGUuZm9udEZhbWlseSA9IG5hbWU7XG4gICAgICBkaXYuYXBwZW5kKHNwYW4pO1xuICAgIH1cbiAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIGlzRm9udFJlYWR5KGxvYWRUZXN0Rm9udElkLCAoKSA9PiB7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICByZXF1ZXN0LmNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEZvbnRGYWNlT2JqZWN0IHtcbiAgY29uc3RydWN0b3IodHJhbnNsYXRlZERhdGEsIHtcbiAgICBkaXNhYmxlRm9udEZhY2UgPSBmYWxzZSxcbiAgICBpbnNwZWN0Rm9udCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuY29tcGlsZWRHbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAoY29uc3QgaSBpbiB0cmFuc2xhdGVkRGF0YSkge1xuICAgICAgdGhpc1tpXSA9IHRyYW5zbGF0ZWREYXRhW2ldO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVGb250RmFjZSA9IGRpc2FibGVGb250RmFjZSA9PT0gdHJ1ZTtcbiAgICB0aGlzLl9pbnNwZWN0Rm9udCA9IGluc3BlY3RGb250O1xuICB9XG4gIGNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCkge1xuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5hdGl2ZUZvbnRGYWNlO1xuICAgIGlmICghdGhpcy5jc3NGb250SW5mbykge1xuICAgICAgbmF0aXZlRm9udEZhY2UgPSBuZXcgRm9udEZhY2UodGhpcy5sb2FkZWROYW1lLCB0aGlzLmRhdGEsIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY3NzID0ge1xuICAgICAgICB3ZWlnaHQ6IHRoaXMuY3NzRm9udEluZm8uZm9udFdlaWdodFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlKSB7XG4gICAgICAgIGNzcy5zdHlsZSA9IGBvYmxpcXVlICR7dGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZX1kZWdgO1xuICAgICAgfVxuICAgICAgbmF0aXZlRm9udEZhY2UgPSBuZXcgRm9udEZhY2UodGhpcy5jc3NGb250SW5mby5mb250RmFtaWx5LCB0aGlzLmRhdGEsIGNzcyk7XG4gICAgfVxuICAgIHRoaXMuX2luc3BlY3RGb250Py4odGhpcyk7XG4gICAgcmV0dXJuIG5hdGl2ZUZvbnRGYWNlO1xuICB9XG4gIGNyZWF0ZUZvbnRGYWNlUnVsZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YToke3RoaXMubWltZXR5cGV9O2Jhc2U2NCwke3RvQmFzZTY0VXRpbCh0aGlzLmRhdGEpfSk7YDtcbiAgICBsZXQgcnVsZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke3RoaXMubG9hZGVkTmFtZX1cIjtzcmM6JHt1cmx9fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjc3MgPSBgZm9udC13ZWlnaHQ6ICR7dGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0fTtgO1xuICAgICAgaWYgKHRoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGUpIHtcbiAgICAgICAgY3NzICs9IGBmb250LXN0eWxlOiBvYmxpcXVlICR7dGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZX1kZWc7YDtcbiAgICAgIH1cbiAgICAgIHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke3RoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseX1cIjske2Nzc31zcmM6JHt1cmx9fWA7XG4gICAgfVxuICAgIHRoaXMuX2luc3BlY3RGb250Py4odGhpcywgdXJsKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICBnZXRQYXRoR2VuZXJhdG9yKG9ianMsIGNoYXJhY3Rlcikge1xuICAgIGlmICh0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXTtcbiAgICB9XG4gICAgbGV0IGNtZHM7XG4gICAgdHJ5IHtcbiAgICAgIGNtZHMgPSBvYmpzLmdldCh0aGlzLmxvYWRlZE5hbWUgKyBcIl9wYXRoX1wiICsgY2hhcmFjdGVyKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgZ2V0UGF0aEdlbmVyYXRvciAtIGlnbm9yaW5nIGNoYXJhY3RlcjogXCIke2V4fVwiLmApO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY21kcykgfHwgY21kcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBmdW5jdGlvbiAoYywgc2l6ZSkge307XG4gICAgfVxuICAgIGNvbnN0IGNvbW1hbmRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY21kcy5sZW5ndGg7IGkgPCBpaTspIHtcbiAgICAgIHN3aXRjaCAoY21kc1tpKytdKSB7XG4gICAgICAgIGNhc2UgRm9udFJlbmRlck9wcy5CRVpJRVJfQ1VSVkVfVE86XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgW2EsIGIsIGMsIGQsIGUsIGZdID0gY21kcy5zbGljZShpLCBpICsgNik7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKGN0eCA9PiBjdHguYmV6aWVyQ3VydmVUbyhhLCBiLCBjLCBkLCBlLCBmKSk7XG4gICAgICAgICAgICBpICs9IDY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZvbnRSZW5kZXJPcHMuTU9WRV9UTzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBbYSwgYl0gPSBjbWRzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goY3R4ID0+IGN0eC5tb3ZlVG8oYSwgYikpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb250UmVuZGVyT3BzLkxJTkVfVE86XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgW2EsIGJdID0gY21kcy5zbGljZShpLCBpICsgMik7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKGN0eCA9PiBjdHgubGluZVRvKGEsIGIpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRm9udFJlbmRlck9wcy5RVUFEUkFUSUNfQ1VSVkVfVE86XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgW2EsIGIsIGMsIGRdID0gY21kcy5zbGljZShpLCBpICsgNCk7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKGN0eCA9PiBjdHgucXVhZHJhdGljQ3VydmVUbyhhLCBiLCBjLCBkKSk7XG4gICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZvbnRSZW5kZXJPcHMuUkVTVE9SRTpcbiAgICAgICAgICBjb21tYW5kcy5wdXNoKGN0eCA9PiBjdHgucmVzdG9yZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb250UmVuZGVyT3BzLlNBVkU6XG4gICAgICAgICAgY29tbWFuZHMucHVzaChjdHggPT4gY3R4LnNhdmUoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRm9udFJlbmRlck9wcy5TQ0FMRTpcbiAgICAgICAgICBhc3NlcnQoY29tbWFuZHMubGVuZ3RoID09PSAyLCBcIlNjYWxlIGNvbW1hbmQgaXMgb25seSB2YWxpZCBhdCB0aGUgdGhpcmQgcG9zaXRpb24uXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZvbnRSZW5kZXJPcHMuVFJBTlNGT1JNOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFthLCBiLCBjLCBkLCBlLCBmXSA9IGNtZHMuc2xpY2UoaSwgaSArIDYpO1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaChjdHggPT4gY3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSk7XG4gICAgICAgICAgICBpICs9IDY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZvbnRSZW5kZXJPcHMuVFJBTlNMQVRFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFthLCBiXSA9IGNtZHMuc2xpY2UoaSwgaSArIDIpO1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaChjdHggPT4gY3R4LnRyYW5zbGF0ZShhLCBiKSk7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gZ2x5cGhEcmF3ZXIoY3R4LCBzaXplKSB7XG4gICAgICBjb21tYW5kc1swXShjdHgpO1xuICAgICAgY29tbWFuZHNbMV0oY3R4KTtcbiAgICAgIGN0eC5zY2FsZShzaXplLCAtc2l6ZSk7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBjb21tYW5kcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbW1hbmRzW2ldKGN0eCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jYW52YXNfZmFjdG9yeS5qc1xuXG5jbGFzcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gICNlbmFibGVIV0EgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGVuYWJsZUhXQSA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLiNlbmFibGVIV0EgPSBlbmFibGVIV0E7XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhdGhpcy4jZW5hYmxlSFdBXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgcmVzZXQoY2FudmFzQW5kQ29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZGVzdHJveShjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzID0gbnVsbDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlQ2FudmFzYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01DYW52YXNGYWN0b3J5IGV4dGVuZHMgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgZW5hYmxlSFdBID0gZmFsc2VcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jbWFwX3JlYWRlcl9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsLFxuICAgIGlzQ29tcHJlc3NlZCA9IHRydWVcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy5pc0NvbXByZXNzZWQgPSBpc0NvbXByZXNzZWQ7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIG5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYGNNYXBVcmxgIGFuZCBgY01hcFBhY2tlZGAgQVBJIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB0aGlzLmJhc2VVcmwgKyBuYW1lICsgKHRoaXMuaXNDb21wcmVzc2VkID8gXCIuYmNtYXBcIiA6IFwiXCIpO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLnRoZW4oY01hcERhdGEgPT4gKHtcbiAgICAgIGNNYXBEYXRhLFxuICAgICAgaXNDb21wcmVzc2VkOiB0aGlzLmlzQ29tcHJlc3NlZFxuICAgIH0pKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCAke3RoaXMuaXNDb21wcmVzc2VkID8gXCJiaW5hcnkgXCIgOiBcIlwifUNNYXAgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01DTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgdGhpcy5pc0NvbXByZXNzZWQgPyBcImFycmF5YnVmZmVyXCIgOiBcInRleHRcIik7XG4gICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KGRhdGEpIDogc3RyaW5nVG9CeXRlcyhkYXRhKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9maWx0ZXJfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkQWxwaGFGaWx0ZXIobWFwKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEx1bWlub3NpdHlGaWx0ZXIobWFwKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmaWx0ZXJOYW1lLCBmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7fVxufVxuY2xhc3MgRE9NRmlsdGVyRmFjdG9yeSBleHRlbmRzIEJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgI2Jhc2VVcmw7XG4gICNfY2FjaGU7XG4gICNfZGVmcztcbiAgI2RvY0lkO1xuICAjZG9jdW1lbnQ7XG4gICNfaGNtQ2FjaGU7XG4gICNpZCA9IDA7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkb2NJZCxcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudFxuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNkb2NJZCA9IGRvY0lkO1xuICAgIHRoaXMuI2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBnZXQgI2NhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2hjbUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfaGNtQ2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2RlZnMoKSB7XG4gICAgaWYgKCF0aGlzLiNfZGVmcykge1xuICAgICAgY29uc3QgZGl2ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBkaXY7XG4gICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIHN0eWxlLmNvbnRhaW4gPSBcInN0cmljdFwiO1xuICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSAwO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gMDtcbiAgICAgIHN0eWxlLnpJbmRleCA9IC0xO1xuICAgICAgY29uc3Qgc3ZnID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJzdmdcIik7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgICAgdGhpcy4jX2RlZnMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImRlZnNcIik7XG4gICAgICBkaXYuYXBwZW5kKHN2Zyk7XG4gICAgICBzdmcuYXBwZW5kKHRoaXMuI19kZWZzKTtcbiAgICAgIHRoaXMuI2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNfZGVmcztcbiAgfVxuICAjY3JlYXRlVGFibGVzKG1hcHMpIHtcbiAgICBpZiAobWFwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IG1hcFIgPSBtYXBzWzBdO1xuICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZSA9IGJ1ZmZlci5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBbdGFibGUsIHRhYmxlLCB0YWJsZV07XG4gICAgfVxuICAgIGNvbnN0IFttYXBSLCBtYXBHLCBtYXBCXSA9IG1hcHM7XG4gICAgY29uc3QgYnVmZmVyUiA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGNvbnN0IGJ1ZmZlckcgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBjb25zdCBidWZmZXJCID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgYnVmZmVyUltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICBidWZmZXJHW2ldID0gbWFwR1tpXSAvIDI1NTtcbiAgICAgIGJ1ZmZlckJbaV0gPSBtYXBCW2ldIC8gMjU1O1xuICAgIH1cbiAgICByZXR1cm4gW2J1ZmZlclIuam9pbihcIixcIiksIGJ1ZmZlckcuam9pbihcIixcIiksIGJ1ZmZlckIuam9pbihcIixcIildO1xuICB9XG4gICNjcmVhdGVVcmwoaWQpIHtcbiAgICBpZiAodGhpcy4jYmFzZVVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLiNiYXNlVXJsID0gXCJcIjtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuI2RvY3VtZW50LlVSTDtcbiAgICAgIGlmICh1cmwgIT09IHRoaXMuI2RvY3VtZW50LmJhc2VVUkkpIHtcbiAgICAgICAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgICAgICAgd2FybignI2NyZWF0ZVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jYmFzZVVybCA9IHVybC5zcGxpdChcIiNcIiwgMSlbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGB1cmwoJHt0aGlzLiNiYXNlVXJsfSMke2lkfSlgO1xuICB9XG4gIGFkZEZpbHRlcihtYXBzKSB7XG4gICAgaWYgKCFtYXBzKSB7XG4gICAgICByZXR1cm4gXCJub25lXCI7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChtYXBzKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlUiwgdGFibGVHLCB0YWJsZUJdID0gdGhpcy4jY3JlYXRlVGFibGVzKG1hcHMpO1xuICAgIGNvbnN0IGtleSA9IG1hcHMubGVuZ3RoID09PSAxID8gdGFibGVSIDogYCR7dGFibGVSfSR7dGFibGVHfSR7dGFibGVCfWA7XG4gICAgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1fdHJhbnNmZXJfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcHMsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbih0YWJsZVIsIHRhYmxlRywgdGFibGVCLCBmaWx0ZXIpO1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkSENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9YDtcbiAgICBjb25zdCBmaWx0ZXJOYW1lID0gXCJiYXNlXCI7XG4gICAgbGV0IGluZm8gPSB0aGlzLiNoY21DYWNoZS5nZXQoZmlsdGVyTmFtZSk7XG4gICAgaWYgKGluZm8/LmtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvLmZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgICBpbmZvLmtleSA9IGtleTtcbiAgICAgIGluZm8udXJsID0gXCJub25lXCI7XG4gICAgICBpbmZvLmZpbHRlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gPSB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdXJsOiBcIm5vbmVcIixcbiAgICAgICAgZmlsdGVyOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy4jaGNtQ2FjaGUuc2V0KGZpbHRlck5hbWUsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgY29uc3QgZmdSR0IgPSB0aGlzLiNnZXRSR0IoZmdDb2xvcik7XG4gICAgZmdDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmZnUkdCKTtcbiAgICBjb25zdCBiZ1JHQiA9IHRoaXMuI2dldFJHQihiZ0NvbG9yKTtcbiAgICBiZ0NvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uYmdSR0IpO1xuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBcIlwiO1xuICAgIGlmIChmZ0NvbG9yID09PSBcIiMwMDAwMDBcIiAmJiBiZ0NvbG9yID09PSBcIiNmZmZmZmZcIiB8fCBmZ0NvbG9yID09PSBiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDI1NTsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAvIDI1NTtcbiAgICAgIG1hcFtpXSA9IHggPD0gMC4wMzkyOCA/IHggLyAxMi45MiA6ICgoeCArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQ7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlID0gbWFwLmpvaW4oXCIsXCIpO1xuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1faGNtX2ZpbHRlcmA7XG4gICAgY29uc3QgZmlsdGVyID0gaW5mby5maWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbih0YWJsZSwgdGFibGUsIHRhYmxlLCBmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoYywgbikgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBmZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGVuZCA9IGJnUkdCW2NdIC8gMjU1O1xuICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4gKyAxKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBzdGFydCArIGkgLyBuICogKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIuam9pbihcIixcIik7XG4gICAgfTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMoMCwgNSksIGdldFN0ZXBzKDEsIDUpLCBnZXRTdGVwcygyLCA1KSwgZmlsdGVyKTtcbiAgICBpbmZvLnVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgcmV0dXJuIGluZm8udXJsO1xuICB9XG4gIGFkZEFscGhhRmlsdGVyKG1hcCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChtYXApO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBbdGFibGVBXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhbbWFwXSk7XG4gICAgY29uc3Qga2V5ID0gYGFscGhhXyR7dGFibGVBfWA7XG4gICAgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9hbHBoYV9tYXBfJHt0aGlzLiNpZCsrfWA7XG4gICAgY29uc3QgdXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbih0YWJsZUEsIGZpbHRlcik7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBhZGRMdW1pbm9zaXR5RmlsdGVyKG1hcCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChtYXAgfHwgXCJsdW1pbm9zaXR5XCIpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgdGFibGVBLCBrZXk7XG4gICAgaWYgKG1hcCkge1xuICAgICAgW3RhYmxlQV0gPSB0aGlzLiNjcmVhdGVUYWJsZXMoW21hcF0pO1xuICAgICAga2V5ID0gYGx1bWlub3NpdHlfJHt0YWJsZUF9YDtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gXCJsdW1pbm9zaXR5XCI7XG4gICAgfVxuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1fbHVtaW5vc2l0eV9tYXBfJHt0aGlzLiNpZCsrfWA7XG4gICAgY29uc3QgdXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRMdW1pbm9zaXR5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIGlmIChtYXApIHtcbiAgICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uKHRhYmxlQSwgZmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBhZGRIaWdobGlnaHRIQ01GaWx0ZXIoZmlsdGVyTmFtZSwgZmdDb2xvciwgYmdDb2xvciwgbmV3RmdDb2xvciwgbmV3QmdDb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGAke2ZnQ29sb3J9LSR7YmdDb2xvcn0tJHtuZXdGZ0NvbG9yfS0ke25ld0JnQ29sb3J9YDtcbiAgICBsZXQgaW5mbyA9IHRoaXMuI2hjbUNhY2hlLmdldChmaWx0ZXJOYW1lKTtcbiAgICBpZiAoaW5mbz8ua2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGluZm8uZmlsdGVyPy5yZW1vdmUoKTtcbiAgICAgIGluZm8ua2V5ID0ga2V5O1xuICAgICAgaW5mby51cmwgPSBcIm5vbmVcIjtcbiAgICAgIGluZm8uZmlsdGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IHtcbiAgICAgICAga2V5LFxuICAgICAgICB1cmw6IFwibm9uZVwiLFxuICAgICAgICBmaWx0ZXI6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLiNoY21DYWNoZS5zZXQoZmlsdGVyTmFtZSwgaW5mbyk7XG4gICAgfVxuICAgIGlmICghZmdDb2xvciB8fCAhYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBjb25zdCBbZmdSR0IsIGJnUkdCXSA9IFtmZ0NvbG9yLCBiZ0NvbG9yXS5tYXAodGhpcy4jZ2V0UkdCLmJpbmQodGhpcykpO1xuICAgIGxldCBmZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGZnUkdCWzBdICsgMC43MTUyICogZmdSR0JbMV0gKyAwLjA3MjIgKiBmZ1JHQlsyXSk7XG4gICAgbGV0IGJnR3JheSA9IE1hdGgucm91bmQoMC4yMTI2ICogYmdSR0JbMF0gKyAwLjcxNTIgKiBiZ1JHQlsxXSArIDAuMDcyMiAqIGJnUkdCWzJdKTtcbiAgICBsZXQgW25ld0ZnUkdCLCBuZXdCZ1JHQl0gPSBbbmV3RmdDb2xvciwgbmV3QmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBpZiAoYmdHcmF5IDwgZmdHcmF5KSB7XG4gICAgICBbZmdHcmF5LCBiZ0dyYXksIG5ld0ZnUkdCLCBuZXdCZ1JHQl0gPSBbYmdHcmF5LCBmZ0dyYXksIG5ld0JnUkdCLCBuZXdGZ1JHQl07XG4gICAgfVxuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBcIlwiO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGZnLCBiZywgbikgPT4ge1xuICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBjb25zdCBzdGVwID0gKGJnR3JheSAtIGZnR3JheSkgLyBuO1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBmZyAvIDI1NTtcbiAgICAgIGNvbnN0IG5ld1N0ZXAgPSAoYmcgLSBmZykgLyAoMjU1ICogbik7XG4gICAgICBsZXQgcHJldiA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgayA9IE1hdGgucm91bmQoZmdHcmF5ICsgaSAqIHN0ZXApO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5ld1N0YXJ0ICsgaSAqIG5ld1N0ZXA7XG4gICAgICAgIGZvciAobGV0IGogPSBwcmV2OyBqIDw9IGs7IGorKykge1xuICAgICAgICAgIGFycltqXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBrICsgMTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBwcmV2OyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW3ByZXYgLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIuam9pbihcIixcIik7XG4gICAgfTtcbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2hjbV8ke2ZpbHRlck5hbWV9X2ZpbHRlcmA7XG4gICAgY29uc3QgZmlsdGVyID0gaW5mby5maWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKG5ld0ZnUkdCWzBdLCBuZXdCZ1JHQlswXSwgNSksIGdldFN0ZXBzKG5ld0ZnUkdCWzFdLCBuZXdCZ1JHQlsxXSwgNSksIGdldFN0ZXBzKG5ld0ZnUkdCWzJdLCBuZXdCZ1JHQlsyXSwgNSksIGZpbHRlcik7XG4gICAgaW5mby51cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHJldHVybiBpbmZvLnVybDtcbiAgfVxuICBkZXN0cm95KGtlZXBIQ00gPSBmYWxzZSkge1xuICAgIGlmIChrZWVwSENNICYmIHRoaXMuI2hjbUNhY2hlLnNpemUgIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI19kZWZzKSB7XG4gICAgICB0aGlzLiNfZGVmcy5wYXJlbnROb2RlLnBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNfZGVmcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiNfY2FjaGUpIHtcbiAgICAgIHRoaXMuI19jYWNoZS5jbGVhcigpO1xuICAgICAgdGhpcy4jX2NhY2hlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jaWQgPSAwO1xuICB9XG4gICNhZGRMdW1pbm9zaXR5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMyAwLjU5IDAuMTEgMCAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29sb3JNYXRyaXggPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29sb3JNYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidmFsdWVzXCIsIFwiMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMCAwIDAgMSAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2NyZWF0ZUZpbHRlcihpZCkge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmlsdGVyXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIiwgXCJzUkdCXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgdGhpcy4jZGVmcy5hcHBlbmQoZmlsdGVyKTtcbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG4gICNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgZnVuYywgdGFibGUpIHtcbiAgICBjb25zdCBmZUZ1bmMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBmdW5jKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImRpc2NyZXRlXCIpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0YWJsZVZhbHVlc1wiLCB0YWJsZSk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmQoZmVGdW5jKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHJUYWJsZSwgZ1RhYmxlLCBiVGFibGUsIGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNSXCIsIHJUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jR1wiLCBnVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0JcIiwgYlRhYmxlKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24oYVRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQVwiLCBhVGFibGUpO1xuICB9XG4gICNnZXRSR0IoY29sb3IpIHtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgcmV0dXJuIGdldFJHQihnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2RlZnMpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvc3RhbmRhcmRfZm9udGRhdGFfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgZmlsZW5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYHN0YW5kYXJkRm9udERhdGFVcmxgIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGZpbGVuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7ZmlsZW5hbWV9YDtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBmb250IGRhdGEgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgXCJhcnJheWJ1ZmZlclwiKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbm9kZV91dGlscy5qc1xuXG5cblxuXG5cbmlmIChpc05vZGVKUykge1xuICB2YXIgcGFja2FnZUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgdmFyIHBhY2thZ2VNYXAgPSBudWxsO1xuICBjb25zdCBsb2FkUGFja2FnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZnMgPSBhd2FpdCBpbXBvcnQoLyp3ZWJwYWNrSWdub3JlOiB0cnVlKi9cImZzXCIpLFxuICAgICAgaHR0cCA9IGF3YWl0IGltcG9ydCgvKndlYnBhY2tJZ25vcmU6IHRydWUqL1wiaHR0cFwiKSxcbiAgICAgIGh0dHBzID0gYXdhaXQgaW1wb3J0KC8qd2VicGFja0lnbm9yZTogdHJ1ZSovXCJodHRwc1wiKSxcbiAgICAgIHVybCA9IGF3YWl0IGltcG9ydCgvKndlYnBhY2tJZ25vcmU6IHRydWUqL1widXJsXCIpO1xuICAgIGxldCBjYW52YXMsIHBhdGgyZDtcbiAgICByZXR1cm4gbmV3IE1hcChPYmplY3QuZW50cmllcyh7XG4gICAgICBmcyxcbiAgICAgIGh0dHAsXG4gICAgICBodHRwcyxcbiAgICAgIHVybCxcbiAgICAgIGNhbnZhcyxcbiAgICAgIHBhdGgyZFxuICAgIH0pKTtcbiAgfTtcbiAgbG9hZFBhY2thZ2VzKCkudGhlbihtYXAgPT4ge1xuICAgIHBhY2thZ2VNYXAgPSBtYXA7XG4gICAgcGFja2FnZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9LCByZWFzb24gPT4ge1xuICAgIHdhcm4oYGxvYWRQYWNrYWdlczogJHtyZWFzb259YCk7XG4gICAgcGFja2FnZU1hcCA9IG5ldyBNYXAoKTtcbiAgICBwYWNrYWdlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH0pO1xufVxuY2xhc3MgTm9kZVBhY2thZ2VzIHtcbiAgc3RhdGljIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiBwYWNrYWdlQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHN0YXRpYyBnZXQobmFtZSkge1xuICAgIHJldHVybiBwYWNrYWdlTWFwPy5nZXQobmFtZSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCkge1xuICBjb25zdCBmcyA9IE5vZGVQYWNrYWdlcy5nZXQoXCJmc1wiKTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKHVybCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbn1cbmNsYXNzIE5vZGVGaWx0ZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUZpbHRlckZhY3Rvcnkge31cbmNsYXNzIE5vZGVDYW52YXNGYWN0b3J5IGV4dGVuZHMgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBOb2RlUGFja2FnZXMuZ2V0KFwiY2FudmFzXCIpO1xuICAgIHJldHVybiBjYW52YXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICB9XG59XG5jbGFzcyBOb2RlQ01hcFJlYWRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgcmV0dXJuIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cbmNsYXNzIE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICByZXR1cm4gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9wYXR0ZXJuX2hlbHBlci5qc1xuXG5cbmNvbnN0IFBhdGhUeXBlID0ge1xuICBGSUxMOiBcIkZpbGxcIixcbiAgU1RST0tFOiBcIlN0cm9rZVwiLFxuICBTSEFESU5HOiBcIlNoYWRpbmdcIlxufTtcbmZ1bmN0aW9uIGFwcGx5Qm91bmRpbmdCb3goY3R4LCBiYm94KSB7XG4gIGlmICghYmJveCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgY29uc3QgcmVnaW9uID0gbmV3IFBhdGgyRCgpO1xuICByZWdpb24ucmVjdChiYm94WzBdLCBiYm94WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY3R4LmNsaXAocmVnaW9uKTtcbn1cbmNsYXNzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGdldFBhdHRlcm4oKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYGdldFBhdHRlcm5gIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIFJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcihJUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdHlwZSA9IElSWzFdO1xuICAgIHRoaXMuX2Jib3ggPSBJUlsyXTtcbiAgICB0aGlzLl9jb2xvclN0b3BzID0gSVJbM107XG4gICAgdGhpcy5fcDAgPSBJUls0XTtcbiAgICB0aGlzLl9wMSA9IElSWzVdO1xuICAgIHRoaXMuX3IwID0gSVJbNl07XG4gICAgdGhpcy5fcjEgPSBJUls3XTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUdyYWRpZW50KGN0eCkge1xuICAgIGxldCBncmFkO1xuICAgIGlmICh0aGlzLl90eXBlID09PSBcImF4aWFsXCIpIHtcbiAgICAgIGdyYWQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQodGhpcy5fcDBbMF0sIHRoaXMuX3AwWzFdLCB0aGlzLl9wMVswXSwgdGhpcy5fcDFbMV0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gXCJyYWRpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3IwLCB0aGlzLl9wMVswXSwgdGhpcy5fcDFbMV0sIHRoaXMuX3IxKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb2xvclN0b3Agb2YgdGhpcy5fY29sb3JTdG9wcykge1xuICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wWzBdLCBjb2xvclN0b3BbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhZDtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TVFJPS0UgfHwgcGF0aFR5cGUgPT09IFBhdGhUeXBlLkZJTEwpIHtcbiAgICAgIGNvbnN0IG93bmVyQkJveCA9IG93bmVyLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpKSB8fCBbMCwgMCwgMCwgMF07XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChvd25lckJCb3hbMl0gLSBvd25lckJCb3hbMF0pIHx8IDE7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwob3duZXJCQm94WzNdIC0gb3duZXJCQm94WzFdKSB8fCAxO1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHguYmVnaW5QYXRoKCk7XG4gICAgICB0bXBDdHgucmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHgudHJhbnNsYXRlKC1vd25lckJCb3hbMF0sIC1vd25lckJCb3hbMV0pO1xuICAgICAgaW52ZXJzZSA9IFV0aWwudHJhbnNmb3JtKGludmVyc2UsIFsxLCAwLCAwLCAxLCBvd25lckJCb3hbMF0sIG93bmVyQkJveFsxXV0pO1xuICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICB0bXBDdHgudHJhbnNmb3JtKC4uLnRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGFwcGx5Qm91bmRpbmdCb3godG1wQ3R4LCB0aGlzLl9iYm94KTtcbiAgICAgIHRtcEN0eC5maWxsU3R5bGUgPSB0aGlzLl9jcmVhdGVHcmFkaWVudCh0bXBDdHgpO1xuICAgICAgdG1wQ3R4LmZpbGwoKTtcbiAgICAgIHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0bXBDYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgICAgIGNvbnN0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgoaW52ZXJzZSk7XG4gICAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fY3JlYXRlR3JhZGllbnQoY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwMSwgcDIsIHAzLCBjMSwgYzIsIGMzKSB7XG4gIGNvbnN0IGNvb3JkcyA9IGNvbnRleHQuY29vcmRzLFxuICAgIGNvbG9ycyA9IGNvbnRleHQuY29sb3JzO1xuICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YSxcbiAgICByb3dTaXplID0gZGF0YS53aWR0aCAqIDQ7XG4gIGxldCB0bXA7XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDIgKyAxXSA+IGNvb3Jkc1twMyArIDFdKSB7XG4gICAgdG1wID0gcDI7XG4gICAgcDIgPSBwMztcbiAgICBwMyA9IHRtcDtcbiAgICB0bXAgPSBjMjtcbiAgICBjMiA9IGMzO1xuICAgIGMzID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGNvbnN0IHgxID0gKGNvb3Jkc1twMV0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkxID0gKGNvb3Jkc1twMSArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MiA9IChjb29yZHNbcDJdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MiA9IChjb29yZHNbcDIgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDMgPSAoY29vcmRzW3AzXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTMgPSAoY29vcmRzW3AzICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGlmICh5MSA+PSB5Mykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjMXIgPSBjb2xvcnNbYzFdLFxuICAgIGMxZyA9IGNvbG9yc1tjMSArIDFdLFxuICAgIGMxYiA9IGNvbG9yc1tjMSArIDJdO1xuICBjb25zdCBjMnIgPSBjb2xvcnNbYzJdLFxuICAgIGMyZyA9IGNvbG9yc1tjMiArIDFdLFxuICAgIGMyYiA9IGNvbG9yc1tjMiArIDJdO1xuICBjb25zdCBjM3IgPSBjb2xvcnNbYzNdLFxuICAgIGMzZyA9IGNvbG9yc1tjMyArIDFdLFxuICAgIGMzYiA9IGNvbG9yc1tjMyArIDJdO1xuICBjb25zdCBtaW5ZID0gTWF0aC5yb3VuZCh5MSksXG4gICAgbWF4WSA9IE1hdGgucm91bmQoeTMpO1xuICBsZXQgeGEsIGNhciwgY2FnLCBjYWI7XG4gIGxldCB4YiwgY2JyLCBjYmcsIGNiYjtcbiAgZm9yIChsZXQgeSA9IG1pblk7IHkgPD0gbWF4WTsgeSsrKSB7XG4gICAgaWYgKHkgPCB5Mikge1xuICAgICAgY29uc3QgayA9IHkgPCB5MSA/IDAgOiAoeTEgLSB5KSAvICh5MSAtIHkyKTtcbiAgICAgIHhhID0geDEgLSAoeDEgLSB4MikgKiBrO1xuICAgICAgY2FyID0gYzFyIC0gKGMxciAtIGMycikgKiBrO1xuICAgICAgY2FnID0gYzFnIC0gKGMxZyAtIGMyZykgKiBrO1xuICAgICAgY2FiID0gYzFiIC0gKGMxYiAtIGMyYikgKiBrO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaztcbiAgICAgIGlmICh5ID4geTMpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHkyID09PSB5Mykge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSAoeTIgLSB5KSAvICh5MiAtIHkzKTtcbiAgICAgIH1cbiAgICAgIHhhID0geDIgLSAoeDIgLSB4MykgKiBrO1xuICAgICAgY2FyID0gYzJyIC0gKGMyciAtIGMzcikgKiBrO1xuICAgICAgY2FnID0gYzJnIC0gKGMyZyAtIGMzZykgKiBrO1xuICAgICAgY2FiID0gYzJiIC0gKGMyYiAtIGMzYikgKiBrO1xuICAgIH1cbiAgICBsZXQgaztcbiAgICBpZiAoeSA8IHkxKSB7XG4gICAgICBrID0gMDtcbiAgICB9IGVsc2UgaWYgKHkgPiB5Mykge1xuICAgICAgayA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGsgPSAoeTEgLSB5KSAvICh5MSAtIHkzKTtcbiAgICB9XG4gICAgeGIgPSB4MSAtICh4MSAtIHgzKSAqIGs7XG4gICAgY2JyID0gYzFyIC0gKGMxciAtIGMzcikgKiBrO1xuICAgIGNiZyA9IGMxZyAtIChjMWcgLSBjM2cpICogaztcbiAgICBjYmIgPSBjMWIgLSAoYzFiIC0gYzNiKSAqIGs7XG4gICAgY29uc3QgeDFfID0gTWF0aC5yb3VuZChNYXRoLm1pbih4YSwgeGIpKTtcbiAgICBjb25zdCB4Ml8gPSBNYXRoLnJvdW5kKE1hdGgubWF4KHhhLCB4YikpO1xuICAgIGxldCBqID0gcm93U2l6ZSAqIHkgKyB4MV8gKiA0O1xuICAgIGZvciAobGV0IHggPSB4MV87IHggPD0geDJfOyB4KyspIHtcbiAgICAgIGsgPSAoeGEgLSB4KSAvICh4YSAtIHhiKTtcbiAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoayA+IDEpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9XG4gICAgICBieXRlc1tqKytdID0gY2FyIC0gKGNhciAtIGNicikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWcgLSAoY2FnIC0gY2JnKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhYiAtIChjYWIgLSBjYmIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gMjU1O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHMgPSBmaWd1cmUuY29vcmRzO1xuICBjb25zdCBjcyA9IGZpZ3VyZS5jb2xvcnM7XG4gIGxldCBpLCBpaTtcbiAgc3dpdGNoIChmaWd1cmUudHlwZSkge1xuICAgIGNhc2UgXCJsYXR0aWNlXCI6XG4gICAgICBjb25zdCB2ZXJ0aWNlc1BlclJvdyA9IGZpZ3VyZS52ZXJ0aWNlc1BlclJvdztcbiAgICAgIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKHBzLmxlbmd0aCAvIHZlcnRpY2VzUGVyUm93KSAtIDE7XG4gICAgICBjb25zdCBjb2xzID0gdmVydGljZXNQZXJSb3cgLSAxO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICBsZXQgcSA9IGkgKiB2ZXJ0aWNlc1BlclJvdztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyBqKyssIHErKykge1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cmlhbmdsZXNcIjpcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gcHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbaV0sIHBzW2kgKyAxXSwgcHNbaSArIDJdLCBjc1tpXSwgY3NbaSArIDFdLCBjc1tpICsgMl0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgZmlndXJlXCIpO1xuICB9XG59XG5jbGFzcyBNZXNoU2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcihJUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29vcmRzID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JzID0gSVJbM107XG4gICAgdGhpcy5fZmlndXJlcyA9IElSWzRdO1xuICAgIHRoaXMuX2JvdW5kcyA9IElSWzVdO1xuICAgIHRoaXMuX2Jib3ggPSBJUls3XTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kID0gSVJbOF07XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVNZXNoQ2FudmFzKGNvbWJpbmVkU2NhbGUsIGJhY2tncm91bmRDb2xvciwgY2FjaGVkQ2FudmFzZXMpIHtcbiAgICBjb25zdCBFWFBFQ1RFRF9TQ0FMRSA9IDEuMTtcbiAgICBjb25zdCBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMV0pO1xuICAgIGNvbnN0IGJvdW5kc1dpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1syXSkgLSBvZmZzZXRYO1xuICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbM10pIC0gb2Zmc2V0WTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNXaWR0aCAqIGNvbWJpbmVkU2NhbGVbMF0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzSGVpZ2h0ICogY29tYmluZWRTY2FsZVsxXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IHNjYWxlWCA9IGJvdW5kc1dpZHRoIC8gd2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBjb29yZHM6IHRoaXMuX2Nvb3JkcyxcbiAgICAgIGNvbG9yczogdGhpcy5fY29sb3JzLFxuICAgICAgb2Zmc2V0WDogLW9mZnNldFgsXG4gICAgICBvZmZzZXRZOiAtb2Zmc2V0WSxcbiAgICAgIHNjYWxlWDogMSAvIHNjYWxlWCxcbiAgICAgIHNjYWxlWTogMSAvIHNjYWxlWVxuICAgIH07XG4gICAgY29uc3QgcGFkZGVkV2lkdGggPSB3aWR0aCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCBwYWRkZWRIZWlnaHQgPSBoZWlnaHQgKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWVzaFwiLCBwYWRkZWRXaWR0aCwgcGFkZGVkSGVpZ2h0KTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBkYXRhID0gdG1wQ3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJ5dGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBiYWNrZ3JvdW5kQ29sb3JbMF07XG4gICAgICAgIGJ5dGVzW2kgKyAxXSA9IGJhY2tncm91bmRDb2xvclsxXTtcbiAgICAgICAgYnl0ZXNbaSArIDJdID0gYmFja2dyb3VuZENvbG9yWzJdO1xuICAgICAgICBieXRlc1tpICsgM10gPSAyNTU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmlndXJlIG9mIHRoaXMuX2ZpZ3VyZXMpIHtcbiAgICAgIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdG1wQ3R4LnB1dEltYWdlRGF0YShkYXRhLCBCT1JERVJfU0laRSwgQk9SREVSX1NJWkUpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIG9mZnNldFg6IG9mZnNldFggLSBCT1JERVJfU0laRSAqIHNjYWxlWCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFkgLSBCT1JERVJfU0laRSAqIHNjYWxlWSxcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWVxuICAgIH07XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCB0aGlzLl9iYm94KTtcbiAgICBsZXQgc2NhbGU7XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBzY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIGNvbnN0IG1hdHJpeFNjYWxlID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCk7XG4gICAgICAgIHNjYWxlID0gW3NjYWxlWzBdICogbWF0cml4U2NhbGVbMF0sIHNjYWxlWzFdICogbWF0cml4U2NhbGVbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5fY3JlYXRlTWVzaENhbnZhcyhzY2FsZSwgcGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcgPyBudWxsIDogdGhpcy5fYmFja2dyb3VuZCwgb3duZXIuY2FjaGVkQ2FudmFzZXMpO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBjdHgudHJhbnNmb3JtKC4uLnRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgY3R4LnNjYWxlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgfVxufVxuY2xhc3MgRHVtbXlTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGdldFBhdHRlcm4oKSB7XG4gICAgcmV0dXJuIFwiaG90cGlua1wiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTaGFkaW5nUGF0dGVybihJUikge1xuICBzd2l0Y2ggKElSWzBdKSB7XG4gICAgY2FzZSBcIlJhZGlhbEF4aWFsXCI6XG4gICAgICByZXR1cm4gbmV3IFJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJNZXNoXCI6XG4gICAgICByZXR1cm4gbmV3IE1lc2hTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIkR1bW15XCI6XG4gICAgICByZXR1cm4gbmV3IER1bW15U2hhZGluZ1BhdHRlcm4oKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSVIgdHlwZTogJHtJUlswXX1gKTtcbn1cbmNvbnN0IFBhaW50VHlwZSA9IHtcbiAgQ09MT1JFRDogMSxcbiAgVU5DT0xPUkVEOiAyXG59O1xuY2xhc3MgVGlsaW5nUGF0dGVybiB7XG4gIHN0YXRpYyBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgY29uc3RydWN0b3IoSVIsIGNvbG9yLCBjdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSkge1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gSVJbMl07XG4gICAgdGhpcy5tYXRyaXggPSBJUlszXTtcbiAgICB0aGlzLmJib3ggPSBJUls0XTtcbiAgICB0aGlzLnhzdGVwID0gSVJbNV07XG4gICAgdGhpcy55c3RlcCA9IElSWzZdO1xuICAgIHRoaXMucGFpbnRUeXBlID0gSVJbN107XG4gICAgdGhpcy50aWxpbmdUeXBlID0gSVJbOF07XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5O1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGJhc2VUcmFuc2Zvcm07XG4gIH1cbiAgY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGJib3gsXG4gICAgICBvcGVyYXRvckxpc3QsXG4gICAgICBwYWludFR5cGUsXG4gICAgICB0aWxpbmdUeXBlLFxuICAgICAgY29sb3IsXG4gICAgICBjYW52YXNHcmFwaGljc0ZhY3RvcnlcbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgeHN0ZXAsXG4gICAgICB5c3RlcFxuICAgIH0gPSB0aGlzO1xuICAgIHhzdGVwID0gTWF0aC5hYnMoeHN0ZXApO1xuICAgIHlzdGVwID0gTWF0aC5hYnMoeXN0ZXApO1xuICAgIGluZm8oXCJUaWxpbmdUeXBlOiBcIiArIHRpbGluZ1R5cGUpO1xuICAgIGNvbnN0IHgwID0gYmJveFswXSxcbiAgICAgIHkwID0gYmJveFsxXSxcbiAgICAgIHgxID0gYmJveFsyXSxcbiAgICAgIHkxID0gYmJveFszXTtcbiAgICBjb25zdCB3aWR0aCA9IHgxIC0geDA7XG4gICAgY29uc3QgaGVpZ2h0ID0geTEgLSB5MDtcbiAgICBjb25zdCBtYXRyaXhTY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgpO1xuICAgIGNvbnN0IGN1ck1hdHJpeFNjYWxlID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGNvbnN0IGNvbWJpbmVkU2NhbGVYID0gbWF0cml4U2NhbGVbMF0gKiBjdXJNYXRyaXhTY2FsZVswXTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlWSA9IG1hdHJpeFNjYWxlWzFdICogY3VyTWF0cml4U2NhbGVbMV07XG4gICAgbGV0IGNhbnZhc1dpZHRoID0gd2lkdGgsXG4gICAgICBjYW52YXNIZWlnaHQgPSBoZWlnaHQsXG4gICAgICByZWRyYXdIb3Jpem9udGFsbHkgPSBmYWxzZSxcbiAgICAgIHJlZHJhd1ZlcnRpY2FsbHkgPSBmYWxzZTtcbiAgICBjb25zdCB4U2NhbGVkU3RlcCA9IE1hdGguY2VpbCh4c3RlcCAqIGNvbWJpbmVkU2NhbGVYKTtcbiAgICBjb25zdCB5U2NhbGVkU3RlcCA9IE1hdGguY2VpbCh5c3RlcCAqIGNvbWJpbmVkU2NhbGVZKTtcbiAgICBjb25zdCB4U2NhbGVkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgeVNjYWxlZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBjb21iaW5lZFNjYWxlWSk7XG4gICAgaWYgKHhTY2FsZWRTdGVwID49IHhTY2FsZWRXaWR0aCkge1xuICAgICAgY2FudmFzV2lkdGggPSB4c3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkcmF3SG9yaXpvbnRhbGx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHlTY2FsZWRTdGVwID49IHlTY2FsZWRIZWlnaHQpIHtcbiAgICAgIGNhbnZhc0hlaWdodCA9IHlzdGVwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRyYXdWZXJ0aWNhbGx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZGlteCA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc1dpZHRoLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIGNvbWJpbmVkU2NhbGVYKTtcbiAgICBjb25zdCBkaW15ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzSGVpZ2h0LCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0LCBjb21iaW5lZFNjYWxlWSk7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCBkaW14LnNpemUsIGRpbXkuc2l6ZSk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZ3JhcGhpY3MgPSBjYW52YXNHcmFwaGljc0ZhY3RvcnkuY3JlYXRlQ2FudmFzR3JhcGhpY3ModG1wQ3R4KTtcbiAgICBncmFwaGljcy5ncm91cExldmVsID0gb3duZXIuZ3JvdXBMZXZlbDtcbiAgICB0aGlzLnNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcik7XG4gICAgdG1wQ3R4LnRyYW5zbGF0ZSgtZGlteC5zY2FsZSAqIHgwLCAtZGlteS5zY2FsZSAqIHkwKTtcbiAgICBncmFwaGljcy50cmFuc2Zvcm0oZGlteC5zY2FsZSwgMCwgMCwgZGlteS5zY2FsZSwgMCwgMCk7XG4gICAgdG1wQ3R4LnNhdmUoKTtcbiAgICB0aGlzLmNsaXBCYm94KGdyYXBoaWNzLCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgZ3JhcGhpY3MuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oZ3JhcGhpY3MuY3R4KTtcbiAgICBncmFwaGljcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgZ3JhcGhpY3MuZW5kRHJhd2luZygpO1xuICAgIHRtcEN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKHJlZHJhd0hvcml6b250YWxseSB8fCByZWRyYXdWZXJ0aWNhbGx5KSB7XG4gICAgICBjb25zdCBpbWFnZSA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICBpZiAocmVkcmF3SG9yaXpvbnRhbGx5KSB7XG4gICAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgICB9XG4gICAgICBpZiAocmVkcmF3VmVydGljYWxseSkge1xuICAgICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpbXgyID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzV2lkdGgsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgY29tYmluZWRTY2FsZVgpO1xuICAgICAgY29uc3QgZGlteTIgPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNIZWlnaHQsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVZKTtcbiAgICAgIGNvbnN0IHhTaXplID0gZGlteDIuc2l6ZTtcbiAgICAgIGNvbnN0IHlTaXplID0gZGlteTIuc2l6ZTtcbiAgICAgIGNvbnN0IHRtcENhbnZhczIgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuLXdvcmthcm91bmRcIiwgeFNpemUsIHlTaXplKTtcbiAgICAgIGNvbnN0IHRtcEN0eDIgPSB0bXBDYW52YXMyLmNvbnRleHQ7XG4gICAgICBjb25zdCBpaSA9IHJlZHJhd0hvcml6b250YWxseSA/IE1hdGguZmxvb3Iod2lkdGggLyB4c3RlcCkgOiAwO1xuICAgICAgY29uc3QgamogPSByZWRyYXdWZXJ0aWNhbGx5ID8gTWF0aC5mbG9vcihoZWlnaHQgLyB5c3RlcCkgOiAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaWk7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBqajsgaisrKSB7XG4gICAgICAgICAgdG1wQ3R4Mi5kcmF3SW1hZ2UoaW1hZ2UsIHhTaXplICogaSwgeVNpemUgKiBqLCB4U2l6ZSwgeVNpemUsIDAsIDAsIHhTaXplLCB5U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbnZhczogdG1wQ2FudmFzMi5jYW52YXMsXG4gICAgICAgIHNjYWxlWDogZGlteDIuc2NhbGUsXG4gICAgICAgIHNjYWxlWTogZGlteTIuc2NhbGUsXG4gICAgICAgIG9mZnNldFg6IHgwLFxuICAgICAgICBvZmZzZXRZOiB5MFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogdG1wQ2FudmFzLmNhbnZhcyxcbiAgICAgIHNjYWxlWDogZGlteC5zY2FsZSxcbiAgICAgIHNjYWxlWTogZGlteS5zY2FsZSxcbiAgICAgIG9mZnNldFg6IHgwLFxuICAgICAgb2Zmc2V0WTogeTBcbiAgICB9O1xuICB9XG4gIGdldFNpemVBbmRTY2FsZShzdGVwLCByZWFsT3V0cHV0U2l6ZSwgc2NhbGUpIHtcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoVGlsaW5nUGF0dGVybi5NQVhfUEFUVEVSTl9TSVpFLCByZWFsT3V0cHV0U2l6ZSk7XG4gICAgbGV0IHNpemUgPSBNYXRoLmNlaWwoc3RlcCAqIHNjYWxlKTtcbiAgICBpZiAoc2l6ZSA+PSBtYXhTaXplKSB7XG4gICAgICBzaXplID0gbWF4U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBzaXplIC8gc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgY2xpcEJib3goZ3JhcGhpY3MsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgY29uc3QgYmJveFdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0geTEgLSB5MDtcbiAgICBncmFwaGljcy5jdHgucmVjdCh4MCwgeTAsIGJib3hXaWR0aCwgYmJveEhlaWdodCk7XG4gICAgZ3JhcGhpY3MuY3VycmVudC51cGRhdGVSZWN0TWluTWF4KGdldEN1cnJlbnRUcmFuc2Zvcm0oZ3JhcGhpY3MuY3R4KSwgW3gwLCB5MCwgeDEsIHkxXSk7XG4gICAgZ3JhcGhpY3MuY2xpcCgpO1xuICAgIGdyYXBoaWNzLmVuZFBhdGgoKTtcbiAgfVxuICBzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gZ3JhcGhpY3MuY3R4LFxuICAgICAgY3VycmVudCA9IGdyYXBoaWNzLmN1cnJlbnQ7XG4gICAgc3dpdGNoIChwYWludFR5cGUpIHtcbiAgICAgIGNhc2UgUGFpbnRUeXBlLkNPTE9SRUQ6XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgIGN1cnJlbnQuZmlsbENvbG9yID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgY3VycmVudC5zdHJva2VDb2xvciA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBhaW50VHlwZS5VTkNPTE9SRUQ6XG4gICAgICAgIGNvbnN0IGNzc0NvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjc3NDb2xvcjtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgY3VycmVudC5zdHJva2VDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBGb3JtYXRFcnJvcihgVW5zdXBwb3J0ZWQgcGFpbnQgdHlwZTogJHtwYWludFR5cGV9YCk7XG4gICAgfVxuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgbWF0cml4ID0gaW52ZXJzZTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIG1hdHJpeCA9IFV0aWwudHJhbnNmb3JtKG1hdHJpeCwgb3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgbWF0cml4ID0gVXRpbC50cmFuc2Zvcm0obWF0cml4LCB0aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLmNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpO1xuICAgIGxldCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KG1hdHJpeCk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnNjYWxlKDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwicmVwZWF0XCIpO1xuICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9pbWFnZV91dGlscy5qc1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9SR0JBKHBhcmFtcykge1xuICBzd2l0Y2ggKHBhcmFtcy5raW5kKSB7XG4gICAgY2FzZSBJbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFA6XG4gICAgICByZXR1cm4gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEocGFyYW1zKTtcbiAgICBjYXNlIEltYWdlS2luZC5SR0JfMjRCUFA6XG4gICAgICByZXR1cm4gY29udmVydFJHQlRvUkdCQShwYXJhbXMpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICBzcmMsXG4gIHNyY1BvcyA9IDAsXG4gIGRlc3QsXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIG5vbkJsYWNrQ29sb3IgPSAweGZmZmZmZmZmLFxuICBpbnZlcnNlRGVjb2RlID0gZmFsc2Vcbn0pIHtcbiAgY29uc3QgYmxhY2sgPSB1dGlsX0ZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG4gIGNvbnN0IFt6ZXJvTWFwcGluZywgb25lTWFwcGluZ10gPSBpbnZlcnNlRGVjb2RlID8gW25vbkJsYWNrQ29sb3IsIGJsYWNrXSA6IFtibGFjaywgbm9uQmxhY2tDb2xvcl07XG4gIGNvbnN0IHdpZHRoSW5Tb3VyY2UgPSB3aWR0aCA+PiAzO1xuICBjb25zdCB3aWR0aFJlbWFpbmRlciA9IHdpZHRoICYgNztcbiAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgZGVzdCA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlcik7XG4gIGxldCBkZXN0UG9zID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIGZvciAoY29uc3QgbWF4ID0gc3JjUG9zICsgd2lkdGhJblNvdXJjZTsgc3JjUG9zIDwgbWF4OyBzcmNQb3MrKykge1xuICAgICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3NdIDogMjU1O1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgIH1cbiAgICBpZiAod2lkdGhSZW1haW5kZXIgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBlbGVtID0gc3JjUG9zIDwgc3JjTGVuZ3RoID8gc3JjW3NyY1BvcysrXSA6IDI1NTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoUmVtYWluZGVyOyBqKyspIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAxIDw8IDcgLSBqID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1BvcyxcbiAgICBkZXN0UG9zXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UkdCVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICBkZXN0UG9zID0gMCxcbiAgd2lkdGgsXG4gIGhlaWdodFxufSkge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbjMyID0gc3JjLmxlbmd0aCA+PiAyO1xuICBjb25zdCBzcmMzMiA9IG5ldyBVaW50MzJBcnJheShzcmMuYnVmZmVyLCBzcmNQb3MsIGxlbjMyKTtcbiAgaWYgKEZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yICg7IGkgPCBsZW4zMiAtIDI7IGkgKz0gMywgZGVzdFBvcyArPSA0KSB7XG4gICAgICBjb25zdCBzMSA9IHNyYzMyW2ldO1xuICAgICAgY29uc3QgczIgPSBzcmMzMltpICsgMV07XG4gICAgICBjb25zdCBzMyA9IHNyYzMyW2kgKyAyXTtcbiAgICAgIGRlc3RbZGVzdFBvc10gPSBzMSB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAxXSA9IHMxID4+PiAyNCB8IHMyIDw8IDggfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMl0gPSBzMiA+Pj4gMTYgfCBzMyA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAzXSA9IHMzID4+PiA4IHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyYy5sZW5ndGg7IGogPCBqajsgaiArPSAzKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbal0gfCBzcmNbaiArIDFdIDw8IDggfCBzcmNbaiArIDJdIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICg7IGkgPCBsZW4zMiAtIDI7IGkgKz0gMywgZGVzdFBvcyArPSA0KSB7XG4gICAgICBjb25zdCBzMSA9IHNyYzMyW2ldO1xuICAgICAgY29uc3QgczIgPSBzcmMzMltpICsgMV07XG4gICAgICBjb25zdCBzMyA9IHNyYzMyW2kgKyAyXTtcbiAgICAgIGRlc3RbZGVzdFBvc10gPSBzMSB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAxXSA9IHMxIDw8IDI0IHwgczIgPj4+IDggfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMl0gPSBzMiA8PCAxNiB8IHMzID4+PiAxNiB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAzXSA9IHMzIDw8IDggfCAweGZmO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjLmxlbmd0aDsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSA8PCAyNCB8IHNyY1tqICsgMV0gPDwgMTYgfCBzcmNbaiArIDJdIDw8IDggfCAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1BvcyxcbiAgICBkZXN0UG9zXG4gIH07XG59XG5mdW5jdGlvbiBncmF5VG9SR0JBKHNyYywgZGVzdCkge1xuICBpZiAoRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgZGVzdFtpXSA9IHNyY1tpXSAqIDB4MTAxMDEgfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgZGVzdFtpXSA9IHNyY1tpXSAqIDB4MTAxMDEwMCB8IDB4MDAwMDAwZmY7XG4gICAgfVxuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NhbnZhcy5qc1xuXG5cblxuXG5jb25zdCBNSU5fRk9OVF9TSVpFID0gMTY7XG5jb25zdCBNQVhfRk9OVF9TSVpFID0gMTAwO1xuY29uc3QgRVhFQ1VUSU9OX1RJTUUgPSAxNTtcbmNvbnN0IEVYRUNVVElPTl9TVEVQUyA9IDEwO1xuY29uc3QgTUFYX1NJWkVfVE9fQ09NUElMRSA9IDEwMDA7XG5jb25zdCBGVUxMX0NIVU5LX0hFSUdIVCA9IDE2O1xuZnVuY3Rpb24gbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCBkZXN0Q3R4KSB7XG4gIGlmIChjdHguX3JlbW92ZU1pcnJvcmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgaXMgYWxyZWFkeSBmb3J3YXJkaW5nIG9wZXJhdGlvbnMuXCIpO1xuICB9XG4gIGN0eC5fX29yaWdpbmFsU2F2ZSA9IGN0eC5zYXZlO1xuICBjdHguX19vcmlnaW5hbFJlc3RvcmUgPSBjdHgucmVzdG9yZTtcbiAgY3R4Ll9fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICBjdHguX19vcmlnaW5hbFNjYWxlID0gY3R4LnNjYWxlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZSA9IGN0eC50cmFuc2xhdGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0gPSBjdHguc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtID0gY3R4LnJlc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbENsaXAgPSBjdHguY2xpcDtcbiAgY3R4Ll9fb3JpZ2luYWxNb3ZlVG8gPSBjdHgubW92ZVRvO1xuICBjdHguX19vcmlnaW5hbExpbmVUbyA9IGN0eC5saW5lVG87XG4gIGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyA9IGN0eC5iZXppZXJDdXJ2ZVRvO1xuICBjdHguX19vcmlnaW5hbFJlY3QgPSBjdHgucmVjdDtcbiAgY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGggPSBjdHguY2xvc2VQYXRoO1xuICBjdHguX19vcmlnaW5hbEJlZ2luUGF0aCA9IGN0eC5iZWdpblBhdGg7XG4gIGN0eC5fcmVtb3ZlTWlycm9yaW5nID0gKCkgPT4ge1xuICAgIGN0eC5zYXZlID0gY3R4Ll9fb3JpZ2luYWxTYXZlO1xuICAgIGN0eC5yZXN0b3JlID0gY3R4Ll9fb3JpZ2luYWxSZXN0b3JlO1xuICAgIGN0eC5yb3RhdGUgPSBjdHguX19vcmlnaW5hbFJvdGF0ZTtcbiAgICBjdHguc2NhbGUgPSBjdHguX19vcmlnaW5hbFNjYWxlO1xuICAgIGN0eC50cmFuc2xhdGUgPSBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZTtcbiAgICBjdHgudHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm07XG4gICAgY3R4LnNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtO1xuICAgIGN0eC5yZXNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm07XG4gICAgY3R4LmNsaXAgPSBjdHguX19vcmlnaW5hbENsaXA7XG4gICAgY3R4Lm1vdmVUbyA9IGN0eC5fX29yaWdpbmFsTW92ZVRvO1xuICAgIGN0eC5saW5lVG8gPSBjdHguX19vcmlnaW5hbExpbmVUbztcbiAgICBjdHguYmV6aWVyQ3VydmVUbyA9IGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbztcbiAgICBjdHgucmVjdCA9IGN0eC5fX29yaWdpbmFsUmVjdDtcbiAgICBjdHguY2xvc2VQYXRoID0gY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGg7XG4gICAgY3R4LmJlZ2luUGF0aCA9IGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoO1xuICAgIGRlbGV0ZSBjdHguX3JlbW92ZU1pcnJvcmluZztcbiAgfTtcbiAgY3R4LnNhdmUgPSBmdW5jdGlvbiBjdHhTYXZlKCkge1xuICAgIGRlc3RDdHguc2F2ZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNhdmUoKTtcbiAgfTtcbiAgY3R4LnJlc3RvcmUgPSBmdW5jdGlvbiBjdHhSZXN0b3JlKCkge1xuICAgIGRlc3RDdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlc3RvcmUoKTtcbiAgfTtcbiAgY3R4LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIGN0eFRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgZGVzdEN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNsYXRlKHgsIHkpO1xuICB9O1xuICBjdHguc2NhbGUgPSBmdW5jdGlvbiBjdHhTY2FsZSh4LCB5KSB7XG4gICAgZGVzdEN0eC5zY2FsZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTY2FsZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgZGVzdEN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9O1xuICBjdHguc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4U2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5yZXNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFJlc2V0VHJhbnNmb3JtKCkge1xuICAgIGRlc3RDdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSgpO1xuICB9O1xuICBjdHgucm90YXRlID0gZnVuY3Rpb24gY3R4Um90YXRlKGFuZ2xlKSB7XG4gICAgZGVzdEN0eC5yb3RhdGUoYW5nbGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJvdGF0ZShhbmdsZSk7XG4gIH07XG4gIGN0eC5jbGlwID0gZnVuY3Rpb24gY3R4Um90YXRlKHJ1bGUpIHtcbiAgICBkZXN0Q3R4LmNsaXAocnVsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xpcChydWxlKTtcbiAgfTtcbiAgY3R4Lm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTW92ZVRvKHgsIHkpO1xuICB9O1xuICBjdHgubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LmxpbmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxMaW5lVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICBkZXN0Q3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgfTtcbiAgY3R4LnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGRlc3RDdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuICBjdHguY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xvc2VQYXRoKCk7XG4gIH07XG4gIGN0eC5iZWdpblBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZWdpblBhdGgoKTtcbiAgfTtcbn1cbmNsYXNzIENhY2hlZENhbnZhc2VzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzRmFjdG9yeSkge1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZ2V0Q2FudmFzKGlkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgbGV0IGNhbnZhc0VudHJ5O1xuICAgIGlmICh0aGlzLmNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LnJlc2V0KGNhbnZhc0VudHJ5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBjYW52YXNFbnRyeTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhc0VudHJ5O1xuICB9XG4gIGRlbGV0ZShpZCkge1xuICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkuZGVzdHJveShjYW52YXNFbnRyeSk7XG4gICAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKSB7XG4gIGNvbnN0IFthLCBiLCBjLCBkLCB0eCwgdHldID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICBpZiAoYiA9PT0gMCAmJiBjID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFggKiBhICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WSAqIGQgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WCArIGRlc3RXKSAqIGEgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WSArIGRlc3RIKSAqIGQgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKE1hdGguc2lnbihhKSwgMCwgMCwgTWF0aC5zaWduKGQpLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgcldpZHRoLCBySGVpZ2h0KTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtyV2lkdGgsIHJIZWlnaHRdO1xuICB9XG4gIGlmIChhID09PSAwICYmIGQgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WSAqIGMgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RYICogYiArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RZICsgZGVzdEgpICogYyArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RYICsgZGVzdFcpICogYiArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMCwgTWF0aC5zaWduKGIpLCBNYXRoLnNpZ24oYyksIDAsIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCBySGVpZ2h0LCByV2lkdGgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JIZWlnaHQsIHJXaWR0aF07XG4gIH1cbiAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKTtcbiAgY29uc3Qgc2NhbGVYID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgY29uc3Qgc2NhbGVZID0gTWF0aC5oeXBvdChjLCBkKTtcbiAgcmV0dXJuIFtzY2FsZVggKiBkZXN0Vywgc2NhbGVZICogZGVzdEhdO1xufVxuZnVuY3Rpb24gY29tcGlsZVR5cGUzR2x5cGgoaW1nRGF0YSkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBpbWdEYXRhO1xuICBpZiAod2lkdGggPiBNQVhfU0laRV9UT19DT01QSUxFIHx8IGhlaWdodCA+IE1BWF9TSVpFX1RPX0NPTVBJTEUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBQT0lOVF9UT19QUk9DRVNTX0xJTUlUID0gMTAwMDtcbiAgY29uc3QgUE9JTlRfVFlQRVMgPSBuZXcgVWludDhBcnJheShbMCwgMiwgNCwgMCwgMSwgMCwgNSwgNCwgOCwgMTAsIDAsIDgsIDAsIDIsIDEsIDBdKTtcbiAgY29uc3Qgd2lkdGgxID0gd2lkdGggKyAxO1xuICBsZXQgcG9pbnRzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgxICogKGhlaWdodCArIDEpKTtcbiAgbGV0IGksIGosIGowO1xuICBjb25zdCBsaW5lU2l6ZSA9IHdpZHRoICsgNyAmIH43O1xuICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KGxpbmVTaXplICogaGVpZ2h0KSxcbiAgICBwb3MgPSAwO1xuICBmb3IgKGNvbnN0IGVsZW0gb2YgaW1nRGF0YS5kYXRhKSB7XG4gICAgbGV0IG1hc2sgPSAxMjg7XG4gICAgd2hpbGUgKG1hc2sgPiAwKSB7XG4gICAgICBkYXRhW3BvcysrXSA9IGVsZW0gJiBtYXNrID8gMCA6IDI1NTtcbiAgICAgIG1hc2sgPj49IDE7XG4gICAgfVxuICB9XG4gIGxldCBjb3VudCA9IDA7XG4gIHBvcyA9IDA7XG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbMF0gPSAxO1xuICAgICsrY291bnQ7XG4gIH1cbiAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICBpZiAoZGF0YVtwb3NdICE9PSBkYXRhW3BvcyArIDFdKSB7XG4gICAgICBwb2ludHNbal0gPSBkYXRhW3Bvc10gPyAyIDogMTtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbal0gPSAyO1xuICAgICsrY291bnQ7XG4gIH1cbiAgZm9yIChpID0gMTsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgcG9zID0gaSAqIGxpbmVTaXplO1xuICAgIGowID0gaSAqIHdpZHRoMTtcbiAgICBpZiAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gIT09IGRhdGFbcG9zXSkge1xuICAgICAgcG9pbnRzW2owXSA9IGRhdGFbcG9zXSA/IDEgOiA4O1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgbGV0IHN1bSA9IChkYXRhW3Bvc10gPyA0IDogMCkgKyAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gPyA4IDogMCk7XG4gICAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgIHN1bSA9IChzdW0gPj4gMikgKyAoZGF0YVtwb3MgKyAxXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplICsgMV0gPyA4IDogMCk7XG4gICAgICBpZiAoUE9JTlRfVFlQRVNbc3VtXSkge1xuICAgICAgICBwb2ludHNbajAgKyBqXSA9IFBPSU5UX1RZUEVTW3N1bV07XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgICBwb3MrKztcbiAgICB9XG4gICAgaWYgKGRhdGFbcG9zIC0gbGluZVNpemVdICE9PSBkYXRhW3Bvc10pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gMiA6IDQ7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBpZiAoY291bnQgPiBQT0lOVF9UT19QUk9DRVNTX0xJTUlUKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcG9zID0gbGluZVNpemUgKiAoaGVpZ2h0IC0gMSk7XG4gIGowID0gaSAqIHdpZHRoMTtcbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqMF0gPSA4O1xuICAgICsrY291bnQ7XG4gIH1cbiAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICBpZiAoZGF0YVtwb3NdICE9PSBkYXRhW3BvcyArIDFdKSB7XG4gICAgICBwb2ludHNbajAgKyBqXSA9IGRhdGFbcG9zXSA/IDQgOiA4O1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqMCArIGpdID0gNDtcbiAgICArK2NvdW50O1xuICB9XG4gIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzdGVwcyA9IG5ldyBJbnQzMkFycmF5KFswLCB3aWR0aDEsIC0xLCAwLCAtd2lkdGgxLCAwLCAwLCAwLCAxXSk7XG4gIGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gIGZvciAoaSA9IDA7IGNvdW50ICYmIGkgPD0gaGVpZ2h0OyBpKyspIHtcbiAgICBsZXQgcCA9IGkgKiB3aWR0aDE7XG4gICAgY29uc3QgZW5kID0gcCArIHdpZHRoO1xuICAgIHdoaWxlIChwIDwgZW5kICYmICFwb2ludHNbcF0pIHtcbiAgICAgIHArKztcbiAgICB9XG4gICAgaWYgKHAgPT09IGVuZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBhdGgubW92ZVRvKHAgJSB3aWR0aDEsIGkpO1xuICAgIGNvbnN0IHAwID0gcDtcbiAgICBsZXQgdHlwZSA9IHBvaW50c1twXTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBzdGVwID0gc3RlcHNbdHlwZV07XG4gICAgICBkbyB7XG4gICAgICAgIHAgKz0gc3RlcDtcbiAgICAgIH0gd2hpbGUgKCFwb2ludHNbcF0pO1xuICAgICAgY29uc3QgcHAgPSBwb2ludHNbcF07XG4gICAgICBpZiAocHAgIT09IDUgJiYgcHAgIT09IDEwKSB7XG4gICAgICAgIHR5cGUgPSBwcDtcbiAgICAgICAgcG9pbnRzW3BdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBwcCAmIDB4MzMgKiB0eXBlID4+IDQ7XG4gICAgICAgIHBvaW50c1twXSAmPSB0eXBlID4+IDIgfCB0eXBlIDw8IDI7XG4gICAgICB9XG4gICAgICBwYXRoLmxpbmVUbyhwICUgd2lkdGgxLCBwIC8gd2lkdGgxIHwgMCk7XG4gICAgICBpZiAoIXBvaW50c1twXSkge1xuICAgICAgICAtLWNvdW50O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHAwICE9PSBwKTtcbiAgICAtLWk7XG4gIH1cbiAgZGF0YSA9IG51bGw7XG4gIHBvaW50cyA9IG51bGw7XG4gIGNvbnN0IGRyYXdPdXRsaW5lID0gZnVuY3Rpb24gKGMpIHtcbiAgICBjLnNhdmUoKTtcbiAgICBjLnNjYWxlKDEgLyB3aWR0aCwgLTEgLyBoZWlnaHQpO1xuICAgIGMudHJhbnNsYXRlKDAsIC1oZWlnaHQpO1xuICAgIGMuZmlsbChwYXRoKTtcbiAgICBjLmJlZ2luUGF0aCgpO1xuICAgIGMucmVzdG9yZSgpO1xuICB9O1xuICByZXR1cm4gZHJhd091dGxpbmU7XG59XG5jbGFzcyBDYW52YXNFeHRyYVN0YXRlIHtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuYWxwaGFJc1NoYXBlID0gZmFsc2U7XG4gICAgdGhpcy5mb250U2l6ZSA9IDA7XG4gICAgdGhpcy5mb250U2l6ZVNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRNYXRyaXggPSBJREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuZm9udE1hdHJpeCA9IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMubGVhZGluZyA9IDA7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGluZVggPSAwO1xuICAgIHRoaXMubGluZVkgPSAwO1xuICAgIHRoaXMuY2hhclNwYWNpbmcgPSAwO1xuICAgIHRoaXMud29yZFNwYWNpbmcgPSAwO1xuICAgIHRoaXMudGV4dEhTY2FsZSA9IDE7XG4gICAgdGhpcy50ZXh0UmVuZGVyaW5nTW9kZSA9IFRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gICAgdGhpcy50ZXh0UmlzZSA9IDA7XG4gICAgdGhpcy5maWxsQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgdGhpcy5wYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMuZmlsbEFscGhhID0gMTtcbiAgICB0aGlzLnN0cm9rZUFscGhhID0gMTtcbiAgICB0aGlzLmxpbmVXaWR0aCA9IDE7XG4gICAgdGhpcy5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zlck1hcHMgPSBcIm5vbmVcIjtcbiAgICB0aGlzLnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgY2xvbmUuY2xpcEJveCA9IHRoaXMuY2xpcEJveC5zbGljZSgpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICBzZXRDdXJyZW50UG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuICB1cGRhdGVQYXRoTWluTWF4KHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIFt4LCB5XSA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gsIHldLCB0cmFuc2Zvcm0pO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgeCk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCB5KTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHgpO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgeSk7XG4gIH1cbiAgdXBkYXRlUmVjdE1pbk1heCh0cmFuc2Zvcm0sIHJlY3QpIHtcbiAgICBjb25zdCBwMSA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0ocmVjdCwgdHJhbnNmb3JtKTtcbiAgICBjb25zdCBwMiA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0ocmVjdC5zbGljZSgyKSwgdHJhbnNmb3JtKTtcbiAgICBjb25zdCBwMyA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMF0sIHJlY3RbM11dLCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHA0ID0gVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFsyXSwgcmVjdFsxXV0sIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCBwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSk7XG4gIH1cbiAgdXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpIHtcbiAgICBVdGlsLnNjYWxlTWluTWF4KHRyYW5zZm9ybSwgbWluTWF4KTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIG1pbk1heFswXSk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCBtaW5NYXhbMV0pO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgbWluTWF4WzJdKTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIG1pbk1heFszXSk7XG4gIH1cbiAgdXBkYXRlQ3VydmVQYXRoTWluTWF4KHRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpIHtcbiAgICBjb25zdCBib3ggPSBVdGlsLmJlemllckJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluTWF4KTtcbiAgICBpZiAobWluTWF4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUmVjdE1pbk1heCh0cmFuc2Zvcm0sIGJveCk7XG4gIH1cbiAgZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIGNvbnN0IGJveCA9IFt0aGlzLm1pblgsIHRoaXMubWluWSwgdGhpcy5tYXhYLCB0aGlzLm1heFldO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICB1bnJlYWNoYWJsZShcIlN0cm9rZSBib3VuZGluZyBib3ggbXVzdCBpbmNsdWRlIHRyYW5zZm9ybS5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHhTdHJva2VQYWQgPSBzY2FsZVswXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IHlTdHJva2VQYWQgPSBzY2FsZVsxXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGJveFswXSAtPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzFdIC09IHlTdHJva2VQYWQ7XG4gICAgICBib3hbMl0gKz0geFN0cm9rZVBhZDtcbiAgICAgIGJveFszXSArPSB5U3Ryb2tlUGFkO1xuICAgIH1cbiAgICByZXR1cm4gYm94O1xuICB9XG4gIHVwZGF0ZUNsaXBGcm9tUGF0aCgpIHtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSBVdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChpbnRlcnNlY3QgfHwgWzAsIDAsIDAsIDBdKTtcbiAgfVxuICBpc0VtcHR5Q2xpcCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YID09PSBJbmZpbml0eTtcbiAgfVxuICBzdGFydE5ld1BhdGhBbmRDbGlwQm94KGJveCkge1xuICAgIHRoaXMuY2xpcEJveCA9IGJveDtcbiAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcbiAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heFggPSAwO1xuICAgIHRoaXMubWF4WSA9IDA7XG4gIH1cbiAgZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IFBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICByZXR1cm4gVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgdHJhbnNmb3JtKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlRGF0YShjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKHR5cGVvZiBJbWFnZURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgaW1nRGF0YSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMCxcbiAgICBkZXN0UG9zO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgbGV0IGksIGosIHRoaXNDaHVua0hlaWdodCwgZWxlbXNJblRoaXNDaHVuaztcbiAgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFApIHtcbiAgICBjb25zdCBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIsIDAsIGRlc3QuYnl0ZUxlbmd0aCA+PiAyKTtcbiAgICBjb25zdCBkZXN0MzJEYXRhTGVuZ3RoID0gZGVzdDMyLmxlbmd0aDtcbiAgICBjb25zdCBmdWxsU3JjRGlmZiA9IHdpZHRoICsgNyA+PiAzO1xuICAgIGNvbnN0IHdoaXRlID0gMHhmZmZmZmZmZjtcbiAgICBjb25zdCBibGFjayA9IHV0aWxfRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgY29uc3Qga0VuZCA9IHNyY0RpZmYgPiBmdWxsU3JjRGlmZiA/IHdpZHRoIDogc3JjRGlmZiAqIDggLSA3O1xuICAgICAgICBjb25zdCBrRW5kVW5yb2xsZWQgPSBrRW5kICYgfjc7XG4gICAgICAgIGxldCBtYXNrID0gMDtcbiAgICAgICAgbGV0IHNyY0J5dGUgPSAwO1xuICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTI4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDE2ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgayA8IGtFbmQ7IGsrKykge1xuICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICAgIG1hc2sgPSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIG1hc2sgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChkZXN0UG9zIDwgZGVzdDMyRGF0YUxlbmd0aCkge1xuICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgaiA9IDA7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogRlVMTF9DSFVOS19IRUlHSFQgKiA0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIHNyY1BvcyArPSBlbGVtc0luVGhpc0NodW5rO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgaiArPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB9XG4gICAgaWYgKGkgPCB0b3RhbENodW5rcykge1xuICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogcGFydGlhbENodW5rSGVpZ2h0ICogNDtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5SR0JfMjRCUFApIHtcbiAgICB0aGlzQ2h1bmtIZWlnaHQgPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGlmIChpID49IGZ1bGxDaHVua3MpIHtcbiAgICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgICB9XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IGVsZW1zSW5UaGlzQ2h1bms7IGotLTspIHtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmFkIGltYWdlIGtpbmQ6ICR7aW1nRGF0YS5raW5kfWApO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZU1hc2soY3R4LCBpbWdEYXRhKSB7XG4gIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nRGF0YS5iaXRtYXAsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDA7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICBjb25zdCB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICh7XG4gICAgICBzcmNQb3NcbiAgICB9ID0gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICAgICAgc3JjLFxuICAgICAgc3JjUG9zLFxuICAgICAgZGVzdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzQ2h1bmtIZWlnaHQsXG4gICAgICBub25CbGFja0NvbG9yOiAwXG4gICAgfSkpO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5Q3R4U3RhdGUoc291cmNlQ3R4LCBkZXN0Q3R4KSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBbXCJzdHJva2VTdHlsZVwiLCBcImZpbGxTdHlsZVwiLCBcImZpbGxSdWxlXCIsIFwiZ2xvYmFsQWxwaGFcIiwgXCJsaW5lV2lkdGhcIiwgXCJsaW5lQ2FwXCIsIFwibGluZUpvaW5cIiwgXCJtaXRlckxpbWl0XCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwiZm9udFwiLCBcImZpbHRlclwiXTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHNvdXJjZUN0eFtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdEN0eFtwcm9wZXJ0eV0gPSBzb3VyY2VDdHhbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBpZiAoc291cmNlQ3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZXN0Q3R4LnNldExpbmVEYXNoKHNvdXJjZUN0eC5nZXRMaW5lRGFzaCgpKTtcbiAgICBkZXN0Q3R4LmxpbmVEYXNoT2Zmc2V0ID0gc291cmNlQ3R4LmxpbmVEYXNoT2Zmc2V0O1xuICB9XG59XG5mdW5jdGlvbiByZXNldEN0eFRvRGVmYXVsdChjdHgpIHtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IFwiIzAwMDAwMFwiO1xuICBjdHguZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gIGN0eC5saW5lQ2FwID0gXCJidXR0XCI7XG4gIGN0eC5saW5lSm9pbiA9IFwibWl0ZXJcIjtcbiAgY3R4Lm1pdGVyTGltaXQgPSAxMDtcbiAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgY3R4LmZvbnQgPSBcIjEwcHggc2Fucy1zZXJpZlwiO1xuICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gIH1cbiAgaWYgKCFpc05vZGVKUykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbHRlclxuICAgIH0gPSBjdHg7XG4gICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQodHJhbnNmb3JtLCBpbnRlcnBvbGF0ZSkge1xuICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBzY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtKTtcbiAgc2NhbGVbMF0gPSBNYXRoLmZyb3VuZChzY2FsZVswXSk7XG4gIHNjYWxlWzFdID0gTWF0aC5mcm91bmQoc2NhbGVbMV0pO1xuICBjb25zdCBhY3R1YWxTY2FsZSA9IE1hdGguZnJvdW5kKChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICByZXR1cm4gc2NhbGVbMF0gPD0gYWN0dWFsU2NhbGUgJiYgc2NhbGVbMV0gPD0gYWN0dWFsU2NhbGU7XG59XG5jb25zdCBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5jb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuY29uc3QgTk9STUFMX0NMSVAgPSB7fTtcbmNvbnN0IEVPX0NMSVAgPSB7fTtcbmNsYXNzIENhbnZhc0dyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzQ3R4LCBjb21tb25PYmpzLCBvYmpzLCBjYW52YXNGYWN0b3J5LCBmaWx0ZXJGYWN0b3J5LCB7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgIG1hcmtlZENvbnRlbnRTdGFjayA9IG51bGxcbiAgfSwgYW5ub3RhdGlvbkNhbnZhc01hcCwgcGFnZUNvbG9ycykge1xuICAgIHRoaXMuY3R4ID0gY2FudmFzQ3R4O1xuICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5zdGF0ZVN0YWNrID0gW107XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5yZXMgPSBudWxsO1xuICAgIHRoaXMueG9ianMgPSBudWxsO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5ncm91cFN0YWNrID0gW107XG4gICAgdGhpcy5wcm9jZXNzaW5nVHlwZTMgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwgPSAwO1xuICAgIHRoaXMuc21hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuc21hc2tDb3VudGVyID0gMDtcbiAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrID0gbWFya2VkQ29udGVudFN0YWNrIHx8IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWCA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVkgPSAxO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IFstMSwgMF07XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcCA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXRPYmplY3QoZGF0YSwgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KGRhdGEpIDogdGhpcy5vYmpzLmdldChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIGJlZ2luRHJhd2luZyh7XG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdwb3J0LFxuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIGJhY2tncm91bmQgPSBudWxsXG4gIH0pIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHNhdmVkRmlsbFN0eWxlID0gdGhpcy5jdHguZmlsbFN0eWxlO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmQgfHwgXCIjZmZmZmZmXCI7XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gc2F2ZWRGaWxsU3R5bGU7XG4gICAgaWYgKHRyYW5zcGFyZW5jeSkge1xuICAgICAgY29uc3QgdHJhbnNwYXJlbnRDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInRyYW5zcGFyZW50XCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jb21wb3NpdGVDdHggPSB0aGlzLmN0eDtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSB0cmFuc3BhcmVudENhbnZhcy5jYW52YXM7XG4gICAgICB0aGlzLmN0eCA9IHRyYW5zcGFyZW50Q2FudmFzLmNvbnRleHQ7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4uZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmNvbXBvc2l0ZUN0eCkpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVggPSB0cmFuc2Zvcm1bMF07XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWSA9IHRyYW5zZm9ybVswXTtcbiAgICB9XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnZpZXdwb3J0LnRyYW5zZm9ybSk7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gdmlld3BvcnQuc2NhbGU7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gIH1cbiAgZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QsIGV4ZWN1dGlvblN0YXJ0SWR4LCBjb250aW51ZUNhbGxiYWNrLCBzdGVwcGVyKSB7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgbGV0IGkgPSBleGVjdXRpb25TdGFydElkeCB8fCAwO1xuICAgIGNvbnN0IGFyZ3NBcnJheUxlbiA9IGFyZ3NBcnJheS5sZW5ndGg7XG4gICAgaWYgKGFyZ3NBcnJheUxlbiA9PT0gaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rT3BlcmF0aW9ucyA9IGFyZ3NBcnJheUxlbiAtIGkgPiBFWEVDVVRJT05fU1RFUFMgJiYgdHlwZW9mIGNvbnRpbnVlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBjb25zdCBlbmRUaW1lID0gY2h1bmtPcGVyYXRpb25zID8gRGF0ZS5ub3coKSArIEVYRUNVVElPTl9USU1FIDogMDtcbiAgICBsZXQgc3RlcHMgPSAwO1xuICAgIGNvbnN0IGNvbW1vbk9ianMgPSB0aGlzLmNvbW1vbk9ianM7XG4gICAgY29uc3Qgb2JqcyA9IHRoaXMub2JqcztcbiAgICBsZXQgZm5JZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHN0ZXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBmbklkID0gZm5BcnJheVtpXTtcbiAgICAgIGlmIChmbklkICE9PSBPUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICB0aGlzW2ZuSWRdLmFwcGx5KHRoaXMsIGFyZ3NBcnJheVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcE9iaklkIG9mIGFyZ3NBcnJheVtpXSkge1xuICAgICAgICAgIGNvbnN0IG9ianNQb29sID0gZGVwT2JqSWQuc3RhcnRzV2l0aChcImdfXCIpID8gY29tbW9uT2JqcyA6IG9ianM7XG4gICAgICAgICAgaWYgKCFvYmpzUG9vbC5oYXMoZGVwT2JqSWQpKSB7XG4gICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgICBpZiAoaSA9PT0gYXJnc0FycmF5TGVuKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rT3BlcmF0aW9ucyAmJiArK3N0ZXBzID4gRVhFQ1VUSU9OX1NURVBTKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kVGltZSkge1xuICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNyZXN0b3JlSW5pdGlhbFN0YXRlKCkge1xuICAgIHdoaWxlICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoIHx8IHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAodGhpcy50cmFuc3BhcmVudENhbnZhcykge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmNvbXBvc2l0ZUN0eDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRyYW5zcGFyZW50Q2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBlbmREcmF3aW5nKCkge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgY2FjaGUgb2YgdGhpcy5fY2FjaGVkQml0bWFwc01hcC52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBjYW52YXMgb2YgY2FjaGUudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmNsZWFyKCk7XG4gICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICB9XG4gICNkcmF3RmlsdGVyKCkge1xuICAgIGlmICh0aGlzLnBhZ2VDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGhjbUZpbHRlcklkID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLnBhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy5wYWdlQ29sb3JzLmJhY2tncm91bmQpO1xuICAgICAgaWYgKGhjbUZpbHRlcklkICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb25zdCBzYXZlZEZpbHRlciA9IHRoaXMuY3R4LmZpbHRlcjtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gaGNtRmlsdGVySWQ7XG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBzYXZlZEZpbHRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NjYWxlSW1hZ2UoaW1nLCBpbnZlcnNlVHJhbnNmb3JtKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbWcud2lkdGggPz8gaW1nLmRpc3BsYXlXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWcuaGVpZ2h0ID8/IGltZy5kaXNwbGF5SGVpZ2h0O1xuICAgIGxldCB3aWR0aFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzBdLCBpbnZlcnNlVHJhbnNmb3JtWzFdKSwgMSk7XG4gICAgbGV0IGhlaWdodFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzJdLCBpbnZlcnNlVHJhbnNmb3JtWzNdKSwgMSk7XG4gICAgbGV0IHBhaW50V2lkdGggPSB3aWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGxldCB0bXBDYW52YXNJZCA9IFwicHJlc2NhbGUxXCI7XG4gICAgbGV0IHRtcENhbnZhcywgdG1wQ3R4O1xuICAgIHdoaWxlICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSB8fCBoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICBsZXQgbmV3V2lkdGggPSBwYWludFdpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodDtcbiAgICAgIGlmICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSkge1xuICAgICAgICBuZXdXaWR0aCA9IHBhaW50V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50V2lkdGggLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludFdpZHRoIC8gMik7XG4gICAgICAgIHdpZHRoU2NhbGUgLz0gcGFpbnRXaWR0aCAvIG5ld1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50SGVpZ2h0IC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgaGVpZ2h0U2NhbGUgLz0gcGFpbnRIZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyh0bXBDYW52YXNJZCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHguZHJhd0ltYWdlKGltZywgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgaW1nID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIHBhaW50V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHBhaW50SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdG1wQ2FudmFzSWQgPSB0bXBDYW52YXNJZCA9PT0gXCJwcmVzY2FsZTFcIiA/IFwicHJlc2NhbGUyXCIgOiBcInByZXNjYWxlMVwiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaW1nLFxuICAgICAgcGFpbnRXaWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICBfY3JlYXRlTWFza0NhbnZhcyhpbWcpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWc7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgbGV0IGNhY2hlLCBjYWNoZUtleSwgc2NhbGVkLCBtYXNrQ2FudmFzO1xuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShpc1BhdHRlcm5GaWxsID8gY3VycmVudFRyYW5zZm9ybSA6IFtjdXJyZW50VHJhbnNmb3JtLnNsaWNlKDAsIDQpLCBmaWxsQ29sb3JdKTtcbiAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGVkQml0bWFwc01hcC5nZXQobWFpbktleSk7XG4gICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWNoZWRJbWFnZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVsxXSwgY3VycmVudFRyYW5zZm9ybVszXSkgKyBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW52YXM6IGNhY2hlZEltYWdlLFxuICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc2NhbGVkID0gY2FjaGVkSW1hZ2U7XG4gICAgfVxuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDYW52YXMuY29udGV4dCwgaW1nKTtcbiAgICB9XG4gICAgbGV0IG1hc2tUb0NhbnZhcyA9IFV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFsxIC8gd2lkdGgsIDAsIDAsIC0xIC8gaGVpZ2h0LCAwLCAwXSk7XG4gICAgbWFza1RvQ2FudmFzID0gVXRpbC50cmFuc2Zvcm0obWFza1RvQ2FudmFzLCBbMSwgMCwgMCwgMSwgMCwgLWhlaWdodF0pO1xuICAgIGNvbnN0IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSA9IFV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBtYXNrVG9DYW52YXMpO1xuICAgIGNvbnN0IGRyYXduV2lkdGggPSBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSB8fCAxO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gTWF0aC5yb3VuZChtYXhZIC0gbWluWSkgfHwgMTtcbiAgICBjb25zdCBmaWxsQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJmaWxsQ2FudmFzXCIsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBmaWxsQ3R4ID0gZmlsbENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IG9mZnNldFggPSBtaW5YO1xuICAgIGNvbnN0IG9mZnNldFkgPSBtaW5ZO1xuICAgIGZpbGxDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZmlsbEN0eC50cmFuc2Zvcm0oLi4ubWFza1RvQ2FudmFzKTtcbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShtYXNrQ2FudmFzLmNhbnZhcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoZmlsbEN0eCkpO1xuICAgICAgc2NhbGVkID0gc2NhbGVkLmltZztcbiAgICAgIGlmIChjYWNoZSAmJiBpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgc2NhbGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmlsbEN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZ2V0Q3VycmVudFRyYW5zZm9ybShmaWxsQ3R4KSwgaW1nLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoZmlsbEN0eCwgc2NhbGVkLCAwLCAwLCBzY2FsZWQud2lkdGgsIHNjYWxlZC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZpbGxDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcbiAgICBjb25zdCBpbnZlcnNlID0gVXRpbC50cmFuc2Zvcm0oZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoZmlsbEN0eCksIFsxLCAwLCAwLCAxLCAtb2Zmc2V0WCwgLW9mZnNldFldKTtcbiAgICBmaWxsQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGludmVyc2UsIFBhdGhUeXBlLkZJTEwpIDogZmlsbENvbG9yO1xuICAgIGZpbGxDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGNhY2hlICYmICFpc1BhdHRlcm5GaWxsKSB7XG4gICAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmRlbGV0ZShcImZpbGxDYW52YXNcIik7XG4gICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGZpbGxDYW52YXMuY2FudmFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogZmlsbENhbnZhcy5jYW52YXMsXG4gICAgICBvZmZzZXRYOiBNYXRoLnJvdW5kKG9mZnNldFgpLFxuICAgICAgb2Zmc2V0WTogTWF0aC5yb3VuZChvZmZzZXRZKVxuICAgIH07XG4gIH1cbiAgc2V0TGluZVdpZHRoKHdpZHRoKSB7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLmN1cnJlbnQubGluZVdpZHRoKSB7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aDtcbiAgfVxuICBzZXRMaW5lQ2FwKHN0eWxlKSB7XG4gICAgdGhpcy5jdHgubGluZUNhcCA9IExJTkVfQ0FQX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TGluZUpvaW4oc3R5bGUpIHtcbiAgICB0aGlzLmN0eC5saW5lSm9pbiA9IExJTkVfSk9JTl9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldE1pdGVyTGltaXQobGltaXQpIHtcbiAgICB0aGlzLmN0eC5taXRlckxpbWl0ID0gbGltaXQ7XG4gIH1cbiAgc2V0RGFzaChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgfVxuICB9XG4gIHNldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHt9XG4gIHNldEZsYXRuZXNzKGZsYXRuZXNzKSB7fVxuICBzZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RhdGVzKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMQ1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMSlwiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIHRoaXMuc2V0RGFzaCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUklcIjpcbiAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3ModmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIHRoaXMuc2V0Rm9udCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ0FcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJCTVwiOlxuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcbiAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRSXCI6XG4gICAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRGaWx0ZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgaW5TTWFza01vZGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zdXNwZW5kZWRDdHg7XG4gIH1cbiAgY2hlY2tTTWFza1N0YXRlKCkge1xuICAgIGNvbnN0IGluU01hc2tNb2RlID0gdGhpcy5pblNNYXNrTW9kZTtcbiAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmICFpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5iZWdpblNNYXNrTW9kZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiBpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gIH1cbiAgYmVnaW5TTWFza01vZGUoKSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJlZ2luU01hc2tNb2RlIGNhbGxlZCB3aGlsZSBhbHJlYWR5IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGRyYXduV2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IGNhY2hlSWQgPSBcInNtYXNrR3JvdXBBdFwiICsgdGhpcy5ncm91cExldmVsO1xuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLmN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2V0VHJhbnNmb3JtKC4uLmdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5zdXNwZW5kZWRDdHgpKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIGN0eCk7XG4gICAgbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICB9XG4gIGVuZFNNYXNrTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVuZFNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgbm90IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIHRoaXMuY3R4Ll9yZW1vdmVNaXJyb3JpbmcoKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgfVxuICBjb21wb3NlKGRpcnR5Qm94KSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkaXJ0eUJveCkge1xuICAgICAgZGlydHlCb3ggPSBbMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlCb3hbMF0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzBdKTtcbiAgICAgIGRpcnR5Qm94WzFdID0gTWF0aC5mbG9vcihkaXJ0eUJveFsxXSk7XG4gICAgICBkaXJ0eUJveFsyXSA9IE1hdGguY2VpbChkaXJ0eUJveFsyXSk7XG4gICAgICBkaXJ0eUJveFszXSA9IE1hdGguY2VpbChkaXJ0eUJveFszXSk7XG4gICAgfVxuICAgIGNvbnN0IHNtYXNrID0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrO1xuICAgIGNvbnN0IHN1c3BlbmRlZEN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuY29tcG9zZVNNYXNrKHN1c3BlbmRlZEN0eCwgc21hc2ssIHRoaXMuY3R4LCBkaXJ0eUJveCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgY29tcG9zZVNNYXNrKGN0eCwgc21hc2ssIGxheWVyQ3R4LCBsYXllckJveCkge1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WCA9IGxheWVyQm94WzBdO1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WSA9IGxheWVyQm94WzFdO1xuICAgIGNvbnN0IGxheWVyV2lkdGggPSBsYXllckJveFsyXSAtIGxheWVyT2Zmc2V0WDtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IGxheWVyQm94WzNdIC0gbGF5ZXJPZmZzZXRZO1xuICAgIGlmIChsYXllcldpZHRoID09PSAwIHx8IGxheWVySGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2VuZXJpY0NvbXBvc2VTTWFzayhzbWFzay5jb250ZXh0LCBsYXllckN0eCwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHQsIHNtYXNrLnN1YnR5cGUsIHNtYXNrLmJhY2tkcm9wLCBzbWFzay50cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHNtYXNrLm9mZnNldFgsIHNtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShsYXllckN0eC5jYW52YXMsIDAsIDApO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZ2VuZXJpY0NvbXBvc2VTTWFzayhtYXNrQ3R4LCBsYXllckN0eCwgd2lkdGgsIGhlaWdodCwgc3VidHlwZSwgYmFja2Ryb3AsIHRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgbWFza09mZnNldFgsIG1hc2tPZmZzZXRZKSB7XG4gICAgbGV0IG1hc2tDYW52YXMgPSBtYXNrQ3R4LmNhbnZhcztcbiAgICBsZXQgbWFza1ggPSBsYXllck9mZnNldFggLSBtYXNrT2Zmc2V0WDtcbiAgICBsZXQgbWFza1kgPSBsYXllck9mZnNldFkgLSBtYXNrT2Zmc2V0WTtcbiAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgIGNvbnN0IGJhY2tkcm9wUkdCID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uYmFja2Ryb3ApO1xuICAgICAgaWYgKG1hc2tYIDwgMCB8fCBtYXNrWSA8IDAgfHwgbWFza1ggKyB3aWR0aCA+IG1hc2tDYW52YXMud2lkdGggfHwgbWFza1kgKyBoZWlnaHQgPiBtYXNrQ2FudmFzLmhlaWdodCkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tFeHRlbnNpb25cIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5jb250ZXh0O1xuICAgICAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIC1tYXNrWCwgLW1hc2tZKTtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tYXRvcFwiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BSR0I7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgbWFza0NhbnZhcyA9IGNhbnZhcy5jYW52YXM7XG4gICAgICAgIG1hc2tYID0gbWFza1kgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFza0N0eC5zYXZlKCk7XG4gICAgICAgIG1hc2tDdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBtYXNrQ3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgY2xpcC5yZWN0KG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1hc2tDdHguY2xpcChjbGlwKTtcbiAgICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWF0b3BcIjtcbiAgICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBiYWNrZHJvcFJHQjtcbiAgICAgICAgbWFza0N0eC5maWxsUmVjdChtYXNrWCwgbWFza1ksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGF5ZXJDdHguc2F2ZSgpO1xuICAgIGxheWVyQ3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICBsYXllckN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgaWYgKHN1YnR5cGUgPT09IFwiQWxwaGFcIiAmJiB0cmFuc2Zlck1hcCkge1xuICAgICAgbGF5ZXJDdHguZmlsdGVyID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEFscGhhRmlsdGVyKHRyYW5zZmVyTWFwKTtcbiAgICB9IGVsc2UgaWYgKHN1YnR5cGUgPT09IFwiTHVtaW5vc2l0eVwiKSB7XG4gICAgICBsYXllckN0eC5maWx0ZXIgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkTHVtaW5vc2l0eUZpbHRlcih0cmFuc2Zlck1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgY2xpcC5yZWN0KGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBsYXllckN0eC5jbGlwKGNsaXApO1xuICAgIGxheWVyQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIjtcbiAgICBsYXllckN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgbWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0LCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgd2lkdGgsIGhlaWdodCk7XG4gICAgbGF5ZXJDdHgucmVzdG9yZSgpO1xuICB9XG4gIHNhdmUoKSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgICAgdGhpcy5zdXNwZW5kZWRDdHguc2F2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICB9XG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPT09IDAgJiYgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICAgIHRoaXMuc3VzcGVuZGVkQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCB0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdFBhdGgob3BzLCBhcmdzLCBtaW5NYXgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGxldCB4ID0gY3VycmVudC54LFxuICAgICAgeSA9IGN1cnJlbnQueTtcbiAgICBsZXQgc3RhcnRYLCBzdGFydFk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjb25zdCBpc1NjYWxpbmdNYXRyaXggPSBjdXJyZW50VHJhbnNmb3JtWzBdID09PSAwICYmIGN1cnJlbnRUcmFuc2Zvcm1bM10gPT09IDAgfHwgY3VycmVudFRyYW5zZm9ybVsxXSA9PT0gMCAmJiBjdXJyZW50VHJhbnNmb3JtWzJdID09PSAwO1xuICAgIGNvbnN0IG1pbk1heEZvckJlemllciA9IGlzU2NhbGluZ01hdHJpeCA/IG1pbk1heC5zbGljZSgwKSA6IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBpaSA9IG9wcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBzd2l0Y2ggKG9wc1tpXSB8IDApIHtcbiAgICAgICAgY2FzZSBPUFMucmVjdGFuZ2xlOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3QgeHcgPSB4ICsgd2lkdGg7XG4gICAgICAgICAgY29uc3QgeWggPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeWgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHloKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeWgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVSZWN0TWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIFt4LCB5LCB4dywgeWhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE9QUy5tb3ZlVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKCFpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudXBkYXRlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BTLmxpbmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUFMuY3VydmVUbzpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDRdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyA1XTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCB4LCB5KTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgeCwgeSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICBqICs9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BTLmN1cnZlVG8yOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdKTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgeCwgeSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUFMuY3VydmVUbzM6XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oYXJnc1tqXSwgYXJnc1tqICsgMV0sIHgsIHksIHgsIHkpO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgIGN1cnJlbnQudXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICB9XG4gICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICB9XG4gIHN0cm9rZShjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBzdHJva2VDb2xvciA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvcjtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGE7XG4gICAgaWYgKHRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3Ryb2tlQ29sb3IgPT09IFwib2JqZWN0XCIgJiYgc3Ryb2tlQ29sb3I/LmdldFBhdHRlcm4pIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNUUk9LRSk7XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZShmYWxzZSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aCh0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LmZpbGxBbHBoYTtcbiAgfVxuICBjbG9zZVN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuc3Ryb2tlKCk7XG4gIH1cbiAgZmlsbChjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgbGV0IG5lZWRSZXN0b3JlID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKTtcbiAgICAgIG5lZWRSZXN0b3JlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gdGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiBpbnRlcnNlY3QgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdFT0ZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGwoXCJldmVub2RkXCIpO1xuICAgICAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWVkUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKGludGVyc2VjdCk7XG4gICAgfVxuICB9XG4gIGVvRmlsbCgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbCgpO1xuICB9XG4gIGZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5maWxsKGZhbHNlKTtcbiAgICB0aGlzLnN0cm9rZShmYWxzZSk7XG4gICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICB9XG4gIGVvRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRU9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBlbmRQYXRoKCkge1xuICAgIHRoaXMuY29uc3VtZVBhdGgoKTtcbiAgfVxuICBjbGlwKCkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBOT1JNQUxfQ0xJUDtcbiAgfVxuICBlb0NsaXAoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IEVPX0NMSVA7XG4gIH1cbiAgYmVnaW5UZXh0KCkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gIH1cbiAgZW5kVGV4dCgpIHtcbiAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAocGF0aHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0aC50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnRyYW5zbGF0ZShwYXRoLngsIHBhdGgueSk7XG4gICAgICBwYXRoLmFkZFRvUGF0aChjdHgsIHBhdGguZm9udFNpemUpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5jbGlwKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUZXh0UGF0aHM7XG4gIH1cbiAgc2V0Q2hhclNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC5jaGFyU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0V29yZFNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC53b3JkU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRMZWFkaW5nKGxlYWRpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICB9XG4gIHNldEZvbnQoZm9udFJlZk5hbWUsIHNpemUpIHtcbiAgICBjb25zdCBmb250T2JqID0gdGhpcy5jb21tb25PYmpzLmdldChmb250UmVmTmFtZSk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBmb250IGZvciAke2ZvbnRSZWZOYW1lfWApO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgaWYgKGN1cnJlbnQuZm9udE1hdHJpeFswXSA9PT0gMCB8fCBjdXJyZW50LmZvbnRNYXRyaXhbM10gPT09IDApIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIGZvbnQgbWF0cml4IGZvciBmb250IFwiICsgZm9udFJlZk5hbWUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoZm9udE9iai5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gZm9udE9iai5sb2FkZWROYW1lIHx8IFwic2Fucy1zZXJpZlwiO1xuICAgIGNvbnN0IHR5cGVmYWNlID0gZm9udE9iai5zeXN0ZW1Gb250SW5mbz8uY3NzIHx8IGBcIiR7bmFtZX1cIiwgJHtmb250T2JqLmZhbGxiYWNrTmFtZX1gO1xuICAgIGxldCBib2xkID0gXCJub3JtYWxcIjtcbiAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgfSBlbHNlIGlmIChmb250T2JqLmJvbGQpIHtcbiAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICB9XG4gICAgY29uc3QgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICBsZXQgYnJvd3NlckZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoc2l6ZSA8IE1JTl9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1JTl9GT05UX1NJWkU7XG4gICAgfSBlbHNlIGlmIChzaXplID4gTUFYX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUFYX0ZPTlRfU0laRTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplU2NhbGUgPSBzaXplIC8gYnJvd3NlckZvbnRTaXplO1xuICAgIHRoaXMuY3R4LmZvbnQgPSBgJHtpdGFsaWN9ICR7Ym9sZH0gJHticm93c2VyRm9udFNpemV9cHggJHt0eXBlZmFjZX1gO1xuICB9XG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKG1vZGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICB9XG4gIHNldFRleHRSaXNlKHJpc2UpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJpc2UgPSByaXNlO1xuICB9XG4gIG1vdmVUZXh0KHgsIHkpIHtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCArPSB4O1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZICs9IHk7XG4gIH1cbiAgc2V0TGVhZGluZ01vdmVUZXh0KHgsIHkpIHtcbiAgICB0aGlzLnNldExlYWRpbmcoLXkpO1xuICAgIHRoaXMubW92ZVRleHQoeCwgeSk7XG4gIH1cbiAgc2V0VGV4dE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IE1hdGguaHlwb3QoYSwgYik7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgfVxuICBuZXh0TGluZSgpIHtcbiAgICB0aGlzLm1vdmVUZXh0KDAsIHRoaXMuY3VycmVudC5sZWFkaW5nKTtcbiAgfVxuICBwYWludENoYXIoY2hhcmFjdGVyLCB4LCB5LCBwYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IHRleHRSZW5kZXJpbmdNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemUgLyBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSB0ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgY29uc3QgaXNBZGRUb1BhdGhTZXQgPSAhISh0ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpO1xuICAgIGNvbnN0IHBhdHRlcm5GaWxsID0gY3VycmVudC5wYXR0ZXJuRmlsbCAmJiAhZm9udC5taXNzaW5nRmlsZTtcbiAgICBsZXQgYWRkVG9QYXRoO1xuICAgIGlmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBpc0FkZFRvUGF0aFNldCB8fCBwYXR0ZXJuRmlsbCkge1xuICAgICAgYWRkVG9QYXRoID0gZm9udC5nZXRQYXRoR2VuZXJhdG9yKHRoaXMuY29tbW9uT2JqcywgY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgaWYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IHBhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFRvUGF0aChjdHgsIGZvbnRTaXplKTtcbiAgICAgIGlmIChwYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguc3Ryb2tlVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBZGRUb1BhdGhTZXQpIHtcbiAgICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzIHx8PSBbXTtcbiAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIGFkZFRvUGF0aFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBjdHhcbiAgICB9ID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCAxMCwgMTApO1xuICAgIGN0eC5zY2FsZSgxLjUsIDEpO1xuICAgIGN0eC5maWxsVGV4dChcIklcIiwgMCwgMTApO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwLCAxMCkuZGF0YTtcbiAgICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgaWYgKGRhdGFbaV0gPiAwICYmIGRhdGFbaV0gPCAyNTUpIHtcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgZW5hYmxlZCk7XG4gIH1cbiAgc2hvd1RleHQoZ2x5cGhzKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGlmIChmb250LmlzVHlwZTNGb250KSB7XG4gICAgICByZXR1cm4gdGhpcy5zaG93VHlwZTNUZXh0KGdseXBocyk7XG4gICAgfVxuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBpZiAoZm9udFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZvbnRTaXplU2NhbGUgPSBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgdmVydGljYWwgPSBmb250LnZlcnRpY2FsO1xuICAgIGNvbnN0IHNwYWNpbmdEaXIgPSB2ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICBjb25zdCBkZWZhdWx0Vk1ldHJpY3MgPSBmb250LmRlZmF1bHRWTWV0cmljcztcbiAgICBjb25zdCB3aWR0aEFkdmFuY2VTY2FsZSA9IGZvbnRTaXplICogY3VycmVudC5mb250TWF0cml4WzBdO1xuICAgIGNvbnN0IHNpbXBsZUZpbGxUZXh0ID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTCAmJiAhZm9udC5kaXNhYmxlRm9udEZhY2UgJiYgIWN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSArIGN1cnJlbnQudGV4dFJpc2UpO1xuICAgIGlmIChmb250RGlyZWN0aW9uID4gMCkge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIDEpO1xuICAgIH1cbiAgICBsZXQgcGF0dGVyblRyYW5zZm9ybTtcbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyZW50LmZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCk7XG4gICAgICBwYXR0ZXJuVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBsZXQgbGluZVdpZHRoID0gY3VycmVudC5saW5lV2lkdGg7XG4gICAgY29uc3Qgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcbiAgICBpZiAoc2NhbGUgPT09IDAgfHwgbGluZVdpZHRoID09PSAwKSB7XG4gICAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lV2lkdGggLz0gc2NhbGU7XG4gICAgfVxuICAgIGlmIChmb250U2l6ZVNjYWxlICE9PSAxLjApIHtcbiAgICAgIGN0eC5zY2FsZShmb250U2l6ZVNjYWxlLCBmb250U2l6ZVNjYWxlKTtcbiAgICAgIGxpbmVXaWR0aCAvPSBmb250U2l6ZVNjYWxlO1xuICAgIH1cbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIGlmIChmb250LmlzSW52YWxpZFBERmpzRm9udCkge1xuICAgICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xuICAgICAgICBjaGFycy5wdXNoKGdseXBoLnVuaWNvZGUpO1xuICAgICAgICB3aWR0aCArPSBnbHlwaC53aWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsVGV4dChjaGFycy5qb2luKFwiXCIpLCAwLCAwKTtcbiAgICAgIGN1cnJlbnQueCArPSB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICogdGV4dEhTY2FsZTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCB4ID0gMCxcbiAgICAgIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBoc0xlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgZ2x5cGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgeCArPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3RvcmVOZWVkZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGdseXBoLmZvbnRDaGFyO1xuICAgICAgY29uc3QgYWNjZW50ID0gZ2x5cGguYWNjZW50O1xuICAgICAgbGV0IHNjYWxlZFgsIHNjYWxlZFk7XG4gICAgICBsZXQgd2lkdGggPSBnbHlwaC53aWR0aDtcbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBjb25zdCB2bWV0cmljID0gZ2x5cGgudm1ldHJpYyB8fCBkZWZhdWx0Vk1ldHJpY3M7XG4gICAgICAgIGNvbnN0IHZ4ID0gLShnbHlwaC52bWV0cmljID8gdm1ldHJpY1sxXSA6IHdpZHRoICogMC41KSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICBjb25zdCB2eSA9IHZtZXRyaWNbMl0gKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgd2lkdGggPSB2bWV0cmljID8gLXZtZXRyaWNbMF0gOiB3aWR0aDtcbiAgICAgICAgc2NhbGVkWCA9IHZ4IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgc2NhbGVkWSA9ICh4ICsgdnkpIC8gZm9udFNpemVTY2FsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlZFggPSB4IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgc2NhbGVkWSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZm9udC5yZW1lYXN1cmUgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVkV2lkdGggPSBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKS53aWR0aCAqIDEwMDAgLyBmb250U2l6ZSAqIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIGlmICh3aWR0aCA8IG1lYXN1cmVkV2lkdGggJiYgdGhpcy5pc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCkge1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlclNjYWxlWCA9IHdpZHRoIC8gbWVhc3VyZWRXaWR0aDtcbiAgICAgICAgICByZXN0b3JlTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGN0eC5zY2FsZShjaGFyYWN0ZXJTY2FsZVgsIDEpO1xuICAgICAgICAgIHNjYWxlZFggLz0gY2hhcmFjdGVyU2NhbGVYO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoICE9PSBtZWFzdXJlZFdpZHRoKSB7XG4gICAgICAgICAgc2NhbGVkWCArPSAod2lkdGggLSBtZWFzdXJlZFdpZHRoKSAvIDIwMDAgKiBmb250U2l6ZSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIChnbHlwaC5pc0luRm9udCB8fCBmb250Lm1pc3NpbmdGaWxlKSkge1xuICAgICAgICBpZiAoc2ltcGxlRmlsbFRleHQgJiYgIWFjY2VudCkge1xuICAgICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSwgcGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICAgICAgaWYgKGFjY2VudCkge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WCA9IHNjYWxlZFggKyBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRZID0gc2NhbGVkWSAtIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC55IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFyV2lkdGggPSB2ZXJ0aWNhbCA/IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgLSBzcGFjaW5nICogZm9udERpcmVjdGlvbiA6IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKyBzcGFjaW5nICogZm9udERpcmVjdGlvbjtcbiAgICAgIHggKz0gY2hhcldpZHRoO1xuICAgICAgaWYgKHJlc3RvcmVOZWVkZWQpIHtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBjdXJyZW50LnkgLT0geDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC54ICs9IHggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgc2hvd1R5cGUzVGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IGZvbnQudmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBmb250TWF0cml4ID0gY3VycmVudC5mb250TWF0cml4IHx8IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgaXNUZXh0SW52aXNpYmxlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuSU5WSVNJQkxFO1xuICAgIGxldCBpLCBnbHlwaCwgd2lkdGgsIHNwYWNpbmdMZW5ndGg7XG4gICAgaWYgKGlzVGV4dEludmlzaWJsZSB8fCBmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSk7XG4gICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIGZvbnREaXJlY3Rpb24pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNwYWNpbmdMZW5ndGggPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZShzcGFjaW5nTGVuZ3RoLCAwKTtcbiAgICAgICAgY3VycmVudC54ICs9IHNwYWNpbmdMZW5ndGggKiB0ZXh0SFNjYWxlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IGZvbnQuY2hhclByb2NPcGVyYXRvckxpc3RbZ2x5cGgub3BlcmF0b3JMaXN0SWRdO1xuICAgICAgaWYgKCFvcGVyYXRvckxpc3QpIHtcbiAgICAgICAgd2FybihgVHlwZTMgY2hhcmFjdGVyIFwiJHtnbHlwaC5vcGVyYXRvckxpc3RJZH1cIiBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gZ2x5cGg7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemUsIGZvbnRTaXplKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi5mb250TWF0cml4KTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtnbHlwaC53aWR0aCwgMF0sIGZvbnRNYXRyaXgpO1xuICAgICAgd2lkdGggPSB0cmFuc2Zvcm1lZFswXSAqIGZvbnRTaXplICsgc3BhY2luZztcbiAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gIH1cbiAgc2V0Q2hhcldpZHRoKHhXaWR0aCwgeVdpZHRoKSB7fVxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHMoeFdpZHRoLCB5V2lkdGgsIGxseCwgbGx5LCB1cngsIHVyeSkge1xuICAgIHRoaXMuY3R4LnJlY3QobGx4LCBsbHksIHVyeCAtIGxseCwgdXJ5IC0gbGx5KTtcbiAgICB0aGlzLmN0eC5jbGlwKCk7XG4gICAgdGhpcy5lbmRQYXRoKCk7XG4gIH1cbiAgZ2V0Q29sb3JOX1BhdHRlcm4oSVIpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAoSVJbMF0gPT09IFwiVGlsaW5nUGF0dGVyblwiKSB7XG4gICAgICBjb25zdCBjb2xvciA9IElSWzFdO1xuICAgICAgY29uc3QgYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybSB8fCBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIGNvbnN0IGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHtcbiAgICAgICAgY3JlYXRlQ2FudmFzR3JhcGhpY3M6IGN0eCA9PiBuZXcgQ2FudmFzR3JhcGhpY3MoY3R4LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWc6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgICAgICAgIG1hcmtlZENvbnRlbnRTdGFjazogdGhpcy5tYXJrZWRDb250ZW50U3RhY2tcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgICBwYXR0ZXJuID0gbmV3IFRpbGluZ1BhdHRlcm4oSVIsIGNvbG9yLCB0aGlzLmN0eCwgY2FudmFzR3JhcGhpY3NGYWN0b3J5LCBiYXNlVHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4oSVJbMV0sIElSWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2V0U3Ryb2tlQ29sb3JOKCkge1xuICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgfVxuICBzZXRGaWxsQ29sb3JOKCkge1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gdHJ1ZTtcbiAgfVxuICBzZXRTdHJva2VSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgfVxuICBzZXRTdHJva2VUcmFuc3BhcmVudCgpIHtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgfVxuICBzZXRGaWxsUkdCQ29sb3IociwgZywgYikge1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBzZXRGaWxsVHJhbnNwYXJlbnQoKSB7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBfZ2V0UGF0dGVybihvYmpJZCwgbWF0cml4ID0gbnVsbCkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmICh0aGlzLmNhY2hlZFBhdHRlcm5zLmhhcyhvYmpJZCkpIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLmNhY2hlZFBhdHRlcm5zLmdldChvYmpJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSBnZXRTaGFkaW5nUGF0dGVybih0aGlzLmdldE9iamVjdChvYmpJZCkpO1xuICAgICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5zZXQob2JqSWQsIHBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAobWF0cml4KSB7XG4gICAgICBwYXR0ZXJuLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2hhZGluZ0ZpbGwob2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4ob2JqSWQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TSEFESU5HKTtcbiAgICBjb25zdCBpbnYgPSBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpO1xuICAgIGlmIChpbnYpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGN0eC5jYW52YXM7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgd2lkdGgsIGhlaWdodF0sIGludik7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdCgtMWUxMCwgLTFlMTAsIDJlMTAsIDJlMTApO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UodGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgYmVnaW5JbmxpbmVJbWFnZSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICB9XG4gIGJlZ2luSW1hZ2VEYXRhKCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW1hZ2VEYXRhXCIpO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihtYXRyaXgsIGJib3gpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKC4uLm1hdHJpeCk7XG4gICAgfVxuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgIGlmIChiYm94KSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gICAgICB0aGlzLmN0eC5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jdXJyZW50LnVwZGF0ZVJlY3RNaW5NYXgoZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCksIGJib3gpO1xuICAgICAgdGhpcy5jbGlwKCk7XG4gICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICB9XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEVuZCgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gIH1cbiAgYmVnaW5Hcm91cChncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRDdHggPSB0aGlzLmN0eDtcbiAgICBpZiAoIWdyb3VwLmlzb2xhdGVkKSB7XG4gICAgICBpbmZvKFwiVE9ETzogU3VwcG9ydCBub24taXNvbGF0ZWQgZ3JvdXBzLlwiKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLmtub2Nrb3V0KSB7XG4gICAgICB3YXJuKFwiS25vY2tvdXQgZ3JvdXBzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdXJyZW50Q3R4KTtcbiAgICBpZiAoZ3JvdXAubWF0cml4KSB7XG4gICAgICBjdXJyZW50Q3R4LnRyYW5zZm9ybSguLi5ncm91cC5tYXRyaXgpO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwLmJib3gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdW5kaW5nIGJveCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGxldCBib3VuZHMgPSBVdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGdyb3VwLmJib3gsIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3VycmVudEN0eCkpO1xuICAgIGNvbnN0IGNhbnZhc0JvdW5kcyA9IFswLCAwLCBjdXJyZW50Q3R4LmNhbnZhcy53aWR0aCwgY3VycmVudEN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICBib3VuZHMgPSBVdGlsLmludGVyc2VjdChib3VuZHMsIGNhbnZhc0JvdW5kcykgfHwgWzAsIDAsIDAsIDBdO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKGJvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IoYm91bmRzWzFdKTtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1syXSkgLSBvZmZzZXRYLCAxKTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbM10pIC0gb2Zmc2V0WSwgMSk7XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goWzAsIDAsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0XSk7XG4gICAgbGV0IGNhY2hlSWQgPSBcImdyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIGNhY2hlSWQgKz0gXCJfc21hc2tfXCIgKyB0aGlzLnNtYXNrQ291bnRlcisrICUgMjtcbiAgICB9XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBncm91cEN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBncm91cEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBncm91cEN0eC50cmFuc2Zvcm0oLi4uY3VycmVudFRyYW5zZm9ybSk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnNtYXNrU3RhY2sucHVzaCh7XG4gICAgICAgIGNhbnZhczogc2NyYXRjaENhbnZhcy5jYW52YXMsXG4gICAgICAgIGNvbnRleHQ6IGdyb3VwQ3R4LFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgICAgICBzdWJ0eXBlOiBncm91cC5zbWFzay5zdWJ0eXBlLFxuICAgICAgICBiYWNrZHJvcDogZ3JvdXAuc21hc2suYmFja2Ryb3AsXG4gICAgICAgIHRyYW5zZmVyTWFwOiBncm91cC5zbWFzay50cmFuc2Zlck1hcCB8fCBudWxsLFxuICAgICAgICBzdGFydFRyYW5zZm9ybUludmVyc2U6IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgY3VycmVudEN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICB0aGlzLnNldEdTdGF0ZShbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgdGhpcy5ncm91cExldmVsKys7XG4gIH1cbiAgZW5kR3JvdXAoZ3JvdXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ncm91cExldmVsLS07XG4gICAgY29uc3QgZ3JvdXBDdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmdyb3VwU3RhY2sucG9wKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnRlbXBTTWFzayA9IHRoaXMuc21hc2tTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICBjb25zdCBjdXJyZW50TXR4ID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi5jdXJyZW50TXR4KTtcbiAgICAgIGNvbnN0IGRpcnR5Qm94ID0gVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0XSwgY3VycmVudE10eCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoZ3JvdXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZShkaXJ0eUJveCk7XG4gICAgfVxuICB9XG4gIGJlZ2luQW5ub3RhdGlvbihpZCwgcmVjdCwgdHJhbnNmb3JtLCBtYXRyaXgsIGhhc093bkNhbnZhcykge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi50aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgICAgaWYgKGhhc093bkNhbnZhcyAmJiB0aGlzLmFubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgICAgIHRyYW5zZm9ybVs0XSAtPSByZWN0WzBdO1xuICAgICAgICB0cmFuc2Zvcm1bNV0gLT0gcmVjdFsxXTtcbiAgICAgICAgcmVjdCA9IHJlY3Quc2xpY2UoKTtcbiAgICAgICAgcmVjdFswXSA9IHJlY3RbMV0gPSAwO1xuICAgICAgICByZWN0WzJdID0gd2lkdGg7XG4gICAgICAgIHJlY3RbM10gPSBoZWlnaHQ7XG4gICAgICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZpZXdwb3J0U2NhbGVcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogdGhpcy5vdXRwdXRTY2FsZVggKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHRoaXMub3V0cHV0U2NhbGVZICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcyA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAuc2V0KGlkLCBjYW52YXMpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShzY2FsZVgsIDAsIDAsIC1zY2FsZVksIDAsIGhlaWdodCAqIHNjYWxlWSk7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LnJlY3QocmVjdFswXSwgcmVjdFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuY3R4LmNsaXAoKTtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICB0aGlzLnRyYW5zZm9ybSguLi5tYXRyaXgpO1xuICB9XG4gIGVuZEFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkNhbnZhcykge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICB9XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0KGltZykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IGltZy5jb3VudDtcbiAgICBpbWcgPSB0aGlzLmdldE9iamVjdChpbWcuZGF0YSwgaW1nKTtcbiAgICBpbWcuY291bnQgPSBjb3VudDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBnbHlwaCA9IHRoaXMucHJvY2Vzc2luZ1R5cGUzO1xuICAgIGlmIChnbHlwaCkge1xuICAgICAgaWYgKGdseXBoLmNvbXBpbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2x5cGguY29tcGlsZWQgPSBjb21waWxlVHlwZTNHbHlwaChpbWcpO1xuICAgICAgfVxuICAgICAgaWYgKGdseXBoLmNvbXBpbGVkKSB7XG4gICAgICAgIGdseXBoLmNvbXBpbGVkKGN0eCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX2NyZWF0ZU1hc2tDYW52YXMoaW1nKTtcbiAgICBjb25zdCBtYXNrQ2FudmFzID0gbWFzay5jYW52YXM7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgbWFzay5vZmZzZXRYLCBtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0KGltZywgc2NhbGVYLCBza2V3WCA9IDAsIHNrZXdZID0gMCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3QoaW1nLmRhdGEsIGltZyk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgIGN0eC50cmFuc2Zvcm0oc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgMCwgMCk7XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX2NyZWF0ZU1hc2tDYW52YXMoaW1nKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIG1hc2sub2Zmc2V0WCAtIGN1cnJlbnRUcmFuc2Zvcm1bNF0sIG1hc2sub2Zmc2V0WSAtIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCB0cmFucyA9IFV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFtzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV1dKTtcbiAgICAgIGNvbnN0IFt4LCB5XSA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIDBdLCB0cmFucyk7XG4gICAgICBjdHguZHJhd0ltYWdlKG1hc2suY2FudmFzLCB4LCB5KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3RHcm91cChpbWFnZXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRyYW5zZm9ybVxuICAgICAgfSA9IGltYWdlO1xuICAgICAgY29uc3QgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IG1hc2tDdHggPSBtYXNrQ2FudmFzLmNvbnRleHQ7XG4gICAgICBtYXNrQ3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IGltZyA9IHRoaXMuZ2V0T2JqZWN0KGRhdGEsIGltYWdlKTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ3R4LCBpbWcpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIG1hc2tDYW52YXMuY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAtMSwgMSwgMSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdChvYmpJZCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgd2FybihcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQob2JqSWQsIHNjYWxlWCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KG9iaklkKTtcbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgIHdhcm4oXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgbWFwID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0sXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAoaW1nRGF0YSwgbWFwKTtcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKGN0eCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzICE9PSBcIm5vbmVcIikge1xuICAgICAgY3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgICBjdHguZHJhd0ltYWdlKGN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gY3R4LmNhbnZhcztcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybiBpbWdEYXRhLmJpdG1hcDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYml0bWFwLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1nRGF0YTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIHRtcEN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgIHRtcEN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwKTtcbiAgICB0bXBDdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgcmV0dXJuIHRtcENhbnZhcy5jYW52YXM7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKCFpc05vZGVKUykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWx0ZXJcbiAgICAgIH0gPSBjdHg7XG4gICAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgaW1nRGF0YSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8ICFpbWdEYXRhLmRhdGEpIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShpbWdUb1BhaW50LCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpKTtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSwgaW1nRGF0YS5pbnRlcnBvbGF0ZSk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc2NhbGVkLmltZywgMCwgMCwgc2NhbGVkLnBhaW50V2lkdGgsIHNjYWxlZC5wYWludEhlaWdodCwgMCwgLWhlaWdodCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChpbWdEYXRhLCBtYXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YS5iaXRtYXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHcgPSBpbWdEYXRhLndpZHRoO1xuICAgICAgY29uc3QgaCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3LCBoKTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgbWFwKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi5lbnRyeS50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIGltZ1RvUGFpbnQsIGVudHJ5LngsIGVudHJ5LnksIGVudHJ5LncsIGVudHJ5LmgsIDAsIC0xLCAxLCAxKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzaygpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgbWFya1BvaW50KHRhZykge31cbiAgbWFya1BvaW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7fVxuICBiZWdpbk1hcmtlZENvbnRlbnQodGFnKSB7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICB2aXNpYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHRhZyA9PT0gXCJPQ1wiKSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcuaXNWaXNpYmxlKHByb3BlcnRpZXMpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgZW5kTWFya2VkQ29udGVudCgpIHtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wb3AoKTtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgYmVnaW5Db21wYXQoKSB7fVxuICBlbmRDb21wYXQoKSB7fVxuICBjb25zdW1lUGF0aChjbGlwQm94KSB7XG4gICAgY29uc3QgaXNFbXB0eSA9IHRoaXMuY3VycmVudC5pc0VtcHR5Q2xpcCgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudXBkYXRlQ2xpcEZyb21QYXRoKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jb21wb3NlKGNsaXBCb3gpO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBFT19DTElQKSB7XG4gICAgICAgICAgY3R4LmNsaXAoXCJldmVub2RkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuc3RhcnROZXdQYXRoQW5kQ2xpcEJveCh0aGlzLmN1cnJlbnQuY2xpcEJveCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICB9XG4gIGdldFNpbmdsZVBpeGVsV2lkdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoKSB7XG4gICAgICBjb25zdCBtID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgICBpZiAobVsxXSA9PT0gMCAmJiBtWzJdID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSAxIC8gTWF0aC5taW4oTWF0aC5hYnMobVswXSksIE1hdGguYWJzKG1bM10pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QobVswXSwgbVsyXSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChtWzFdLCBtWzNdKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IE1hdGgubWF4KG5vcm1YLCBub3JtWSkgLyBhYnNEZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoO1xuICB9XG4gIGdldFNjYWxlRm9yU3Ryb2tpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPT09IC0xKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmVXaWR0aFxuICAgICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZFxuICAgICAgfSA9IHRoaXMuY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgbGV0IHNjYWxlWCwgc2NhbGVZO1xuICAgICAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguYWJzKGEpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguYWJzKGQpO1xuICAgICAgICBpZiAobm9ybVggPT09IG5vcm1ZKSB7XG4gICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gMSAvIG5vcm1YO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IHNjYWxlZExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkTGluZVdpZHRoIDogMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gMSAvIG5vcm1YO1xuICAgICAgICAgIHNjYWxlWSA9IDEgLyBub3JtWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzY2FsZWRYTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWUxpbmVXaWR0aCA9IG5vcm1ZICogbGluZVdpZHRoO1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlZFhMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFhMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IHNjYWxlZFlMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFlMaW5lV2lkdGggOiAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhhICogZCAtIGIgKiBjKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSAvIGFic0RldDtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCAvIGFic0RldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiYXNlQXJlYSA9IGxpbmVXaWR0aCAqIGFic0RldDtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSA+IGJhc2VBcmVhID8gbm9ybVkgLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggPiBiYXNlQXJlYSA/IG5vcm1YIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gc2NhbGVYO1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1sxXSA9IHNjYWxlWTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmc7XG4gIH1cbiAgcmVzY2FsZUFuZFN0cm9rZShzYXZlUmVzdG9yZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVXaWR0aFxuICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IHRoaXMuZ2V0U2NhbGVGb3JTdHJva2luZygpO1xuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggfHwgMTtcbiAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXNoZXMgPSBjdHguZ2V0TGluZURhc2goKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgaWYgKGRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZXMubWFwKHggPT4geCAvIHNjYWxlKSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgLz0gc2NhbGU7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGlzQ29udGVudFZpc2libGUoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubWFya2VkQ29udGVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoIXRoaXMubWFya2VkQ29udGVudFN0YWNrW2ldLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZm9yIChjb25zdCBvcCBpbiBPUFMpIHtcbiAgaWYgKENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgIENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtPUFNbb3BdXSA9IENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvd29ya2VyX29wdGlvbnMuanNcbmNsYXNzIEdsb2JhbFdvcmtlck9wdGlvbnMge1xuICBzdGF0aWMgI3BvcnQgPSBudWxsO1xuICBzdGF0aWMgI3NyYyA9IFwiXCI7XG4gIHN0YXRpYyBnZXQgd29ya2VyUG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9ydDtcbiAgfVxuICBzdGF0aWMgc2V0IHdvcmtlclBvcnQodmFsKSB7XG4gICAgaWYgKCEodHlwZW9mIFdvcmtlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBXb3JrZXIpICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgd29ya2VyUG9ydGAgdHlwZS5cIik7XG4gICAgfVxuICAgIHRoaXMuI3BvcnQgPSB2YWw7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NyYztcbiAgfVxuICBzdGF0aWMgc2V0IHdvcmtlclNyYyh2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgd29ya2VyU3JjYCB0eXBlLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc3JjID0gdmFsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvbWVzc2FnZV9oYW5kbGVyLmpzXG5cbmNvbnN0IENhbGxiYWNrS2luZCA9IHtcbiAgVU5LTk9XTjogMCxcbiAgREFUQTogMSxcbiAgRVJST1I6IDJcbn07XG5jb25zdCBTdHJlYW1LaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBDQU5DRUw6IDEsXG4gIENBTkNFTF9DT01QTEVURTogMixcbiAgQ0xPU0U6IDMsXG4gIEVOUVVFVUU6IDQsXG4gIEVSUk9SOiA1LFxuICBQVUxMOiA2LFxuICBQVUxMX0NPTVBMRVRFOiA3LFxuICBTVEFSVF9DT01QTEVURTogOFxufTtcbmZ1bmN0aW9uIHdyYXBSZWFzb24ocmVhc29uKSB7XG4gIGlmICghKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiByZWFzb24gPT09IFwib2JqZWN0XCIgJiYgcmVhc29uICE9PSBudWxsKSkge1xuICAgIHVucmVhY2hhYmxlKCd3cmFwUmVhc29uOiBFeHBlY3RlZCBcInJlYXNvblwiIHRvIGJlIGEgKHBvc3NpYmx5IGNsb25lZCkgRXJyb3IuJyk7XG4gIH1cbiAgc3dpdGNoIChyZWFzb24ubmFtZSkge1xuICAgIGNhc2UgXCJBYm9ydEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBBYm9ydEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSk7XG4gICAgY2FzZSBcIk1pc3NpbmdQREZFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgTWlzc2luZ1BERkV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSk7XG4gICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFBhc3N3b3JkRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uY29kZSk7XG4gICAgY2FzZSBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi5zdGF0dXMpO1xuICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uZGV0YWlscyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24udG9TdHJpbmcoKSk7XG4gIH1cbn1cbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIHtcbiAgI21lc3NhZ2VBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3RydWN0b3Ioc291cmNlTmFtZSwgdGFyZ2V0TmFtZSwgY29tT2JqKSB7XG4gICAgdGhpcy5zb3VyY2VOYW1lID0gc291cmNlTmFtZTtcbiAgICB0aGlzLnRhcmdldE5hbWUgPSB0YXJnZXROYW1lO1xuICAgIHRoaXMuY29tT2JqID0gY29tT2JqO1xuICAgIHRoaXMuY2FsbGJhY2tJZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1JZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1TaW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3Rpb25IYW5kbGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb21PYmouYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy4jb25NZXNzYWdlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbDogdGhpcy4jbWVzc2FnZUFDLnNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNvbk1lc3NhZ2Uoe1xuICAgIGRhdGFcbiAgfSkge1xuICAgIGlmIChkYXRhLnRhcmdldE5hbWUgIT09IHRoaXMuc291cmNlTmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIHRoaXMuI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgY29uc3QgY2FsbGJhY2tJZCA9IGRhdGEuY2FsbGJhY2tJZDtcbiAgICAgIGNvbnN0IGNhcGFiaWxpdHkgPSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgaWYgKCFjYXBhYmlsaXR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgY2FsbGJhY2sgJHtjYWxsYmFja0lkfWApO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkRBVEEpIHtcbiAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5FUlJPUikge1xuICAgICAgICBjYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNhbGxiYWNrIGNhc2VcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICR7ZGF0YS5hY3Rpb259YCk7XG4gICAgfVxuICAgIGlmIChkYXRhLmNhbGxiYWNrSWQpIHtcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhKSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5EQVRBLFxuICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIGNhbGxiYWNrOiBDYWxsYmFja0tpbmQuRVJST1IsXG4gICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLnN0cmVhbUlkKSB7XG4gICAgICB0aGlzLiNjcmVhdGVTdHJlYW1TaW5rKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3Rpb24oZGF0YS5kYXRhKTtcbiAgfVxuICBvbihhY3Rpb25OYW1lLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgYWggPSB0aGlzLmFjdGlvbkhhbmRsZXI7XG4gICAgaWYgKGFoW2FjdGlvbk5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGFscmVhZHkgYW4gYWN0aW9uTmFtZSBjYWxsZWQgXCIke2FjdGlvbk5hbWV9XCJgKTtcbiAgICB9XG4gICAgYWhbYWN0aW9uTmFtZV0gPSBoYW5kbGVyO1xuICB9XG4gIHNlbmQoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgZGF0YVxuICAgIH0sIHRyYW5zZmVycyk7XG4gIH1cbiAgc2VuZFdpdGhQcm9taXNlKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIGNvbnN0IGNhbGxiYWNrSWQgPSB0aGlzLmNhbGxiYWNrSWQrKztcbiAgICBjb25zdCBjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXSA9IGNhcGFiaWxpdHk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY2FwYWJpbGl0eS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNlbmRXaXRoU3RyZWFtKGFjdGlvbk5hbWUsIGRhdGEsIHF1ZXVlaW5nU3RyYXRlZ3ksIHRyYW5zZmVycykge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gdGhpcy5zdHJlYW1JZCsrLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdID0ge1xuICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgc3RhcnRDYWxsOiBzdGFydENhcGFiaWxpdHksXG4gICAgICAgICAgcHVsbENhbGw6IG51bGwsXG4gICAgICAgICAgY2FuY2VsQ2FsbDogbnVsbCxcbiAgICAgICAgICBpc0Nsb3NlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBwdWxsQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbCA9IHB1bGxDYXBhYmlsaXR5O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHB1bGxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiByZWFzb24gPT4ge1xuICAgICAgICBhc3NlcnQocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiY2FuY2VsIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgY29uc3QgY2FuY2VsQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsID0gY2FuY2VsQ2FwYWJpbGl0eTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2FuY2VsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfVxuICAgIH0sIHF1ZXVlaW5nU3RyYXRlZ3kpO1xuICB9XG4gICNjcmVhdGVTdHJlYW1TaW5rKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLFxuICAgICAgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICBjb25zdCBzdHJlYW1TaW5rID0ge1xuICAgICAgZW5xdWV1ZShjaHVuaywgc2l6ZSA9IDEsIHRyYW5zZmVycykge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0RGVzaXJlZFNpemUgPSB0aGlzLmRlc2lyZWRTaXplO1xuICAgICAgICB0aGlzLmRlc2lyZWRTaXplIC09IHNpemU7XG4gICAgICAgIGlmIChsYXN0RGVzaXJlZFNpemUgPiAwICYmIHRoaXMuZGVzaXJlZFNpemUgPD0gMCkge1xuICAgICAgICAgIHRoaXMuc2lua0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgICB0aGlzLnJlYWR5ID0gdGhpcy5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FTlFVRVVFLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGNodW5rXG4gICAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgICB9LFxuICAgICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0xPU0UsXG4gICAgICAgICAgc3RyZWFtSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBzZWxmLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgIH0sXG4gICAgICBlcnJvcihyZWFzb24pIHtcbiAgICAgICAgYXNzZXJ0KHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImVycm9yIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FUlJPUixcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzaW5rQ2FwYWJpbGl0eTogUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCksXG4gICAgICBvblB1bGw6IG51bGwsXG4gICAgICBvbkNhbmNlbDogbnVsbCxcbiAgICAgIGlzQ2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgIGRlc2lyZWRTaXplOiBkYXRhLmRlc2lyZWRTaXplLFxuICAgICAgcmVhZHk6IG51bGxcbiAgICB9O1xuICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHN0cmVhbVNpbmsucmVhZHkgPSBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0gPSBzdHJlYW1TaW5rO1xuICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKGFjdGlvbihkYXRhLmRhdGEsIHN0cmVhbVNpbmspKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAjcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLFxuICAgICAgc3RyZWFtU2luayA9IHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgIHN3aXRjaCAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA8PSAwICYmIGRhdGEuZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA9IGRhdGEuZGVzaXJlZFNpemU7XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShzdHJlYW1TaW5rLm9uUHVsbD8uKCkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FTlFVRVVFOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJlbnF1ZXVlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKGRhdGEuY2h1bmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DTE9TRTpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiY2xvc2Ugc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRVJST1I6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImVycm9yIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3Iod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoc3RyZWFtU2luay5vbkNhbmNlbD8uKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIHN0cmVhbVNpbmsuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzdHJlYW0gY2FzZVwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW3N0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsPy5wcm9taXNlLCBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsPy5wcm9taXNlLCBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGw/LnByb21pc2VdKTtcbiAgICBkZWxldGUgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNtZXNzYWdlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jbWVzc2FnZUFDID0gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9tZXRhZGF0YS5qc1xuXG5jbGFzcyBNZXRhZGF0YSB7XG4gICNtZXRhZGF0YU1hcDtcbiAgI2RhdGE7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJzZWREYXRhLFxuICAgIHJhd0RhdGFcbiAgfSkge1xuICAgIHRoaXMuI21ldGFkYXRhTWFwID0gcGFyc2VkRGF0YTtcbiAgICB0aGlzLiNkYXRhID0gcmF3RGF0YTtcbiAgfVxuICBnZXRSYXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGE7XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jbWV0YWRhdGFNYXAuZ2V0KG5hbWUpID8/IG51bGw7XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiBvYmplY3RGcm9tTWFwKHRoaXMuI21ldGFkYXRhTWFwKTtcbiAgfVxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YU1hcC5oYXMobmFtZSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvb3B0aW9uYWxfY29udGVudF9jb25maWcuanNcblxuXG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbChcIklOVEVSTkFMXCIpO1xuY2xhc3MgT3B0aW9uYWxDb250ZW50R3JvdXAge1xuICAjaXNEaXNwbGF5ID0gZmFsc2U7XG4gICNpc1ByaW50ID0gZmFsc2U7XG4gICN1c2VyU2V0ID0gZmFsc2U7XG4gICN2aXNpYmxlID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IocmVuZGVyaW5nSW50ZW50LCB7XG4gICAgbmFtZSxcbiAgICBpbnRlbnQsXG4gICAgdXNhZ2UsXG4gICAgcmJHcm91cHNcbiAgfSkge1xuICAgIHRoaXMuI2lzRGlzcGxheSA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWSk7XG4gICAgdGhpcy4jaXNQcmludCA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pbnRlbnQgPSBpbnRlbnQ7XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMucmJHcm91cHMgPSByYkdyb3VwcztcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICBpZiAodGhpcy4jdXNlclNldCkge1xuICAgICAgcmV0dXJuIHRoaXMuI3Zpc2libGU7XG4gICAgfVxuICAgIGlmICghdGhpcy4jdmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwcmludCxcbiAgICAgIHZpZXdcbiAgICB9ID0gdGhpcy51c2FnZTtcbiAgICBpZiAodGhpcy4jaXNEaXNwbGF5KSB7XG4gICAgICByZXR1cm4gdmlldz8udmlld1N0YXRlICE9PSBcIk9GRlwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNQcmludCkge1xuICAgICAgcmV0dXJuIHByaW50Py5wcmludFN0YXRlICE9PSBcIk9GRlwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc2V0VmlzaWJsZShpbnRlcm5hbCwgdmlzaWJsZSwgdXNlclNldCA9IGZhbHNlKSB7XG4gICAgaWYgKGludGVybmFsICE9PSBJTlRFUk5BTCkge1xuICAgICAgdW5yZWFjaGFibGUoXCJJbnRlcm5hbCBtZXRob2QgYF9zZXRWaXNpYmxlYCBjYWxsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLiN1c2VyU2V0ID0gdXNlclNldDtcbiAgICB0aGlzLiN2aXNpYmxlID0gdmlzaWJsZTtcbiAgfVxufVxuY2xhc3MgT3B0aW9uYWxDb250ZW50Q29uZmlnIHtcbiAgI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICAjZ3JvdXBzID0gbmV3IE1hcCgpO1xuICAjaW5pdGlhbEhhc2ggPSBudWxsO1xuICAjb3JkZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihkYXRhLCByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVkpIHtcbiAgICB0aGlzLnJlbmRlcmluZ0ludGVudCA9IHJlbmRlcmluZ0ludGVudDtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuY3JlYXRvciA9IG51bGw7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMuY3JlYXRvciA9IGRhdGEuY3JlYXRvcjtcbiAgICB0aGlzLiNvcmRlciA9IGRhdGEub3JkZXI7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBkYXRhLmdyb3Vwcykge1xuICAgICAgdGhpcy4jZ3JvdXBzLnNldChncm91cC5pZCwgbmV3IE9wdGlvbmFsQ29udGVudEdyb3VwKHJlbmRlcmluZ0ludGVudCwgZ3JvdXApKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYmFzZVN0YXRlID09PSBcIk9GRlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHRoaXMuI2dyb3Vwcy52YWx1ZXMoKSkge1xuICAgICAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9uIG9mIGRhdGEub24pIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob24pLl9zZXRWaXNpYmxlKElOVEVSTkFMLCB0cnVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvZmYgb2YgZGF0YS5vZmYpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob2ZmKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNpbml0aWFsSGFzaCA9IHRoaXMuZ2V0SGFzaCgpO1xuICB9XG4gICNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGFycmF5KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBhcnJheVswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgICBsZXQgc3RhdGU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI2dyb3Vwcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW1lbnQpLnZpc2libGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtlbGVtZW50fWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIkFuZFwiOlxuICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPclwiOlxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTm90XCI6XG4gICAgICAgICAgcmV0dXJuICFzdGF0ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIkFuZFwiO1xuICB9XG4gIGlzVmlzaWJsZShncm91cCkge1xuICAgIGlmICh0aGlzLiNncm91cHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIGluZm8oXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ0dcIikge1xuICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGdyb3VwLmlkKSkge1xuICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtncm91cC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChncm91cC5pZCkudmlzaWJsZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NNRFwiKSB7XG4gICAgICBpZiAoZ3JvdXAuZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihncm91cC5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ3JvdXAucG9saWN5IHx8IGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQW55T2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgd2FybihgVW5rbm93biBvcHRpb25hbCBjb250ZW50IHBvbGljeSAke2dyb3VwLnBvbGljeX0uYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2FybihgVW5rbm93biBncm91cCB0eXBlICR7Z3JvdXAudHlwZX0uYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0VmlzaWJpbGl0eShpZCwgdmlzaWJsZSA9IHRydWUsIHByZXNlcnZlUkIgPSB0cnVlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSB0aGlzLiNncm91cHMuZ2V0KGlkKTtcbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXNlcnZlUkIgJiYgdmlzaWJsZSAmJiBncm91cC5yYkdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgcmJHcm91cCBvZiBncm91cC5yYkdyb3Vwcykge1xuICAgICAgICBmb3IgKGNvbnN0IG90aGVySWQgb2YgcmJHcm91cCkge1xuICAgICAgICAgIGlmIChvdGhlcklkICE9PSBpZCkge1xuICAgICAgICAgICAgdGhpcy4jZ3JvdXBzLmdldChvdGhlcklkKT8uX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXAuX3NldFZpc2libGUoSU5URVJOQUwsICEhdmlzaWJsZSwgdHJ1ZSk7XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgc2V0T0NHU3RhdGUoe1xuICAgIHN0YXRlLFxuICAgIHByZXNlcnZlUkJcbiAgfSkge1xuICAgIGxldCBvcGVyYXRvcjtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2Ygc3RhdGUpIHtcbiAgICAgIHN3aXRjaCAoZWxlbSkge1xuICAgICAgICBjYXNlIFwiT05cIjpcbiAgICAgICAgY2FzZSBcIk9GRlwiOlxuICAgICAgICBjYXNlIFwiVG9nZ2xlXCI6XG4gICAgICAgICAgb3BlcmF0b3IgPSBlbGVtO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW0pO1xuICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIk9OXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sIHRydWUsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiT0ZGXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sIGZhbHNlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRvZ2dsZVwiOlxuICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eShlbGVtLCAhZ3JvdXAudmlzaWJsZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICB9XG4gIGdldCBoYXNJbml0aWFsVmlzaWJpbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5pdGlhbEhhc2ggPT09IG51bGwgfHwgdGhpcy5nZXRIYXNoKCkgPT09IHRoaXMuI2luaXRpYWxIYXNoO1xuICB9XG4gIGdldE9yZGVyKCkge1xuICAgIGlmICghdGhpcy4jZ3JvdXBzLnNpemUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jb3JkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvcmRlci5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gWy4uLnRoaXMuI2dyb3Vwcy5rZXlzKCldO1xuICB9XG4gIGdldEdyb3VwcygpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLnNpemUgPiAwID8gb2JqZWN0RnJvbU1hcCh0aGlzLiNncm91cHMpIDogbnVsbDtcbiAgfVxuICBnZXRHcm91cChpZCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIGdldEhhc2goKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEdldEhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID0gbmV3IE11cm11ckhhc2gzXzY0KCk7XG4gICAgZm9yIChjb25zdCBbaWQsIGdyb3VwXSBvZiB0aGlzLiNncm91cHMpIHtcbiAgICAgIGhhc2gudXBkYXRlKGAke2lkfToke2dyb3VwLnZpc2libGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoID0gaGFzaC5oZXhkaWdlc3QoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS90cmFuc3BvcnRfc3RyZWFtLmpzXG5cblxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHBkZkRhdGFSYW5nZVRyYW5zcG9ydCwge1xuICAgIGRpc2FibGVSYW5nZSA9IGZhbHNlLFxuICAgIGRpc2FibGVTdHJlYW0gPSBmYWxzZVxuICB9KSB7XG4gICAgYXNzZXJ0KHBkZkRhdGFSYW5nZVRyYW5zcG9ydCwgJ1BERkRhdGFUcmFuc3BvcnRTdHJlYW0gLSBtaXNzaW5nIHJlcXVpcmVkIFwicGRmRGF0YVJhbmdlVHJhbnNwb3J0XCIgYXJndW1lbnQuJyk7XG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoLFxuICAgICAgaW5pdGlhbERhdGEsXG4gICAgICBwcm9ncmVzc2l2ZURvbmUsXG4gICAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZVxuICAgIH0gPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gcHJvZ3Jlc3NpdmVEb25lO1xuICAgIHRoaXMuX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gICAgaWYgKGluaXRpYWxEYXRhPy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBpbml0aWFsRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgaW5pdGlhbERhdGEuYnl0ZUxlbmd0aCA9PT0gaW5pdGlhbERhdGEuYnVmZmVyLmJ5dGVMZW5ndGggPyBpbml0aWFsRGF0YS5idWZmZXIgOiBuZXcgVWludDhBcnJheShpbml0aWFsRGF0YSkuYnVmZmVyO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goYnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIWRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFkaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzID0gW107XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFJhbmdlTGlzdGVuZXIoKGJlZ2luLCBjaHVuaykgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGJlZ2luLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzTGlzdGVuZXIoKGxvYWRlZCwgdG90YWwpID0+IHtcbiAgICAgIHRoaXMuX29uUHJvZ3Jlc3Moe1xuICAgICAgICBsb2FkZWQsXG4gICAgICAgIHRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIoY2h1bmsgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQudHJhbnNwb3J0UmVhZHkoKTtcbiAgfVxuICBfb25SZWNlaXZlRGF0YSh7XG4gICAgYmVnaW4sXG4gICAgY2h1bmtcbiAgfSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNodW5rIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBjaHVuay5ieXRlTGVuZ3RoID09PSBjaHVuay5idWZmZXIuYnl0ZUxlbmd0aCA/IGNodW5rLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgaWYgKGJlZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcikge1xuICAgICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZm91bmQgPSB0aGlzLl9yYW5nZVJlYWRlcnMuc29tZShmdW5jdGlvbiAocmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgaWYgKHJhbmdlUmVhZGVyLl9iZWdpbiAhPT0gYmVnaW4pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2VSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIGFzc2VydChmb3VuZCwgXCJfb25SZWNlaXZlRGF0YSAtIG5vIGBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXJgIGluc3RhbmNlIGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKGV2dC50b3RhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnNbMF0/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfb25Qcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LnByb2dyZXNzaXZlRG9uZSgpO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHRydWU7XG4gIH1cbiAgX3JlbW92ZVJhbmdlUmVhZGVyKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgYXNzZXJ0KCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIGNvbnN0IHF1ZXVlZENodW5rcyA9IHRoaXMuX3F1ZXVlZENodW5rcztcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBudWxsO1xuICAgIHJldHVybiBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlcih0aGlzLCBxdWV1ZWRDaHVua3MsIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSwgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHF1ZXVlZENodW5rcywgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9kb25lID0gcHJvZ3Jlc3NpdmVEb25lIHx8IGZhbHNlO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gaXNQZGZGaWxlKGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lKSA/IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIDogbnVsbDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBxdWV1ZWRDaHVua3MgfHwgW107XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHRoaXMuX3F1ZXVlZENodW5rcykge1xuICAgICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5faGVhZGVyc1JlYWR5ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtLl9mdWxsUmVxdWVzdFJlYWRlciA9IHRoaXM7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc1JlYWR5O1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5fY29udGVudExlbmd0aDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgcHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICB9XG59XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fYmVnaW4gPSBiZWdpbjtcbiAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXF1ZXN0c0NhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdHNDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NvbnRlbnRfZGlzcG9zaXRpb24uanNcblxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICBsZXQgbmVlZHNFbmNvZGluZ0ZpeHVwID0gdHJ1ZTtcbiAgbGV0IHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHVuZXNjYXBlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzU5ODdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKHRtcCk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9QYXJhbVJlZ0V4cChhdHRyaWJ1dGVQYXR0ZXJuLCBmbGFncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86Xnw7KVxcXFxzKlwiICsgYXR0cmlidXRlUGF0dGVybiArIFwiXFxcXHMqPVxcXFxzKlwiICsgXCIoXCIgKyAnW15cIjtcXFxcc11bXjtcXFxcc10qJyArIFwifFwiICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXFwiPykrXCI/JyArIFwiKVwiLCBmbGFncyk7XG4gIH1cbiAgZnVuY3Rpb24gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGlmICghL15bXFx4MDAtXFx4RkZdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgbmVlZHNFbmNvZGluZ0ZpeHVwID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBmaXh1cEVuY29kaW5nKHZhbHVlKSB7XG4gICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCAmJiAvW1xceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcInV0Zi04XCIsIHZhbHVlKTtcbiAgICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXApIHtcbiAgICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwiaXNvLTg4NTktMVwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uU3RyKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBpdGVyID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCooKD8hMFxcXFxkKVxcXFxkKykoXFxcXCo/KVwiLCBcImlnXCIpO1xuICAgIHdoaWxlICgobWF0Y2ggPSBpdGVyLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uU3RyKSkgIT09IG51bGwpIHtcbiAgICAgIGxldCBbLCBuLCBxdW90LCBwYXJ0XSA9IG1hdGNoO1xuICAgICAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgICAgIGlmIChuIGluIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1hdGNoZXNbbl0gPSBbcXVvdCwgcGFydF07XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBtYXRjaGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAoIShuIGluIG1hdGNoZXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IFtxdW90LCBwYXJ0XSA9IG1hdGNoZXNbbl07XG4gICAgICBwYXJ0ID0gcmZjMjYxNnVucXVvdGUocGFydCk7XG4gICAgICBpZiAocXVvdCkge1xuICAgICAgICBwYXJ0ID0gdW5lc2NhcGUocGFydCk7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgcGFydCA9IHJmYzU5ODdkZWNvZGUocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzI2MTZ1bnF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc2xpY2UoMSkuc3BsaXQoJ1xcXFxcIicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBxdW90aW5kZXggPSBwYXJ0c1tpXS5pbmRleE9mKCdcIicpO1xuICAgICAgICBpZiAocXVvdGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0uc2xpY2UoMCwgcXVvdGluZGV4KTtcbiAgICAgICAgICBwYXJ0cy5sZW5ndGggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnJlcGxhY2VBbGwoL1xcXFwoLikvZywgXCIkMVwiKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gcGFydHMuam9pbignXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzU5ODdkZWNvZGUoZXh0dmFsdWUpIHtcbiAgICBjb25zdCBlbmNvZGluZ2VuZCA9IGV4dHZhbHVlLmluZGV4T2YoXCInXCIpO1xuICAgIGlmIChlbmNvZGluZ2VuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBleHR2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RpbmcgPSBleHR2YWx1ZS5zbGljZSgwLCBlbmNvZGluZ2VuZCk7XG4gICAgY29uc3QgbGFuZ3ZhbHVlID0gZXh0dmFsdWUuc2xpY2UoZW5jb2RpbmdlbmQgKyAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxhbmd2YWx1ZS5yZXBsYWNlKC9eW14nXSonLywgXCJcIik7XG4gICAgcmV0dXJuIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMDQ3ZGVjb2RlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwiPT9cIikgfHwgL1tcXHgwMC1cXHgxOVxceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2VBbGwoLz1cXD8oW1xcdy1dKilcXD8oW1FxQmJdKVxcPygoPzpbXj9dfFxcPyg/IT0pKSopXFw/PS9nLCBmdW5jdGlvbiAobWF0Y2hlcywgY2hhcnNldCwgZW5jb2RpbmcsIHRleHQpIHtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJxXCIgfHwgZW5jb2RpbmcgPT09IFwiUVwiKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2VBbGwoXCJfXCIsIFwiIFwiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbCgvPShbMC05YS1mQS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBoZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRleHQgPSBhdG9iKHRleHQpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L25ldHdvcmtfdXRpbHMuanNcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnMoaXNIdHRwLCBodHRwSGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgaWYgKCFpc0h0dHAgfHwgIWh0dHBIZWFkZXJzIHx8IHR5cGVvZiBodHRwSGVhZGVycyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGh0dHBIZWFkZXJzKSB7XG4gICAgY29uc3QgdmFsID0gaHR0cEhlYWRlcnNba2V5XTtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gIHJlc3BvbnNlSGVhZGVycyxcbiAgaXNIdHRwLFxuICByYW5nZUNodW5rU2l6ZSxcbiAgZGlzYWJsZVJhbmdlXG59KSB7XG4gIGNvbnN0IHJldHVyblZhbHVlcyA9IHtcbiAgICBhbGxvd1JhbmdlUmVxdWVzdHM6IGZhbHNlLFxuICAgIHN1Z2dlc3RlZExlbmd0aDogdW5kZWZpbmVkXG4gIH07XG4gIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobGVuZ3RoKSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8PSAyICogcmFuZ2VDaHVua1NpemUpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChkaXNhYmxlUmFuZ2UgfHwgIWlzSHR0cCkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKHJlc3BvbnNlSGVhZGVycy5nZXQoXCJBY2NlcHQtUmFuZ2VzXCIpICE9PSBcImJ5dGVzXCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LUVuY29kaW5nXCIpIHx8IFwiaWRlbnRpdHlcIjtcbiAgaWYgKGNvbnRlbnRFbmNvZGluZyAhPT0gXCJpZGVudGl0eVwiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuYWxsb3dSYW5nZVJlcXVlc3RzID0gdHJ1ZTtcbiAgcmV0dXJuIHJldHVyblZhbHVlcztcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIocmVzcG9uc2VIZWFkZXJzKSB7XG4gIGNvbnN0IGNvbnRlbnREaXNwb3NpdGlvbiA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuICBpZiAoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gICAgbGV0IGZpbGVuYW1lID0gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gICAgaWYgKGZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZW5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICBpZiAoaXNQZGZGaWxlKGZpbGVuYW1lKSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3Ioc3RhdHVzLCB1cmwpIHtcbiAgaWYgKHN0YXR1cyA9PT0gNDA0IHx8IHN0YXR1cyA9PT0gMCAmJiB1cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpKSB7XG4gICAgcmV0dXJuIG5ldyBNaXNzaW5nUERGRXhjZXB0aW9uKCdNaXNzaW5nIFBERiBcIicgKyB1cmwgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24oYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlICgke3N0YXR1c30pIHdoaWxlIHJldHJpZXZpbmcgUERGIFwiJHt1cmx9XCIuYCwgc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2VTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNjtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZmV0Y2hfc3RyZWFtLmpzXG5cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscywgYWJvcnRDb250cm9sbGVyKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnMsXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHZhbC5idWZmZXI7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB3YXJuKGBnZXRBcnJheUJ1ZmZlciAtIHVuZXhwZWN0ZWQgZGF0YSBmb3JtYXQ6ICR7dmFsfWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKS5idWZmZXI7XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuaXNIdHRwLCBzb3VyY2UuaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkZldGNoU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJlYW0uaGVhZGVycyk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKCF2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICAgIH0gPSB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgaXNIdHRwOiBzdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgICB0aGlzLl9maWxlbmFtZSA9IGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIocmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICB0aGlzLmNhbmNlbChuZXcgQWJvcnRFeGNlcHRpb24oXCJTdHJlYW1pbmcgaXMgZGlzYWJsZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCh0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmVhbS5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLmFwcGVuZChcIlJhbmdlXCIsIGBieXRlcz0ke2JlZ2lufS0ke2VuZCAtIDF9YCk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKCF2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIH0pLmNhdGNoKHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbmV0d29yay5qc1xuXG5cbmNvbnN0IE9LX1JFU1BPTlNFID0gMjAwO1xuY29uc3QgUEFSVElBTF9DT05URU5UX1JFU1BPTlNFID0gMjA2O1xuZnVuY3Rpb24gbmV0d29ya19nZXRBcnJheUJ1ZmZlcih4aHIpIHtcbiAgY29uc3QgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1RvQnl0ZXMoZGF0YSkuYnVmZmVyO1xufVxuY2xhc3MgTmV0d29ya01hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsLFxuICAgIGh0dHBIZWFkZXJzLFxuICAgIHdpdGhDcmVkZW50aWFsc1xuICB9KSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHVybCk7XG4gICAgdGhpcy5oZWFkZXJzID0gY3JlYXRlSGVhZGVycyh0aGlzLmlzSHR0cCwgaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuY3VyclhocklkID0gMDtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgcmVxdWVzdFJhbmdlKGJlZ2luLCBlbmQsIGxpc3RlbmVycykge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBiZWdpbixcbiAgICAgIGVuZFxuICAgIH07XG4gICAgZm9yIChjb25zdCBwcm9wIGluIGxpc3RlbmVycykge1xuICAgICAgYXJnc1twcm9wXSA9IGxpc3RlbmVyc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcmdzKTtcbiAgfVxuICByZXF1ZXN0RnVsbChsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGxpc3RlbmVycyk7XG4gIH1cbiAgcmVxdWVzdChhcmdzKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY29uc3QgeGhySWQgPSB0aGlzLmN1cnJYaHJJZCsrO1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdID0ge1xuICAgICAgeGhyXG4gICAgfTtcbiAgICB4aHIub3BlbihcIkdFVFwiLCB0aGlzLnVybCk7XG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNIdHRwICYmIFwiYmVnaW5cIiBpbiBhcmdzICYmIFwiZW5kXCIgaW4gYXJncykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBgYnl0ZXM9JHthcmdzLmJlZ2lufS0ke2FyZ3MuZW5kIC0gMX1gKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IE9LX1JFU1BPTlNFO1xuICAgIH1cbiAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIGlmIChhcmdzLm9uRXJyb3IpIHtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBhcmdzLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICB9O1xuICAgIH1cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5vblByb2dyZXNzLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkID0gYXJncy5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yID0gYXJncy5vbkVycm9yO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MgPSBhcmdzLm9uUHJvZ3Jlc3M7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIHhocklkO1xuICB9XG4gIG9uUHJvZ3Jlc3MoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcz8uKGV2dCk7XG4gIH1cbiAgb25TdGF0ZUNoYW5nZSh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSBwZW5kaW5nUmVxdWVzdC54aHI7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID49IDIgJiYgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKCk7XG4gICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgfVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCAmJiB0aGlzLmlzSHR0cCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHJTdGF0dXMgPSB4aHIuc3RhdHVzIHx8IE9LX1JFU1BPTlNFO1xuICAgIGNvbnN0IG9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgPSB4aHJTdGF0dXMgPT09IE9LX1JFU1BPTlNFICYmIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgaWYgKCFva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ICYmIHhoclN0YXR1cyAhPT0gcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSBuZXR3b3JrX2dldEFycmF5QnVmZmVyKHhocik7XG4gICAgaWYgKHhoclN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFKSB7XG4gICAgICBjb25zdCByYW5nZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtUmFuZ2VcIik7XG4gICAgICBjb25zdCBtYXRjaGVzID0gL2J5dGVzIChcXGQrKS0oXFxkKylcXC8oXFxkKykvLmV4ZWMocmFuZ2VIZWFkZXIpO1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgYmVnaW46IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiAwLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVxdWVzdFhocih4aHJJZCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICB9XG4gIGlzUGVuZGluZ1JlcXVlc3QoeGhySWQpIHtcbiAgICByZXR1cm4geGhySWQgaW4gdGhpcy5wZW5kaW5nUmVxdWVzdHM7XG4gIH1cbiAgYWJvcnRSZXF1ZXN0KHhocklkKSB7XG4gICAgY29uc3QgeGhyID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIHhoci5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX21hbmFnZXIgPSBuZXcgTmV0d29ya01hbmFnZXIoc291cmNlKTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIF9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZChyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgYXNzZXJ0KCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZOZXR3b3JrU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCB0aGlzLl9zb3VyY2UpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIodGhpcy5fbWFuYWdlciwgYmVnaW4sIGVuZCk7XG4gICAgcmVhZGVyLm9uQ2xvc2VkID0gdGhpcy5fb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBzb3VyY2UpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgb25IZWFkZXJzUmVjZWl2ZWQ6IHRoaXMuX29uSGVhZGVyc1JlY2VpdmVkLmJpbmQodGhpcyksXG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLl91cmwgPSBzb3VyY2UudXJsO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3RGdWxsKGFyZ3MpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9vbkhlYWRlcnNSZWNlaXZlZCgpIHtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhocklkID0gdGhpcy5fZnVsbFJlcXVlc3RJZDtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhociA9IHRoaXMuX21hbmFnZXIuZ2V0UmVxdWVzdFhocihmdWxsUmVxdWVzdFhocklkKTtcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBuZXcgSGVhZGVycyhmdWxsUmVxdWVzdFhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy8pLm1hcCh4ID0+IHtcbiAgICAgIGNvbnN0IFtrZXksIC4uLnZhbF0gPSB4LnNwbGl0KFwiOiBcIik7XG4gICAgICByZXR1cm4gW2tleSwgdmFsLmpvaW4oXCI6IFwiKV07XG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgIH0gPSB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICBpc0h0dHA6IHRoaXMuX21hbmFnZXIuaXNIdHRwLFxuICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICB9KTtcbiAgICBpZiAoYWxsb3dSYW5nZVJlcXVlc3RzKSB7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpO1xuICAgIGlmICh0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdChmdWxsUmVxdWVzdFhocklkKTtcbiAgICB9XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiBkYXRhLmNodW5rLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzLnB1c2goZGF0YS5jaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgdG90YWw6IGV2dC5sZW5ndGhDb21wdXRhYmxlID8gZXZ0LnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NhY2hlZENodW5rcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKTtcbiAgICB9XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLl91cmwgPSBtYW5hZ2VyLnVybDtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3RSYW5nZShiZWdpbiwgZW5kLCBhcmdzKTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xvc2VkID0gbnVsbDtcbiAgfVxuICBfY2xvc2UoKSB7XG4gICAgdGhpcy5vbkNsb3NlZD8uKHRoaXMpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGNvbnN0IGNodW5rID0gZGF0YS5jaHVuaztcbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3Ioc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmICghdGhpcy5pc1N0cmVhbWluZ1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbm9kZV9zdHJlYW0uanNcblxuXG5cbmNvbnN0IHVybFJlZ2V4ID0gL15bYS16XVthLXowLTlcXC0rLl0rOi9pO1xuZnVuY3Rpb24gcGFyc2VVcmxPclBhdGgoc291cmNlVXJsKSB7XG4gIGlmICh1cmxSZWdleC50ZXN0KHNvdXJjZVVybCkpIHtcbiAgICByZXR1cm4gbmV3IFVSTChzb3VyY2VVcmwpO1xuICB9XG4gIGNvbnN0IHVybCA9IE5vZGVQYWNrYWdlcy5nZXQoXCJ1cmxcIik7XG4gIHJldHVybiBuZXcgVVJMKHVybC5wYXRoVG9GaWxlVVJMKHNvdXJjZVVybCkpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdCh1cmwsIGhlYWRlcnMsIGNhbGxiYWNrKSB7XG4gIGlmICh1cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIikge1xuICAgIGNvbnN0IGh0dHAgPSBOb2RlUGFja2FnZXMuZ2V0KFwiaHR0cFwiKTtcbiAgICByZXR1cm4gaHR0cC5yZXF1ZXN0KHVybCwge1xuICAgICAgaGVhZGVyc1xuICAgIH0sIGNhbGxiYWNrKTtcbiAgfVxuICBjb25zdCBodHRwcyA9IE5vZGVQYWNrYWdlcy5nZXQoXCJodHRwc1wiKTtcbiAgcmV0dXJuIGh0dHBzLnJlcXVlc3QodXJsLCB7XG4gICAgaGVhZGVyc1xuICB9LCBjYWxsYmFjayk7XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy51cmwgPSBwYXJzZVVybE9yUGF0aChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmlzSHR0cCA9IHRoaXMudXJsLnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgdGhpcy51cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgdGhpcy5pc0ZzVXJsID0gdGhpcy51cmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIjtcbiAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuaXNIdHRwLCBzb3VyY2UuaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5vZGVTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKSA6IG5ldyBQREZOb2RlU3RyZWFtRnVsbFJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCkgOiBuZXcgUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyYW5nZVJlYWRlcik7XG4gICAgcmV0dXJuIHJhbmdlUmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9lcnJvcihuZXcgQWJvcnRFeGNlcHRpb24oXCJzdHJlYW1pbmcgaXMgZGlzYWJsZWRcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1GdWxsUmVhZGVyIGV4dGVuZHMgQmFzZUZ1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMoc3RyZWFtLmhlYWRlcnMpO1xuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gcmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBNaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7dGhpcy5fdXJsfVwiLmApO1xuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSk7XG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzLl9yZWFkYWJsZVN0cmVhbS5oZWFkZXJzKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICAgIH0gPSB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgaXNIdHRwOiBzdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgICB0aGlzLl9maWxlbmFtZSA9IGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIocmVzcG9uc2VIZWFkZXJzKTtcbiAgICB9O1xuICAgIHRoaXMuX3JlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0KHRoaXMuX3VybCwgaGVhZGVycywgaGFuZGxlUmVzcG9uc2UpO1xuICAgIHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXF1ZXN0LmVuZCgpO1xuICB9XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIgZXh0ZW5kcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMoc3RyZWFtLmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuUmFuZ2UgPSBgYnl0ZXM9JHtzdGFydH0tJHtlbmQgLSAxfWA7XG4gICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IE1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHt0aGlzLl91cmx9XCIuYCk7XG4gICAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHRoaXMuX3JlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0KHRoaXMuX3VybCwgaGVhZGVycywgaGFuZGxlUmVzcG9uc2UpO1xuICAgIHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgfSk7XG4gICAgdGhpcy5fcmVxdWVzdC5lbmQoKTtcbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlciBleHRlbmRzIEJhc2VGdWxsUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICBjb25zdCBmcyA9IE5vZGVQYWNrYWdlcy5nZXQoXCJmc1wiKTtcbiAgICBmcy5wcm9taXNlcy5sc3RhdCh0aGlzLl91cmwpLnRoZW4oc3RhdCA9PiB7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3RhdC5zaXplO1xuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbSh0aGlzLl91cmwpKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9LCBlcnJvciA9PiB7XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICBlcnJvciA9IG5ldyBNaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7dGhpcy5fdXJsfVwiLmApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyIGV4dGVuZHMgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICBjb25zdCBmcyA9IE5vZGVQYWNrYWdlcy5nZXQoXCJmc1wiKTtcbiAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuX3VybCwge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmQ6IGVuZCAtIDFcbiAgICB9KSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvdGV4dF9sYXllci5qc1xuXG5cbmNvbnN0IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSID0gMTAwMDAwO1xuY29uc3QgREVGQVVMVF9GT05UX1NJWkUgPSAzMDtcbmNvbnN0IERFRkFVTFRfRk9OVF9BU0NFTlQgPSAwLjg7XG5jbGFzcyBUZXh0TGF5ZXIge1xuICAjY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI2Rpc2FibGVQcm9jZXNzSXRlbXMgPSBmYWxzZTtcbiAgI2ZvbnRJbnNwZWN0b3JFbmFibGVkID0gISFnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQ7XG4gICNsYW5nID0gbnVsbDtcbiAgI2xheW91dFRleHRQYXJhbXMgPSBudWxsO1xuICAjcGFnZUhlaWdodCA9IDA7XG4gICNwYWdlV2lkdGggPSAwO1xuICAjcmVhZGVyID0gbnVsbDtcbiAgI3Jvb3RDb250YWluZXIgPSBudWxsO1xuICAjcm90YXRpb24gPSAwO1xuICAjc2NhbGUgPSAwO1xuICAjc3R5bGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICN0ZXh0Q29udGVudEl0ZW1zU3RyID0gW107XG4gICN0ZXh0Q29udGVudFNvdXJjZSA9IG51bGw7XG4gICN0ZXh0RGl2cyA9IFtdO1xuICAjdGV4dERpdlByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xuICAjdHJhbnNmb3JtID0gbnVsbDtcbiAgc3RhdGljICNhc2NlbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgc3RhdGljICNjYW52YXNDb250ZXh0cyA9IG5ldyBNYXAoKTtcbiAgc3RhdGljICNjYW52YXNDdHhGb250cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHN0YXRpYyAjbWluRm9udFNpemUgPSBudWxsO1xuICBzdGF0aWMgI3BlbmRpbmdUZXh0TGF5ZXJzID0gbmV3IFNldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdGV4dENvbnRlbnRTb3VyY2UsXG4gICAgY29udGFpbmVyLFxuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICBpZiAodGV4dENvbnRlbnRTb3VyY2UgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy4jdGV4dENvbnRlbnRTb3VyY2UgPSB0ZXh0Q29udGVudFNvdXJjZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ZXh0Q29udGVudFNvdXJjZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdGhpcy4jdGV4dENvbnRlbnRTb3VyY2UgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRDb250ZW50U291cmNlKTtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwidGV4dENvbnRlbnRTb3VyY2VcIiBwYXJhbWV0ZXIgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIgPSB0aGlzLiNyb290Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3NjYWxlID0gdmlld3BvcnQuc2NhbGUgKiAoZ2xvYmFsVGhpcy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuICAgIHRoaXMuI3JvdGF0aW9uID0gdmlld3BvcnQucm90YXRpb247XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcyA9IHtcbiAgICAgIGRpdjogbnVsbCxcbiAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICBjdHg6IG51bGxcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgdGhpcy4jdHJhbnNmb3JtID0gWzEsIDAsIDAsIC0xLCAtcGFnZVgsIHBhZ2VZICsgcGFnZUhlaWdodF07XG4gICAgdGhpcy4jcGFnZVdpZHRoID0gcGFnZVdpZHRoO1xuICAgIHRoaXMuI3BhZ2VIZWlnaHQgPSBwYWdlSGVpZ2h0O1xuICAgIFRleHRMYXllci4jZW5zdXJlTWluRm9udFNpemVDb21wdXRlZCgpO1xuICAgIHNldExheWVyRGltZW5zaW9ucyhjb250YWluZXIsIHZpZXdwb3J0KTtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICBUZXh0TGF5ZXIuI3BlbmRpbmdUZXh0TGF5ZXJzLmRlbGV0ZSh0aGlzKTtcbiAgICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMgPSBudWxsO1xuICAgICAgdGhpcy4jc3R5bGVDYWNoZSA9IG51bGw7XG4gICAgfSkuY2F0Y2goKCkgPT4ge30pO1xuICB9XG4gIHN0YXRpYyBnZXQgZm9udEZhbWlseU1hcCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1dpbmRvd3MsXG4gICAgICBpc0ZpcmVmb3hcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiZm9udEZhbWlseU1hcFwiLCBuZXcgTWFwKFtbXCJzYW5zLXNlcmlmXCIsIGAke2lzV2luZG93cyAmJiBpc0ZpcmVmb3ggPyBcIkNhbGlicmksIFwiIDogXCJcIn1zYW5zLXNlcmlmYF0sIFtcIm1vbm9zcGFjZVwiLCBgJHtpc1dpbmRvd3MgJiYgaXNGaXJlZm94ID8gXCJMdWNpZGEgQ29uc29sZSwgXCIgOiBcIlwifW1vbm9zcGFjZWBdXSkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgdGhpcy4jcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgdGhpcy4jY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2xhbmcgPz89IHZhbHVlLmxhbmc7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy4jc3R5bGVDYWNoZSwgdmFsdWUuc3R5bGVzKTtcbiAgICAgICAgdGhpcy4jcHJvY2Vzc0l0ZW1zKHZhbHVlLml0ZW1zKTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSwgdGhpcy4jY2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIH07XG4gICAgdGhpcy4jcmVhZGVyID0gdGhpcy4jdGV4dENvbnRlbnRTb3VyY2UuZ2V0UmVhZGVyKCk7XG4gICAgVGV4dExheWVyLiNwZW5kaW5nVGV4dExheWVycy5hZGQodGhpcyk7XG4gICAgcHVtcCgpO1xuICAgIHJldHVybiB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydCxcbiAgICBvbkJlZm9yZSA9IG51bGxcbiAgfSkge1xuICAgIGNvbnN0IHNjYWxlID0gdmlld3BvcnQuc2NhbGUgKiAoZ2xvYmFsVGhpcy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdmlld3BvcnQucm90YXRpb247XG4gICAgaWYgKHJvdGF0aW9uICE9PSB0aGlzLiNyb3RhdGlvbikge1xuICAgICAgb25CZWZvcmU/LigpO1xuICAgICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgIHNldExheWVyRGltZW5zaW9ucyh0aGlzLiNyb290Q29udGFpbmVyLCB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjYWxlICE9PSB0aGlzLiNzY2FsZSkge1xuICAgICAgb25CZWZvcmU/LigpO1xuICAgICAgdGhpcy4jc2NhbGUgPSBzY2FsZTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICBjdHg6IFRleHRMYXllci4jZ2V0Q3R4KHRoaXMuI2xhbmcpXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jdGV4dERpdnMpIHtcbiAgICAgICAgcGFyYW1zLnByb3BlcnRpZXMgPSB0aGlzLiN0ZXh0RGl2UHJvcGVydGllcy5nZXQoZGl2KTtcbiAgICAgICAgcGFyYW1zLmRpdiA9IGRpdjtcbiAgICAgICAgdGhpcy4jbGF5b3V0KHBhcmFtcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBjb25zdCBhYm9ydEV4ID0gbmV3IEFib3J0RXhjZXB0aW9uKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKTtcbiAgICB0aGlzLiNyZWFkZXI/LmNhbmNlbChhYm9ydEV4KS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgdGhpcy4jcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdChhYm9ydEV4KTtcbiAgfVxuICBnZXQgdGV4dERpdnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RleHREaXZzO1xuICB9XG4gIGdldCB0ZXh0Q29udGVudEl0ZW1zU3RyKCkge1xuICAgIHJldHVybiB0aGlzLiN0ZXh0Q29udGVudEl0ZW1zU3RyO1xuICB9XG4gICNwcm9jZXNzSXRlbXMoaXRlbXMpIHtcbiAgICBpZiAodGhpcy4jZGlzYWJsZVByb2Nlc3NJdGVtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zLmN0eCA/Pz0gVGV4dExheWVyLiNnZXRDdHgodGhpcy4jbGFuZyk7XG4gICAgY29uc3QgdGV4dERpdnMgPSB0aGlzLiN0ZXh0RGl2cyxcbiAgICAgIHRleHRDb250ZW50SXRlbXNTdHIgPSB0aGlzLiN0ZXh0Q29udGVudEl0ZW1zU3RyO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgaWYgKHRleHREaXZzLmxlbmd0aCA+IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSKSB7XG4gICAgICAgIHdhcm4oXCJJZ25vcmluZyBhZGRpdGlvbmFsIHRleHREaXZzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlwiKTtcbiAgICAgICAgdGhpcy4jZGlzYWJsZVByb2Nlc3NJdGVtcyA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtLnN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHNcIiB8fCBpdGVtLnR5cGUgPT09IFwiYmVnaW5NYXJrZWRDb250ZW50XCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiNjb250YWluZXI7XG4gICAgICAgICAgdGhpcy4jY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXJrZWRDb250ZW50XCIpO1xuICAgICAgICAgIGlmIChpdGVtLmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNjb250YWluZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgYCR7aXRlbS5pZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50LmFwcGVuZCh0aGlzLiNjb250YWluZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gXCJlbmRNYXJrZWRDb250ZW50XCIpIHtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIgPSB0aGlzLiNjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRleHRDb250ZW50SXRlbXNTdHIucHVzaChpdGVtLnN0cik7XG4gICAgICB0aGlzLiNhcHBlbmRUZXh0KGl0ZW0pO1xuICAgIH1cbiAgfVxuICAjYXBwZW5kVGV4dChnZW9tKSB7XG4gICAgY29uc3QgdGV4dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0ge1xuICAgICAgYW5nbGU6IDAsXG4gICAgICBjYW52YXNXaWR0aDogMCxcbiAgICAgIGhhc1RleHQ6IGdlb20uc3RyICE9PSBcIlwiLFxuICAgICAgaGFzRU9MOiBnZW9tLmhhc0VPTCxcbiAgICAgIGZvbnRTaXplOiAwXG4gICAgfTtcbiAgICB0aGlzLiN0ZXh0RGl2cy5wdXNoKHRleHREaXYpO1xuICAgIGNvbnN0IHR4ID0gVXRpbC50cmFuc2Zvcm0odGhpcy4jdHJhbnNmb3JtLCBnZW9tLnRyYW5zZm9ybSk7XG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih0eFsxXSwgdHhbMF0pO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy4jc3R5bGVDYWNoZVtnZW9tLmZvbnROYW1lXTtcbiAgICBpZiAoc3R5bGUudmVydGljYWwpIHtcbiAgICAgIGFuZ2xlICs9IE1hdGguUEkgLyAyO1xuICAgIH1cbiAgICBsZXQgZm9udEZhbWlseSA9IHRoaXMuI2ZvbnRJbnNwZWN0b3JFbmFibGVkICYmIHN0eWxlLmZvbnRTdWJzdGl0dXRpb24gfHwgc3R5bGUuZm9udEZhbWlseTtcbiAgICBmb250RmFtaWx5ID0gVGV4dExheWVyLmZvbnRGYW1pbHlNYXAuZ2V0KGZvbnRGYW1pbHkpIHx8IGZvbnRGYW1pbHk7XG4gICAgY29uc3QgZm9udEhlaWdodCA9IE1hdGguaHlwb3QodHhbMl0sIHR4WzNdKTtcbiAgICBjb25zdCBmb250QXNjZW50ID0gZm9udEhlaWdodCAqIFRleHRMYXllci4jZ2V0QXNjZW50KGZvbnRGYW1pbHksIHRoaXMuI2xhbmcpO1xuICAgIGxldCBsZWZ0LCB0b3A7XG4gICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICBsZWZ0ID0gdHhbNF07XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSB0eFs0XSArIGZvbnRBc2NlbnQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlRmFjdG9yU3RyID0gXCJjYWxjKHZhcigtLXNjYWxlLWZhY3RvcikqXCI7XG4gICAgY29uc3QgZGl2U3R5bGUgPSB0ZXh0RGl2LnN0eWxlO1xuICAgIGlmICh0aGlzLiNjb250YWluZXIgPT09IHRoaXMuI3Jvb3RDb250YWluZXIpIHtcbiAgICAgIGRpdlN0eWxlLmxlZnQgPSBgJHsoMTAwICogbGVmdCAvIHRoaXMuI3BhZ2VXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICAgIGRpdlN0eWxlLnRvcCA9IGAkeygxMDAgKiB0b3AgLyB0aGlzLiNwYWdlSGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHtsZWZ0LnRvRml4ZWQoMil9cHgpYDtcbiAgICAgIGRpdlN0eWxlLnRvcCA9IGAke3NjYWxlRmFjdG9yU3RyfSR7dG9wLnRvRml4ZWQoMil9cHgpYDtcbiAgICB9XG4gICAgZGl2U3R5bGUuZm9udFNpemUgPSBgJHtzY2FsZUZhY3RvclN0cn0keyhUZXh0TGF5ZXIuI21pbkZvbnRTaXplICogZm9udEhlaWdodCkudG9GaXhlZCgyKX1weClgO1xuICAgIGRpdlN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgIHRleHREaXZQcm9wZXJ0aWVzLmZvbnRTaXplID0gZm9udEhlaWdodDtcbiAgICB0ZXh0RGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgdGV4dERpdi50ZXh0Q29udGVudCA9IGdlb20uc3RyO1xuICAgIHRleHREaXYuZGlyID0gZ2VvbS5kaXI7XG4gICAgaWYgKHRoaXMuI2ZvbnRJbnNwZWN0b3JFbmFibGVkKSB7XG4gICAgICB0ZXh0RGl2LmRhdGFzZXQuZm9udE5hbWUgPSBzdHlsZS5mb250U3Vic3RpdHV0aW9uTG9hZGVkTmFtZSB8fCBnZW9tLmZvbnROYW1lO1xuICAgIH1cbiAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmFuZ2xlID0gYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgfVxuICAgIGxldCBzaG91bGRTY2FsZVRleHQgPSBmYWxzZTtcbiAgICBpZiAoZ2VvbS5zdHIubGVuZ3RoID4gMSkge1xuICAgICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGdlb20uc3RyICE9PSBcIiBcIiAmJiBnZW9tLnRyYW5zZm9ybVswXSAhPT0gZ2VvbS50cmFuc2Zvcm1bM10pIHtcbiAgICAgIGNvbnN0IGFic1NjYWxlWCA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzBdKSxcbiAgICAgICAgYWJzU2NhbGVZID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bM10pO1xuICAgICAgaWYgKGFic1NjYWxlWCAhPT0gYWJzU2NhbGVZICYmIE1hdGgubWF4KGFic1NjYWxlWCwgYWJzU2NhbGVZKSAvIE1hdGgubWluKGFic1NjYWxlWCwgYWJzU2NhbGVZKSA+IDEuNSkge1xuICAgICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkU2NhbGVUZXh0KSB7XG4gICAgICB0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCA9IHN0eWxlLnZlcnRpY2FsID8gZ2VvbS5oZWlnaHQgOiBnZW9tLndpZHRoO1xuICAgIH1cbiAgICB0aGlzLiN0ZXh0RGl2UHJvcGVydGllcy5zZXQodGV4dERpdiwgdGV4dERpdlByb3BlcnRpZXMpO1xuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMuZGl2ID0gdGV4dERpdjtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zLnByb3BlcnRpZXMgPSB0ZXh0RGl2UHJvcGVydGllcztcbiAgICB0aGlzLiNsYXlvdXQodGhpcy4jbGF5b3V0VGV4dFBhcmFtcyk7XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQodGV4dERpdik7XG4gICAgfVxuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNFT0wpIHtcbiAgICAgIGNvbnN0IGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgYnIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQoYnIpO1xuICAgIH1cbiAgfVxuICAjbGF5b3V0KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdixcbiAgICAgIHByb3BlcnRpZXMsXG4gICAgICBjdHhcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBsZXQgdHJhbnNmb3JtID0gXCJcIjtcbiAgICBpZiAoVGV4dExheWVyLiNtaW5Gb250U2l6ZSA+IDEpIHtcbiAgICAgIHRyYW5zZm9ybSA9IGBzY2FsZSgkezEgLyBUZXh0TGF5ZXIuI21pbkZvbnRTaXplfSlgO1xuICAgIH1cbiAgICBpZiAocHJvcGVydGllcy5jYW52YXNXaWR0aCAhPT0gMCAmJiBwcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9udEZhbWlseVxuICAgICAgfSA9IHN0eWxlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYW52YXNXaWR0aCxcbiAgICAgICAgZm9udFNpemVcbiAgICAgIH0gPSBwcm9wZXJ0aWVzO1xuICAgICAgVGV4dExheWVyLiNlbnN1cmVDdHhGb250KGN0eCwgZm9udFNpemUgKiB0aGlzLiNzY2FsZSwgZm9udEZhbWlseSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoXG4gICAgICB9ID0gY3R4Lm1lYXN1cmVUZXh0KGRpdi50ZXh0Q29udGVudCk7XG4gICAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IGBzY2FsZVgoJHtjYW52YXNXaWR0aCAqIHRoaXMuI3NjYWxlIC8gd2lkdGh9KSAke3RyYW5zZm9ybX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcGVydGllcy5hbmdsZSAhPT0gMCkge1xuICAgICAgdHJhbnNmb3JtID0gYHJvdGF0ZSgke3Byb3BlcnRpZXMuYW5nbGV9ZGVnKSAke3RyYW5zZm9ybX1gO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuI3BlbmRpbmdUZXh0TGF5ZXJzLnNpemUgPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FzY2VudENhY2hlLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBjYW52YXNcbiAgICB9IG9mIHRoaXMuI2NhbnZhc0NvbnRleHRzLnZhbHVlcygpKSB7XG4gICAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuI2NhbnZhc0NvbnRleHRzLmNsZWFyKCk7XG4gIH1cbiAgc3RhdGljICNnZXRDdHgobGFuZyA9IG51bGwpIHtcbiAgICBsZXQgY3R4ID0gdGhpcy4jY2FudmFzQ29udGV4dHMuZ2V0KGxhbmcgfHw9IFwiXCIpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiaGlkZGVuQ2FudmFzRWxlbWVudFwiO1xuICAgICAgY2FudmFzLmxhbmcgPSBsYW5nO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoY2FudmFzKTtcbiAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICBhbHBoYTogZmFsc2UsXG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLiNjYW52YXNDb250ZXh0cy5zZXQobGFuZywgY3R4KTtcbiAgICAgIHRoaXMuI2NhbnZhc0N0eEZvbnRzLnNldChjdHgsIHtcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgZmFtaWx5OiBcIlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuICBzdGF0aWMgI2Vuc3VyZUN0eEZvbnQoY3R4LCBzaXplLCBmYW1pbHkpIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLiNjYW52YXNDdHhGb250cy5nZXQoY3R4KTtcbiAgICBpZiAoc2l6ZSA9PT0gY2FjaGVkLnNpemUgJiYgZmFtaWx5ID09PSBjYWNoZWQuZmFtaWx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5mb250ID0gYCR7c2l6ZX1weCAke2ZhbWlseX1gO1xuICAgIGNhY2hlZC5zaXplID0gc2l6ZTtcbiAgICBjYWNoZWQuZmFtaWx5ID0gZmFtaWx5O1xuICB9XG4gIHN0YXRpYyAjZW5zdXJlTWluRm9udFNpemVDb21wdXRlZCgpIHtcbiAgICBpZiAodGhpcy4jbWluRm9udFNpemUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAxO1xuICAgIGRpdi5zdHlsZS5mb250U2l6ZSA9IFwiMXB4XCI7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi50ZXh0Q29udGVudCA9IFwiWFwiO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgdGhpcy4jbWluRm9udFNpemUgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIGRpdi5yZW1vdmUoKTtcbiAgfVxuICBzdGF0aWMgI2dldEFzY2VudChmb250RmFtaWx5LCBsYW5nKSB7XG4gICAgY29uc3QgY2FjaGVkQXNjZW50ID0gdGhpcy4jYXNjZW50Q2FjaGUuZ2V0KGZvbnRGYW1pbHkpO1xuICAgIGlmIChjYWNoZWRBc2NlbnQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRBc2NlbnQ7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuI2dldEN0eChsYW5nKTtcbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSBERUZBVUxUX0ZPTlRfU0laRTtcbiAgICB0aGlzLiNlbnN1cmVDdHhGb250KGN0eCwgREVGQVVMVF9GT05UX1NJWkUsIGZvbnRGYW1pbHkpO1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQoXCJcIik7XG4gICAgbGV0IGFzY2VudCA9IG1ldHJpY3MuZm9udEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGxldCBkZXNjZW50ID0gTWF0aC5hYnMobWV0cmljcy5mb250Qm91bmRpbmdCb3hEZXNjZW50KTtcbiAgICBpZiAoYXNjZW50KSB7XG4gICAgICBjb25zdCByYXRpbyA9IGFzY2VudCAvIChhc2NlbnQgKyBkZXNjZW50KTtcbiAgICAgIHRoaXMuI2FzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgcmV0dXJuIHJhdGlvO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgICBjdHguc3Ryb2tlVGV4dChcImdcIiwgMCwgMCk7XG4gICAgbGV0IHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKS5kYXRhO1xuICAgIGRlc2NlbnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSBwaXhlbHMubGVuZ3RoIC0gMSAtIDM7IGkgPj0gMDsgaSAtPSA0KSB7XG4gICAgICBpZiAocGl4ZWxzW2ldID4gMCkge1xuICAgICAgICBkZXNjZW50ID0gTWF0aC5jZWlsKGkgLyA0IC8gREVGQVVMVF9GT05UX1NJWkUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpO1xuICAgIGN0eC5zdHJva2VUZXh0KFwiQVwiLCAwLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpLmRhdGE7XG4gICAgYXNjZW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwaXhlbHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgaWYgKHBpeGVsc1tpXSA+IDApIHtcbiAgICAgICAgYXNjZW50ID0gREVGQVVMVF9GT05UX1NJWkUgLSBNYXRoLmZsb29yKGkgLyA0IC8gREVGQVVMVF9GT05UX1NJWkUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmNhbnZhcy53aWR0aCA9IGN0eC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICBjb25zdCByYXRpbyA9IGFzY2VudCA/IGFzY2VudCAvIChhc2NlbnQgKyBkZXNjZW50KSA6IERFRkFVTFRfRk9OVF9BU0NFTlQ7XG4gICAgdGhpcy4jYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIHJhdGlvKTtcbiAgICByZXR1cm4gcmF0aW87XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkveGZhX3RleHQuanNcbmNsYXNzIFhmYVRleHQge1xuICBzdGF0aWMgdGV4dENvbnRlbnQoeGZhKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICBpdGVtcyxcbiAgICAgIHN0eWxlczogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG4gICAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN0ciA9IG51bGw7XG4gICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmICghWGZhVGV4dC5zaG91bGRCdWlsZFRleHQobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChub2RlPy5hdHRyaWJ1dGVzPy50ZXh0Q29udGVudCkge1xuICAgICAgICBzdHIgPSBub2RlLmF0dHJpYnV0ZXMudGV4dENvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgc3RyID0gbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIgIT09IG51bGwpIHtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgc3RyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICB3YWxrKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2Fsayh4ZmEpO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgc3RhdGljIHNob3VsZEJ1aWxkVGV4dChuYW1lKSB7XG4gICAgcmV0dXJuICEobmFtZSA9PT0gXCJ0ZXh0YXJlYVwiIHx8IG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcIm9wdGlvblwiIHx8IG5hbWUgPT09IFwic2VsZWN0XCIpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2FwaS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRSA9IDY1NTM2O1xuY29uc3QgUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUID0gMTAwO1xuY29uc3QgREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQgPSA1MDAwO1xuY29uc3QgRGVmYXVsdENhbnZhc0ZhY3RvcnkgPSBpc05vZGVKUyA/IE5vZGVDYW52YXNGYWN0b3J5IDogRE9NQ2FudmFzRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSA9IGlzTm9kZUpTID8gTm9kZUNNYXBSZWFkZXJGYWN0b3J5IDogRE9NQ01hcFJlYWRlckZhY3Rvcnk7XG5jb25zdCBEZWZhdWx0RmlsdGVyRmFjdG9yeSA9IGlzTm9kZUpTID8gTm9kZUZpbHRlckZhY3RvcnkgOiBET01GaWx0ZXJGYWN0b3J5O1xuY29uc3QgRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gaXNOb2RlSlMgPyBOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgOiBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbmZ1bmN0aW9uIGdldERvY3VtZW50KHNyYyA9IHt9KSB7XG4gIGlmICh0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiIHx8IHNyYyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHNyYyA9IHtcbiAgICAgIHVybDogc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoc3JjKSkge1xuICAgIHNyYyA9IHtcbiAgICAgIGRhdGE6IHNyY1xuICAgIH07XG4gIH1cbiAgY29uc3QgdGFzayA9IG5ldyBQREZEb2N1bWVudExvYWRpbmdUYXNrKCk7XG4gIGNvbnN0IHtcbiAgICBkb2NJZFxuICB9ID0gdGFzaztcbiAgY29uc3QgdXJsID0gc3JjLnVybCA/IGdldFVybFByb3Aoc3JjLnVybCkgOiBudWxsO1xuICBjb25zdCBkYXRhID0gc3JjLmRhdGEgPyBnZXREYXRhUHJvcChzcmMuZGF0YSkgOiBudWxsO1xuICBjb25zdCBodHRwSGVhZGVycyA9IHNyYy5odHRwSGVhZGVycyB8fCBudWxsO1xuICBjb25zdCB3aXRoQ3JlZGVudGlhbHMgPSBzcmMud2l0aENyZWRlbnRpYWxzID09PSB0cnVlO1xuICBjb25zdCBwYXNzd29yZCA9IHNyYy5wYXNzd29yZCA/PyBudWxsO1xuICBjb25zdCByYW5nZVRyYW5zcG9ydCA9IHNyYy5yYW5nZSBpbnN0YW5jZW9mIFBERkRhdGFSYW5nZVRyYW5zcG9ydCA/IHNyYy5yYW5nZSA6IG51bGw7XG4gIGNvbnN0IHJhbmdlQ2h1bmtTaXplID0gTnVtYmVyLmlzSW50ZWdlcihzcmMucmFuZ2VDaHVua1NpemUpICYmIHNyYy5yYW5nZUNodW5rU2l6ZSA+IDAgPyBzcmMucmFuZ2VDaHVua1NpemUgOiBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkU7XG4gIGxldCB3b3JrZXIgPSBzcmMud29ya2VyIGluc3RhbmNlb2YgUERGV29ya2VyID8gc3JjLndvcmtlciA6IG51bGw7XG4gIGNvbnN0IHZlcmJvc2l0eSA9IHNyYy52ZXJib3NpdHk7XG4gIGNvbnN0IGRvY0Jhc2VVcmwgPSB0eXBlb2Ygc3JjLmRvY0Jhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgIWlzRGF0YVNjaGVtZShzcmMuZG9jQmFzZVVybCkgPyBzcmMuZG9jQmFzZVVybCA6IG51bGw7XG4gIGNvbnN0IGNNYXBVcmwgPSB0eXBlb2Ygc3JjLmNNYXBVcmwgPT09IFwic3RyaW5nXCIgPyBzcmMuY01hcFVybCA6IG51bGw7XG4gIGNvbnN0IGNNYXBQYWNrZWQgPSBzcmMuY01hcFBhY2tlZCAhPT0gZmFsc2U7XG4gIGNvbnN0IENNYXBSZWFkZXJGYWN0b3J5ID0gc3JjLkNNYXBSZWFkZXJGYWN0b3J5IHx8IERlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeTtcbiAgY29uc3Qgc3RhbmRhcmRGb250RGF0YVVybCA9IHR5cGVvZiBzcmMuc3RhbmRhcmRGb250RGF0YVVybCA9PT0gXCJzdHJpbmdcIiA/IHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsIDogbnVsbDtcbiAgY29uc3QgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBzcmMuU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgfHwgRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuICBjb25zdCBpZ25vcmVFcnJvcnMgPSBzcmMuc3RvcEF0RXJyb3JzICE9PSB0cnVlO1xuICBjb25zdCBtYXhJbWFnZVNpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5tYXhJbWFnZVNpemUpICYmIHNyYy5tYXhJbWFnZVNpemUgPiAtMSA/IHNyYy5tYXhJbWFnZVNpemUgOiAtMTtcbiAgY29uc3QgaXNFdmFsU3VwcG9ydGVkID0gc3JjLmlzRXZhbFN1cHBvcnRlZCAhPT0gZmFsc2U7XG4gIGNvbnN0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID0gdHlwZW9mIHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA9PT0gXCJib29sZWFuXCIgPyBzcmMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgOiAhaXNOb2RlSlM7XG4gIGNvbnN0IGlzQ2hyb21lID0gdHlwZW9mIHNyYy5pc0Nocm9tZSA9PT0gXCJib29sZWFuXCIgPyBzcmMuaXNDaHJvbWUgOiAhdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc0ZpcmVmb3ggJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIXdpbmRvdz8uY2hyb21lO1xuICBjb25zdCBjYW52YXNNYXhBcmVhSW5CeXRlcyA9IE51bWJlci5pc0ludGVnZXIoc3JjLmNhbnZhc01heEFyZWFJbkJ5dGVzKSA/IHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcyA6IC0xO1xuICBjb25zdCBkaXNhYmxlRm9udEZhY2UgPSB0eXBlb2Ygc3JjLmRpc2FibGVGb250RmFjZSA9PT0gXCJib29sZWFuXCIgPyBzcmMuZGlzYWJsZUZvbnRGYWNlIDogaXNOb2RlSlM7XG4gIGNvbnN0IGZvbnRFeHRyYVByb3BlcnRpZXMgPSBzcmMuZm9udEV4dHJhUHJvcGVydGllcyA9PT0gdHJ1ZTtcbiAgY29uc3QgZW5hYmxlWGZhID0gc3JjLmVuYWJsZVhmYSA9PT0gdHJ1ZTtcbiAgY29uc3Qgb3duZXJEb2N1bWVudCA9IHNyYy5vd25lckRvY3VtZW50IHx8IGdsb2JhbFRoaXMuZG9jdW1lbnQ7XG4gIGNvbnN0IGRpc2FibGVSYW5nZSA9IHNyYy5kaXNhYmxlUmFuZ2UgPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVTdHJlYW0gPSBzcmMuZGlzYWJsZVN0cmVhbSA9PT0gdHJ1ZTtcbiAgY29uc3QgZGlzYWJsZUF1dG9GZXRjaCA9IHNyYy5kaXNhYmxlQXV0b0ZldGNoID09PSB0cnVlO1xuICBjb25zdCBwZGZCdWcgPSBzcmMucGRmQnVnID09PSB0cnVlO1xuICBjb25zdCBDYW52YXNGYWN0b3J5ID0gc3JjLkNhbnZhc0ZhY3RvcnkgfHwgRGVmYXVsdENhbnZhc0ZhY3Rvcnk7XG4gIGNvbnN0IEZpbHRlckZhY3RvcnkgPSBzcmMuRmlsdGVyRmFjdG9yeSB8fCBEZWZhdWx0RmlsdGVyRmFjdG9yeTtcbiAgY29uc3QgZW5hYmxlSFdBID0gc3JjLmVuYWJsZUhXQSA9PT0gdHJ1ZTtcbiAgY29uc3QgbGVuZ3RoID0gcmFuZ2VUcmFuc3BvcnQgPyByYW5nZVRyYW5zcG9ydC5sZW5ndGggOiBzcmMubGVuZ3RoID8/IE5hTjtcbiAgY29uc3QgdXNlU3lzdGVtRm9udHMgPSB0eXBlb2Ygc3JjLnVzZVN5c3RlbUZvbnRzID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VTeXN0ZW1Gb250cyA6ICFpc05vZGVKUyAmJiAhZGlzYWJsZUZvbnRGYWNlO1xuICBjb25zdCB1c2VXb3JrZXJGZXRjaCA9IHR5cGVvZiBzcmMudXNlV29ya2VyRmV0Y2ggPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVdvcmtlckZldGNoIDogQ01hcFJlYWRlckZhY3RvcnkgPT09IERPTUNNYXBSZWFkZXJGYWN0b3J5ICYmIFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID09PSBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSAmJiBjTWFwVXJsICYmIHN0YW5kYXJkRm9udERhdGFVcmwgJiYgaXNWYWxpZEZldGNoVXJsKGNNYXBVcmwsIGRvY3VtZW50LmJhc2VVUkkpICYmIGlzVmFsaWRGZXRjaFVybChzdGFuZGFyZEZvbnREYXRhVXJsLCBkb2N1bWVudC5iYXNlVVJJKTtcbiAgaWYgKHNyYy5jYW52YXNGYWN0b3J5KSB7XG4gICAgZGVwcmVjYXRlZChcImBjYW52YXNGYWN0b3J5YC1pbnN0YW5jZSBvcHRpb24sIHBsZWFzZSB1c2UgYENhbnZhc0ZhY3RvcnlgIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmIChzcmMuZmlsdGVyRmFjdG9yeSkge1xuICAgIGRlcHJlY2F0ZWQoXCJgZmlsdGVyRmFjdG9yeWAtaW5zdGFuY2Ugb3B0aW9uLCBwbGVhc2UgdXNlIGBGaWx0ZXJGYWN0b3J5YCBpbnN0ZWFkLlwiKTtcbiAgfVxuICBjb25zdCBzdHlsZUVsZW1lbnQgPSBudWxsO1xuICBzZXRWZXJib3NpdHlMZXZlbCh2ZXJib3NpdHkpO1xuICBjb25zdCB0cmFuc3BvcnRGYWN0b3J5ID0ge1xuICAgIGNhbnZhc0ZhY3Rvcnk6IG5ldyBDYW52YXNGYWN0b3J5KHtcbiAgICAgIG93bmVyRG9jdW1lbnQsXG4gICAgICBlbmFibGVIV0FcbiAgICB9KSxcbiAgICBmaWx0ZXJGYWN0b3J5OiBuZXcgRmlsdGVyRmFjdG9yeSh7XG4gICAgICBkb2NJZCxcbiAgICAgIG93bmVyRG9jdW1lbnRcbiAgICB9KSxcbiAgICBjTWFwUmVhZGVyRmFjdG9yeTogdXNlV29ya2VyRmV0Y2ggPyBudWxsIDogbmV3IENNYXBSZWFkZXJGYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IGNNYXBVcmwsXG4gICAgICBpc0NvbXByZXNzZWQ6IGNNYXBQYWNrZWRcbiAgICB9KSxcbiAgICBzdGFuZGFyZEZvbnREYXRhRmFjdG9yeTogdXNlV29ya2VyRmV0Y2ggPyBudWxsIDogbmV3IFN0YW5kYXJkRm9udERhdGFGYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IHN0YW5kYXJkRm9udERhdGFVcmxcbiAgICB9KVxuICB9O1xuICBpZiAoIXdvcmtlcikge1xuICAgIGNvbnN0IHdvcmtlclBhcmFtcyA9IHtcbiAgICAgIHZlcmJvc2l0eSxcbiAgICAgIHBvcnQ6IEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydFxuICAgIH07XG4gICAgd29ya2VyID0gd29ya2VyUGFyYW1zLnBvcnQgPyBQREZXb3JrZXIuZnJvbVBvcnQod29ya2VyUGFyYW1zKSA6IG5ldyBQREZXb3JrZXIod29ya2VyUGFyYW1zKTtcbiAgICB0YXNrLl93b3JrZXIgPSB3b3JrZXI7XG4gIH1cbiAgY29uc3QgZG9jUGFyYW1zID0ge1xuICAgIGRvY0lkLFxuICAgIGFwaVZlcnNpb246IFwiNC44LjY5XCIsXG4gICAgZGF0YSxcbiAgICBwYXNzd29yZCxcbiAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgIGxlbmd0aCxcbiAgICBkb2NCYXNlVXJsLFxuICAgIGVuYWJsZVhmYSxcbiAgICBldmFsdWF0b3JPcHRpb25zOiB7XG4gICAgICBtYXhJbWFnZVNpemUsXG4gICAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgICBpZ25vcmVFcnJvcnMsXG4gICAgICBpc0V2YWxTdXBwb3J0ZWQsXG4gICAgICBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCxcbiAgICAgIGlzQ2hyb21lLFxuICAgICAgY2FudmFzTWF4QXJlYUluQnl0ZXMsXG4gICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgdXNlU3lzdGVtRm9udHMsXG4gICAgICBjTWFwVXJsOiB1c2VXb3JrZXJGZXRjaCA/IGNNYXBVcmwgOiBudWxsLFxuICAgICAgc3RhbmRhcmRGb250RGF0YVVybDogdXNlV29ya2VyRmV0Y2ggPyBzdGFuZGFyZEZvbnREYXRhVXJsIDogbnVsbFxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJhbnNwb3J0UGFyYW1zID0ge1xuICAgIGRpc2FibGVGb250RmFjZSxcbiAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgcGRmQnVnLFxuICAgIHN0eWxlRWxlbWVudCxcbiAgICBsb2FkaW5nUGFyYW1zOiB7XG4gICAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgICAgZW5hYmxlWGZhXG4gICAgfVxuICB9O1xuICB3b3JrZXIucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB3b3JrZXJJZFByb21pc2UgPSB3b3JrZXIubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RG9jUmVxdWVzdFwiLCBkb2NQYXJhbXMsIGRhdGEgPyBbZGF0YS5idWZmZXJdIDogbnVsbCk7XG4gICAgbGV0IG5ldHdvcmtTdHJlYW07XG4gICAgaWYgKHJhbmdlVHJhbnNwb3J0KSB7XG4gICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW0ocmFuZ2VUcmFuc3BvcnQsIHtcbiAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFkYXRhKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREb2N1bWVudCAtIG5vIGB1cmxgIHBhcmFtZXRlciBwcm92aWRlZC5cIik7XG4gICAgICB9XG4gICAgICBsZXQgTmV0d29ya1N0cmVhbTtcbiAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICBjb25zdCBpc0ZldGNoU3VwcG9ydGVkID0gdHlwZW9mIGZldGNoICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBSZXNwb25zZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcImJvZHlcIiBpbiBSZXNwb25zZS5wcm90b3R5cGU7XG4gICAgICAgIE5ldHdvcmtTdHJlYW0gPSBpc0ZldGNoU3VwcG9ydGVkICYmIGlzVmFsaWRGZXRjaFVybCh1cmwpID8gUERGRmV0Y2hTdHJlYW0gOiBQREZOb2RlU3RyZWFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTmV0d29ya1N0cmVhbSA9IGlzVmFsaWRGZXRjaFVybCh1cmwpID8gUERGRmV0Y2hTdHJlYW0gOiBQREZOZXR3b3JrU3RyZWFtO1xuICAgICAgfVxuICAgICAgbmV0d29ya1N0cmVhbSA9IG5ldyBOZXR3b3JrU3RyZWFtKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGh0dHBIZWFkZXJzLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2UsXG4gICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VySWRQcm9taXNlLnRoZW4od29ya2VySWQgPT4ge1xuICAgICAgaWYgKHRhc2suZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoZG9jSWQsIHdvcmtlcklkLCB3b3JrZXIucG9ydCk7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgV29ya2VyVHJhbnNwb3J0KG1lc3NhZ2VIYW5kbGVyLCB0YXNrLCBuZXR3b3JrU3RyZWFtLCB0cmFuc3BvcnRQYXJhbXMsIHRyYW5zcG9ydEZhY3RvcnkpO1xuICAgICAgdGFzay5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcIlJlYWR5XCIsIG51bGwpO1xuICAgIH0pO1xuICB9KS5jYXRjaCh0YXNrLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gIHJldHVybiB0YXNrO1xufVxuZnVuY3Rpb24gZ2V0VXJsUHJvcCh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHJldHVybiB2YWwuaHJlZjtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKHZhbCwgd2luZG93LmxvY2F0aW9uKS5ocmVmO1xuICB9IGNhdGNoIHtcbiAgICBpZiAoaXNOb2RlSlMgJiYgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgdXJsIGRhdGE6IFwiICsgXCJlaXRoZXIgc3RyaW5nIG9yIFVSTC1vYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIHVybCBwcm9wZXJ0eS5cIik7XG59XG5mdW5jdGlvbiBnZXREYXRhUHJvcCh2YWwpIHtcbiAgaWYgKGlzTm9kZUpTICYmIHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYmluYXJ5IGRhdGEgYXMgYFVpbnQ4QXJyYXlgLCByYXRoZXIgdGhhbiBgQnVmZmVyYC5cIik7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsLmJ5dGVMZW5ndGggPT09IHZhbC5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWwpO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKSB8fCB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmICFpc05hTih2YWw/Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiBiaW5hcnkgZGF0YTogZWl0aGVyIFR5cGVkQXJyYXksIFwiICsgXCJzdHJpbmcsIG9yIGFycmF5LWxpa2Ugb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSBkYXRhIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGlzUmVmUHJveHkocmVmKSB7XG4gIHJldHVybiB0eXBlb2YgcmVmID09PSBcIm9iamVjdFwiICYmIE51bWJlci5pc0ludGVnZXIocmVmPy5udW0pICYmIHJlZi5udW0gPj0gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHJlZj8uZ2VuKSAmJiByZWYuZ2VuID49IDA7XG59XG5jbGFzcyBQREZEb2N1bWVudExvYWRpbmdUYXNrIHtcbiAgc3RhdGljICNkb2NJZCA9IDA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgdGhpcy5kb2NJZCA9IGBkJHtQREZEb2N1bWVudExvYWRpbmdUYXNrLiNkb2NJZCsrfWA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uUGFzc3dvcmQgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydD8uZGVzdHJveSgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXg7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3dvcmtlcikge1xuICAgICAgdGhpcy5fd29ya2VyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZEYXRhUmFuZ2VUcmFuc3BvcnQge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGluaXRpYWxEYXRhLCBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSwgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHRoaXMucHJvZ3Jlc3NpdmVEb25lID0gcHJvZ3Jlc3NpdmVEb25lO1xuICAgIHRoaXMuY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgICB0aGlzLl9yYW5nZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gIH1cbiAgYWRkUmFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3JhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBvbkRhdGFSYW5nZShiZWdpbiwgY2h1bmspIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3JhbmdlTGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcihiZWdpbiwgY2h1bmspO1xuICAgIH1cbiAgfVxuICBvbkRhdGFQcm9ncmVzcyhsb2FkZWQsIHRvdGFsKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGxvYWRlZCwgdG90YWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uRGF0YVByb2dyZXNzaXZlUmVhZChjaHVuaykge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uRGF0YVByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdHJhbnNwb3J0UmVhZHkoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICByZXF1ZXN0RGF0YVJhbmdlKGJlZ2luLCBlbmQpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZVwiKTtcbiAgfVxuICBhYm9ydCgpIHt9XG59XG5jbGFzcyBQREZEb2N1bWVudFByb3h5IHtcbiAgY29uc3RydWN0b3IocGRmSW5mbywgdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fcGRmSW5mbyA9IHBkZkluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmFubm90YXRpb25TdG9yYWdlO1xuICB9XG4gIGdldCBjYW52YXNGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuY2FudmFzRmFjdG9yeTtcbiAgfVxuICBnZXQgZmlsdGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3Rvcnk7XG4gIH1cbiAgZ2V0IG51bVBhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9wZGZJbmZvLm51bVBhZ2VzO1xuICB9XG4gIGdldCBmaW5nZXJwcmludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8uZmluZ2VycHJpbnRzO1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgZ2V0IGFsbFhmYUh0bWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYTtcbiAgfVxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2UocGFnZU51bWJlcik7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUluZGV4KHJlZik7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb25zKCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9uKGlkKTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxhYmVscygpO1xuICB9XG4gIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGF5b3V0KCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTW9kZSgpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKTtcbiAgfVxuICBnZXRPcGVuQWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3BlbkFjdGlvbigpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QXR0YWNobWVudHMoKTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREb2NKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3V0bGluZSgpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZyh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50XG4gICAgfSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGVybWlzc2lvbnMoKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1ldGFkYXRhKCk7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNYXJrSW5mbygpO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREYXRhKCk7XG4gIH1cbiAgc2F2ZURvY3VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2F2ZURvY3VtZW50KCk7XG4gIH1cbiAgZ2V0RG93bmxvYWRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgfHwgdGhpcy5pc1B1cmVYZmEpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1Rhc2suZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlZFBhZ2VOdW1iZXIocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5jYWNoZWRQYWdlTnVtYmVyKHJlZik7XG4gIH1cbiAgZ2V0IGxvYWRpbmdQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nUGFyYW1zO1xuICB9XG4gIGdldCBsb2FkaW5nVGFzaygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdUYXNrO1xuICB9XG4gIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEZpZWxkT2JqZWN0cygpO1xuICB9XG4gIGhhc0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lmhhc0pTQWN0aW9ucygpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRDYWxjdWxhdGlvbk9yZGVySWRzKCk7XG4gIH1cbn1cbmNsYXNzIFBERlBhZ2VQcm94eSB7XG4gICNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBudWxsO1xuICAjcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IocGFnZUluZGV4LCBwYWdlSW5mbywgdHJhbnNwb3J0LCBwZGZCdWcgPSBmYWxzZSkge1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLl9wYWdlSW5mbyA9IHBhZ2VJbmZvO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLl9zdGF0cyA9IHBkZkJ1ZyA/IG5ldyBTdGF0VGltZXIoKSA6IG51bGw7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IHRyYW5zcG9ydC5jb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5fbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgcGFnZU51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZGV4ICsgMTtcbiAgfVxuICBnZXQgcm90YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yb3RhdGU7XG4gIH1cbiAgZ2V0IHJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8ucmVmO1xuICB9XG4gIGdldCB1c2VyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udXNlclVuaXQ7XG4gIH1cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnZpZXc7XG4gIH1cbiAgZ2V0Vmlld3BvcnQoe1xuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGUsXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgICB2aWV3Qm94OiB0aGlzLnZpZXcsXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIlxuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnRcbiAgICB9ID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QW5ub3RhdGlvbnModGhpcy5fcGFnZUluZGV4LCByZW5kZXJpbmdJbnRlbnQpO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VKU0FjdGlvbnModGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBnZXQgZmlsdGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3Rvcnk7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBhc3luYyBnZXRYZmEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYT8uY2hpbGRyZW5bdGhpcy5fcGFnZUluZGV4XSB8fCBudWxsO1xuICB9XG4gIHJlbmRlcih7XG4gICAgY2FudmFzQ29udGV4dCxcbiAgICB2aWV3cG9ydCxcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICB0cmFuc2Zvcm0gPSBudWxsLFxuICAgIGJhY2tncm91bmQgPSBudWxsLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSBudWxsLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAgPSBudWxsLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLFxuICAgIGlzRWRpdGluZyA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLl9zdGF0cz8udGltZShcIk92ZXJhbGxcIik7XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgaXNFZGl0aW5nKTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleVxuICAgIH0gPSBpbnRlbnRBcmdzO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgdGhpcy4jYWJvcnREZWxheWVkQ2xlYW51cCgpO1xuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgfHw9IHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KTtcbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW50ZW50UHJpbnQgPSAhIShyZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtcbiAgICBpZiAoIWludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBjb21wbGV0ZSA9IGVycm9yID0+IHtcbiAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgICAgaWYgKHRoaXMuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyIHx8IGludGVudFByaW50KSB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3RyeUNsZWFudXAoIWludGVudFByaW50KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgcmVhc29uOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJSZW5kZXJpbmdcIik7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJPdmVyYWxsXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5TdGF0cz8uZW5hYmxlZCkge1xuICAgICAgICAgIGdsb2JhbFRoaXMuU3RhdHMuYWRkKHRoaXMucGFnZU51bWJlciwgdGhpcy5fc3RhdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgPSBuZXcgSW50ZXJuYWxSZW5kZXJUYXNrKHtcbiAgICAgIGNhbGxiYWNrOiBjb21wbGV0ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBiYWNrZ3JvdW5kXG4gICAgICB9LFxuICAgICAgb2JqczogdGhpcy5vYmpzLFxuICAgICAgY29tbW9uT2JqczogdGhpcy5jb21tb25PYmpzLFxuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICAgIG9wZXJhdG9yTGlzdDogaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LFxuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBjYW52YXNGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuY2FudmFzRmFjdG9yeSxcbiAgICAgIGZpbHRlckZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5LFxuICAgICAgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lOiAhaW50ZW50UHJpbnQsXG4gICAgICBwZGZCdWc6IHRoaXMuX3BkZkJ1ZyxcbiAgICAgIHBhZ2VDb2xvcnNcbiAgICB9KTtcbiAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgY29uc3QgcmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzay50YXNrO1xuICAgIFByb21pc2UuYWxsKFtpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnByb21pc2UsIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2VdKS50aGVuKChbdHJhbnNwYXJlbmN5LCBvcHRpb25hbENvbnRlbnRDb25maWddKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJSZW5kZXJpbmdcIik7XG4gICAgICBpZiAoIShvcHRpb25hbENvbnRlbnRDb25maWcucmVuZGVyaW5nSW50ZW50ICYgcmVuZGVyaW5nSW50ZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHVzZSB0aGUgc2FtZSBgaW50ZW50YC1hcmd1bWVudCB3aGVuIGNhbGxpbmcgdGhlIGBQREZQYWdlUHJveHkucmVuZGVyYCBcIiArIFwiYW5kIGBQREZEb2N1bWVudFByb3h5LmdldE9wdGlvbmFsQ29udGVudENvbmZpZ2AgbWV0aG9kcy5cIik7XG4gICAgICB9XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2suaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICAgIH0pO1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9KS5jYXRjaChjb21wbGV0ZSk7XG4gICAgcmV0dXJuIHJlbmRlclRhc2s7XG4gIH1cbiAgZ2V0T3BlcmF0b3JMaXN0KHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCxcbiAgICBpc0VkaXRpbmcgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBmdW5jdGlvbiBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVzb2x2ZShpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpO1xuICAgICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUob3BMaXN0VGFzayk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIGlzRWRpdGluZywgdHJ1ZSk7XG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChpbnRlbnRBcmdzLmNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGludGVudEFyZ3MuY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG9wTGlzdFRhc2s7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgb3BMaXN0VGFzayA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBvcExpc3RUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQgPSBvcGVyYXRvckxpc3RDaGFuZ2VkO1xuICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQob3BMaXN0VGFzayk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc3RyZWFtVGV4dENvbnRlbnQoe1xuICAgIGluY2x1ZGVNYXJrZWRDb250ZW50ID0gZmFsc2UsXG4gICAgZGlzYWJsZU5vcm1hbGl6YXRpb24gPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBjb25zdCBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSA9IDEwMDtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKFwiR2V0VGV4dENvbnRlbnRcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbmNsdWRlTWFya2VkQ29udGVudDogaW5jbHVkZU1hcmtlZENvbnRlbnQgPT09IHRydWUsXG4gICAgICBkaXNhYmxlTm9ybWFsaXphdGlvbjogZGlzYWJsZU5vcm1hbGl6YXRpb24gPT09IHRydWVcbiAgICB9LCB7XG4gICAgICBoaWdoV2F0ZXJNYXJrOiBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSxcbiAgICAgIHNpemUodGV4dENvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb250ZW50Lml0ZW1zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUZXh0Q29udGVudChwYXJhbXMgPSB7fSkge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFhmYSgpLnRoZW4oeGZhID0+IFhmYVRleHQudGV4dENvbnRlbnQoeGZhKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gdGhpcy5zdHJlYW1UZXh0Q29udGVudChwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRDb250ZW50LmxhbmcgPz89IHZhbHVlLmxhbmc7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0ZXh0Q29udGVudC5zdHlsZXMsIHZhbHVlLnN0eWxlcyk7XG4gICAgICAgICAgdGV4dENvbnRlbnQuaXRlbXMucHVzaCguLi52YWx1ZS5pdGVtcyk7XG4gICAgICAgICAgcHVtcCgpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudCA9IHtcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGxhbmc6IG51bGxcbiAgICAgIH07XG4gICAgICBwdW1wKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RydWN0VHJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFN0cnVjdFRyZWUodGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBpbnRlbnRTdGF0ZSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgIHJlYXNvbjogbmV3IEVycm9yKFwiUGFnZSB3YXMgZGVzdHJveWVkLlwiKSxcbiAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgd2FpdE9uLnB1c2goaW50ZXJuYWxSZW5kZXJUYXNrLmNvbXBsZXRlZCk7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHdhaXRPbik7XG4gIH1cbiAgY2xlYW51cChyZXNldFN0YXRzID0gZmFsc2UpIHtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgY29uc3Qgc3VjY2VzcyA9IHRoaXMuI3RyeUNsZWFudXAoZmFsc2UpO1xuICAgIGlmIChyZXNldFN0YXRzICYmIHN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX3N0YXRzICYmPSBuZXcgU3RhdFRpbWVyKCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG4gICN0cnlDbGVhbnVwKGRlbGF5ZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuI2Fib3J0RGVsYXllZENsZWFudXAoKTtcbiAgICBpZiAoIXRoaXMuI3BlbmRpbmdDbGVhbnVwIHx8IHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWxheWVkKSB7XG4gICAgICB0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jdHJ5Q2xlYW51cChmYWxzZSk7XG4gICAgICB9LCBERUxBWUVEX0NMRUFOVVBfVElNRU9VVCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgcmVuZGVyVGFza3MsXG4gICAgICBvcGVyYXRvckxpc3RcbiAgICB9IG9mIHRoaXMuX2ludGVudFN0YXRlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHJlbmRlclRhc2tzLnNpemUgPiAwIHx8ICFvcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faW50ZW50U3RhdGVzLmNsZWFyKCk7XG4gICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAjYWJvcnREZWxheWVkQ2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0KTtcbiAgICAgIHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9XG4gIF9zdGFydFJlbmRlclBhZ2UodHJhbnNwYXJlbmN5LCBjYWNoZUtleSkge1xuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0cz8udGltZUVuZChcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5Py5yZXNvbHZlKHRyYW5zcGFyZW5jeSk7XG4gIH1cbiAgX3JlbmRlclBhZ2VDaHVuayhvcGVyYXRvckxpc3RDaHVuaywgaW50ZW50U3RhdGUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvcGVyYXRvckxpc3RDaHVuay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuZm5BcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmZuQXJyYXlbaV0pO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmFyZ3NBcnJheVtpXSk7XG4gICAgfVxuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSBvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bms7XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LnNlcGFyYXRlQW5ub3RzID0gb3BlcmF0b3JMaXN0Q2h1bmsuc2VwYXJhdGVBbm5vdHM7XG4gICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlmIChvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bmspIHtcbiAgICAgIHRoaXMuI3RyeUNsZWFudXAodHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9wdW1wT3BlcmF0b3JMaXN0KHtcbiAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgY2FjaGVLZXksXG4gICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUsXG4gICAgbW9kaWZpZWRJZHNcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlO1xuICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gdGhpcy5fdHJhbnNwb3J0Lm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKFwiR2V0T3BlcmF0b3JMaXN0XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW50ZW50OiByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXAsXG4gICAgICBtb2RpZmllZElkc1xuICAgIH0sIHRyYW5zZmVyKTtcbiAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IHJlYWRlcjtcbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyUGFnZUNodW5rKHZhbHVlLCBpbnRlbnRTdGF0ZSk7XG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0sIHJlYXNvbiA9PiB7XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy4jdHJ5Q2xlYW51cCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgcHVtcCgpO1xuICB9XG4gIF9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50U3RhdGUsXG4gICAgcmVhc29uLFxuICAgIGZvcmNlID0gZmFsc2VcbiAgfSkge1xuICAgIGlmICghaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgaWYgKGludGVudFN0YXRlLnJlbmRlclRhc2tzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24pIHtcbiAgICAgICAgbGV0IGRlbGF5ID0gUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUO1xuICAgICAgICBpZiAocmVhc29uLmV4dHJhRGVsYXkgPiAwICYmIHJlYXNvbi5leHRyYURlbGF5IDwgMTAwMCkge1xuICAgICAgICAgIGRlbGF5ICs9IHJlYXNvbi5leHRyYURlbGF5O1xuICAgICAgICB9XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIuY2FuY2VsKG5ldyBBYm9ydEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSkpLmNhdGNoKCgpID0+IHt9KTtcbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2N1ckNhY2hlS2V5LCBjdXJJbnRlbnRTdGF0ZV0gb2YgdGhpcy5faW50ZW50U3RhdGVzKSB7XG4gICAgICBpZiAoY3VySW50ZW50U3RhdGUgPT09IGludGVudFN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5kZWxldGUoY3VyQ2FjaGVLZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgZ2V0IHN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0cztcbiAgfVxufVxuY2xhc3MgTG9vcGJhY2tQb3J0IHtcbiAgI2xpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgI2RlZmVycmVkID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHBvc3RNZXNzYWdlKG9iaiwgdHJhbnNmZXIpIHtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGRhdGE6IHN0cnVjdHVyZWRDbG9uZShvYmosIHRyYW5zZmVyID8ge1xuICAgICAgICB0cmFuc2ZlclxuICAgICAgfSA6IG51bGwpXG4gICAgfTtcbiAgICB0aGlzLiNkZWZlcnJlZC50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW2xpc3RlbmVyXSBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lciwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICBsZXQgcm1BYm9ydCA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnM/LnNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgd2FybihcIkxvb3BiYWNrUG9ydCAtIGNhbm5vdCB1c2UgYW4gYGFib3J0ZWRgIHNpZ25hbC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpO1xuICAgICAgcm1BYm9ydCA9ICgpID0+IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgIH1cbiAgICB0aGlzLiNsaXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCBybUFib3J0KTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3Qgcm1BYm9ydCA9IHRoaXMuI2xpc3RlbmVycy5nZXQobGlzdGVuZXIpO1xuICAgIHJtQWJvcnQ/LigpO1xuICAgIHRoaXMuI2xpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9XG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBmb3IgKGNvbnN0IFssIHJtQWJvcnRdIG9mIHRoaXMuI2xpc3RlbmVycykge1xuICAgICAgcm1BYm9ydD8uKCk7XG4gICAgfVxuICAgIHRoaXMuI2xpc3RlbmVycy5jbGVhcigpO1xuICB9XG59XG5jbGFzcyBQREZXb3JrZXIge1xuICBzdGF0aWMgI2Zha2VXb3JrZXJJZCA9IDA7XG4gIHN0YXRpYyAjaXNXb3JrZXJEaXNhYmxlZCA9IGZhbHNlO1xuICBzdGF0aWMgI3dvcmtlclBvcnRzO1xuICBzdGF0aWMge1xuICAgIGlmIChpc05vZGVKUykge1xuICAgICAgdGhpcy4jaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgICBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyB8fD0gXCIuL3BkZi53b3JrZXIubWpzXCI7XG4gICAgfVxuICAgIHRoaXMuX2lzU2FtZU9yaWdpbiA9IChiYXNlVXJsLCBvdGhlclVybCkgPT4ge1xuICAgICAgbGV0IGJhc2U7XG4gICAgICB0cnkge1xuICAgICAgICBiYXNlID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICAgICAgaWYgKCFiYXNlLm9yaWdpbiB8fCBiYXNlLm9yaWdpbiA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBvdGhlciA9IG5ldyBVUkwob3RoZXJVcmwsIGJhc2UpO1xuICAgICAgcmV0dXJuIGJhc2Uub3JpZ2luID09PSBvdGhlci5vcmlnaW47XG4gICAgfTtcbiAgICB0aGlzLl9jcmVhdGVDRE5XcmFwcGVyID0gdXJsID0+IHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBgYXdhaXQgaW1wb3J0KFwiJHt1cmx9XCIpO2A7XG4gICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd3JhcHBlcl0sIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHRcIlxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWUgPSBudWxsLFxuICAgIHBvcnQgPSBudWxsLFxuICAgIHZlcmJvc2l0eSA9IGdldFZlcmJvc2l0eUxldmVsKClcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMudmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgIGlmIChwb3J0KSB7XG4gICAgICBpZiAoUERGV29ya2VyLiN3b3JrZXJQb3J0cz8uaGFzKHBvcnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgbW9yZSB0aGFuIG9uZSBQREZXb3JrZXIgcGVyIHBvcnQuXCIpO1xuICAgICAgfVxuICAgICAgKFBERldvcmtlci4jd29ya2VyUG9ydHMgfHw9IG5ldyBXZWFrTWFwKCkpLnNldChwb3J0LCB0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVGcm9tUG9ydChwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIGlmIChpc05vZGVKUykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtOb2RlUGFja2FnZXMucHJvbWlzZSwgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2VdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gICNyZXNvbHZlKCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcnQ7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlSGFuZGxlcjtcbiAgfVxuICBfaW5pdGlhbGl6ZUZyb21Qb3J0KHBvcnQpIHtcbiAgICB0aGlzLl9wb3J0ID0gcG9ydDtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgcG9ydCk7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgdGhpcy4jcmVzb2x2ZSgpO1xuICB9XG4gIF9pbml0aWFsaXplKCkge1xuICAgIGlmIChQREZXb3JrZXIuI2lzV29ya2VyRGlzYWJsZWQgfHwgUERGV29ya2VyLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgd29ya2VyU3JjXG4gICAgfSA9IFBERldvcmtlcjtcbiAgICB0cnkge1xuICAgICAgaWYgKCFQREZXb3JrZXIuX2lzU2FtZU9yaWdpbih3aW5kb3cubG9jYXRpb24uaHJlZiwgd29ya2VyU3JjKSkge1xuICAgICAgICB3b3JrZXJTcmMgPSBQREZXb3JrZXIuX2NyZWF0ZUNETldyYXBwZXIobmV3IFVSTCh3b3JrZXJTcmMsIHdpbmRvdy5sb2NhdGlvbikuaHJlZik7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclNyYywge1xuICAgICAgICB0eXBlOiBcIm1vZHVsZVwiXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCB3b3JrZXIpO1xuICAgICAgY29uc3QgdGVybWluYXRlRWFybHkgPSAoKSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViV29ya2VyKSB7XG4gICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBzaWduYWw6IGFjLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcInRlc3RcIiwgZGF0YSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCB8fCAhZGF0YSkge1xuICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICAgIHRoaXMuX3BvcnQgPSB3b3JrZXI7XG4gICAgICAgIHRoaXMuX3dlYldvcmtlciA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGRhdGEgPT4ge1xuICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNlbmRUZXN0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0T2JqID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcInRlc3RcIiwgdGVzdE9iaiwgW3Rlc3RPYmouYnVmZmVyXSk7XG4gICAgICB9O1xuICAgICAgc2VuZFRlc3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGluZm8oXCJUaGUgd29ya2VyIGhhcyBiZWVuIGRpc2FibGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gIH1cbiAgX3NldHVwRmFrZVdvcmtlcigpIHtcbiAgICBpZiAoIVBERldvcmtlci4jaXNXb3JrZXJEaXNhYmxlZCkge1xuICAgICAgd2FybihcIlNldHRpbmcgdXAgZmFrZSB3b3JrZXIuXCIpO1xuICAgICAgUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgUERGV29ya2VyLl9zZXR1cEZha2VXb3JrZXJHbG9iYWwudGhlbihXb3JrZXJNZXNzYWdlSGFuZGxlciA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvcnQgPSBuZXcgTG9vcGJhY2tQb3J0KCk7XG4gICAgICB0aGlzLl9wb3J0ID0gcG9ydDtcbiAgICAgIGNvbnN0IGlkID0gYGZha2Uke1BERldvcmtlci4jZmFrZVdvcmtlcklkKyt9YDtcbiAgICAgIGNvbnN0IHdvcmtlckhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoaWQgKyBcIl93b3JrZXJcIiwgaWQsIHBvcnQpO1xuICAgICAgV29ya2VyTWVzc2FnZUhhbmRsZXIuc2V0dXAod29ya2VySGFuZGxlciwgcG9ydCk7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihpZCwgaWQgKyBcIl93b3JrZXJcIiwgcG9ydCk7XG4gICAgICB0aGlzLiNyZXNvbHZlKCk7XG4gICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKGBTZXR0aW5nIHVwIGZha2Ugd29ya2VyIGZhaWxlZDogXCIke3JlYXNvbi5tZXNzYWdlfVwiLmApKTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fd2ViV29ya2VyKSB7XG4gICAgICB0aGlzLl93ZWJXb3JrZXIudGVybWluYXRlKCk7XG4gICAgICB0aGlzLl93ZWJXb3JrZXIgPSBudWxsO1xuICAgIH1cbiAgICBQREZXb3JrZXIuI3dvcmtlclBvcnRzPy5kZWxldGUodGhpcy5fcG9ydCk7XG4gICAgdGhpcy5fcG9ydCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX21lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tUG9ydChwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcz8ucG9ydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmZyb21Qb3J0IC0gaW52YWxpZCBtZXRob2Qgc2lnbmF0dXJlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkUG9ydCA9IHRoaXMuI3dvcmtlclBvcnRzPy5nZXQocGFyYW1zLnBvcnQpO1xuICAgIGlmIChjYWNoZWRQb3J0KSB7XG4gICAgICBpZiAoY2FjaGVkUG9ydC5fcGVuZGluZ0Rlc3Ryb3kpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmZyb21Qb3J0IC0gdGhlIHdvcmtlciBpcyBiZWluZyBkZXN0cm95ZWQuXFxuXCIgKyBcIlBsZWFzZSByZW1lbWJlciB0byBhd2FpdCBgUERGRG9jdW1lbnRMb2FkaW5nVGFzay5kZXN0cm95KClgLWNhbGxzLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZWRQb3J0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBERldvcmtlcihwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBnZXQgd29ya2VyU3JjKCkge1xuICAgIGlmIChHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYykge1xuICAgICAgcmV0dXJuIEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwiR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmNcIiBzcGVjaWZpZWQuJyk7XG4gIH1cbiAgc3RhdGljIGdldCAjbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2xvYmFsVGhpcy5wZGZqc1dvcmtlcj8uV29ya2VyTWVzc2FnZUhhbmRsZXIgfHwgbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IF9zZXR1cEZha2VXb3JrZXJHbG9iYWwoKSB7XG4gICAgY29uc3QgbG9hZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgICAgfVxuICAgICAgY29uc3Qgd29ya2VyID0gYXdhaXQgaW1wb3J0KC8qd2VicGFja0lnbm9yZTogdHJ1ZSovdGhpcy53b3JrZXJTcmMpO1xuICAgICAgcmV0dXJuIHdvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICB9O1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfc2V0dXBGYWtlV29ya2VyR2xvYmFsXCIsIGxvYWRlcigpKTtcbiAgfVxufVxuY2xhc3MgV29ya2VyVHJhbnNwb3J0IHtcbiAgI21ldGhvZFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFnZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFnZVJlZkNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFzc3dvcmRDYXBhYmlsaXR5ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZUhhbmRsZXIsIGxvYWRpbmdUYXNrLCBuZXR3b3JrU3RyZWFtLCBwYXJhbXMsIGZhY3RvcnkpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgdGhpcy5sb2FkaW5nVGFzayA9IGxvYWRpbmdUYXNrO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5mb250TG9hZGVyID0gbmV3IEZvbnRMb2FkZXIoe1xuICAgICAgb3duZXJEb2N1bWVudDogcGFyYW1zLm93bmVyRG9jdW1lbnQsXG4gICAgICBzdHlsZUVsZW1lbnQ6IHBhcmFtcy5zdHlsZUVsZW1lbnRcbiAgICB9KTtcbiAgICB0aGlzLmxvYWRpbmdQYXJhbXMgPSBwYXJhbXMubG9hZGluZ1BhcmFtcztcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gZmFjdG9yeS5jYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZhY3RvcnkuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLmNNYXBSZWFkZXJGYWN0b3J5ID0gZmFjdG9yeS5jTWFwUmVhZGVyRmFjdG9yeTtcbiAgICB0aGlzLnN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZmFjdG9yeS5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkgPSBudWxsO1xuICAgIHRoaXMuX25ldHdvcmtTdHJlYW0gPSBuZXR3b3JrU3RyZWFtO1xuICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5zZXR1cE1lc3NhZ2VIYW5kbGVyKCk7XG4gIH1cbiAgI2NhY2hlU2ltcGxlTWV0aG9kKG5hbWUsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3QgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI21ldGhvZFByb21pc2VzLmdldChuYW1lKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShuYW1lLCBkYXRhKTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJhbm5vdGF0aW9uU3RvcmFnZVwiLCBuZXcgQW5ub3RhdGlvblN0b3JhZ2UoKSk7XG4gIH1cbiAgZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLCBpc0VkaXRpbmcgPSBmYWxzZSwgaXNPcExpc3QgPSBmYWxzZSkge1xuICAgIGxldCByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVk7XG4gICAgbGV0IGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlID0gU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgc3dpdGNoIChpbnRlbnQpIHtcbiAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTlk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpc3BsYXlcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicHJpbnRcIjpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3YXJuKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGludGVudDogJHtpbnRlbnR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGFubm90YXRpb25TdG9yYWdlID0gcmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCAmJiBwcmludEFubm90YXRpb25TdG9yYWdlIGluc3RhbmNlb2YgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA/IHByaW50QW5ub3RhdGlvblN0b3JhZ2UgOiB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIHN3aXRjaCAoYW5ub3RhdGlvbk1vZGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRElTQUJMRTpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRElTQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRV9GT1JNUzpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRk9STVM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5FTkFCTEVfU1RPUkFHRTpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfU1RPUkFHRTtcbiAgICAgICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUgPSBhbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2FybihgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBhbm5vdGF0aW9uTW9kZTogJHthbm5vdGF0aW9uTW9kZX1gKTtcbiAgICB9XG4gICAgaWYgKGlzRWRpdGluZykge1xuICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuSVNfRURJVElORztcbiAgICB9XG4gICAgaWYgKGlzT3BMaXN0KSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5PUExJU1Q7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlkczogbW9kaWZpZWRJZHMsXG4gICAgICBoYXNoOiBtb2RpZmllZElkc0hhc2hcbiAgICB9ID0gYW5ub3RhdGlvblN0b3JhZ2UubW9kaWZpZWRJZHM7XG4gICAgY29uc3QgY2FjaGVLZXlCdWYgPSBbcmVuZGVyaW5nSW50ZW50LCBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZS5oYXNoLCBtb2RpZmllZElkc0hhc2hdO1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleTogY2FjaGVLZXlCdWYuam9pbihcIl9cIiksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSxcbiAgICAgIG1vZGlmaWVkSWRzXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eT8ucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkIGR1cmluZyBvblBhc3N3b3JkIGNhbGxiYWNrXCIpKTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICB3YWl0T24ucHVzaChwYWdlLl9kZXN0cm95KCkpO1xuICAgIH1cbiAgICB0aGlzLiNwYWdlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuY2xlYXIoKTtcbiAgICB0aGlzLiNwYWdlUmVmQ2FjaGUuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShcImFubm90YXRpb25TdG9yYWdlXCIpKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgY29uc3QgdGVybWluYXRlZCA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiVGVybWluYXRlXCIsIG51bGwpO1xuICAgIHdhaXRPbi5wdXNoKHRlcm1pbmF0ZWQpO1xuICAgIFByb21pc2UuYWxsKHdhaXRPbikudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KCk7XG4gICAgICBUZXh0TGF5ZXIuY2xlYW51cCgpO1xuICAgICAgdGhpcy5fbmV0d29ya1N0cmVhbT8uY2FuY2VsQWxsUmVxdWVzdHMobmV3IEFib3J0RXhjZXB0aW9uKFwiV29ya2VyIHdhcyB0ZXJtaW5hdGVkLlwiKSk7XG4gICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9LCB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzZXR1cE1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLFxuICAgICAgbG9hZGluZ1Rhc2tcbiAgICB9ID0gdGhpcztcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgYXNzZXJ0KHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmVhZGVyIC0gbm8gYElQREZTdHJlYW1gIGluc3RhbmNlIGF2YWlsYWJsZS5cIik7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyKCk7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlJlYWRlckhlYWRlcnNSZWFkeVwiLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuX2Z1bGxSZWFkZXIuaGVhZGVyc1JlYWR5O1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgY29udGVudExlbmd0aFxuICAgICAgfSA9IHRoaXMuX2Z1bGxSZWFkZXI7XG4gICAgICBpZiAoIWlzU3RyZWFtaW5nU3VwcG9ydGVkIHx8ICFpc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4odGhpcy5fbGFzdFByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgY29udGVudExlbmd0aFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJhbmdlUmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICBhc3NlcnQodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSYW5nZVJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldFJhbmdlUmVhZGVyKGRhdGEuYmVnaW4sIGRhdGEuZW5kKTtcbiAgICAgIGlmICghcmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSYW5nZVJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICByYW5nZVJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXREb2NcIiwgKHtcbiAgICAgIHBkZkluZm9cbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLl9udW1QYWdlcyA9IHBkZkluZm8ubnVtUGFnZXM7XG4gICAgICB0aGlzLl9odG1sRm9yWGZhID0gcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgZGVsZXRlIHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlc29sdmUobmV3IFBERkRvY3VtZW50UHJveHkocGRmSW5mbywgdGhpcykpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jRXhjZXB0aW9uXCIsIGZ1bmN0aW9uIChleCkge1xuICAgICAgbGV0IHJlYXNvbjtcbiAgICAgIHN3aXRjaCAoZXgubmFtZSkge1xuICAgICAgICBjYXNlIFwiUGFzc3dvcmRFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgUGFzc3dvcmRFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguY29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IEludmFsaWRQREZFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IE1pc3NpbmdQREZFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LnN0YXR1cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgVW5rbm93bkVycm9yRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmRldGFpbHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHVucmVhY2hhYmxlKFwiRG9jRXhjZXB0aW9uIC0gZXhwZWN0ZWQgYSB2YWxpZCBFcnJvci5cIik7XG4gICAgICB9XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlBhc3N3b3JkUmVxdWVzdFwiLCBleGNlcHRpb24gPT4ge1xuICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICBpZiAobG9hZGluZ1Rhc2sub25QYXNzd29yZCkge1xuICAgICAgICBjb25zdCB1cGRhdGVQYXNzd29yZCA9IHBhc3N3b3JkID0+IHtcbiAgICAgICAgICBpZiAocGFzc3dvcmQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChwYXNzd29yZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgcGFzc3dvcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblBhc3N3b3JkKHVwZGF0ZVBhc3N3b3JkLCBleGNlcHRpb24uY29kZSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QobmV3IFBhc3N3b3JkRXhjZXB0aW9uKGV4Y2VwdGlvbi5tZXNzYWdlLCBleGNlcHRpb24uY29kZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRGF0YUxvYWRlZFwiLCBkYXRhID0+IHtcbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sZW5ndGgsXG4gICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucmVzb2x2ZShkYXRhKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlN0YXJ0UmVuZGVyUGFnZVwiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlID0gdGhpcy4jcGFnZUNhY2hlLmdldChkYXRhLnBhZ2VJbmRleCk7XG4gICAgICBwYWdlLl9zdGFydFJlbmRlclBhZ2UoZGF0YS50cmFuc3BhcmVuY3ksIGRhdGEuY2FjaGVLZXkpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiY29tbW9ub2JqXCIsIChbaWQsIHR5cGUsIGV4cG9ydGVkRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbW1vbk9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRpc2FibGVGb250RmFjZSxcbiAgICAgICAgICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgICAgICAgICBwZGZCdWdcbiAgICAgICAgICB9ID0gdGhpcy5fcGFyYW1zO1xuICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gZXhwb3J0ZWREYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZEVycm9yID0gZXhwb3J0ZWREYXRhLmVycm9yO1xuICAgICAgICAgICAgd2FybihgRXJyb3IgZHVyaW5nIGZvbnQgbG9hZGluZzogJHtleHBvcnRlZEVycm9yfWApO1xuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluc3BlY3RGb250ID0gcGRmQnVnICYmIGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZCA/IChmb250LCB1cmwpID0+IGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvci5mb250QWRkZWQoZm9udCwgdXJsKSA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZm9udCA9IG5ldyBGb250RmFjZU9iamVjdChleHBvcnRlZERhdGEsIHtcbiAgICAgICAgICAgIGRpc2FibGVGb250RmFjZSxcbiAgICAgICAgICAgIGluc3BlY3RGb250XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5mb250TG9hZGVyLmJpbmQoZm9udCkuY2F0Y2goKCkgPT4gbWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiRm9udEZhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSkpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmb250RXh0cmFQcm9wZXJ0aWVzICYmIGZvbnQuZGF0YSkge1xuICAgICAgICAgICAgICBmb250LmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGZvbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ29weUxvY2FsSW1hZ2VcIjpcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbWFnZVJlZlxuICAgICAgICAgIH0gPSBleHBvcnRlZERhdGE7XG4gICAgICAgICAgYXNzZXJ0KGltYWdlUmVmLCBcIlRoZSBpbWFnZVJlZiBtdXN0IGJlIGRlZmluZWQuXCIpO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFnZVByb3h5IG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBkYXRhXSBvZiBwYWdlUHJveHkub2Jqcykge1xuICAgICAgICAgICAgICBpZiAoZGF0YT8ucmVmICE9PSBpbWFnZVJlZikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YS5kYXRhTGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIHN0cnVjdHVyZWRDbG9uZShkYXRhKSk7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmRhdGFMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFBhdGhcIjpcbiAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBjb21tb24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJvYmpcIiwgKFtpZCwgcGFnZUluZGV4LCB0eXBlLCBpbWFnZURhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZVByb3h5ID0gdGhpcy4jcGFnZUNhY2hlLmdldChwYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhZ2VQcm94eS5vYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VQcm94eS5faW50ZW50U3RhdGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgaW1hZ2VEYXRhPy5iaXRtYXA/LmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgIGlmIChpbWFnZURhdGE/LmRhdGFMZW4gPiBNQVhfSU1BR0VfU0laRV9UT19DQUNIRSkge1xuICAgICAgICAgICAgcGFnZVByb3h5Ll9tYXliZUNsZWFudXBBZnRlclJlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgIHBhZ2VQcm94eS5vYmpzLnJlc29sdmUoaWQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBvYmplY3QgdHlwZSAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NQcm9ncmVzc1wiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubG9hZGVkLFxuICAgICAgICB0b3RhbDogZGF0YS50b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaEJ1aWx0SW5DTWFwXCIsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jTWFwUmVhZGVyRmFjdG9yeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwUmVhZGVyRmFjdG9yeSBub3QgaW5pdGlhbGl6ZWQsIHNlZSB0aGUgYHVzZVdvcmtlckZldGNoYCBwYXJhbWV0ZXIuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY01hcFJlYWRlckZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaFN0YW5kYXJkRm9udERhdGFcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YW5kYXJkRm9udERhdGFGYWN0b3J5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeS5mZXRjaChkYXRhKTtcbiAgICB9KTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERhdGFcIiwgbnVsbCk7XG4gIH1cbiAgc2F2ZURvY3VtZW50KCkge1xuICAgIGlmICh0aGlzLmFubm90YXRpb25TdG9yYWdlLnNpemUgPD0gMCkge1xuICAgICAgd2FybihcInNhdmVEb2N1bWVudCBjYWxsZWQgd2hpbGUgYGFubm90YXRpb25TdG9yYWdlYCBpcyBlbXB0eSwgXCIgKyBcInBsZWFzZSB1c2UgdGhlIGdldERhdGEtbWV0aG9kIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlclxuICAgIH0gPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJTYXZlRG9jdW1lbnRcIiwge1xuICAgICAgaXNQdXJlWGZhOiAhIXRoaXMuX2h0bWxGb3JYZmEsXG4gICAgICBudW1QYWdlczogdGhpcy5fbnVtUGFnZXMsXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogbWFwLFxuICAgICAgZmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGxcbiAgICB9LCB0cmFuc2ZlcikuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9KTtcbiAgfVxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocGFnZU51bWJlcikgfHwgcGFnZU51bWJlciA8PSAwIHx8IHBhZ2VOdW1iZXIgPiB0aGlzLl9udW1QYWdlcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZSByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI3BhZ2VQcm9taXNlcy5nZXQocGFnZUluZGV4KTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSkudGhlbihwYWdlSW5mbyA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0IGRlc3Ryb3llZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlSW5mby5yZWZTdHIpIHtcbiAgICAgICAgdGhpcy4jcGFnZVJlZkNhY2hlLnNldChwYWdlSW5mby5yZWZTdHIsIHBhZ2VOdW1iZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IG5ldyBQREZQYWdlUHJveHkocGFnZUluZGV4LCBwYWdlSW5mbywgdGhpcywgdGhpcy5fcGFyYW1zLnBkZkJ1Zyk7XG4gICAgICB0aGlzLiNwYWdlQ2FjaGUuc2V0KHBhZ2VJbmRleCwgcGFnZSk7XG4gICAgICByZXR1cm4gcGFnZTtcbiAgICB9KTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuc2V0KHBhZ2VJbmRleCwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIGlmICghaXNSZWZQcm94eShyZWYpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlSW5kZXggcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSW5kZXhcIiwge1xuICAgICAgbnVtOiByZWYubnVtLFxuICAgICAgZ2VuOiByZWYuZ2VuXG4gICAgfSk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnMocGFnZUluZGV4LCBpbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBbm5vdGF0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXgsXG4gICAgICBpbnRlbnRcbiAgICB9KTtcbiAgfVxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0RmllbGRPYmplY3RzXCIpO1xuICB9XG4gIGhhc0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJIYXNKU0FjdGlvbnNcIik7XG4gIH1cbiAgZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRDYWxjdWxhdGlvbk9yZGVySWRzXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvbnNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBkZXN0aW5hdGlvbiByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERlc3RpbmF0aW9uXCIsIHtcbiAgICAgIGlkXG4gICAgfSk7XG4gIH1cbiAgZ2V0UGFnZUxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGFiZWxzXCIsIG51bGwpO1xuICB9XG4gIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxheW91dFwiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTW9kZVwiLCBudWxsKTtcbiAgfVxuICBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRWaWV3ZXJQcmVmZXJlbmNlc1wiLCBudWxsKTtcbiAgfVxuICBnZXRPcGVuQWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE9wZW5BY3Rpb25cIiwgbnVsbCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QXR0YWNobWVudHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0RG9jSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldERvY0pTQWN0aW9uc1wiKTtcbiAgfVxuICBnZXRQYWdlSlNBY3Rpb25zKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VKU0FjdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RydWN0VHJlZShwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRTdHJ1Y3RUcmVlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3V0bGluZVwiLCBudWxsKTtcbiAgfVxuICBnZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0T3B0aW9uYWxDb250ZW50Q29uZmlnXCIpLnRoZW4oZGF0YSA9PiBuZXcgT3B0aW9uYWxDb250ZW50Q29uZmlnKGRhdGEsIHJlbmRlcmluZ0ludGVudCkpO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBlcm1pc3Npb25zXCIsIG51bGwpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IG5hbWUgPSBcIkdldE1ldGFkYXRhXCIsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIG51bGwpLnRoZW4ocmVzdWx0cyA9PiAoe1xuICAgICAgaW5mbzogcmVzdWx0c1swXSxcbiAgICAgIG1ldGFkYXRhOiByZXN1bHRzWzFdID8gbmV3IE1ldGFkYXRhKHJlc3VsdHNbMV0pIDogbnVsbCxcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyPy5maWxlbmFtZSA/PyBudWxsLFxuICAgICAgY29udGVudExlbmd0aDogdGhpcy5fZnVsbFJlYWRlcj8uY29udGVudExlbmd0aCA/PyBudWxsXG4gICAgfSkpO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNYXJrSW5mb1wiLCBudWxsKTtcbiAgfVxuICBhc3luYyBzdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJDbGVhbnVwXCIsIG51bGwpO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsZWFudXBTdWNjZXNzZnVsID0gcGFnZS5jbGVhbnVwKCk7XG4gICAgICBpZiAoIWNsZWFudXBTdWNjZXNzZnVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RhcnRDbGVhbnVwOiBQYWdlICR7cGFnZS5wYWdlTnVtYmVyfSBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICBpZiAoIWtlZXBMb2FkZWRGb250cykge1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3kodHJ1ZSk7XG4gICAgVGV4dExheWVyLmNsZWFudXAoKTtcbiAgfVxuICBjYWNoZWRQYWdlTnVtYmVyKHJlZikge1xuICAgIGlmICghaXNSZWZQcm94eShyZWYpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVmU3RyID0gcmVmLmdlbiA9PT0gMCA/IGAke3JlZi5udW19UmAgOiBgJHtyZWYubnVtfVIke3JlZi5nZW59YDtcbiAgICByZXR1cm4gdGhpcy4jcGFnZVJlZkNhY2hlLmdldChyZWZTdHIpID8/IG51bGw7XG4gIH1cbn1cbmNvbnN0IElOSVRJQUxfREFUQSA9IFN5bWJvbChcIklOSVRJQUxfREFUQVwiKTtcbmNsYXNzIFBERk9iamVjdHMge1xuICAjb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICNlbnN1cmVPYmoob2JqSWQpIHtcbiAgICByZXR1cm4gdGhpcy4jb2Jqc1tvYmpJZF0gfHw9IHtcbiAgICAgIC4uLlByb21pc2Uud2l0aFJlc29sdmVycygpLFxuICAgICAgZGF0YTogSU5JVElBTF9EQVRBXG4gICAgfTtcbiAgfVxuICBnZXQob2JqSWQsIGNhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY29uc3Qgb2JqID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICAgIG9iai5wcm9taXNlLnRoZW4oKCkgPT4gY2FsbGJhY2sob2JqLmRhdGEpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICBpZiAoIW9iaiB8fCBvYmouZGF0YSA9PT0gSU5JVElBTF9EQVRBKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3Rpbmcgb2JqZWN0IHRoYXQgaXNuJ3QgcmVzb2x2ZWQgeWV0ICR7b2JqSWR9LmApO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH1cbiAgaGFzKG9iaklkKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgcmV0dXJuICEhb2JqICYmIG9iai5kYXRhICE9PSBJTklUSUFMX0RBVEE7XG4gIH1cbiAgcmVzb2x2ZShvYmpJZCwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgIG9iai5kYXRhID0gZGF0YTtcbiAgICBvYmoucmVzb2x2ZSgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3Qgb2JqSWQgaW4gdGhpcy4jb2Jqcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhXG4gICAgICB9ID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgICBkYXRhPy5iaXRtYXA/LmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGNvbnN0IG9iaklkIGluIHRoaXMuI29ianMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgICAgaWYgKGRhdGEgPT09IElOSVRJQUxfREFUQSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIFtvYmpJZCwgZGF0YV07XG4gICAgfVxuICB9XG59XG5jbGFzcyBSZW5kZXJUYXNrIHtcbiAgI2ludGVybmFsUmVuZGVyVGFzayA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGludGVybmFsUmVuZGVyVGFzaykge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzaztcbiAgICB0aGlzLm9uQ29udGludWUgPSBudWxsO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYW5jZWwobnVsbCwgZXh0cmFEZWxheSk7XG4gIH1cbiAgZ2V0IHNlcGFyYXRlQW5ub3RzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcGFyYXRlQW5ub3RzXG4gICAgfSA9IHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3Q7XG4gICAgaWYgKCFzZXBhcmF0ZUFubm90cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwXG4gICAgfSA9IHRoaXMuI2ludGVybmFsUmVuZGVyVGFzaztcbiAgICByZXR1cm4gc2VwYXJhdGVBbm5vdHMuZm9ybSB8fCBzZXBhcmF0ZUFubm90cy5jYW52YXMgJiYgYW5ub3RhdGlvbkNhbnZhc01hcD8uc2l6ZSA+IDA7XG4gIH1cbn1cbmNsYXNzIEludGVybmFsUmVuZGVyVGFzayB7XG4gICNyQUYgPSBudWxsO1xuICBzdGF0aWMgI2NhbnZhc0luVXNlID0gbmV3IFdlYWtTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNhbGxiYWNrLFxuICAgIHBhcmFtcyxcbiAgICBvYmpzLFxuICAgIGNvbW1vbk9ianMsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBvcGVyYXRvckxpc3QsXG4gICAgcGFnZUluZGV4LFxuICAgIGNhbnZhc0ZhY3RvcnksXG4gICAgZmlsdGVyRmFjdG9yeSxcbiAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmYWxzZSxcbiAgICBwZGZCdWcgPSBmYWxzZSxcbiAgICBwYWdlQ29sb3JzID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gbnVsbDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IG9wZXJhdG9yTGlzdDtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLnBhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHRydWUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMudGFzayA9IG5ldyBSZW5kZXJUYXNrKHRoaXMpO1xuICAgIHRoaXMuX2NhbmNlbEJvdW5kID0gdGhpcy5jYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jb250aW51ZUJvdW5kID0gdGhpcy5fY29udGludWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCA9IHRoaXMuX3NjaGVkdWxlTmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX25leHRCb3VuZCA9IHRoaXMuX25leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jYW52YXMgPSBwYXJhbXMuY2FudmFzQ29udGV4dC5jYW52YXM7XG4gIH1cbiAgZ2V0IGNvbXBsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYXBhYmlsaXR5LnByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICB9XG4gIGluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgaWYgKEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuaGFzKHRoaXMuX2NhbnZhcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgc2FtZSBjYW52YXMgZHVyaW5nIG11bHRpcGxlIHJlbmRlcigpIG9wZXJhdGlvbnMuIFwiICsgXCJVc2UgZGlmZmVyZW50IGNhbnZhcyBvciBlbnN1cmUgcHJldmlvdXMgb3BlcmF0aW9ucyB3ZXJlIFwiICsgXCJjYW5jZWxsZWQgb3IgY29tcGxldGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuYWRkKHRoaXMuX2NhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wZGZCdWcgJiYgZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlcj8uZW5hYmxlZCkge1xuICAgICAgdGhpcy5zdGVwcGVyID0gZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlci5jcmVhdGUodGhpcy5fcGFnZUluZGV4KTtcbiAgICAgIHRoaXMuc3RlcHBlci5pbml0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICAgIHRoaXMuc3RlcHBlci5uZXh0QnJlYWtQb2ludCA9IHRoaXMuc3RlcHBlci5nZXROZXh0QnJlYWtQb2ludCgpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSA9IHRoaXMucGFyYW1zO1xuICAgIHRoaXMuZ2Z4ID0gbmV3IENhbnZhc0dyYXBoaWNzKGNhbnZhc0NvbnRleHQsIHRoaXMuY29tbW9uT2JqcywgdGhpcy5vYmpzLCB0aGlzLmNhbnZhc0ZhY3RvcnksIHRoaXMuZmlsdGVyRmFjdG9yeSwge1xuICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gICAgfSwgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwLCB0aGlzLnBhZ2VDb2xvcnMpO1xuICAgIHRoaXMuZ2Z4LmJlZ2luRHJhd2luZyh7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHRyYW5zcGFyZW5jeSxcbiAgICAgIGJhY2tncm91bmRcbiAgICB9KTtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IDA7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjaz8uKCk7XG4gIH1cbiAgY2FuY2VsKGVycm9yID0gbnVsbCwgZXh0cmFEZWxheSA9IDApIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgdGhpcy5nZng/LmVuZERyYXdpbmcoKTtcbiAgICBpZiAodGhpcy4jckFGKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy4jckFGKTtcbiAgICAgIHRoaXMuI3JBRiA9IG51bGw7XG4gICAgfVxuICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgdGhpcy5jYWxsYmFjayhlcnJvciB8fCBuZXcgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKGBSZW5kZXJpbmcgY2FuY2VsbGVkLCBwYWdlICR7dGhpcy5fcGFnZUluZGV4ICsgMX1gLCBleHRyYURlbGF5KSk7XG4gIH1cbiAgb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NSZWFkeSkge1xuICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgfHw9IHRoaXMuX2NvbnRpbnVlQm91bmQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RlcHBlcj8udXBkYXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NvbnRpbnVlKCk7XG4gIH1cbiAgX2NvbnRpbnVlKCkge1xuICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRhc2sub25Db250aW51ZSkge1xuICAgICAgdGhpcy50YXNrLm9uQ29udGludWUodGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZU5leHQoKTtcbiAgICB9XG4gIH1cbiAgX3NjaGVkdWxlTmV4dCgpIHtcbiAgICBpZiAodGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB0aGlzLiNyQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy4jckFGID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmV4dEJvdW5kKCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4odGhpcy5fbmV4dEJvdW5kKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9uZXh0KCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IHRoaXMuZ2Z4LmV4ZWN1dGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QsIHRoaXMub3BlcmF0b3JMaXN0SWR4LCB0aGlzLl9jb250aW51ZUJvdW5kLCB0aGlzLnN0ZXBwZXIpO1xuICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdElkeCA9PT0gdGhpcy5vcGVyYXRvckxpc3QuYXJnc0FycmF5Lmxlbmd0aCkge1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIHRoaXMuZ2Z4LmVuZERyYXdpbmcoKTtcbiAgICAgICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY29uc3QgdmVyc2lvbiA9IFwiNC44LjY5XCI7XG5jb25zdCBidWlsZCA9IFwiMzYzNGRhYjEwXCI7XG5cbjsvLyAuL3NyYy9zaGFyZWQvc2NyaXB0aW5nX3V0aWxzLmpzXG5mdW5jdGlvbiBtYWtlQ29sb3JDb21wKG4pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbikpICogMjU1KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gc2NhbGVBbmRDbGFtcCh4KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIDI1NSAqIHgpKTtcbn1cbmNsYXNzIENvbG9yQ29udmVydGVycyB7XG4gIHN0YXRpYyBDTVlLX0coW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMSAtIE1hdGgubWluKDEsIDAuMyAqIGMgKyAwLjU5ICogbSArIDAuMTEgKiB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBHX0NNWUsoW2ddKSB7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgMCwgMCwgMCwgMSAtIGddO1xuICB9XG4gIHN0YXRpYyBHX1JHQihbZ10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIGcsIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX3JnYihbZ10pIHtcbiAgICBnID0gc2NhbGVBbmRDbGFtcChnKTtcbiAgICByZXR1cm4gW2csIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX0hUTUwoW2ddKSB7XG4gICAgY29uc3QgRyA9IG1ha2VDb2xvckNvbXAoZyk7XG4gICAgcmV0dXJuIGAjJHtHfSR7R30ke0d9YDtcbiAgfVxuICBzdGF0aWMgUkdCX0coW3IsIGcsIGJdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMC4zICogciArIDAuNTkgKiBnICsgMC4xMSAqIGJdO1xuICB9XG4gIHN0YXRpYyBSR0JfcmdiKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yLm1hcChzY2FsZUFuZENsYW1wKTtcbiAgfVxuICBzdGF0aWMgUkdCX0hUTUwoY29sb3IpIHtcbiAgICByZXR1cm4gYCMke2NvbG9yLm1hcChtYWtlQ29sb3JDb21wKS5qb2luKFwiXCIpfWA7XG4gIH1cbiAgc3RhdGljIFRfSFRNTCgpIHtcbiAgICByZXR1cm4gXCIjMDAwMDAwMDBcIjtcbiAgfVxuICBzdGF0aWMgVF9yZ2IoKSB7XG4gICAgcmV0dXJuIFtudWxsXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19SR0IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCAxIC0gTWF0aC5taW4oMSwgYyArIGspLCAxIC0gTWF0aC5taW4oMSwgbSArIGspLCAxIC0gTWF0aC5taW4oMSwgeSArIGspXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19yZ2IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBjICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBtICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCB5ICsgaykpXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19IVE1MKGNvbXBvbmVudHMpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLkNNWUtfUkdCKGNvbXBvbmVudHMpLnNsaWNlKDEpO1xuICAgIHJldHVybiB0aGlzLlJHQl9IVE1MKHJnYik7XG4gIH1cbiAgc3RhdGljIFJHQl9DTVlLKFtyLCBnLCBiXSkge1xuICAgIGNvbnN0IGMgPSAxIC0gcjtcbiAgICBjb25zdCBtID0gMSAtIGc7XG4gICAgY29uc3QgeSA9IDEgLSBiO1xuICAgIGNvbnN0IGsgPSBNYXRoLm1pbihjLCBtLCB5KTtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCBjLCBtLCB5LCBrXTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9zdmdfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VTVkdGYWN0b3J5IHtcbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHNraXBEaW1lbnNpb25zID0gZmFsc2UpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZGltZW5zaW9uc1wiKTtcbiAgICB9XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fY3JlYXRlU1ZHKFwic3ZnOnN2Z1wiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcbiAgICBpZiAoIXNraXBEaW1lbnNpb25zKSB7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7d2lkdGh9cHhgKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCR7aGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVTVkcodHlwZSk7XG4gIH1cbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVTVkdgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVNWR0ZhY3RvcnkgZXh0ZW5kcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS94ZmFfbGF5ZXIuanNcblxuY2xhc3MgWGZhTGF5ZXIge1xuICBzdGF0aWMgc2V0dXBTdG9yYWdlKGh0bWwsIGlkLCBlbGVtZW50LCBzdG9yYWdlLCBpbnRlbnQpIHtcbiAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIGlmIChlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiIHx8IGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9uKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT2ZmKSB7XG4gICAgICAgICAgICBodG1sLnJlbW92ZUF0dHJpYnV0ZShcImNoZWNrZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZCA/IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPblwiKSA6IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPZmZcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLnZhbHVlID09PSBzdG9yZWREYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoXCJzZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gXCJcIiA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXRBdHRyaWJ1dGVzKHtcbiAgICBodG1sLFxuICAgIGVsZW1lbnQsXG4gICAgc3RvcmFnZSA9IG51bGwsXG4gICAgaW50ZW50LFxuICAgIGxpbmtTZXJ2aWNlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgaXNIVE1MQW5jaG9yRWxlbWVudCA9IGh0bWwgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudDtcbiAgICBpZiAoYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXMubmFtZSA9IGAke2F0dHJpYnV0ZXMubmFtZX0tJHtpbnRlbnR9YDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0YUlkXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihodG1sLnN0eWxlLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWlzSFRNTEFuY2hvckVsZW1lbnQgfHwga2V5ICE9PSBcImhyZWZcIiAmJiBrZXkgIT09IFwibmV3V2luZG93XCIpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSFRNTEFuY2hvckVsZW1lbnQpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGh0bWwsIGF0dHJpYnV0ZXMuaHJlZiwgYXR0cmlidXRlcy5uZXdXaW5kb3cpO1xuICAgIH1cbiAgICBpZiAoc3RvcmFnZSAmJiBhdHRyaWJ1dGVzLmRhdGFJZCkge1xuICAgICAgdGhpcy5zZXR1cFN0b3JhZ2UoaHRtbCwgYXR0cmlidXRlcy5kYXRhSWQsIGVsZW1lbnQsIHN0b3JhZ2UpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVuZGVyKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBsaW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmFtZXRlcnMueGZhSHRtbDtcbiAgICBjb25zdCBpbnRlbnQgPSBwYXJhbWV0ZXJzLmludGVudCB8fCBcImRpc3BsYXlcIjtcbiAgICBjb25zdCByb290SHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocm9vdC5uYW1lKTtcbiAgICBpZiAocm9vdC5hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBodG1sOiByb290SHRtbCxcbiAgICAgICAgZWxlbWVudDogcm9vdCxcbiAgICAgICAgaW50ZW50LFxuICAgICAgICBsaW5rU2VydmljZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlzTm90Rm9yUmljaFRleHQgPSBpbnRlbnQgIT09IFwicmljaFRleHRcIjtcbiAgICBjb25zdCByb290RGl2ID0gcGFyYW1ldGVycy5kaXY7XG4gICAgcm9vdERpdi5hcHBlbmQocm9vdEh0bWwpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnZpZXdwb3J0KSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgICByb290RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gICAgaWYgKGlzTm90Rm9yUmljaFRleHQpIHtcbiAgICAgIHJvb3REaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ4ZmFMYXllciB4ZmFGb250XCIpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0RGl2cyA9IFtdO1xuICAgIGlmIChyb290LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvb3QudmFsdWUpO1xuICAgICAgICByb290SHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGlmIChpc05vdEZvclJpY2hUZXh0ICYmIFhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KHJvb3QubmFtZSkpIHtcbiAgICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0RGl2c1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBbW3Jvb3QsIC0xLCByb290SHRtbF1dO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbcGFyZW50LCBpLCBodG1sXSA9IHN0YWNrLmF0KC0xKTtcbiAgICAgIGlmIChpICsgMSA9PT0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlblsrK3N0YWNrLmF0KC0xKVsxXV07XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgaHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRIdG1sID0gY2hpbGQ/LmF0dHJpYnV0ZXM/LnhtbG5zID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGNoaWxkLmF0dHJpYnV0ZXMueG1sbnMsIG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgIGh0bWwuYXBwZW5kKGNoaWxkSHRtbCk7XG4gICAgICBpZiAoY2hpbGQuYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGh0bWw6IGNoaWxkSHRtbCxcbiAgICAgICAgICBlbGVtZW50OiBjaGlsZCxcbiAgICAgICAgICBzdG9yYWdlLFxuICAgICAgICAgIGludGVudCxcbiAgICAgICAgICBsaW5rU2VydmljZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbj8ubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFjay5wdXNoKFtjaGlsZCwgLTEsIGNoaWxkSHRtbF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCAmJiBYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbCBvZiByb290RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIueGZhTm9uSW50ZXJhY3RpdmUgaW5wdXQsIC54ZmFOb25JbnRlcmFjdGl2ZSB0ZXh0YXJlYVwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwicmVhZE9ubHlcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RGl2c1xuICAgIH07XG4gIH1cbiAgc3RhdGljIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgIHBhcmFtZXRlcnMuZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBwYXJhbWV0ZXJzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9hbm5vdGF0aW9uX2xheWVyLmpzXG5cblxuXG5cblxuXG5jb25zdCBERUZBVUxUX1RBQl9JTkRFWCA9IDEwMDA7XG5jb25zdCBhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFID0gOTtcbmNvbnN0IEdldEVsZW1lbnRzQnlOYW1lU2V0ID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIGdldFJlY3REaW1zKHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICB9O1xufVxuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IHtcbiAgc3RhdGljIGNyZWF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc3VidHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5hbm5vdGF0aW9uVHlwZTtcbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuTElOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5XSURHRVQ6XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5maWVsZFR5cGU7XG4gICAgICAgIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlR4XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiQnRuXCI6XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycy5kYXRhLnJhZGlvQnV0dG9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5kYXRhLmNoZWNrQm94KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJDaFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiU2lnXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPUFVQOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkZSRUVURVhUOlxuICAgICAgICByZXR1cm4gbmV3IEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgTGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TUVVBUkU6XG4gICAgICAgIHJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkNJUkNMRTpcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9MWUxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuQ0FSRVQ6XG4gICAgICAgIHJldHVybiBuZXcgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gbmV3IElua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT0xZR09OOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuSElHSExJR0hUOlxuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNRVUlHR0xZOlxuICAgICAgICByZXR1cm4gbmV3IFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNUUklLRU9VVDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1RBTVA6XG4gICAgICAgIHJldHVybiBuZXcgU3RhbXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuRklMRUFUVEFDSE1FTlQ6XG4gICAgICAgIHJldHVybiBuZXcgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICN1cGRhdGVzID0gbnVsbDtcbiAgI2hhc0JvcmRlciA9IGZhbHNlO1xuICAjcG9wdXBFbGVtZW50ID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycywge1xuICAgIGlzUmVuZGVyYWJsZSA9IGZhbHNlLFxuICAgIGlnbm9yZUJvcmRlciA9IGZhbHNlLFxuICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5pc1JlbmRlcmFibGUgPSBpc1JlbmRlcmFibGU7XG4gICAgdGhpcy5kYXRhID0gcGFyYW1ldGVycy5kYXRhO1xuICAgIHRoaXMubGF5ZXIgPSBwYXJhbWV0ZXJzLmxheWVyO1xuICAgIHRoaXMubGlua1NlcnZpY2UgPSBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlO1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyID0gcGFyYW1ldGVycy5kb3dubG9hZE1hbmFnZXI7XG4gICAgdGhpcy5pbWFnZVJlc291cmNlc1BhdGggPSBwYXJhbWV0ZXJzLmltYWdlUmVzb3VyY2VzUGF0aDtcbiAgICB0aGlzLnJlbmRlckZvcm1zID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcztcbiAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBwYXJhbWV0ZXJzLnN2Z0ZhY3Rvcnk7XG4gICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy5lbmFibGVTY3JpcHRpbmcgPSBwYXJhbWV0ZXJzLmVuYWJsZVNjcmlwdGluZztcbiAgICB0aGlzLmhhc0pTQWN0aW9ucyA9IHBhcmFtZXRlcnMuaGFzSlNBY3Rpb25zO1xuICAgIHRoaXMuX2ZpZWxkT2JqZWN0cyA9IHBhcmFtZXRlcnMuZmllbGRPYmplY3RzO1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgaWYgKGlzUmVuZGVyYWJsZSkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl9jcmVhdGVDb250YWluZXIoaWdub3JlQm9yZGVyKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZVF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICB0aGlzLl9jcmVhdGVRdWFkcmlsYXRlcmFscygpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2hhc1BvcHVwRGF0YSh7XG4gICAgdGl0bGVPYmosXG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHRcbiAgfSkge1xuICAgIHJldHVybiAhISh0aXRsZU9iaj8uc3RyIHx8IGNvbnRlbnRzT2JqPy5zdHIgfHwgcmljaFRleHQ/LnN0cik7XG4gIH1cbiAgZ2V0IF9pc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuaXNFZGl0YWJsZTtcbiAgfVxuICBnZXQgaGFzUG9wdXBEYXRhKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKHRoaXMuZGF0YSk7XG4gIH1cbiAgdXBkYXRlRWRpdGVkKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlcyB8fD0ge1xuICAgICAgcmVjdDogdGhpcy5kYXRhLnJlY3Quc2xpY2UoMClcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3RcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmIChyZWN0KSB7XG4gICAgICB0aGlzLiNzZXRSZWN0RWRpdGVkKHJlY3QpO1xuICAgIH1cbiAgICB0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwLnVwZGF0ZUVkaXRlZChwYXJhbXMpO1xuICB9XG4gIHJlc2V0RWRpdGVkKCkge1xuICAgIGlmICghdGhpcy4jdXBkYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZXRSZWN0RWRpdGVkKHRoaXMuI3VwZGF0ZXMucmVjdCk7XG4gICAgdGhpcy4jcG9wdXBFbGVtZW50Py5wb3B1cC5yZXNldEVkaXRlZCgpO1xuICAgIHRoaXMuI3VwZGF0ZXMgPSBudWxsO1xuICB9XG4gICNzZXRSZWN0RWRpdGVkKHJlY3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlY3Q6IGN1cnJlbnRSZWN0LFxuICAgICAgICByb3RhdGlvblxuICAgICAgfSxcbiAgICAgIHBhcmVudDoge1xuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY3VycmVudFJlY3Q/LnNwbGljZSgwLCA0LCAuLi5yZWN0KTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhyZWN0KTtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogKHBhZ2VIZWlnaHQgLSByZWN0WzNdICsgcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICBpZiAocm90YXRpb24gPT09IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uKTtcbiAgICB9XG4gIH1cbiAgX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHZpZXdwb3J0XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIik7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtYW5ub3RhdGlvbi1pZFwiLCBkYXRhLmlkKTtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpKSB7XG4gICAgICBjb250YWluZXIudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gY29udGFpbmVyO1xuICAgIHN0eWxlLnpJbmRleCA9IHRoaXMucGFyZW50LnpJbmRleCsrO1xuICAgIGlmIChkYXRhLmFsdGVybmF0aXZlVGV4dCkge1xuICAgICAgY29udGFpbmVyLnRpdGxlID0gZGF0YS5hbHRlcm5hdGl2ZVRleHQ7XG4gICAgfVxuICAgIGlmIChkYXRhLm5vUm90YXRlKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm5vcm90YXRlXCIpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEucmVjdCB8fCB0aGlzIGluc3RhbmNlb2YgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3RhdGlvblxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIWRhdGEuaGFzT3duQ2FudmFzICYmIHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGlmICghaWdub3JlQm9yZGVyICYmIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggPiAwKSB7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IGAke2RhdGEuYm9yZGVyU3R5bGUud2lkdGh9cHhgO1xuICAgICAgY29uc3QgaG9yaXpvbnRhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUuaG9yaXpvbnRhbENvcm5lclJhZGl1cztcbiAgICAgIGNvbnN0IHZlcnRpY2FsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS52ZXJ0aWNhbENvcm5lclJhZGl1cztcbiAgICAgIGlmIChob3Jpem9udGFsUmFkaXVzID4gMCB8fCB2ZXJ0aWNhbFJhZGl1cyA+IDApIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gYGNhbGMoJHtob3Jpem9udGFsUmFkaXVzfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7dmVydGljYWxSYWRpdXN9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIHN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH0gZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gYGNhbGMoJHt3aWR0aH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke2hlaWdodH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgICAgc3R5bGUuYm9yZGVyUmFkaXVzID0gcmFkaXVzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkYXRhLmJvcmRlclN0eWxlLnN0eWxlKSB7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5TT0xJRDpcbiAgICAgICAgICBzdHlsZS5ib3JkZXJTdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkRBU0hFRDpcbiAgICAgICAgICBzdHlsZS5ib3JkZXJTdHlsZSA9IFwiZGFzaGVkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5CRVZFTEVEOlxuICAgICAgICAgIHdhcm4oXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogYmV2ZWxlZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLklOU0VUOlxuICAgICAgICAgIHdhcm4oXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogaW5zZXRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyQm90dG9tU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBib3JkZXJDb2xvciA9IGRhdGEuYm9yZGVyQ29sb3IgfHwgbnVsbDtcbiAgICAgIGlmIChib3JkZXJDb2xvcikge1xuICAgICAgICB0aGlzLiNoYXNCb3JkZXIgPSB0cnVlO1xuICAgICAgICBzdHlsZS5ib3JkZXJDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKGJvcmRlckNvbG9yWzBdIHwgMCwgYm9yZGVyQ29sb3JbMV0gfCAwLCBib3JkZXJDb2xvclsyXSB8IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWN0ID0gVXRpbC5ub3JtYWxpemVSZWN0KFtkYXRhLnJlY3RbMF0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFsxXSArIHBhZ2Uudmlld1sxXSwgZGF0YS5yZWN0WzJdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbM10gKyBwYWdlLnZpZXdbMV1dKTtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocmVjdFswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiAocmVjdFsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb25cbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZGF0YS5oYXNPd25DYW52YXMgfHwgcm90YXRpb24gPT09IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uLCBjb250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIHNldFJvdGF0aW9uKGFuZ2xlLCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcikge1xuICAgIGlmICghdGhpcy5kYXRhLnJlY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKHRoaXMuZGF0YS5yZWN0KTtcbiAgICBsZXQgZWxlbWVudFdpZHRoLCBlbGVtZW50SGVpZ2h0O1xuICAgIGlmIChhbmdsZSAlIDE4MCA9PT0gMCkge1xuICAgICAgZWxlbWVudFdpZHRoID0gMTAwICogd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gMTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudFdpZHRoID0gMTAwICogaGVpZ2h0IC8gcGFnZVdpZHRoO1xuICAgICAgZWxlbWVudEhlaWdodCA9IDEwMCAqIHdpZHRoIC8gcGFnZUhlaWdodDtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7ZWxlbWVudFdpZHRofSVgO1xuICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHtlbGVtZW50SGVpZ2h0fSVgO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIiwgKDM2MCAtIGFuZ2xlKSAlIDM2MCk7XG4gIH1cbiAgZ2V0IF9jb21tb25BY3Rpb25zKCkge1xuICAgIGNvbnN0IHNldENvbG9yID0gKGpzTmFtZSwgc3R5bGVOYW1lLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY29sb3IgPSBldmVudC5kZXRhaWxbanNOYW1lXTtcbiAgICAgIGNvbnN0IGNvbG9yVHlwZSA9IGNvbG9yWzBdO1xuICAgICAgY29uc3QgY29sb3JBcnJheSA9IGNvbG9yLnNsaWNlKDEpO1xuICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlW3N0eWxlTmFtZV0gPSBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9IVE1MYF0oY29sb3JBcnJheSk7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICBbc3R5bGVOYW1lXTogQ29sb3JDb252ZXJ0ZXJzW2Ake2NvbG9yVHlwZX1fcmdiYF0oY29sb3JBcnJheSlcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9jb21tb25BY3Rpb25zXCIsIHtcbiAgICAgIGRpc3BsYXk6IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRpc3BsYXlcbiAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgY29uc3QgaGlkZGVuID0gZGlzcGxheSAlIDIgPT09IDE7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9WaWV3OiBoaWRkZW4sXG4gICAgICAgICAgbm9QcmludDogZGlzcGxheSA9PT0gMSB8fCBkaXNwbGF5ID09PSAyXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHByaW50OiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogIWV2ZW50LmRldGFpbC5wcmludFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoaWRkZW46IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGhpZGRlblxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gaGlkZGVuID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIG5vUHJpbnQ6IGhpZGRlbixcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlblxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb2N1czogZXZlbnQgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50LnRhcmdldC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogZmFsc2VcbiAgICAgICAgfSksIDApO1xuICAgICAgfSxcbiAgICAgIHVzZXJOYW1lOiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC50aXRsZSA9IGV2ZW50LmRldGFpbC51c2VyTmFtZTtcbiAgICAgIH0sXG4gICAgICByZWFkb25seTogZXZlbnQgPT4ge1xuICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSBldmVudC5kZXRhaWwucmVhZG9ubHk7XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZXZlbnQudGFyZ2V0LCBldmVudC5kZXRhaWwucmVxdWlyZWQpO1xuICAgICAgfSxcbiAgICAgIGJnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJiZ0NvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmaWxsQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmZ0NvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHRleHRDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcInRleHRDb2xvclwiLCBcImNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBib3JkZXJDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJvcmRlckNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHN0cm9rZUNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwic3Ryb2tlQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgcm90YXRpb246IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBldmVudC5kZXRhaWwucm90YXRpb247XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24oYW5nbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIHJvdGF0aW9uOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpIHtcbiAgICBjb25zdCBjb21tb25BY3Rpb25zID0gdGhpcy5fY29tbW9uQWN0aW9ucztcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoanNFdmVudC5kZXRhaWwpKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW25hbWVdIHx8IGNvbW1vbkFjdGlvbnNbbmFtZV07XG4gICAgICBhY3Rpb24/Lihqc0V2ZW50KTtcbiAgICB9XG4gIH1cbiAgX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZERhdGEgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKHRoaXMuZGF0YS5pZCk7XG4gICAgaWYgKCFzdG9yZWREYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgW2FjdGlvbk5hbWUsIGRldGFpbF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVkRGF0YSkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGNvbW1vbkFjdGlvbnNbYWN0aW9uTmFtZV07XG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50UHJveHkgPSB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBbYWN0aW9uTmFtZV06IGRldGFpbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFyZ2V0OiBlbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIGFjdGlvbihldmVudFByb3h5KTtcbiAgICAgICAgZGVsZXRlIHN0b3JlZERhdGFbYWN0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jcmVhdGVRdWFkcmlsYXRlcmFscygpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHF1YWRQb2ludHNcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIGlmICghcXVhZFBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcmVjdEJsWCwgcmVjdEJsWSwgcmVjdFRyWCwgcmVjdFRyWV0gPSB0aGlzLmRhdGEucmVjdC5tYXAoeCA9PiBNYXRoLmZyb3VuZCh4KSk7XG4gICAgaWYgKHF1YWRQb2ludHMubGVuZ3RoID09PSA4KSB7XG4gICAgICBjb25zdCBbdHJYLCB0clksIGJsWCwgYmxZXSA9IHF1YWRQb2ludHMuc3ViYXJyYXkoMiwgNik7XG4gICAgICBpZiAocmVjdFRyWCA9PT0gdHJYICYmIHJlY3RUclkgPT09IHRyWSAmJiByZWN0QmxYID09PSBibFggJiYgcmVjdEJsWSA9PT0gYmxZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5jb250YWluZXI7XG4gICAgbGV0IHN2Z0J1ZmZlcjtcbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJvcmRlckNvbG9yLFxuICAgICAgICBib3JkZXJXaWR0aFxuICAgICAgfSA9IHN0eWxlO1xuICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgc3ZnQnVmZmVyID0gW1widXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCxcIiwgYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiYCwgYCBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMSAxXCI+YCwgYDxnIGZpbGw9XCJ0cmFuc3BhcmVudFwiIHN0cm9rZT1cIiR7Ym9yZGVyQ29sb3J9XCIgc3Ryb2tlLXdpZHRoPVwiJHtib3JkZXJXaWR0aH1cIj5gXTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNCb3JkZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gcmVjdFRyWCAtIHJlY3RCbFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVjdFRyWSAtIHJlY3RCbFk7XG4gICAgY29uc3Qge1xuICAgICAgc3ZnRmFjdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Z1wiKTtcbiAgICBzdmcuY2xhc3NMaXN0LmFkZChcInF1YWRyaWxhdGVyYWxzQ29udGFpbmVyXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgIGNvbnN0IGRlZnMgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHN2Zy5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgY2xpcFBhdGggPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKTtcbiAgICBjb25zdCBpZCA9IGBjbGlwcGF0aF8ke3RoaXMuZGF0YS5pZH1gO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJjbGlwUGF0aFVuaXRzXCIsIFwib2JqZWN0Qm91bmRpbmdCb3hcIik7XG4gICAgZGVmcy5hcHBlbmQoY2xpcFBhdGgpO1xuICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IHF1YWRQb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gOCkge1xuICAgICAgY29uc3QgdHJYID0gcXVhZFBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHRyWSA9IHF1YWRQb2ludHNbaSArIDFdO1xuICAgICAgY29uc3QgYmxYID0gcXVhZFBvaW50c1tpICsgMl07XG4gICAgICBjb25zdCBibFkgPSBxdWFkUG9pbnRzW2kgKyAzXTtcbiAgICAgIGNvbnN0IHJlY3QgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIpO1xuICAgICAgY29uc3QgeCA9IChibFggLSByZWN0QmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgeSA9IChyZWN0VHJZIC0gdHJZKSAvIGhlaWdodDtcbiAgICAgIGNvbnN0IHJlY3RXaWR0aCA9ICh0clggLSBibFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCByZWN0SGVpZ2h0ID0gKHRyWSAtIGJsWSkgLyBoZWlnaHQ7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcInhcIiwgeCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcInlcIiwgeSk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHJlY3RXaWR0aCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCByZWN0SGVpZ2h0KTtcbiAgICAgIGNsaXBQYXRoLmFwcGVuZChyZWN0KTtcbiAgICAgIHN2Z0J1ZmZlcj8ucHVzaChgPHJlY3QgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiIHg9XCIke3h9XCIgeT1cIiR7eX1cIiB3aWR0aD1cIiR7cmVjdFdpZHRofVwiIGhlaWdodD1cIiR7cmVjdEhlaWdodH1cIi8+YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIHN2Z0J1ZmZlci5wdXNoKGA8L2c+PC9zdmc+JylgKTtcbiAgICAgIHN0eWxlLmJhY2tncm91bmRJbWFnZSA9IHN2Z0J1ZmZlci5qb2luKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5jbGlwUGF0aCA9IGB1cmwoIyR7aWR9KWA7XG4gIH1cbiAgX2NyZWF0ZVBvcHVwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMuI3BvcHVwRWxlbWVudCA9IG5ldyBQb3B1cEFubm90YXRpb25FbGVtZW50KHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29sb3I6IGRhdGEuY29sb3IsXG4gICAgICAgIHRpdGxlT2JqOiBkYXRhLnRpdGxlT2JqLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzT2JqOiBkYXRhLmNvbnRlbnRzT2JqLFxuICAgICAgICByaWNoVGV4dDogZGF0YS5yaWNoVGV4dCxcbiAgICAgICAgcGFyZW50UmVjdDogZGF0YS5yZWN0LFxuICAgICAgICBib3JkZXJTdHlsZTogMCxcbiAgICAgICAgaWQ6IGBwb3B1cF8ke2RhdGEuaWR9YCxcbiAgICAgICAgcm90YXRpb246IGRhdGEucm90YXRpb25cbiAgICAgIH0sXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IFt0aGlzXVxuICAgIH0pO1xuICAgIHRoaXMucGFyZW50LmRpdi5hcHBlbmQocG9wdXAucmVuZGVyKCkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgQW5ub3RhdGlvbkVsZW1lbnQucmVuZGVyYCBjYWxsZWRcIik7XG4gIH1cbiAgX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIHNraXBJZCA9IG51bGwpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBpZiAodGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICBjb25zdCBmaWVsZE9iaiA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tuYW1lXTtcbiAgICAgIGlmIChmaWVsZE9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICBwYWdlLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGV4cG9ydFZhbHVlc1xuICAgICAgICB9IG9mIGZpZWxkT2JqKSB7XG4gICAgICAgICAgaWYgKHBhZ2UgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IHR5cGVvZiBleHBvcnRWYWx1ZXMgPT09IFwic3RyaW5nXCIgPyBleHBvcnRWYWx1ZXMgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1lbGVtZW50LWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgICBpZiAoZG9tRWxlbWVudCAmJiAhR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICB3YXJuKGBfZ2V0RWxlbWVudHNCeU5hbWUgLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgICAgICBkb21FbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgfSA9IGRvbUVsZW1lbnQ7XG4gICAgICBjb25zdCBpZCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIpO1xuICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICBkb21FbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/Lm1heWJlU2hvdygpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5mb3JjZUhpZGUoKTtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5nZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJpZ2dlcnMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlcnMpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlcnMuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgfVxuICB9XG4gIF9lZGl0T25Eb3VibGVDbGljaygpIHtcbiAgICBpZiAoIXRoaXMuX2lzRWRpdGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVkaXRvclR5cGU6IG1vZGUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBlZGl0SWRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgZWRpdElkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgTGlua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCBvcHRpb25zID0gbnVsbCkge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogISFvcHRpb25zPy5pZ25vcmVCb3JkZXIsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaXNUb29sdGlwT25seSA9IHBhcmFtZXRlcnMuZGF0YS5pc1Rvb2x0aXBPbmx5O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgbGlua1NlcnZpY2VcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgZGF0YS5pZCk7XG4gICAgbGV0IGlzQm91bmQgPSBmYWxzZTtcbiAgICBpZiAoZGF0YS51cmwpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGxpbmssIGRhdGEudXJsLCBkYXRhLm5ld1dpbmRvdyk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uKSB7XG4gICAgICB0aGlzLl9iaW5kTmFtZWRBY3Rpb24obGluaywgZGF0YS5hY3Rpb24pO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmF0dGFjaG1lbnQpIHtcbiAgICAgIHRoaXMuI2JpbmRBdHRhY2htZW50KGxpbmssIGRhdGEuYXR0YWNobWVudCwgZGF0YS5hdHRhY2htZW50RGVzdCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuc2V0T0NHU3RhdGUpIHtcbiAgICAgIHRoaXMuI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBkYXRhLnNldE9DR1N0YXRlKTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5kZXN0KSB7XG4gICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBkYXRhLmRlc3QpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhLmFjdGlvbnMgJiYgKGRhdGEuYWN0aW9ucy5BY3Rpb24gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgVXBcIl0gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgRG93blwiXSkgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnJlc2V0Rm9ybSkge1xuICAgICAgICB0aGlzLl9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIGRhdGEucmVzZXRGb3JtKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUb29sdGlwT25seSAmJiAhaXNCb3VuZCkge1xuICAgICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBcIlwiKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5rQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoaXNCb3VuZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgI3NldEludGVybmFsTGluaygpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWludGVybmFsLWxpbmtcIiwgXCJcIik7XG4gIH1cbiAgX2JpbmRMaW5rKGxpbmssIGRlc3RpbmF0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXREZXN0aW5hdGlvbkhhc2goZGVzdGluYXRpb24pO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmdvVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAoZGVzdGluYXRpb24gfHwgZGVzdGluYXRpb24gPT09IFwiXCIpIHtcbiAgICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIH1cbiAgfVxuICBfYmluZE5hbWVkQWN0aW9uKGxpbmssIGFjdGlvbikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZU5hbWVkQWN0aW9uKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICAjYmluZEF0dGFjaG1lbnQobGluaywgYXR0YWNobWVudCwgZGVzdCA9IG51bGwpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBpZiAoYXR0YWNobWVudC5kZXNjcmlwdGlvbikge1xuICAgICAgbGluay50aXRsZSA9IGF0dGFjaG1lbnQuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEoYXR0YWNobWVudC5jb250ZW50LCBhdHRhY2htZW50LmZpbGVuYW1lLCBkZXN0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kU2V0T0NHU3RhdGUobGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlU2V0T0NHU3RhdGUoYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kSlNBY3Rpb24obGluaywgZGF0YSkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoW1tcIkFjdGlvblwiLCBcIm9uY2xpY2tcIl0sIFtcIk1vdXNlIFVwXCIsIFwib25tb3VzZXVwXCJdLCBbXCJNb3VzZSBEb3duXCIsIFwib25tb3VzZWRvd25cIl1dKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZGF0YS5hY3Rpb25zKSkge1xuICAgICAgY29uc3QganNOYW1lID0gbWFwLmdldChuYW1lKTtcbiAgICAgIGlmICghanNOYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGlua1tqc05hbWVdID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghbGluay5vbmNsaWNrKSB7XG4gICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgcmVzZXRGb3JtKSB7XG4gICAgY29uc3Qgb3RoZXJDbGlja0FjdGlvbiA9IGxpbmsub25jbGljaztcbiAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgICBpZiAoIXRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgd2FybihgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBcInJlc2V0Rm9ybVwiIGFjdGlvbiBub3Qgc3VwcG9ydGVkLCBgICsgXCJlbnN1cmUgdGhhdCB0aGUgYGZpZWxkT2JqZWN0c2AgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlwiKTtcbiAgICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgb3RoZXJDbGlja0FjdGlvbj8uKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpZWxkczogcmVzZXRGb3JtRmllbGRzLFxuICAgICAgICByZWZzOiByZXNldEZvcm1SZWZzLFxuICAgICAgICBpbmNsdWRlXG4gICAgICB9ID0gcmVzZXRGb3JtO1xuICAgICAgY29uc3QgYWxsRmllbGRzID0gW107XG4gICAgICBpZiAocmVzZXRGb3JtRmllbGRzLmxlbmd0aCAhPT0gMCB8fCByZXNldEZvcm1SZWZzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBmaWVsZElkcyA9IG5ldyBTZXQocmVzZXRGb3JtUmVmcyk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIHJlc2V0Rm9ybUZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tmaWVsZE5hbWVdIHx8IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9IG9mIGZpZWxkcykge1xuICAgICAgICAgICAgZmllbGRJZHMuYWRkKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZElkcy5oYXMoZmllbGQuaWQpID09PSBpbmNsdWRlKSB7XG4gICAgICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKC4uLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgY29uc3QgYWxsSWRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGFsbEZpZWxkcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGZpZWxkO1xuICAgICAgICBhbGxJZHMucHVzaChpZCk7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgY2FzZSBcInJhZGlvYnV0dG9uXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlID09PSBmaWVsZC5leHBvcnRWYWx1ZXM7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNvbWJvYm94XCI6XG4gICAgICAgICAgY2FzZSBcImxpc3Rib3hcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICBpZiAoIWRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgd2FybihgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRvbUVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJyZXNldGZvcm1cIikpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IFwiYXBwXCIsXG4gICAgICAgICAgICBpZHM6IGFsbElkcyxcbiAgICAgICAgICAgIG5hbWU6IFwiUmVzZXRGb3JtXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn1cbmNsYXNzIFRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dEFubm90YXRpb25cIik7XG4gICAgY29uc3QgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIGltYWdlLnNyYyA9IHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoICsgXCJhbm5vdGF0aW9uLVwiICsgdGhpcy5kYXRhLm5hbWUudG9Mb3dlckNhc2UoKSArIFwiLnN2Z1wiO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLXRleHQtYW5ub3RhdGlvbi10eXBlXCIpO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHR5cGU6IHRoaXMuZGF0YS5uYW1lXG4gICAgfSkpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoaW1hZ2UpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgc2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgaWYgKGVsZW1lbnQucHJldmlvdXNTaWJsaW5nPy5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBlbGVtZW50LnByZXZpb3VzU2libGluZy5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEtleU1vZGlmaWVyKGV2ZW50KSB7XG4gICAgcmV0dXJuIHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNNYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTtcbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgdmFsdWVHZXR0ZXIpIHtcbiAgICBpZiAoYmFzZU5hbWUuaW5jbHVkZXMoXCJtb3VzZVwiKSkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBldmVudCA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUdldHRlcihldmVudCksXG4gICAgICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICBtb2RpZmllcjogdGhpcy5fZ2V0S2V5TW9kaWZpZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGJhc2VOYW1lID09PSBcImJsdXJcIikge1xuICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9jdXNlZCB8fCAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwiZm9jdXNcIikge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBuYW1lcywgZ2V0dGVyKSB7XG4gICAgZm9yIChjb25zdCBbYmFzZU5hbWUsIGV2ZW50TmFtZV0gb2YgbmFtZXMpIHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09IFwiQWN0aW9uXCIgfHwgdGhpcy5kYXRhLmFjdGlvbnM/LltldmVudE5hbWVdKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiB8fCBldmVudE5hbWUgPT09IFwiQmx1clwiKSB7XG4gICAgICAgICAgZWxlbWVudERhdGEgfHw9IHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCBnZXR0ZXIpO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5CbHVyKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJibHVyXCIsIFwiQmx1clwiLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiQmx1clwiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uRm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImZvY3VzXCIsIFwiRm9jdXNcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yIHx8IG51bGw7XG4gICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvciA9PT0gbnVsbCA/IFwidHJhbnNwYXJlbnRcIiA6IFV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuICB9XG4gIF9zZXRUZXh0U3R5bGUoZWxlbWVudCkge1xuICAgIGNvbnN0IFRFWFRfQUxJR05NRU5UID0gW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZvbnRDb2xvclxuICAgIH0gPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhO1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YS5mb250U2l6ZSB8fCBhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFO1xuICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBsZXQgY29tcHV0ZWRGb250U2l6ZTtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgcm91bmRUb09uZURlY2ltYWwgPSB4ID0+IE1hdGgucm91bmQoMTAgKiB4KSAvIDEwO1xuICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29uc3QgbnVtYmVyT2ZMaW5lcyA9IE1hdGgucm91bmQoaGVpZ2h0IC8gKExJTkVfRkFDVE9SICogZm9udFNpemUpKSB8fCAxO1xuICAgICAgY29uc3QgbGluZUhlaWdodCA9IGhlaWdodCAvIG51bWJlck9mTGluZXM7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGxpbmVIZWlnaHQgLyBMSU5FX0ZBQ1RPUikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCByb3VuZFRvT25lRGVjaW1hbChoZWlnaHQgLyBMSU5FX0ZBQ1RPUikpO1xuICAgIH1cbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7Y29tcHV0ZWRGb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IFV0aWwubWFrZUhleENvbG9yKGZvbnRDb2xvclswXSwgZm9udENvbG9yWzFdLCBmb250Q29sb3JbMl0pO1xuICAgIGlmICh0aGlzLmRhdGEudGV4dEFsaWdubWVudCAhPT0gbnVsbCkge1xuICAgICAgc3R5bGUudGV4dEFsaWduID0gVEVYVF9BTElHTk1FTlRbdGhpcy5kYXRhLnRleHRBbGlnbm1lbnRdO1xuICAgIH1cbiAgfVxuICBfc2V0UmVxdWlyZWQoZWxlbWVudCwgaXNSZXF1aXJlZCkge1xuICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInJlcXVpcmVkXCIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgaXNSZXF1aXJlZCk7XG4gIH1cbn1cbmNsYXNzIFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9IHBhcmFtZXRlcnMucmVuZGVyRm9ybXMgfHwgcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhcyB8fCAhcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2UgJiYgISFwYXJhbWV0ZXJzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGVcbiAgICB9KTtcbiAgfVxuICBzZXRQcm9wZXJ0eU9uU2libGluZ3MoYmFzZSwga2V5LCB2YWx1ZSwga2V5SW5TdG9yYWdlKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGJhc2UubmFtZSwgYmFzZS5pZCkpIHtcbiAgICAgIGlmIChlbGVtZW50LmRvbUVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5kb21FbGVtZW50W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoZWxlbWVudC5pZCwge1xuICAgICAgICBba2V5SW5TdG9yYWdlXTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRleHRXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGxldCBlbGVtZW50ID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZW5kZXJGb3Jtcykge1xuICAgICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuZGF0YS5maWVsZFZhbHVlXG4gICAgICB9KTtcbiAgICAgIGxldCB0ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWUgfHwgXCJcIjtcbiAgICAgIGNvbnN0IG1heExlbiA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgICAgY2hhckxpbWl0OiB0aGlzLmRhdGEubWF4TGVuXG4gICAgICB9KS5jaGFyTGltaXQ7XG4gICAgICBpZiAobWF4TGVuICYmIHRleHRDb250ZW50Lmxlbmd0aCA+IG1heExlbikge1xuICAgICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIG1heExlbik7XG4gICAgICB9XG4gICAgICBsZXQgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBzdG9yZWREYXRhLmZvcm1hdHRlZFZhbHVlIHx8IHRoaXMuZGF0YS50ZXh0Q29udGVudD8uam9pbihcIlxcblwiKSB8fCBudWxsO1xuICAgICAgaWYgKGZpZWxkRm9ybWF0dGVkVmFsdWVzICYmIHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGZpZWxkRm9ybWF0dGVkVmFsdWVzID0gZmllbGRGb3JtYXR0ZWRWYWx1ZXMucmVwbGFjZUFsbCgvXFxzKy9nLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnREYXRhID0ge1xuICAgICAgICB1c2VyVmFsdWU6IHRleHRDb250ZW50LFxuICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogZmllbGRGb3JtYXR0ZWRWYWx1ZXMsXG4gICAgICAgIGxhc3RDb21taXR0ZWRWYWx1ZTogbnVsbCxcbiAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICBmb2N1c2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kb05vdFNjcm9sbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgZWxlbWVudC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPz8gdGV4dENvbnRlbnQpO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1ggPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgICBlbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgICAgZWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgICBpZiAobWF4TGVuKSB7XG4gICAgICAgIGVsZW1lbnQubWF4TGVuZ3RoID0gbWF4TGVuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eU9uU2libGluZ3MoZWxlbWVudCwgXCJ2YWx1ZVwiLCBldmVudC50YXJnZXQudmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlID8/IFwiXCI7XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgbGV0IGJsdXJMaXN0ZW5lciA9IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgIH0gPSBlbGVtZW50RGF0YTtcbiAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBudWxsICYmIGZvcm1hdHRlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEuZm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLnVzZXJWYWx1ZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5hY3Rpb25zPy5Gb2N1cykge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgICAgdGhpcy5zaG93RWxlbWVudEFuZEhpZGVDYW52YXMoanNFdmVudC50YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWUgPz8gXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBlbGVtZW50RGF0YS51c2VyVmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBldmVudC50YXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsUmFuZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKC4uLmV2ZW50LmRldGFpbC5zZWxSYW5nZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhckxpbWl0OiBldmVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjaGFyTGltaXRcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgIGlmIChjaGFyTGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwibWF4TGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwibWF4TGVuZ3RoXCIsIGNoYXJMaW1pdCk7XG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPD0gY2hhckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICAgICAgICBzZWxTdGFydDogdGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgc2VsRW5kOiB0YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgbGV0IGNvbW1pdEtleSA9IC0xO1xuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgIGNvbW1pdEtleSA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiAhdGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1pdEtleSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICBjb21taXRLZXksXG4gICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2JsdXJMaXN0ZW5lciA9IGJsdXJMaXN0ZW5lcjtcbiAgICAgICAgYmx1ckxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmFjdGlvbnM/LkJsdXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb21taXRLZXk6IGVsZW1lbnREYXRhLmNvbW1pdEtleSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2JsdXJMaXN0ZW5lcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmFjdGlvbnM/LktleXN0cm9rZSkge1xuICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfSA9IHRhcmdldDtcbiAgICAgICAgICAgIGxldCBzZWxTdGFydCA9IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxFbmQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmlucHV0VHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlV29yZEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9cXHcqW15cXHddKiQvKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkRm9yd2FyZFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvblN0YXJ0KS5tYXRjaCgvXlteXFx3XSpcXHcqLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbEVuZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBkYXRhIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoYmx1ckxpc3RlbmVyKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuY29tYikge1xuICAgICAgICBjb25zdCBmaWVsZFdpZHRoID0gdGhpcy5kYXRhLnJlY3RbMl0gLSB0aGlzLmRhdGEucmVjdFswXTtcbiAgICAgICAgY29uc3QgY29tYldpZHRoID0gZmllbGRXaWR0aCAvIG1heExlbjtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY29tYlwiKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gYGNhbGMoJHtjb21iV2lkdGh9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpIC0gMWNoKWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IHRoaXMuZGF0YS5maWVsZFZhbHVlO1xuICAgICAgZWxlbWVudC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJtaWRkbGVcIjtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwidGFibGUtY2VsbFwiO1xuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgICAgZWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zZXRUZXh0U3R5bGUoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiAhIXBhcmFtZXRlcnMuZGF0YS5oYXNPd25DYW52YXNcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGlkID0gZGF0YS5pZDtcbiAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogZGF0YS5leHBvcnRWYWx1ZSA9PT0gZGF0YS5maWVsZFZhbHVlXG4gICAgfSkudmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcImNoZWNrQm94XCIpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJleHBvcnRWYWx1ZVwiLCBkYXRhLmV4cG9ydFZhbHVlKTtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgY2hlY2tib3ggb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIGNoZWNrYm94LmV4cG9ydFZhbHVlID09PSBkYXRhLmV4cG9ydFZhbHVlO1xuICAgICAgICBpZiAoY2hlY2tib3guZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNoZWNrYm94LmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShjaGVja2JveC5pZCwge1xuICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgfHwgXCJPZmZcIjtcbiAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZGVmYXVsdFZhbHVlID09PSBkYXRhLmV4cG9ydFZhbHVlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZXZlbnQuZGV0YWlsLnZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LmNoZWNrZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBudWxsLCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJyYWRpb0J1dHRvblwiKTtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGlkID0gZGF0YS5pZDtcbiAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogZGF0YS5maWVsZFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlXG4gICAgfSkudmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoZGF0YS5maWVsZE5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBlbGVtZW50LnR5cGUgPSBcInJhZGlvXCI7XG4gICAgZWxlbWVudC5uYW1lID0gZGF0YS5maWVsZE5hbWU7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IGNoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgY29uc3QgcGRmQnV0dG9uVmFsdWUgPSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBwZGZCdXR0b25WYWx1ZSA9PT0gZXZlbnQuZGV0YWlsLnZhbHVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShldmVudC50YXJnZXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgcmFkaW8uaWQgPT09IGlkO1xuICAgICAgICAgICAgICBpZiAocmFkaW8uZG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJhZGlvLmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBudWxsLCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIExpbmtBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpZ25vcmVCb3JkZXI6IHBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInB1c2hCdXR0b25cIik7XG4gICAgY29uc3QgbGlua0VsZW1lbnQgPSBjb250YWluZXIubGFzdENoaWxkO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucyAmJiBsaW5rRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMobGlua0VsZW1lbnQpO1xuICAgICAgbGlua0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goe30sIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaG9pY2VXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoc2VsZWN0RWxlbWVudCk7XG4gICAgc2VsZWN0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIHNlbGVjdEVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoc2VsZWN0RWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBzZWxlY3RFbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgIHNlbGVjdEVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBsZXQgYWRkQW5FbXB0eUVudHJ5ID0gdGhpcy5kYXRhLmNvbWJvICYmIHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKCF0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuc2l6ZSA9IHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnZhbHVlID09PSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5kYXRhLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbi5kaXNwbGF5VmFsdWU7XG4gICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUuaW5jbHVkZXMob3B0aW9uLmV4cG9ydFZhbHVlKSkge1xuICAgICAgICBvcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgICBhZGRBbkVtcHR5RW50cnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cbiAgICBsZXQgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgaWYgKGFkZEFuRW1wdHlFbnRyeSkge1xuICAgICAgY29uc3Qgbm9uZU9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQudmFsdWUgPSBcIiBcIjtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCB0cnVlKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgc2VsZWN0RWxlbWVudC5wcmVwZW5kKG5vbmVPcHRpb25FbGVtZW50KTtcbiAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSAoKSA9PiB7XG4gICAgICAgIG5vbmVPcHRpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgcmVtb3ZlRW1wdHlFbnRyeSk7XG4gICAgfVxuICAgIGNvbnN0IGdldFZhbHVlID0gaXNFeHBvcnQgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGlzRXhwb3J0ID8gXCJ2YWx1ZVwiIDogXCJ0ZXh0Q29udGVudFwiO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBtdWx0aXBsZVxuICAgICAgfSA9IHNlbGVjdEVsZW1lbnQ7XG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gbnVsbCA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XVtuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCkubWFwKG9wdGlvbiA9PiBvcHRpb25bbmFtZV0pO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gKHtcbiAgICAgICAgZGlzcGxheVZhbHVlOiBvcHRpb24udGV4dENvbnRlbnQsXG4gICAgICAgIGV4cG9ydFZhbHVlOiBvcHRpb24udmFsdWVcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIHJlbW92ZUVtcHR5RW50cnk/LigpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZXMuaGFzKG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG11bHRpcGxlU2VsZWN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZShldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHNlbGVjdEVsZW1lbnQub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnQuZGV0YWlsLnJlbW92ZTtcbiAgICAgICAgICAgIG9wdGlvbnNbaW5kZXhdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZShpbmRleCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGkgPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4LmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCk7XG4gICAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsZWFyKGV2ZW50KSB7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnNlcnQoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWwuaW5zZXJ0O1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0Q2hpbGQgPSBzZWxlY3RFbGVtZW50LmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBleHBvcnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RDaGlsZCkge1xuICAgICAgICAgICAgICBzZWxlY3RDaGlsZC5iZWZvcmUob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaXRlbXMoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaXRlbXNcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBleHBvcnRWYWx1ZTtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0RWxlbWVudC5vcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5vcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5kaWNlcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBTZXQoZXZlbnQuZGV0YWlsLmluZGljZXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZXZlbnQudGFyZ2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gaW5kaWNlcy5oYXMob3B0aW9uLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZWRpdGFibGUoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9ICFldmVudC5kZXRhaWwuZWRpdGFibGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZXhwb3J0VmFsdWUgPSBnZXRWYWx1ZSh0cnVlKTtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV4cG9ydFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIGNoYW5nZSxcbiAgICAgICAgICAgIGNoYW5nZUV4OiBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICAgICAga2V5RG93bjogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhzZWxlY3RFbGVtZW50LCBudWxsLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXSwgW1wiaW5wdXRcIiwgXCJBY3Rpb25cIl0sIFtcImlucHV0XCIsIFwiVmFsaWRhdGVcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGUoc2VsZWN0RWxlbWVudCk7XG4gICAgfSBlbHNlIHt9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzZWxlY3RFbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgZWxlbWVudHNcbiAgICB9ID0gcGFyYW1ldGVycztcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEoZGF0YSlcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cEFubm90YXRpb25cIik7XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLnBvcHVwID0gbmV3IFBvcHVwRWxlbWVudCh7XG4gICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgY29sb3I6IHRoaXMuZGF0YS5jb2xvcixcbiAgICAgIHRpdGxlT2JqOiB0aGlzLmRhdGEudGl0bGVPYmosXG4gICAgICBtb2RpZmljYXRpb25EYXRlOiB0aGlzLmRhdGEubW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgIGNvbnRlbnRzT2JqOiB0aGlzLmRhdGEuY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy5kYXRhLnJpY2hUZXh0LFxuICAgICAgcmVjdDogdGhpcy5kYXRhLnJlY3QsXG4gICAgICBwYXJlbnRSZWN0OiB0aGlzLmRhdGEucGFyZW50UmVjdCB8fCBudWxsLFxuICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCxcbiAgICAgIGVsZW1lbnRzOiB0aGlzLmVsZW1lbnRzLFxuICAgICAgb3BlbjogdGhpcy5kYXRhLm9wZW5cbiAgICB9KTtcbiAgICBjb25zdCBlbGVtZW50SWRzID0gW107XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQucG9wdXAgPSBwb3B1cDtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyLmFyaWFIYXNQb3B1cCA9IFwiZGlhbG9nXCI7XG4gICAgICBlbGVtZW50SWRzLnB1c2goZWxlbWVudC5kYXRhLmlkKTtcbiAgICAgIGVsZW1lbnQuYWRkSGlnaGxpZ2h0QXJlYSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIGVsZW1lbnRJZHMubWFwKGlkID0+IGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gKS5qb2luKFwiLFwiKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQb3B1cEVsZW1lbnQge1xuICAjYm91bmRLZXlEb3duID0gdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpO1xuICAjYm91bmRIaWRlID0gdGhpcy4jaGlkZS5iaW5kKHRoaXMpO1xuICAjYm91bmRTaG93ID0gdGhpcy4jc2hvdy5iaW5kKHRoaXMpO1xuICAjYm91bmRUb2dnbGUgPSB0aGlzLiN0b2dnbGUuYmluZCh0aGlzKTtcbiAgI2NvbG9yID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICNjb250ZW50c09iaiA9IG51bGw7XG4gICNkYXRlT2JqID0gbnVsbDtcbiAgI2VsZW1lbnRzID0gbnVsbDtcbiAgI3BhcmVudCA9IG51bGw7XG4gICNwYXJlbnRSZWN0ID0gbnVsbDtcbiAgI3Bpbm5lZCA9IGZhbHNlO1xuICAjcG9wdXAgPSBudWxsO1xuICAjcG9zaXRpb24gPSBudWxsO1xuICAjcmVjdCA9IG51bGw7XG4gICNyaWNoVGV4dCA9IG51bGw7XG4gICN0aXRsZU9iaiA9IG51bGw7XG4gICN1cGRhdGVzID0gbnVsbDtcbiAgI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRhaW5lcixcbiAgICBjb2xvcixcbiAgICBlbGVtZW50cyxcbiAgICB0aXRsZU9iaixcbiAgICBtb2RpZmljYXRpb25EYXRlLFxuICAgIGNvbnRlbnRzT2JqLFxuICAgIHJpY2hUZXh0LFxuICAgIHBhcmVudCxcbiAgICByZWN0LFxuICAgIHBhcmVudFJlY3QsXG4gICAgb3BlblxuICB9KSB7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3RpdGxlT2JqID0gdGl0bGVPYmo7XG4gICAgdGhpcy4jY29udGVudHNPYmogPSBjb250ZW50c09iajtcbiAgICB0aGlzLiNyaWNoVGV4dCA9IHJpY2hUZXh0O1xuICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLiNjb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuI3JlY3QgPSByZWN0O1xuICAgIHRoaXMuI3BhcmVudFJlY3QgPSBwYXJlbnRSZWN0O1xuICAgIHRoaXMuI2VsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgdGhpcy4jZGF0ZU9iaiA9IFBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIHRoaXMudHJpZ2dlciA9IGVsZW1lbnRzLmZsYXRNYXAoZSA9PiBlLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLiNib3VuZFNob3cpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLiNib3VuZEhpZGUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LmNvbnRhaW5lcj8uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBvcHVwID0gdGhpcy4jcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHBvcHVwLmNsYXNzTmFtZSA9IFwicG9wdXBcIjtcbiAgICBpZiAodGhpcy4jY29sb3IpIHtcbiAgICAgIGNvbnN0IGJhc2VDb2xvciA9IHBvcHVwLnN0eWxlLm91dGxpbmVDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLnRoaXMuI2NvbG9yKTtcbiAgICAgIGlmIChDU1Muc3VwcG9ydHMoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiY29sb3ItbWl4KGluIHNyZ2IsIHJlZCAzMCUsIHdoaXRlKVwiKSkge1xuICAgICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgY29sb3ItbWl4KGluIHNyZ2IsICR7YmFzZUNvbG9yfSAzMCUsIHdoaXRlKWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBCQUNLR1JPVU5EX0VOTElHSFQgPSAwLjc7XG4gICAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLnRoaXMuI2NvbG9yLm1hcChjID0+IE1hdGguZmxvb3IoQkFDS0dST1VORF9FTkxJR0hUICogKDI1NSAtIGMpICsgYykpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaGVhZGVyLmNsYXNzTmFtZSA9IFwiaGVhZGVyXCI7XG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDFcIik7XG4gICAgaGVhZGVyLmFwcGVuZCh0aXRsZSk7XG4gICAgKHtcbiAgICAgIGRpcjogdGl0bGUuZGlyLFxuICAgICAgc3RyOiB0aXRsZS50ZXh0Q29udGVudFxuICAgIH0gPSB0aGlzLiN0aXRsZU9iaik7XG4gICAgcG9wdXAuYXBwZW5kKGhlYWRlcik7XG4gICAgaWYgKHRoaXMuI2RhdGVPYmopIHtcbiAgICAgIGNvbnN0IG1vZGlmaWNhdGlvbkRhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuY2xhc3NMaXN0LmFkZChcInBvcHVwRGF0ZVwiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtYW5ub3RhdGlvbi1kYXRlLXRpbWUtc3RyaW5nXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRhdGVPYmo6IHRoaXMuI2RhdGVPYmoudmFsdWVPZigpXG4gICAgICB9KSk7XG4gICAgICBoZWFkZXIuYXBwZW5kKG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIH1cbiAgICBjb25zdCBodG1sID0gdGhpcy4jaHRtbDtcbiAgICBpZiAoaHRtbCkge1xuICAgICAgWGZhTGF5ZXIucmVuZGVyKHtcbiAgICAgICAgeGZhSHRtbDogaHRtbCxcbiAgICAgICAgaW50ZW50OiBcInJpY2hUZXh0XCIsXG4gICAgICAgIGRpdjogcG9wdXBcbiAgICAgIH0pO1xuICAgICAgcG9wdXAubGFzdENoaWxkLmNsYXNzTGlzdC5hZGQoXCJyaWNoVGV4dFwiLCBcInBvcHVwQ29udGVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udGVudHMgPSB0aGlzLl9mb3JtYXRDb250ZW50cyh0aGlzLiNjb250ZW50c09iaik7XG4gICAgICBwb3B1cC5hcHBlbmQoY29udGVudHMpO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuYXBwZW5kKHBvcHVwKTtcbiAgfVxuICBnZXQgI2h0bWwoKSB7XG4gICAgY29uc3QgcmljaFRleHQgPSB0aGlzLiNyaWNoVGV4dDtcbiAgICBjb25zdCBjb250ZW50c09iaiA9IHRoaXMuI2NvbnRlbnRzT2JqO1xuICAgIGlmIChyaWNoVGV4dD8uc3RyICYmICghY29udGVudHNPYmo/LnN0ciB8fCBjb250ZW50c09iai5zdHIgPT09IHJpY2hUZXh0LnN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLiNyaWNoVGV4dC5odG1sIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCAjZm9udFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2h0bWw/LmF0dHJpYnV0ZXM/LnN0eWxlPy5mb250U2l6ZSB8fCAwO1xuICB9XG4gIGdldCAjZm9udENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNodG1sPy5hdHRyaWJ1dGVzPy5zdHlsZT8uY29sb3IgfHwgbnVsbDtcbiAgfVxuICAjbWFrZVBvcHVwQ29udGVudCh0ZXh0KSB7XG4gICAgY29uc3QgcG9wdXBMaW5lcyA9IFtdO1xuICAgIGNvbnN0IHBvcHVwQ29udGVudCA9IHtcbiAgICAgIHN0cjogdGV4dCxcbiAgICAgIGh0bWw6IHtcbiAgICAgICAgbmFtZTogXCJkaXZcIixcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIGRpcjogXCJhdXRvXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgbmFtZTogXCJwXCIsXG4gICAgICAgICAgY2hpbGRyZW46IHBvcHVwTGluZXNcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxpbmVBdHRyaWJ1dGVzID0ge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY29sb3I6IHRoaXMuI2ZvbnRDb2xvcixcbiAgICAgICAgZm9udFNpemU6IHRoaXMuI2ZvbnRTaXplID8gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYCA6IFwiXCJcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgbGluZSBvZiB0ZXh0LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBwb3B1cExpbmVzLnB1c2goe1xuICAgICAgICBuYW1lOiBcInNwYW5cIixcbiAgICAgICAgdmFsdWU6IGxpbmUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGxpbmVBdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcHVwQ29udGVudDtcbiAgfVxuICBfZm9ybWF0Q29udGVudHMoe1xuICAgIHN0cixcbiAgICBkaXJcbiAgfSkge1xuICAgIGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICBwLmNsYXNzTGlzdC5hZGQoXCJwb3B1cENvbnRlbnRcIik7XG4gICAgcC5kaXIgPSBkaXI7XG4gICAgY29uc3QgbGluZXMgPSBzdHIuc3BsaXQoLyg/Olxcclxcbj98XFxuKS8pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIHAuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpKTtcbiAgICAgIGlmIChpIDwgaWkgLSAxKSB7XG4gICAgICAgIHAuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiIHx8IGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIiAmJiB0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFZGl0ZWQoe1xuICAgIHJlY3QsXG4gICAgcG9wdXBDb250ZW50XG4gIH0pIHtcbiAgICB0aGlzLiN1cGRhdGVzIHx8PSB7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9O1xuICAgIGlmIChyZWN0KSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChwb3B1cENvbnRlbnQpIHtcbiAgICAgIHRoaXMuI3JpY2hUZXh0ID0gdGhpcy4jbWFrZVBvcHVwQ29udGVudChwb3B1cENvbnRlbnQpO1xuICAgICAgdGhpcy4jY29udGVudHNPYmogPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNwb3B1cD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jcG9wdXAgPSBudWxsO1xuICB9XG4gIHJlc2V0RWRpdGVkKCkge1xuICAgIGlmICghdGhpcy4jdXBkYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoe1xuICAgICAgY29udGVudHNPYmo6IHRoaXMuI2NvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQ6IHRoaXMuI3JpY2hUZXh0XG4gICAgfSA9IHRoaXMuI3VwZGF0ZXMpO1xuICAgIHRoaXMuI3VwZGF0ZXMgPSBudWxsO1xuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gICAgdGhpcy4jcG9zaXRpb24gPSBudWxsO1xuICB9XG4gICNzZXRQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZToge1xuICAgICAgICB2aWV3XG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgIHBhZ2VZXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcy4jcGFyZW50O1xuICAgIGxldCB1c2VQYXJlbnRSZWN0ID0gISF0aGlzLiNwYXJlbnRSZWN0O1xuICAgIGxldCByZWN0ID0gdXNlUGFyZW50UmVjdCA/IHRoaXMuI3BhcmVudFJlY3QgOiB0aGlzLiNyZWN0O1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLiNlbGVtZW50cykge1xuICAgICAgaWYgKCFyZWN0IHx8IFV0aWwuaW50ZXJzZWN0KGVsZW1lbnQuZGF0YS5yZWN0LCByZWN0KSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0ID0gZWxlbWVudC5kYXRhLnJlY3Q7XG4gICAgICAgIHVzZVBhcmVudFJlY3QgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZFJlY3QgPSBVdGlsLm5vcm1hbGl6ZVJlY3QoW3JlY3RbMF0sIHZpZXdbM10gLSByZWN0WzFdICsgdmlld1sxXSwgcmVjdFsyXSwgdmlld1szXSAtIHJlY3RbM10gKyB2aWV3WzFdXSk7XG4gICAgY29uc3QgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OID0gNTtcbiAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHVzZVBhcmVudFJlY3QgPyByZWN0WzJdIC0gcmVjdFswXSArIEhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiA6IDA7XG4gICAgY29uc3QgcG9wdXBMZWZ0ID0gbm9ybWFsaXplZFJlY3RbMF0gKyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBwb3B1cFRvcCA9IG5vcm1hbGl6ZWRSZWN0WzFdO1xuICAgIHRoaXMuI3Bvc2l0aW9uID0gWzEwMCAqIChwb3B1cExlZnQgLSBwYWdlWCkgLyBwYWdlV2lkdGgsIDEwMCAqIChwb3B1cFRvcCAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7dGhpcy4jcG9zaXRpb25bMF19JWA7XG4gICAgc3R5bGUudG9wID0gYCR7dGhpcy4jcG9zaXRpb25bMV19JWA7XG4gIH1cbiAgI3RvZ2dsZSgpIHtcbiAgICB0aGlzLiNwaW5uZWQgPSAhdGhpcy4jcGlubmVkO1xuICAgIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3Nob3coKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hpZGUoKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfVxuICB9XG4gICNzaG93KCkge1xuICAgIGlmICghdGhpcy4jcG9wdXApIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHRoaXMuI3NldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgICB0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCkgKyAxMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZvY3VzZWRcIik7XG4gICAgfVxuICB9XG4gICNoaWRlKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwiZm9jdXNlZFwiKTtcbiAgICBpZiAodGhpcy4jcGlubmVkIHx8ICF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCkgLSAxMDAwO1xuICB9XG4gIGZvcmNlSGlkZSgpIHtcbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGU7XG4gICAgaWYgKCF0aGlzLiN3YXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICB9XG4gIG1heWJlU2hvdygpIHtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgIH1cbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPT09IGZhbHNlO1xuICB9XG59XG5jbGFzcyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0Q29udGVudDtcbiAgICB0aGlzLnRleHRQb3NpdGlvbiA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0UG9zaXRpb247XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZnJlZVRleHRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICh0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25UZXh0Q29udGVudFwiKTtcbiAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy50ZXh0Q29udGVudCkge1xuICAgICAgICBjb25zdCBsaW5lU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBsaW5lU3Bhbi50ZXh0Q29udGVudCA9IGxpbmU7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kKGxpbmVTcGFuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNsaW5lID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibGluZUFubm90YXRpb25cIik7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lXCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDFcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMF0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTFcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMV0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDJcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMl0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTJcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbM10pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNzcXVhcmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVhcmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBzcXVhcmUgPSB0aGlzLiNzcXVhcmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInlcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHNxdWFyZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3F1YXJlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIENpcmNsZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjY2lyY2xlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2lyY2xlQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgY29uc3QgY2lyY2xlID0gdGhpcy4jY2lyY2xlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6ZWxsaXBzZVwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3hcIiwgd2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3lcIiwgaGVpZ2h0IC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ4XCIsIHdpZHRoIC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ5XCIsIGhlaWdodCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChjaXJjbGUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NpcmNsZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjcG9seWxpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlsaW5lQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlY3QsXG4gICAgICAgIHZlcnRpY2VzLFxuICAgICAgICBib3JkZXJTdHlsZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXZlcnRpY2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKHJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCB5ID0gcmVjdFszXSAtIHZlcnRpY2VzW2kgKyAxXTtcbiAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcbiAgICB9XG4gICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy4jcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5Z29uQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5Z29uXCI7XG4gIH1cbn1cbmNsYXNzIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNhcmV0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBJbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lcyA9IFtdO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcImlua0Fubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gdGhpcy5kYXRhLml0ID09PSBcIklua0hpZ2hsaWdodFwiID8gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUIDogQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlY3QsXG4gICAgICAgIGlua0xpc3RzLFxuICAgICAgICBib3JkZXJTdHlsZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhyZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGZvciAoY29uc3QgaW5rTGlzdCBvZiBpbmtMaXN0cykge1xuICAgICAgbGV0IHBvaW50cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5rTGlzdC5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBpbmtMaXN0W2ldIC0gcmVjdFswXTtcbiAgICAgICAgY29uc3QgeSA9IHJlY3RbM10gLSBpbmtMaXN0W2kgKyAxXTtcbiAgICAgICAgcG9pbnRzLnB1c2goYCR7eH0sJHt5fWApO1xuICAgICAgfVxuICAgICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICAgIHRoaXMuI3BvbHlsaW5lcy5wdXNoKHBvbHlsaW5lKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICBzdmcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB9XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmVzO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFubm90YXRpb25cIik7XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFVuZGVybGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ1bmRlcmxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3F1aWdnbHlBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0cmlrZW91dEFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdGFtcEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RhbXBBbm5vdGF0aW9uXCIpO1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIik7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjdHJpZ2dlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBmaWxlXG4gICAgfSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmZpbGVuYW1lID0gZmlsZS5maWxlbmFtZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBmaWxlLmNvbnRlbnQ7XG4gICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJmaWxlYXR0YWNobWVudGFubm90YXRpb25cIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgLi4uZmlsZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgdHJpZ2dlcjtcbiAgICBpZiAoZGF0YS5oYXNBcHBlYXJhbmNlIHx8IGRhdGEuZmlsbEFscGhhID09PSAwKSB7XG4gICAgICB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICB0cmlnZ2VyLnNyYyA9IGAke3RoaXMuaW1hZ2VSZXNvdXJjZXNQYXRofWFubm90YXRpb24tJHsvcGFwZXJjbGlwL2kudGVzdChkYXRhLm5hbWUpID8gXCJwYXBlcmNsaXBcIiA6IFwicHVzaHBpblwifS5zdmdgO1xuICAgICAgaWYgKGRhdGEuZmlsbEFscGhhICYmIGRhdGEuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICB0cmlnZ2VyLnN0eWxlID0gYGZpbHRlcjogb3BhY2l0eSgke01hdGgucm91bmQoZGF0YS5maWxsQWxwaGEgKiAxMDApfSUpO2A7XG4gICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIHRoaXMuI2Rvd25sb2FkLmJpbmQodGhpcykpO1xuICAgIHRoaXMuI3RyaWdnZXIgPSB0cmlnZ2VyO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2dCA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gXCJFbnRlclwiICYmIChpc01hYyA/IGV2dC5tZXRhS2V5IDogZXZ0LmN0cmxLZXkpKSB7XG4gICAgICAgIHRoaXMuI2Rvd25sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBjb250YWluZXIuYXBwZW5kKHRyaWdnZXIpO1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdHJpZ2dlcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG4gICNkb3dubG9hZCgpIHtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlcj8ub3Blbk9yRG93bmxvYWREYXRhKHRoaXMuY29udGVudCwgdGhpcy5maWxlbmFtZSk7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25MYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbDtcbiAgI2VkaXRhYmxlQW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICNzdHJ1Y3RUcmVlTGF5ZXIgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGl2LFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcixcbiAgICBwYWdlLFxuICAgIHZpZXdwb3J0LFxuICAgIHN0cnVjdFRyZWVMYXllclxuICB9KSB7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLiNzdHJ1Y3RUcmVlTGF5ZXIgPSBzdHJ1Y3RUcmVlTGF5ZXIgfHwgbnVsbDtcbiAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgdGhpcy5fYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciA9IGFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI7XG4gIH1cbiAgaGFzRWRpdGFibGVBbm5vdGF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5zaXplID4gMDtcbiAgfVxuICBhc3luYyAjYXBwZW5kRWxlbWVudChlbGVtZW50LCBpZCkge1xuICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gZWxlbWVudC5maXJzdENoaWxkIHx8IGVsZW1lbnQ7XG4gICAgY29uc3QgYW5ub3RhdGlvbklkID0gY29udGVudEVsZW1lbnQuaWQgPSBgJHtBbm5vdGF0aW9uUHJlZml4fSR7aWR9YDtcbiAgICBjb25zdCBhcmlhQXR0cmlidXRlcyA9IGF3YWl0IHRoaXMuI3N0cnVjdFRyZWVMYXllcj8uZ2V0QXJpYUF0dHJpYnV0ZXMoYW5ub3RhdGlvbklkKTtcbiAgICBpZiAoYXJpYUF0dHJpYnV0ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFyaWFBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnRlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kaXYuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlbGVtZW50LCBjb250ZW50RWxlbWVudCwgZmFsc2UpO1xuICB9XG4gIGFzeW5jIHJlbmRlcihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uc1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICBzZXRMYXllckRpbWVuc2lvbnMobGF5ZXIsIHRoaXMudmlld3BvcnQpO1xuICAgIGNvbnN0IHBvcHVwVG9FbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlbGVtZW50UGFyYW1zID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGxheWVyLFxuICAgICAgbGlua1NlcnZpY2U6IHBhcmFtcy5saW5rU2VydmljZSxcbiAgICAgIGRvd25sb2FkTWFuYWdlcjogcGFyYW1zLmRvd25sb2FkTWFuYWdlcixcbiAgICAgIGltYWdlUmVzb3VyY2VzUGF0aDogcGFyYW1zLmltYWdlUmVzb3VyY2VzUGF0aCB8fCBcIlwiLFxuICAgICAgcmVuZGVyRm9ybXM6IHBhcmFtcy5yZW5kZXJGb3JtcyAhPT0gZmFsc2UsXG4gICAgICBzdmdGYWN0b3J5OiBuZXcgRE9NU1ZHRmFjdG9yeSgpLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IHBhcmFtcy5hbm5vdGF0aW9uU3RvcmFnZSB8fCBuZXcgQW5ub3RhdGlvblN0b3JhZ2UoKSxcbiAgICAgIGVuYWJsZVNjcmlwdGluZzogcGFyYW1zLmVuYWJsZVNjcmlwdGluZyA9PT0gdHJ1ZSxcbiAgICAgIGhhc0pTQWN0aW9uczogcGFyYW1zLmhhc0pTQWN0aW9ucyxcbiAgICAgIGZpZWxkT2JqZWN0czogcGFyYW1zLmZpZWxkT2JqZWN0cyxcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGVsZW1lbnRzOiBudWxsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGlmIChkYXRhLm5vSFRNTCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzUG9wdXBBbm5vdGF0aW9uID0gZGF0YS5hbm5vdGF0aW9uVHlwZSA9PT0gQW5ub3RhdGlvblR5cGUuUE9QVVA7XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHRcbiAgICAgICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLmlkKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRQYXJhbXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRQYXJhbXMuZGF0YSA9IGRhdGE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZShlbGVtZW50UGFyYW1zKTtcbiAgICAgIGlmICghZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uICYmIGRhdGEucG9wdXBSZWYpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwb3B1cFRvRWxlbWVudHMuZ2V0KGRhdGEucG9wdXBSZWYpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgcG9wdXBUb0VsZW1lbnRzLnNldChkYXRhLnBvcHVwUmVmLCBbZWxlbWVudF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVkID0gZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICByZW5kZXJlZC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuI2FwcGVuZEVsZW1lbnQocmVuZGVyZWQsIGRhdGEuaWQpO1xuICAgICAgaWYgKGVsZW1lbnQuX2lzRWRpdGFibGUpIHtcbiAgICAgICAgdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5zZXQoZWxlbWVudC5kYXRhLmlkLCBlbGVtZW50KTtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcj8ucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NldEFubm90YXRpb25DYW52YXNNYXAoKTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBzZXRMYXllckRpbWVuc2lvbnMobGF5ZXIsIHtcbiAgICAgIHJvdGF0aW9uOiB2aWV3cG9ydC5yb3RhdGlvblxuICAgIH0pO1xuICAgIHRoaXMuI3NldEFubm90YXRpb25DYW52YXNNYXAoKTtcbiAgICBsYXllci5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICAjc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpIHtcbiAgICBpZiAoIXRoaXMuI2Fubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY2FudmFzXSBvZiB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gbGF5ZXIucXVlcnlTZWxlY3RvcihgW2RhdGEtYW5ub3RhdGlvbi1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjYW52YXMuY2xhc3NOYW1lID0gXCJhbm5vdGF0aW9uQ29udGVudFwiO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaXJzdENoaWxkXG4gICAgICB9ID0gZWxlbWVudDtcbiAgICAgIGlmICghZmlyc3RDaGlsZCkge1xuICAgICAgICBlbGVtZW50LmFwcGVuZChjYW52YXMpO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdENoaWxkLm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQucmVwbGFjZVdpdGgoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZpcnN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYW5ub3RhdGlvbkNvbnRlbnRcIikpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5iZWZvcmUoY2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuYWZ0ZXIoY2FudmFzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcC5jbGVhcigpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy52YWx1ZXMoKSk7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZnJlZXRleHQuanNcblxuXG5cblxuY29uc3QgRU9MX1BBVFRFUk4gPSAvXFxyXFxuP3xcXG4vZztcbmNsYXNzIEZyZWVUZXh0RWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNjb2xvcjtcbiAgI2NvbnRlbnQgPSBcIlwiO1xuICAjZWRpdG9yRGl2SWQgPSBgJHt0aGlzLmlkfS1lZGl0b3JgO1xuICAjZWRpdE1vZGVBQyA9IG51bGw7XG4gICNmb250U2l6ZTtcbiAgc3RhdGljIF9mcmVlVGV4dERlZmF1bHRDb250ZW50ID0gXCJcIjtcbiAgc3RhdGljIF9pbnRlcm5hbFBhZGRpbmcgPSAwO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdEZvbnRTaXplID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEZyZWVUZXh0RWRpdG9yLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHNlbGYuaXNFbXB0eSgpO1xuICAgIGNvbnN0IHNtYWxsID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK3NcIiwgXCJtYWMrbWV0YStzXCIsIFwiY3RybCtwXCIsIFwibWFjK21ldGErcFwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9XSwgW1tcImN0cmwrRW50ZXJcIiwgXCJtYWMrbWV0YStFbnRlclwiLCBcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgc3RhdGljIF90eXBlID0gXCJmcmVldGV4dFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJmcmVlVGV4dEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yO1xuICAgIHRoaXMuI2ZvbnRTaXplID0gcGFyYW1zLmZvbnRTaXplIHx8IEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgdGhpcy5faW50ZXJuYWxQYWRkaW5nID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1mcmVldGV4dC1wYWRkaW5nXCIpKTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjpcbiAgICAgICAgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUZvbnRTaXplKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZV0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCB0aGlzLiNmb250U2l6ZV0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgdGhpcy4jY29sb3JdXTtcbiAgfVxuICAjdXBkYXRlRm9udFNpemUoZm9udFNpemUpIHtcbiAgICBjb25zdCBzZXRGb250c2l6ZSA9IHNpemUgPT4ge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3NpemV9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSgwLCAtKHNpemUgLSB0aGlzLiNmb250U2l6ZSkgKiB0aGlzLnBhcmVudFNjYWxlKTtcbiAgICAgIHRoaXMuI2ZvbnRTaXplID0gc2l6ZTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkRm9udHNpemUgPSB0aGlzLiNmb250U2l6ZTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Rm9udHNpemUuYmluZCh0aGlzLCBmb250U2l6ZSksXG4gICAgICB1bmRvOiBzZXRGb250c2l6ZS5iaW5kKHRoaXMsIHNhdmVkRm9udHNpemUpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yID0gY29sID0+IHtcbiAgICAgIHRoaXMuI2NvbG9yID0gdGhpcy5lZGl0b3JEaXYuc3R5bGUuY29sb3IgPSBjb2w7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZENvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldENvbG9yLmJpbmQodGhpcywgY29sb3IpLFxuICAgICAgdW5kbzogc2V0Q29sb3IuYmluZCh0aGlzLCBzYXZlZENvbG9yKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX3RyYW5zbGF0ZUVtcHR5KHgsIHkpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIudHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIHRydWUpO1xuICB9XG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMucGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIFstRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHNjYWxlLCAtKEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKyB0aGlzLiNmb250U2l6ZSkgKiBzY2FsZV07XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAodGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgIHRoaXMucGFyZW50LnVwZGF0ZVRvb2xiYXIoQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQpO1xuICAgIHN1cGVyLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgdGhpcy4jZWRpdE1vZGVBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jZWRpdE1vZGVBQyk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5lZGl0b3JEaXZLZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmVkaXRvckRpdkZvY3VzLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuZWRpdG9yRGl2Qmx1ci5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5lZGl0b3JEaXZJbnB1dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy5lZGl0b3JEaXZQYXN0ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICBzdXBlci5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgdGhpcy4jZWRpdE1vZGVBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDID0gbnVsbDtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWV0ZXh0RWRpdGluZ1wiKTtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZm9jdXNpbihldmVudCk7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZCgpIHtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0gbnVsbDtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5lZGl0b3JEaXYgfHwgdGhpcy5lZGl0b3JEaXYuaW5uZXJUZXh0LnRyaW0oKSA9PT0gXCJcIjtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZXRleHRFZGl0aW5nXCIpO1xuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICAjZXh0cmFjdFRleHQoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgbGV0IHByZXZDaGlsZCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICBpZiAocHJldkNoaWxkPy5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgY2hpbGQubm9kZU5hbWUgPT09IFwiQlJcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgcHJldkNoaWxkID0gY2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIlxcblwiKTtcbiAgfVxuICAjc2V0RWRpdG9yRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgbGV0IHJlY3Q7XG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZWN0ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudExheWVyLFxuICAgICAgICBkaXZcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2F2ZWREaXNwbGF5ID0gZGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICBjb25zdCBzYXZlZFZpc2liaWxpdHkgPSBkaXYuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlkZGVuXCIpO1xuICAgICAgZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwiaGlkZGVuXCI7XG4gICAgICBjdXJyZW50TGF5ZXIuZGl2LmFwcGVuZCh0aGlzLmRpdik7XG4gICAgICByZWN0ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBzYXZlZERpc3BsYXk7XG4gICAgICBkaXYuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCBzYXZlZFZpc2liaWxpdHkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yb3RhdGlvbiAlIDE4MCA9PT0gdGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCkge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3Qud2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LmhlaWdodCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LndpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5jb21taXQoKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIGNvbnN0IHNhdmVkVGV4dCA9IHRoaXMuI2NvbnRlbnQ7XG4gICAgY29uc3QgbmV3VGV4dCA9IHRoaXMuI2NvbnRlbnQgPSB0aGlzLiNleHRyYWN0VGV4dCgpLnRyaW1FbmQoKTtcbiAgICBpZiAoc2F2ZWRUZXh0ID09PSBuZXdUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNldFRleHQgPSB0ZXh0ID0+IHtcbiAgICAgIHRoaXMuI2NvbnRlbnQgPSB0ZXh0O1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NldENvbnRlbnQoKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZWJ1aWxkKHRoaXMpO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChuZXdUZXh0KTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHNldFRleHQoc2F2ZWRUZXh0KTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gIH1cbiAgc2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbkVkaXRNb2RlKCk7XG4gIH1cbiAgZW50ZXJJbkVkaXRNb2RlKCkge1xuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICB9XG4gIGRibGNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5lbnRlckluRWRpdE1vZGUoKTtcbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kaXYgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBlZGl0b3JEaXZLZXlkb3duKGV2ZW50KSB7XG4gICAgRnJlZVRleHRFZGl0b3IuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICBlZGl0b3JEaXZGb2N1cyhldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgfVxuICBlZGl0b3JEaXZCbHVyKGV2ZW50KSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgfVxuICBlZGl0b3JEaXZJbnB1dChldmVudCkge1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZnJlZXRleHRFZGl0aW5nXCIsIHRoaXMuaXNFbXB0eSgpKTtcbiAgfVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiKTtcbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0ZXh0Ym94XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIsIHRydWUpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLiNlZGl0b3JEaXZJZCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZnJlZS10ZXh0MlwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXR0cnNcIiwgXCJkZWZhdWx0LWNvbnRlbnRcIik7XG4gICAgdGhpcy5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmVkaXRvckRpdjtcbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7dGhpcy4jZm9udFNpemV9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5lZGl0b3JEaXYpO1xuICAgIHRoaXMub3ZlcmxheURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5hZGQoXCJvdmVybGF5XCIsIFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5vdmVybGF5RGl2KTtcbiAgICBiaW5kRXZlbnRzKHRoaXMsIHRoaXMuZGl2LCBbXCJkYmxjbGlja1wiLCBcImtleWRvd25cIl0pO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgICAgIGxldCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgICAgIFt0eCwgdHldID0gdGhpcy5wYWdlVHJhbnNsYXRpb25Ub1NjcmVlbih0eCwgdHkpO1xuICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgICAgIGxldCBwb3NYLCBwb3NZO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgKyB0aGlzLmhlaWdodCAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZIC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gW3R5LCAtdHhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxODA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggLSB0aGlzLndpZHRoICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZIC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gWy10eCwgLXR5XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjcwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVggLSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgKHBvc2l0aW9uWzFdIC0gcGFnZVkgLSB0aGlzLndpZHRoICogcGFnZVdpZHRoKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHksIHR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QXQocG9zWCAqIHBhcmVudFdpZHRoLCBwb3NZICogcGFyZW50SGVpZ2h0LCB0eCwgdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRBdChiYXNlWCAqIHBhcmVudFdpZHRoLCBiYXNlWSAqIHBhcmVudEhlaWdodCwgdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBzdGF0aWMgI2dldE5vZGVDb250ZW50KG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gbm9kZS5ub2RlVmFsdWUgOiBub2RlLmlubmVyVGV4dCkucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcIik7XG4gIH1cbiAgZWRpdG9yRGl2UGFzdGUoZXZlbnQpIHtcbiAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gZXZlbnQuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlc1xuICAgIH0gPSBjbGlwYm9hcmREYXRhO1xuICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEgJiYgdHlwZXNbMF0gPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgcGFzdGUgPSBGcmVlVGV4dEVkaXRvci4jZGVzZXJpYWxpemVDb250ZW50KGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHRcIikgfHwgXCJcIikucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcXG5cIik7XG4gICAgaWYgKCFwYXN0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24ucmFuZ2VDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICBzZWxlY3Rpb24uZGVsZXRlRnJvbURvY3VtZW50KCk7XG4gICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICBpZiAoIXBhc3RlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICByYW5nZS5pbnNlcnROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhc3RlKSk7XG4gICAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICAgIHNlbGVjdGlvbi5jb2xsYXBzZVRvU3RhcnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRDb250YWluZXIsXG4gICAgICBzdGFydE9mZnNldFxuICAgIH0gPSByYW5nZTtcbiAgICBjb25zdCBidWZmZXJCZWZvcmUgPSBbXTtcbiAgICBjb25zdCBidWZmZXJBZnRlciA9IFtdO1xuICAgIGlmIChzdGFydENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHN0YXJ0Q29udGFpbmVyLnBhcmVudEVsZW1lbnQ7XG4gICAgICBidWZmZXJBZnRlci5wdXNoKHN0YXJ0Q29udGFpbmVyLm5vZGVWYWx1ZS5zbGljZShzdGFydE9mZnNldCkucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcIikpO1xuICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IGJ1ZmZlckJlZm9yZTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlckFmdGVyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWZmZXJCZWZvcmUucHVzaChzdGFydENvbnRhaW5lci5ub2RlVmFsdWUuc2xpY2UoMCwgc3RhcnRPZmZzZXQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0Q29udGFpbmVyID09PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgbGV0IGJ1ZmZlciA9IGJ1ZmZlckJlZm9yZTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAoaSsrID09PSBzdGFydE9mZnNldCkge1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlckFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb250ZW50ID0gYCR7YnVmZmVyQmVmb3JlLmpvaW4oXCJcXG5cIil9JHtwYXN0ZX0ke2J1ZmZlckFmdGVyLmpvaW4oXCJcXG5cIil9YDtcbiAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgICBsZXQgYmVmb3JlTGVuZ3RoID0gYnVmZmVyQmVmb3JlLnJlZHVjZSgoYWNjLCBsaW5lKSA9PiBhY2MgKyBsaW5lLmxlbmd0aCwgMCk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBmaXJzdENoaWxkXG4gICAgfSBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICBpZiAoZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZmlyc3RDaGlsZC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAoYmVmb3JlTGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgICAgIG5ld1JhbmdlLnNldFN0YXJ0KGZpcnN0Q2hpbGQsIGJlZm9yZUxlbmd0aCk7XG4gICAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kKGZpcnN0Q2hpbGQsIGJlZm9yZUxlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYmVmb3JlTGVuZ3RoIC09IGxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbGVjdGlvbi5hZGRSYW5nZShuZXdSYW5nZSk7XG4gIH1cbiAgI3NldENvbnRlbnQoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgaWYgKCF0aGlzLiNjb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLiNjb250ZW50LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZChsaW5lID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuYXBwZW5kKGRpdik7XG4gICAgfVxuICB9XG4gICNzZXJpYWxpemVDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNjb250ZW50LnJlcGxhY2VBbGwoXCJcXHhhMFwiLCBcIiBcIik7XG4gIH1cbiAgc3RhdGljICNkZXNlcmlhbGl6ZUNvbnRlbnQoY29udGVudCkge1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2VBbGwoXCIgXCIsIFwiXFx4YTBcIik7XG4gIH1cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yRGl2O1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkZWZhdWx0QXBwZWFyYW5jZURhdGE6IHtcbiAgICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgICAgZm9udENvbG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBvcHVwUmVmXG4gICAgICAgIH0sXG4gICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaWYgKCF0ZXh0Q29udGVudCB8fCB0ZXh0Q29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oZm9udENvbG9yKSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIHZhbHVlOiB0ZXh0Q29udGVudC5qb2luKFwiXFxuXCIpLFxuICAgICAgICBwb3NpdGlvbjogdGV4dFBvc2l0aW9uLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci4jZm9udFNpemUgPSBkYXRhLmZvbnRTaXplO1xuICAgIGVkaXRvci4jY29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5kYXRhLmNvbG9yKTtcbiAgICBlZGl0b3IuI2NvbnRlbnQgPSBGcmVlVGV4dEVkaXRvci4jZGVzZXJpYWxpemVDb250ZW50KGRhdGEudmFsdWUpO1xuICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZGF0YS5pZCB8fCBudWxsO1xuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFJlY3QocGFkZGluZywgcGFkZGluZyk7XG4gICAgY29uc3QgY29sb3IgPSBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLmlzQXR0YWNoZWRUb0RPTSA/IGdldENvbXB1dGVkU3R5bGUodGhpcy5lZGl0b3JEaXYpLmNvbG9yIDogdGhpcy4jY29sb3IpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICBjb2xvcixcbiAgICAgIGZvbnRTaXplOiB0aGlzLiNmb250U2l6ZSxcbiAgICAgIHZhbHVlOiB0aGlzLiNzZXJpYWxpemVDb250ZW50KCksXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgY29sb3IsXG4gICAgICBwYWdlSW5kZXhcbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIHRoaXMuX2hhc0JlZW5Nb3ZlZCB8fCBzZXJpYWxpemVkLnZhbHVlICE9PSB2YWx1ZSB8fCBzZXJpYWxpemVkLmZvbnRTaXplICE9PSBmb250U2l6ZSB8fCBzZXJpYWxpemVkLmNvbG9yLnNvbWUoKGMsIGkpID0+IGMgIT09IGNvbG9yW2ldKSB8fCBzZXJpYWxpemVkLnBhZ2VJbmRleCAhPT0gcGFnZUluZGV4O1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCBjb250ZW50ID0gc3VwZXIucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGNvbnRlbnQ7XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgY29udGVudC5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmQobGluZSA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIGNvbnRlbnQuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSBGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogdGhpcy5wYXJlbnRTY2FsZTtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFJlY3QocGFkZGluZywgcGFkZGluZyksXG4gICAgICBwb3B1cENvbnRlbnQ6IHRoaXMuI2NvbnRlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICByZXNldEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBzdXBlci5yZXNldEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pO1xuICAgIGFubm90YXRpb24ucmVzZXRFZGl0ZWQoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9vdXRsaW5lLmpzXG5cbmNsYXNzIE91dGxpbmUge1xuICB0b1NWR1BhdGgoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYHRvU1ZHUGF0aGAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IGdldHRlciBgYm94YCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBzZXJpYWxpemUoX2Jib3gsIF9yb3RhdGlvbikge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBzZXJpYWxpemVgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yRHJhd2luZygpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IGdldHRlciBgY2xhc3NOYW1lc0ZvckRyYXdpbmdgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yT3V0bGluaW5nKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgZ2V0dGVyIGBjbGFzc05hbWVzRm9yT3V0bGluaW5nYCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBnZXQgbXVzdFJlbW92ZVNlbGZJbnRlcnNlY3Rpb25zKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9mcmVlZHJhdy5qc1xuXG5cbmNsYXNzIEZyZWVEcmF3T3V0bGluZXIge1xuICAjYm94O1xuICAjYm90dG9tID0gW107XG4gICNpbm5lck1hcmdpbjtcbiAgI2lzTFRSO1xuICAjdG9wID0gW107XG4gICNsYXN0ID0gbmV3IEZsb2F0NjRBcnJheSgxOCk7XG4gICNsYXN0WDtcbiAgI2xhc3RZO1xuICAjbWluO1xuICAjbWluX2Rpc3Q7XG4gICNzY2FsZUZhY3RvcjtcbiAgI3RoaWNrbmVzcztcbiAgI3BvaW50cyA9IFtdO1xuICBzdGF0aWMgI01JTl9ESVNUID0gODtcbiAgc3RhdGljICNNSU5fRElGRiA9IDI7XG4gIHN0YXRpYyAjTUlOID0gRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJU1QgKyBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElGRjtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHgsXG4gICAgeVxuICB9LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzICogc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jaXNMVFIgPSBpc0xUUjtcbiAgICB0aGlzLiNsYXN0LnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5XSwgNik7XG4gICAgdGhpcy4jaW5uZXJNYXJnaW4gPSBpbm5lck1hcmdpbjtcbiAgICB0aGlzLiNtaW5fZGlzdCA9IEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESVNUICogc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jbWluID0gRnJlZURyYXdPdXRsaW5lci4jTUlOICogc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNwb2ludHMucHVzaCh4LCB5KTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBpc05hTih0aGlzLiNsYXN0WzhdKTtcbiAgfVxuICAjZ2V0TGFzdENvb3JkcygpIHtcbiAgICBjb25zdCBsYXN0VG9wID0gdGhpcy4jbGFzdC5zdWJhcnJheSg0LCA2KTtcbiAgICBjb25zdCBsYXN0Qm90dG9tID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNiwgMTgpO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICByZXR1cm4gWyh0aGlzLiNsYXN0WCArIChsYXN0VG9wWzBdIC0gbGFzdEJvdHRvbVswXSkgLyAyIC0geCkgLyB3aWR0aCwgKHRoaXMuI2xhc3RZICsgKGxhc3RUb3BbMV0gLSBsYXN0Qm90dG9tWzFdKSAvIDIgLSB5KSAvIGhlaWdodCwgKHRoaXMuI2xhc3RYICsgKGxhc3RCb3R0b21bMF0gLSBsYXN0VG9wWzBdKSAvIDIgLSB4KSAvIHdpZHRoLCAodGhpcy4jbGFzdFkgKyAobGFzdEJvdHRvbVsxXSAtIGxhc3RUb3BbMV0pIC8gMiAtIHkpIC8gaGVpZ2h0XTtcbiAgfVxuICBhZGQoe1xuICAgIHgsXG4gICAgeVxuICB9KSB7XG4gICAgdGhpcy4jbGFzdFggPSB4O1xuICAgIHRoaXMuI2xhc3RZID0geTtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBsZXQgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoOCwgMTIpO1xuICAgIGNvbnN0IGRpZmZYID0geCAtIHgyO1xuICAgIGNvbnN0IGRpZmZZID0geSAtIHkyO1xuICAgIGNvbnN0IGQgPSBNYXRoLmh5cG90KGRpZmZYLCBkaWZmWSk7XG4gICAgaWYgKGQgPCB0aGlzLiNtaW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZGlmZkQgPSBkIC0gdGhpcy4jbWluX2Rpc3Q7XG4gICAgY29uc3QgSyA9IGRpZmZEIC8gZDtcbiAgICBjb25zdCBzaGlmdFggPSBLICogZGlmZlg7XG4gICAgY29uc3Qgc2hpZnRZID0gSyAqIGRpZmZZO1xuICAgIGxldCB4MCA9IHgxO1xuICAgIGxldCB5MCA9IHkxO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgICB4MiArPSBzaGlmdFg7XG4gICAgeTIgKz0gc2hpZnRZO1xuICAgIHRoaXMuI3BvaW50cz8ucHVzaCh4LCB5KTtcbiAgICBjb25zdCBuWCA9IC1zaGlmdFkgLyBkaWZmRDtcbiAgICBjb25zdCBuWSA9IHNoaWZ0WCAvIGRpZmZEO1xuICAgIGNvbnN0IHRoWCA9IG5YICogdGhpcy4jdGhpY2tuZXNzO1xuICAgIGNvbnN0IHRoWSA9IG5ZICogdGhpcy4jdGhpY2tuZXNzO1xuICAgIHRoaXMuI2xhc3Quc2V0KHRoaXMuI2xhc3Quc3ViYXJyYXkoMiwgOCksIDApO1xuICAgIHRoaXMuI2xhc3Quc2V0KFt4MiArIHRoWCwgeTIgKyB0aFldLCA0KTtcbiAgICB0aGlzLiNsYXN0LnNldCh0aGlzLiNsYXN0LnN1YmFycmF5KDE0LCAxOCksIDEyKTtcbiAgICB0aGlzLiNsYXN0LnNldChbeDIgLSB0aFgsIHkyIC0gdGhZXSwgMTYpO1xuICAgIGlmIChpc05hTih0aGlzLiNsYXN0WzZdKSkge1xuICAgICAgaWYgKHRoaXMuI3RvcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy4jbGFzdC5zZXQoW3gxICsgdGhYLCB5MSArIHRoWV0sIDIpO1xuICAgICAgICB0aGlzLiN0b3AucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICh4MSArIHRoWCAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoeTEgKyB0aFkgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgICB0aGlzLiNsYXN0LnNldChbeDEgLSB0aFgsIHkxIC0gdGhZXSwgMTQpO1xuICAgICAgICB0aGlzLiNib3R0b20ucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICh4MSAtIHRoWCAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoeTEgLSB0aFkgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jbGFzdC5zZXQoW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdLCA2KTtcbiAgICAgIHJldHVybiAhdGhpcy5pc0VtcHR5KCk7XG4gICAgfVxuICAgIHRoaXMuI2xhc3Quc2V0KFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXSwgNik7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHkwIC0geTEsIHgwIC0geDEpIC0gTWF0aC5hdGFuMihzaGlmdFksIHNoaWZ0WCkpO1xuICAgIGlmIChhbmdsZSA8IE1hdGguUEkgLyAyKSB7XG4gICAgICBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgyLCA2KTtcbiAgICAgIHRoaXMuI3RvcC5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKCh4MSArIHgyKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MSArIHkyKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgW3gxLCB5MSwgeDAsIHkwXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTQsIDE4KTtcbiAgICAgIHRoaXMuI2JvdHRvbS5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKCh4MCArIHgxKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MCArIHkxKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMCwgNik7XG4gICAgdGhpcy4jdG9wLnB1c2goKCh4MCArIDUgKiB4MSkgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyA1ICogeTEpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCg1ICogeDEgKyB4MikgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoNSAqIHkxICsgeTIpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCh4MSArIHgyKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MSArIHkyKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgIFt4MiwgeTIsIHgxLCB5MSwgeDAsIHkwXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTIsIDE4KTtcbiAgICB0aGlzLiNib3R0b20ucHVzaCgoKHgwICsgNSAqIHgxKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MCArIDUgKiB5MSkgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKDUgKiB4MSArIHgyKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCg1ICogeTEgKyB5MikgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHRvcCA9IHRoaXMuI3RvcDtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbNl0pICYmICF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI3RvU1ZHUGF0aFR3b1BvaW50cygpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBidWZmZXIucHVzaChgTSR7dG9wWzRdfSAke3RvcFs1XX1gKTtcbiAgICBmb3IgKGxldCBpID0gNjsgaSA8IHRvcC5sZW5ndGg7IGkgKz0gNikge1xuICAgICAgaWYgKGlzTmFOKHRvcFtpXSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke3RvcFtpICsgNF19ICR7dG9wW2kgKyA1XX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHt0b3BbaV19ICR7dG9wW2kgKyAxXX0gJHt0b3BbaSArIDJdfSAke3RvcFtpICsgM119ICR7dG9wW2kgKyA0XX0gJHt0b3BbaSArIDVdfWApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN0b1NWR1BhdGhFbmQoYnVmZmVyKTtcbiAgICBmb3IgKGxldCBpID0gYm90dG9tLmxlbmd0aCAtIDY7IGkgPj0gNjsgaSAtPSA2KSB7XG4gICAgICBpZiAoaXNOYU4oYm90dG9tW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7Ym90dG9tW2kgKyA0XX0gJHtib3R0b21baSArIDVdfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke2JvdHRvbVtpXX0gJHtib3R0b21baSArIDFdfSAke2JvdHRvbVtpICsgMl19ICR7Ym90dG9tW2kgKyAzXX0gJHtib3R0b21baSArIDRdfSAke2JvdHRvbVtpICsgNV19YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3RvU1ZHUGF0aFN0YXJ0KGJ1ZmZlcik7XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICAjdG9TVkdQYXRoVHdvUG9pbnRzKCkge1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIHJldHVybiBgTSR7KHRoaXMuI2xhc3RbMl0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzNdIC0geSkgLyBoZWlnaHR9IEwkeyh0aGlzLiNsYXN0WzRdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFs1XSAtIHkpIC8gaGVpZ2h0fSBMJHtsYXN0VG9wWH0gJHtsYXN0VG9wWX0gTCR7bGFzdEJvdHRvbVh9ICR7bGFzdEJvdHRvbVl9IEwkeyh0aGlzLiNsYXN0WzE2XSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbMTddIC0geSkgLyBoZWlnaHR9IEwkeyh0aGlzLiNsYXN0WzE0XSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbMTVdIC0geSkgLyBoZWlnaHR9IFpgO1xuICB9XG4gICN0b1NWR1BhdGhTdGFydChidWZmZXIpIHtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgYnVmZmVyLnB1c2goYEwke2JvdHRvbVs0XX0gJHtib3R0b21bNV19IFpgKTtcbiAgfVxuICAjdG9TVkdQYXRoRW5kKGJ1ZmZlcikge1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBsYXN0VG9wID0gdGhpcy4jbGFzdC5zdWJhcnJheSg0LCA2KTtcbiAgICBjb25zdCBsYXN0Qm90dG9tID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNiwgMTgpO1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgYnVmZmVyLnB1c2goYEwkeyhsYXN0VG9wWzBdIC0geCkgLyB3aWR0aH0gJHsobGFzdFRvcFsxXSAtIHkpIC8gaGVpZ2h0fSBMJHtsYXN0VG9wWH0gJHtsYXN0VG9wWX0gTCR7bGFzdEJvdHRvbVh9ICR7bGFzdEJvdHRvbVl9IEwkeyhsYXN0Qm90dG9tWzBdIC0geCkgLyB3aWR0aH0gJHsobGFzdEJvdHRvbVsxXSAtIHkpIC8gaGVpZ2h0fWApO1xuICB9XG4gIG5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUikge1xuICAgIHJldHVybiBuZXcgRnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKTtcbiAgfVxuICBnZXRPdXRsaW5lcygpIHtcbiAgICBjb25zdCB0b3AgPSB0aGlzLiN0b3A7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsYXN0O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IHBvaW50cyA9IG5ldyBGbG9hdDY0QXJyYXkoKHRoaXMuI3BvaW50cz8ubGVuZ3RoID8/IDApICsgMik7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aCAtIDI7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBwb2ludHNbaV0gPSAodGhpcy4jcG9pbnRzW2ldIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGg7XG4gICAgICBwb2ludHNbaSArIDFdID0gKHRoaXMuI3BvaW50c1tpICsgMV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQ7XG4gICAgfVxuICAgIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gPSAodGhpcy4jbGFzdFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aDtcbiAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdID0gKHRoaXMuI2xhc3RZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0O1xuICAgIGlmIChpc05hTihsYXN0WzZdKSAmJiAhdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLiNnZXRPdXRsaW5lVHdvUG9pbnRzKHBvaW50cyk7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmUgPSBuZXcgRmxvYXQ2NEFycmF5KHRoaXMuI3RvcC5sZW5ndGggKyAyNCArIHRoaXMuI2JvdHRvbS5sZW5ndGgpO1xuICAgIGxldCBOID0gdG9wLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkgKz0gMikge1xuICAgICAgaWYgKGlzTmFOKHRvcFtpXSkpIHtcbiAgICAgICAgb3V0bGluZVtpXSA9IG91dGxpbmVbaSArIDFdID0gTmFOO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG91dGxpbmVbaV0gPSB0b3BbaV07XG4gICAgICBvdXRsaW5lW2kgKyAxXSA9IHRvcFtpICsgMV07XG4gICAgfVxuICAgIE4gPSB0aGlzLiNnZXRPdXRsaW5lRW5kKG91dGxpbmUsIE4pO1xuICAgIGZvciAobGV0IGkgPSBib3R0b20ubGVuZ3RoIC0gNjsgaSA+PSA2OyBpIC09IDYpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjsgaiArPSAyKSB7XG4gICAgICAgIGlmIChpc05hTihib3R0b21baSArIGpdKSkge1xuICAgICAgICAgIG91dGxpbmVbTl0gPSBvdXRsaW5lW04gKyAxXSA9IE5hTjtcbiAgICAgICAgICBOICs9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0bGluZVtOXSA9IGJvdHRvbVtpICsgal07XG4gICAgICAgIG91dGxpbmVbTiArIDFdID0gYm90dG9tW2kgKyBqICsgMV07XG4gICAgICAgIE4gKz0gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jZ2V0T3V0bGluZVN0YXJ0KG91dGxpbmUsIE4pO1xuICAgIHJldHVybiB0aGlzLm5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIHRoaXMuI2JveCwgdGhpcy4jc2NhbGVGYWN0b3IsIHRoaXMuI2lubmVyTWFyZ2luLCB0aGlzLiNpc0xUUik7XG4gIH1cbiAgI2dldE91dGxpbmVUd29Qb2ludHMocG9pbnRzKSB7XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xhc3Q7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBjb25zdCBvdXRsaW5lID0gbmV3IEZsb2F0NjRBcnJheSgzNik7XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMl0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbM10gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbNF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbNV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdFRvcFgsIGxhc3RUb3BZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsxNl0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbMTddIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzE0XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFsxNV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHRdLCAwKTtcbiAgICByZXR1cm4gdGhpcy5uZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlzLiNpbm5lck1hcmdpbiwgdGhpcy4jaXNMVFIpO1xuICB9XG4gICNnZXRPdXRsaW5lU3RhcnQob3V0bGluZSwgcG9zKSB7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIG91dGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIGJvdHRvbVs0XSwgYm90dG9tWzVdXSwgcG9zKTtcbiAgICByZXR1cm4gcG9zICs9IDY7XG4gIH1cbiAgI2dldE91dGxpbmVFbmQob3V0bGluZSwgcG9zKSB7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIG91dGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0VG9wWzBdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0VG9wWzFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RUb3BYLCBsYXN0VG9wWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVksIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RCb3R0b21bMF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RCb3R0b21bMV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHRdLCBwb3MpO1xuICAgIHJldHVybiBwb3MgKz0gMjQ7XG4gIH1cbn1cbmNsYXNzIEZyZWVEcmF3T3V0bGluZSBleHRlbmRzIE91dGxpbmUge1xuICAjYm94O1xuICAjYmJveCA9IG51bGw7XG4gICNpbm5lck1hcmdpbjtcbiAgI2lzTFRSO1xuICAjcG9pbnRzO1xuICAjc2NhbGVGYWN0b3I7XG4gICNvdXRsaW5lO1xuICBjb25zdHJ1Y3RvcihvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jb3V0bGluZSA9IG91dGxpbmU7XG4gICAgdGhpcy4jcG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLiNzY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW47XG4gICAgdGhpcy4jaXNMVFIgPSBpc0xUUjtcbiAgICB0aGlzLiNjb21wdXRlTWluTWF4KGlzTFRSKTtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2Jib3g7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3V0bGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBvdXRsaW5lW2ldID0gKG91dGxpbmVbaV0gLSB4KSAvIHdpZHRoO1xuICAgICAgb3V0bGluZVtpICsgMV0gPSAob3V0bGluZVtpICsgMV0gLSB5KSAvIGhlaWdodDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIHBvaW50c1tpXSA9IChwb2ludHNbaV0gLSB4KSAvIHdpZHRoO1xuICAgICAgcG9pbnRzW2kgKyAxXSA9IChwb2ludHNbaSArIDFdIC0geSkgLyBoZWlnaHQ7XG4gICAgfVxuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbYE0ke3RoaXMuI291dGxpbmVbNF19ICR7dGhpcy4jb3V0bGluZVs1XX1gXTtcbiAgICBmb3IgKGxldCBpID0gNiwgaWkgPSB0aGlzLiNvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTih0aGlzLiNvdXRsaW5lW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7dGhpcy4jb3V0bGluZVtpICsgNF19ICR7dGhpcy4jb3V0bGluZVtpICsgNV19YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goYEMke3RoaXMuI291dGxpbmVbaV19ICR7dGhpcy4jb3V0bGluZVtpICsgMV19ICR7dGhpcy4jb3V0bGluZVtpICsgMl19ICR7dGhpcy4jb3V0bGluZVtpICsgM119ICR7dGhpcy4jb3V0bGluZVtpICsgNF19ICR7dGhpcy4jb3V0bGluZVtpICsgNV19YCk7XG4gICAgfVxuICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgcm90YXRpb24pIHtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgbGV0IG91dGxpbmU7XG4gICAgbGV0IHBvaW50cztcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIG91dGxpbmUgPSB0aGlzLiNyZXNjYWxlKHRoaXMuI291dGxpbmUsIGJsWCwgdHJZLCB3aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IHRoaXMuI3Jlc2NhbGUodGhpcy4jcG9pbnRzLCBibFgsIHRyWSwgd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIG91dGxpbmUgPSB0aGlzLiNyZXNjYWxlQW5kU3dhcCh0aGlzLiNvdXRsaW5lLCBibFgsIGJsWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IHRoaXMuI3Jlc2NhbGVBbmRTd2FwKHRoaXMuI3BvaW50cywgYmxYLCBibFksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBvdXRsaW5lID0gdGhpcy4jcmVzY2FsZSh0aGlzLiNvdXRsaW5lLCB0clgsIGJsWSwgLXdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSB0aGlzLiNyZXNjYWxlKHRoaXMuI3BvaW50cywgdHJYLCBibFksIC13aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgb3V0bGluZSA9IHRoaXMuI3Jlc2NhbGVBbmRTd2FwKHRoaXMuI291dGxpbmUsIHRyWCwgdHJZLCAtd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSB0aGlzLiNyZXNjYWxlQW5kU3dhcCh0aGlzLiNwb2ludHMsIHRyWCwgdHJZLCAtd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGxpbmU6IEFycmF5LmZyb20ob3V0bGluZSksXG4gICAgICBwb2ludHM6IFtBcnJheS5mcm9tKHBvaW50cyldXG4gICAgfTtcbiAgfVxuICAjcmVzY2FsZShzcmMsIHR4LCB0eSwgc3gsIHN5KSB7XG4gICAgY29uc3QgZGVzdCA9IG5ldyBGbG9hdDY0QXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGRlc3RbaV0gPSB0eCArIHNyY1tpXSAqIHN4O1xuICAgICAgZGVzdFtpICsgMV0gPSB0eSArIHNyY1tpICsgMV0gKiBzeTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgI3Jlc2NhbGVBbmRTd2FwKHNyYywgdHgsIHR5LCBzeCwgc3kpIHtcbiAgICBjb25zdCBkZXN0ID0gbmV3IEZsb2F0NjRBcnJheShzcmMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgZGVzdFtpXSA9IHR4ICsgc3JjW2kgKyAxXSAqIHN4O1xuICAgICAgZGVzdFtpICsgMV0gPSB0eSArIHNyY1tpXSAqIHN5O1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICAjY29tcHV0ZU1pbk1heChpc0xUUikge1xuICAgIGNvbnN0IG91dGxpbmUgPSB0aGlzLiNvdXRsaW5lO1xuICAgIGxldCBsYXN0WCA9IG91dGxpbmVbNF07XG4gICAgbGV0IGxhc3RZID0gb3V0bGluZVs1XTtcbiAgICBsZXQgbWluWCA9IGxhc3RYO1xuICAgIGxldCBtaW5ZID0gbGFzdFk7XG4gICAgbGV0IG1heFggPSBsYXN0WDtcbiAgICBsZXQgbWF4WSA9IGxhc3RZO1xuICAgIGxldCBsYXN0UG9pbnRYID0gbGFzdFg7XG4gICAgbGV0IGxhc3RQb2ludFkgPSBsYXN0WTtcbiAgICBjb25zdCBsdHJDYWxsYmFjayA9IGlzTFRSID8gTWF0aC5tYXggOiBNYXRoLm1pbjtcbiAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTihvdXRsaW5lW2ldKSkge1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgb3V0bGluZVtpICsgNF0pO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgb3V0bGluZVtpICsgNV0pO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgb3V0bGluZVtpICsgNF0pO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgb3V0bGluZVtpICsgNV0pO1xuICAgICAgICBpZiAobGFzdFBvaW50WSA8IG91dGxpbmVbaSArIDVdKSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IG91dGxpbmVbaSArIDRdO1xuICAgICAgICAgIGxhc3RQb2ludFkgPSBvdXRsaW5lW2kgKyA1XTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UG9pbnRZID09PSBvdXRsaW5lW2kgKyA1XSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCBvdXRsaW5lW2kgKyA0XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBVdGlsLmJlemllckJvdW5kaW5nQm94KGxhc3RYLCBsYXN0WSwgLi4ub3V0bGluZS5zbGljZShpLCBpICsgNikpO1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgYmJveFswXSk7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBiYm94WzFdKTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGJib3hbMl0pO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgYmJveFszXSk7XG4gICAgICAgIGlmIChsYXN0UG9pbnRZIDwgYmJveFszXSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBiYm94WzJdO1xuICAgICAgICAgIGxhc3RQb2ludFkgPSBiYm94WzNdO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQb2ludFkgPT09IGJib3hbM10pIHtcbiAgICAgICAgICBsYXN0UG9pbnRYID0gbHRyQ2FsbGJhY2sobGFzdFBvaW50WCwgYmJveFsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RYID0gb3V0bGluZVtpICsgNF07XG4gICAgICBsYXN0WSA9IG91dGxpbmVbaSArIDVdO1xuICAgIH1cbiAgICBjb25zdCB4ID0gbWluWCAtIHRoaXMuI2lubmVyTWFyZ2luLFxuICAgICAgeSA9IG1pblkgLSB0aGlzLiNpbm5lck1hcmdpbixcbiAgICAgIHdpZHRoID0gbWF4WCAtIG1pblggKyAyICogdGhpcy4jaW5uZXJNYXJnaW4sXG4gICAgICBoZWlnaHQgPSBtYXhZIC0gbWluWSArIDIgKiB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICB0aGlzLiNiYm94ID0ge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxhc3RQb2ludDogW2xhc3RQb2ludFgsIGxhc3RQb2ludFldXG4gICAgfTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94O1xuICB9XG4gIG5ld091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luKTtcbiAgfVxuICBnZXROZXdPdXRsaW5lKHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2Jib3g7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3Qgc3ggPSB3aWR0aCAqIGxheWVyV2lkdGg7XG4gICAgY29uc3Qgc3kgPSBoZWlnaHQgKiBsYXllckhlaWdodDtcbiAgICBjb25zdCB0eCA9IHggKiBsYXllcldpZHRoICsgbGF5ZXJYO1xuICAgIGNvbnN0IHR5ID0geSAqIGxheWVySGVpZ2h0ICsgbGF5ZXJZO1xuICAgIGNvbnN0IG91dGxpbmVyID0gdGhpcy5uZXdPdXRsaW5lcih7XG4gICAgICB4OiB0aGlzLiNwb2ludHNbMF0gKiBzeCArIHR4LFxuICAgICAgeTogdGhpcy4jcG9pbnRzWzFdICogc3kgKyB0eVxuICAgIH0sIHRoaXMuI2JveCwgdGhpcy4jc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgdGhpcy4jaXNMVFIsIGlubmVyTWFyZ2luID8/IHRoaXMuI2lubmVyTWFyZ2luKTtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IHRoaXMuI3BvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgb3V0bGluZXIuYWRkKHtcbiAgICAgICAgeDogdGhpcy4jcG9pbnRzW2ldICogc3ggKyB0eCxcbiAgICAgICAgeTogdGhpcy4jcG9pbnRzW2kgKyAxXSAqIHN5ICsgdHlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0bGluZXIuZ2V0T3V0bGluZXMoKTtcbiAgfVxuICBnZXQgbXVzdFJlbW92ZVNlbGZJbnRlcnNlY3Rpb25zKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL2hpZ2hsaWdodC5qc1xuXG5cbmNsYXNzIEhpZ2hsaWdodE91dGxpbmVyIHtcbiAgI2JveDtcbiAgI3ZlcnRpY2FsRWRnZXMgPSBbXTtcbiAgI2ludGVydmFscyA9IFtdO1xuICBjb25zdHJ1Y3Rvcihib3hlcywgYm9yZGVyV2lkdGggPSAwLCBpbm5lck1hcmdpbiA9IDAsIGlzTFRSID0gdHJ1ZSkge1xuICAgIGxldCBtaW5YID0gSW5maW5pdHk7XG4gICAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gICAgbGV0IG1pblkgPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcbiAgICBjb25zdCBOVU1CRVJfT0ZfRElHSVRTID0gNDtcbiAgICBjb25zdCBFUFNJTE9OID0gMTAgKiogLU5VTUJFUl9PRl9ESUdJVFM7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSBvZiBib3hlcykge1xuICAgICAgY29uc3QgeDEgPSBNYXRoLmZsb29yKCh4IC0gYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeDIgPSBNYXRoLmNlaWwoKHggKyB3aWR0aCArIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IHkxID0gTWF0aC5mbG9vcigoeSAtIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IHkyID0gTWF0aC5jZWlsKCh5ICsgaGVpZ2h0ICsgYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgbGVmdCA9IFt4MSwgeTEsIHkyLCB0cnVlXTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gW3gyLCB5MSwgeTIsIGZhbHNlXTtcbiAgICAgIHRoaXMuI3ZlcnRpY2FsRWRnZXMucHVzaChsZWZ0LCByaWdodCk7XG4gICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeDEpO1xuICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgyKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5MSk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeTIpO1xuICAgIH1cbiAgICBjb25zdCBiYm94V2lkdGggPSBtYXhYIC0gbWluWCArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0gbWF4WSAtIG1pblkgKyAyICogaW5uZXJNYXJnaW47XG4gICAgY29uc3Qgc2hpZnRlZE1pblggPSBtaW5YIC0gaW5uZXJNYXJnaW47XG4gICAgY29uc3Qgc2hpZnRlZE1pblkgPSBtaW5ZIC0gaW5uZXJNYXJnaW47XG4gICAgY29uc3QgbGFzdEVkZ2UgPSB0aGlzLiN2ZXJ0aWNhbEVkZ2VzLmF0KGlzTFRSID8gLTEgOiAtMik7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gW2xhc3RFZGdlWzBdLCBsYXN0RWRnZVsyXV07XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuI3ZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGNvbnN0IFt4LCB5MSwgeTJdID0gZWRnZTtcbiAgICAgIGVkZ2VbMF0gPSAoeCAtIHNoaWZ0ZWRNaW5YKSAvIGJib3hXaWR0aDtcbiAgICAgIGVkZ2VbMV0gPSAoeTEgLSBzaGlmdGVkTWluWSkgLyBiYm94SGVpZ2h0O1xuICAgICAgZWRnZVsyXSA9ICh5MiAtIHNoaWZ0ZWRNaW5ZKSAvIGJib3hIZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuI2JveCA9IHtcbiAgICAgIHg6IHNoaWZ0ZWRNaW5YLFxuICAgICAgeTogc2hpZnRlZE1pblksXG4gICAgICB3aWR0aDogYmJveFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiYm94SGVpZ2h0LFxuICAgICAgbGFzdFBvaW50XG4gICAgfTtcbiAgfVxuICBnZXRPdXRsaW5lcygpIHtcbiAgICB0aGlzLiN2ZXJ0aWNhbEVkZ2VzLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdIHx8IGFbMl0gLSBiWzJdKTtcbiAgICBjb25zdCBvdXRsaW5lVmVydGljYWxFZGdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiB0aGlzLiN2ZXJ0aWNhbEVkZ2VzKSB7XG4gICAgICBpZiAoZWRnZVszXSkge1xuICAgICAgICBvdXRsaW5lVmVydGljYWxFZGdlcy5wdXNoKC4uLnRoaXMuI2JyZWFrRWRnZShlZGdlKSk7XG4gICAgICAgIHRoaXMuI2luc2VydChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI3JlbW92ZShlZGdlKTtcbiAgICAgICAgb3V0bGluZVZlcnRpY2FsRWRnZXMucHVzaCguLi50aGlzLiNicmVha0VkZ2UoZWRnZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jZ2V0T3V0bGluZXMob3V0bGluZVZlcnRpY2FsRWRnZXMpO1xuICB9XG4gICNnZXRPdXRsaW5lcyhvdXRsaW5lVmVydGljYWxFZGdlcykge1xuICAgIGNvbnN0IGVkZ2VzID0gW107XG4gICAgY29uc3QgYWxsRWRnZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIG91dGxpbmVWZXJ0aWNhbEVkZ2VzKSB7XG4gICAgICBjb25zdCBbeCwgeTEsIHkyXSA9IGVkZ2U7XG4gICAgICBlZGdlcy5wdXNoKFt4LCB5MSwgZWRnZV0sIFt4LCB5MiwgZWRnZV0pO1xuICAgIH1cbiAgICBlZGdlcy5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSB8fCBhWzBdIC0gYlswXSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZWRnZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgZWRnZTEgPSBlZGdlc1tpXVsyXTtcbiAgICAgIGNvbnN0IGVkZ2UyID0gZWRnZXNbaSArIDFdWzJdO1xuICAgICAgZWRnZTEucHVzaChlZGdlMik7XG4gICAgICBlZGdlMi5wdXNoKGVkZ2UxKTtcbiAgICAgIGFsbEVkZ2VzLmFkZChlZGdlMSk7XG4gICAgICBhbGxFZGdlcy5hZGQoZWRnZTIpO1xuICAgIH1cbiAgICBjb25zdCBvdXRsaW5lcyA9IFtdO1xuICAgIGxldCBvdXRsaW5lO1xuICAgIHdoaWxlIChhbGxFZGdlcy5zaXplID4gMCkge1xuICAgICAgY29uc3QgZWRnZSA9IGFsbEVkZ2VzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgIGxldCBbeCwgeTEsIHkyLCBlZGdlMSwgZWRnZTJdID0gZWRnZTtcbiAgICAgIGFsbEVkZ2VzLmRlbGV0ZShlZGdlKTtcbiAgICAgIGxldCBsYXN0UG9pbnRYID0geDtcbiAgICAgIGxldCBsYXN0UG9pbnRZID0geTE7XG4gICAgICBvdXRsaW5lID0gW3gsIHkyXTtcbiAgICAgIG91dGxpbmVzLnB1c2gob3V0bGluZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgZTtcbiAgICAgICAgaWYgKGFsbEVkZ2VzLmhhcyhlZGdlMSkpIHtcbiAgICAgICAgICBlID0gZWRnZTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsRWRnZXMuaGFzKGVkZ2UyKSkge1xuICAgICAgICAgIGUgPSBlZGdlMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhbGxFZGdlcy5kZWxldGUoZSk7XG4gICAgICAgIFt4LCB5MSwgeTIsIGVkZ2UxLCBlZGdlMl0gPSBlO1xuICAgICAgICBpZiAobGFzdFBvaW50WCAhPT0geCkge1xuICAgICAgICAgIG91dGxpbmUucHVzaChsYXN0UG9pbnRYLCBsYXN0UG9pbnRZLCB4LCBsYXN0UG9pbnRZID09PSB5MSA/IHkxIDogeTIpO1xuICAgICAgICAgIGxhc3RQb2ludFggPSB4O1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQb2ludFkgPSBsYXN0UG9pbnRZID09PSB5MSA/IHkyIDogeTE7XG4gICAgICB9XG4gICAgICBvdXRsaW5lLnB1c2gobGFzdFBvaW50WCwgbGFzdFBvaW50WSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0T3V0bGluZShvdXRsaW5lcywgdGhpcy4jYm94KTtcbiAgfVxuICAjYmluYXJ5U2VhcmNoKHkpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuI2ludGVydmFscztcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+IDE7XG4gICAgICBjb25zdCB5MSA9IGFycmF5W21pZGRsZV1bMF07XG4gICAgICBpZiAoeTEgPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgIH1cbiAgICAgIGlmICh5MSA8IHkpIHtcbiAgICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gbWlkZGxlIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZCArIDE7XG4gIH1cbiAgI2luc2VydChbLCB5MSwgeTJdKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTEpO1xuICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaW5kZXgsIDAsIFt5MSwgeTJdKTtcbiAgfVxuICAjcmVtb3ZlKFssIHkxLCB5Ml0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5MSk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy4jaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBpZiAoc3RhcnQgIT09IHkxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB5MSAmJiBlbmQgPT09IHkyKSB7XG4gICAgICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGlmIChzdGFydCAhPT0geTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IHkxICYmIGVuZCA9PT0geTIpIHtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjYnJlYWtFZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBbeCwgeTEsIHkyXSA9IGVkZ2U7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtbeCwgeTEsIHkyXV07XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gcmVzdWx0cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIGNvbnN0IFssIHkzLCB5NF0gPSByZXN1bHRzW2pdO1xuICAgICAgICBpZiAoZW5kIDw9IHkzIHx8IHk0IDw9IHN0YXJ0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkzID49IHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHk0ID4gZW5kKSB7XG4gICAgICAgICAgICByZXN1bHRzW2pdWzFdID0gZW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoamogPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICBqai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzW2pdWzJdID0gc3RhcnQ7XG4gICAgICAgIGlmICh5NCA+IGVuZCkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChbeCwgZW5kLCB5NF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5jbGFzcyBIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNib3g7XG4gICNvdXRsaW5lcztcbiAgY29uc3RydWN0b3Iob3V0bGluZXMsIGJveCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jb3V0bGluZXMgPSBvdXRsaW5lcztcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiB0aGlzLiNvdXRsaW5lcykge1xuICAgICAgbGV0IFtwcmV2WCwgcHJldlldID0gcG9seWdvbjtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNJHtwcmV2WH0gJHtwcmV2WX1gKTtcbiAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCB4ID0gcG9seWdvbltpXTtcbiAgICAgICAgY29uc3QgeSA9IHBvbHlnb25baSArIDFdO1xuICAgICAgICBpZiAoeCA9PT0gcHJldlgpIHtcbiAgICAgICAgICBidWZmZXIucHVzaChgViR7eX1gKTtcbiAgICAgICAgICBwcmV2WSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA9PT0gcHJldlkpIHtcbiAgICAgICAgICBidWZmZXIucHVzaChgSCR7eH1gKTtcbiAgICAgICAgICBwcmV2WCA9IHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICBzZXJpYWxpemUoW2JsWCwgYmxZLCB0clgsIHRyWV0sIF9yb3RhdGlvbikge1xuICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgY29uc3Qgd2lkdGggPSB0clggLSBibFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJZIC0gYmxZO1xuICAgIGZvciAoY29uc3Qgb3V0bGluZSBvZiB0aGlzLiNvdXRsaW5lcykge1xuICAgICAgY29uc3QgcG9pbnRzID0gbmV3IEFycmF5KG91dGxpbmUubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0bGluZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwb2ludHNbaV0gPSBibFggKyBvdXRsaW5lW2ldICogd2lkdGg7XG4gICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSBvdXRsaW5lW2kgKyAxXSAqIGhlaWdodDtcbiAgICAgIH1cbiAgICAgIG91dGxpbmVzLnB1c2gocG9pbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxpbmVzO1xuICB9XG4gIGdldCBib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2JveDtcbiAgfVxuICBnZXQgY2xhc3NOYW1lc0ZvckRyYXdpbmcoKSB7XG4gICAgcmV0dXJuIFtcImhpZ2hsaWdodFwiXTtcbiAgfVxuICBnZXQgY2xhc3NOYW1lc0Zvck91dGxpbmluZygpIHtcbiAgICByZXR1cm4gW1wiaGlnaGxpZ2h0T3V0bGluZVwiXTtcbiAgfVxufVxuY2xhc3MgRnJlZUhpZ2hsaWdodE91dGxpbmVyIGV4dGVuZHMgRnJlZURyYXdPdXRsaW5lciB7XG4gIG5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUikge1xuICAgIHJldHVybiBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpO1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yRHJhd2luZygpIHtcbiAgICByZXR1cm4gW1wiaGlnaGxpZ2h0XCIsIFwiZnJlZVwiXTtcbiAgfVxufVxuY2xhc3MgRnJlZUhpZ2hsaWdodE91dGxpbmUgZXh0ZW5kcyBGcmVlRHJhd091dGxpbmUge1xuICBnZXQgY2xhc3NOYW1lc0ZvckRyYXdpbmcoKSB7XG4gICAgcmV0dXJuIFtcImhpZ2hsaWdodFwiLCBcImZyZWVcIl07XG4gIH1cbiAgZ2V0IGNsYXNzTmFtZXNGb3JPdXRsaW5pbmcoKSB7XG4gICAgcmV0dXJuIFtcImhpZ2hsaWdodE91dGxpbmVcIiwgXCJmcmVlXCJdO1xuICB9XG4gIG5ld091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICByZXR1cm4gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcihwb2ludCwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4pO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9jb2xvcl9waWNrZXIuanNcblxuXG5cbmNsYXNzIENvbG9yUGlja2VyIHtcbiAgI2J1dHRvbiA9IG51bGw7XG4gICNidXR0b25Td2F0Y2ggPSBudWxsO1xuICAjZGVmYXVsdENvbG9yO1xuICAjZHJvcGRvd24gPSBudWxsO1xuICAjZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmQgPSBmYWxzZTtcbiAgI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICNlZGl0b3IgPSBudWxsO1xuICAjZXZlbnRCdXM7XG4gICNvcGVuRHJvcGRvd25BQyA9IG51bGw7XG4gICN1aU1hbmFnZXIgPSBudWxsO1xuICAjdHlwZTtcbiAgc3RhdGljICNsMTBuQ29sb3IgPSBudWxsO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5faGlkZURyb3Bkb3duRnJvbUtleWJvYXJkXSwgW1tcIiBcIiwgXCJtYWMrIFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9jb2xvclNlbGVjdEZyb21LZXlib2FyZF0sIFtbXCJBcnJvd0Rvd25cIiwgXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93RG93blwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb05leHRdLCBbW1wiQXJyb3dVcFwiLCBcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd1VwXCIsIFwibWFjK0Fycm93TGVmdFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9QcmV2aW91c10sIFtbXCJIb21lXCIsIFwibWFjK0hvbWVcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvQmVnaW5uaW5nXSwgW1tcIkVuZFwiLCBcIm1hYytFbmRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvRW5kXV0pKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgZWRpdG9yID0gbnVsbCxcbiAgICB1aU1hbmFnZXIgPSBudWxsXG4gIH0pIHtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLiNpc01haW5Db2xvclBpY2tlciA9IGZhbHNlO1xuICAgICAgdGhpcy4jdHlwZSA9IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUjtcbiAgICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaXNNYWluQ29sb3JQaWNrZXIgPSB0cnVlO1xuICAgICAgdGhpcy4jdHlwZSA9IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIgPSBlZGl0b3I/Ll91aU1hbmFnZXIgfHwgdWlNYW5hZ2VyO1xuICAgIHRoaXMuI2V2ZW50QnVzID0gdGhpcy4jdWlNYW5hZ2VyLl9ldmVudEJ1cztcbiAgICB0aGlzLiNkZWZhdWx0Q29sb3IgPSBlZGl0b3I/LmNvbG9yIHx8IHRoaXMuI3VpTWFuYWdlcj8uaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZSB8fCBcIiNGRkZGOThcIjtcbiAgICBDb2xvclBpY2tlci4jbDEwbkNvbG9yIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGJsdWU6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWJsdWVcIixcbiAgICAgIGdyZWVuOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1ncmVlblwiLFxuICAgICAgcGluazogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItcGlua1wiLFxuICAgICAgcmVkOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1yZWRcIixcbiAgICAgIHllbGxvdzogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXIteWVsbG93XCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXJCdXR0b24oKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gXCJjb2xvclBpY2tlclwiO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IFwiMFwiO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsIHRydWUpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jb3BlbkRyb3Bkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHN3YXRjaCA9IHRoaXMuI2J1dHRvblN3YXRjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHN3YXRjaC5jbGFzc05hbWUgPSBcInN3YXRjaFwiO1xuICAgIHN3YXRjaC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgICBzd2F0Y2guc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy4jZGVmYXVsdENvbG9yO1xuICAgIGJ1dHRvbi5hcHBlbmQoc3dhdGNoKTtcbiAgICByZXR1cm4gYnV0dG9uO1xuICB9XG4gIHJlbmRlck1haW5Ecm9wZG93bigpIHtcbiAgICBjb25zdCBkcm9wZG93biA9IHRoaXMuI2Ryb3Bkb3duID0gdGhpcy4jZ2V0RHJvcGRvd25Sb290KCk7XG4gICAgZHJvcGRvd24uc2V0QXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiLCBcImhvcml6b250YWxcIik7XG4gICAgZHJvcGRvd24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIFwiaGlnaGxpZ2h0Q29sb3JQaWNrZXJMYWJlbFwiKTtcbiAgICByZXR1cm4gZHJvcGRvd247XG4gIH1cbiAgI2dldERyb3Bkb3duUm9vdCgpIHtcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZGl2LmNsYXNzTmFtZSA9IFwiZHJvcGRvd25cIjtcbiAgICBkaXYucm9sZSA9IFwibGlzdGJveFwiO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiLCBmYWxzZSk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtb3JpZW50YXRpb25cIiwgXCJ2ZXJ0aWNhbFwiKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWRyb3Bkb3duXCIpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIGNvbG9yXSBvZiB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgYnV0dG9uLnRhYkluZGV4ID0gXCIwXCI7XG4gICAgICBidXR0b24ucm9sZSA9IFwib3B0aW9uXCI7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiLCBjb2xvcik7XG4gICAgICBidXR0b24udGl0bGUgPSBuYW1lO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBDb2xvclBpY2tlci4jbDEwbkNvbG9yW25hbWVdKTtcbiAgICAgIGNvbnN0IHN3YXRjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgICAgc3dhdGNoLmNsYXNzTmFtZSA9IFwic3dhdGNoXCI7XG4gICAgICBzd2F0Y2guc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBjb2xvciA9PT0gdGhpcy4jZGVmYXVsdENvbG9yKTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jY29sb3JTZWxlY3QuYmluZCh0aGlzLCBjb2xvciksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi5hcHBlbmQoYnV0dG9uKTtcbiAgICB9XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2tleURvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICAjY29sb3JTZWxlY3QoY29sb3IsIGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy4jZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ycGFyYW1zXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIHR5cGU6IHRoaXMuI3R5cGUsXG4gICAgICB2YWx1ZTogY29sb3JcbiAgICB9KTtcbiAgfVxuICBfY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29sb3JcIik7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb2xvclNlbGVjdChjb2xvciwgZXZlbnQpO1xuICB9XG4gIF9tb3ZlVG9OZXh0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy4jYnV0dG9uKSB7XG4gICAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQubmV4dFNpYmxpbmc/LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVUb1ByZXZpb3VzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy4jZHJvcGRvd24/LmZpcnN0Q2hpbGQgfHwgZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIGlmICh0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgICB0aGlzLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICB9XG4gICAgZXZlbnQudGFyZ2V0LnByZXZpb3VzU2libGluZz8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvQmVnaW5uaW5nKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZHJvcGRvd24uZmlyc3RDaGlsZD8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvRW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZHJvcGRvd24ubGFzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgQ29sb3JQaWNrZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjb3BlbkRyb3Bkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGV2ZW50LmRldGFpbCA9PT0gMDtcbiAgICBpZiAoIXRoaXMuI29wZW5Ecm9wZG93bkFDKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcG9pbnRlckRvd24uYmluZCh0aGlzKSwge1xuICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNvcGVuRHJvcGRvd25BQylcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZHJvcGRvd24pIHtcbiAgICAgIHRoaXMuI2Ryb3Bkb3duLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNkcm9wZG93biA9IHRoaXMuI2dldERyb3Bkb3duUm9vdCgpO1xuICAgIHRoaXMuI2J1dHRvbi5hcHBlbmQocm9vdCk7XG4gIH1cbiAgI3BvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2Ryb3Bkb3duPy5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGlkZURyb3Bkb3duKCk7XG4gIH1cbiAgaGlkZURyb3Bkb3duKCkge1xuICAgIHRoaXMuI2Ryb3Bkb3duPy5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgfVxuICBnZXQgI2lzRHJvcGRvd25WaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNkcm9wZG93biAmJiAhdGhpcy4jZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlkZGVuXCIpO1xuICB9XG4gIF9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQoKSB7XG4gICAgaWYgKHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuI2VkaXRvcj8udW5zZWxlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oaWRlRHJvcGRvd24oKTtcbiAgICB0aGlzLiNidXR0b24uZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmRcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGlmICh0aGlzLiNidXR0b25Td2F0Y2gpIHtcbiAgICAgIHRoaXMuI2J1dHRvblN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNkcm9wZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0gdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycy52YWx1ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuI2Ryb3Bkb3duLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIGkubmV4dCgpLnZhbHVlID09PSBjb2xvcik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jYnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNidXR0b24gPSBudWxsO1xuICAgIHRoaXMuI2J1dHRvblN3YXRjaCA9IG51bGw7XG4gICAgdGhpcy4jZHJvcGRvd24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2Ryb3Bkb3duID0gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvaGlnaGxpZ2h0LmpzXG5cblxuXG5cblxuXG5cbmNsYXNzIEhpZ2hsaWdodEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYW5jaG9yTm9kZSA9IG51bGw7XG4gICNhbmNob3JPZmZzZXQgPSAwO1xuICAjYm94ZXM7XG4gICNjbGlwUGF0aElkID0gbnVsbDtcbiAgI2NvbG9yUGlja2VyID0gbnVsbDtcbiAgI2ZvY3VzT3V0bGluZXMgPSBudWxsO1xuICAjZm9jdXNOb2RlID0gbnVsbDtcbiAgI2ZvY3VzT2Zmc2V0ID0gMDtcbiAgI2hpZ2hsaWdodERpdiA9IG51bGw7XG4gICNoaWdobGlnaHRPdXRsaW5lcyA9IG51bGw7XG4gICNpZCA9IG51bGw7XG4gICNpc0ZyZWVIaWdobGlnaHQgPSBmYWxzZTtcbiAgI2xhc3RQb2ludCA9IG51bGw7XG4gICNvcGFjaXR5O1xuICAjb3V0bGluZUlkID0gbnVsbDtcbiAgI3RleHQgPSBcIlwiO1xuICAjdGhpY2tuZXNzO1xuICAjbWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCI7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0T3BhY2l0eSA9IDE7XG4gIHN0YXRpYyBfZGVmYXVsdFRoaWNrbmVzcyA9IDEyO1xuICBzdGF0aWMgX3R5cGUgPSBcImhpZ2hsaWdodFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQ7XG4gIHN0YXRpYyBfZnJlZUhpZ2hsaWdodElkID0gLTE7XG4gIHN0YXRpYyBfZnJlZUhpZ2hsaWdodCA9IG51bGw7XG4gIHN0YXRpYyBfZnJlZUhpZ2hsaWdodENsaXBJZCA9IFwiXCI7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEhpZ2hsaWdodEVkaXRvci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFswXVxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMV1cbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzJdXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbM11cbiAgICB9XV0pKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImhpZ2hsaWdodEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtcy5jb2xvciB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcjtcbiAgICB0aGlzLiN0aGlja25lc3MgPSBwYXJhbXMudGhpY2tuZXNzIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzcztcbiAgICB0aGlzLiNvcGFjaXR5ID0gcGFyYW1zLm9wYWNpdHkgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0T3BhY2l0eTtcbiAgICB0aGlzLiNib3hlcyA9IHBhcmFtcy5ib3hlcyB8fCBudWxsO1xuICAgIHRoaXMuI21ldGhvZE9mQ3JlYXRpb24gPSBwYXJhbXMubWV0aG9kT2ZDcmVhdGlvbiB8fCBcIlwiO1xuICAgIHRoaXMuI3RleHQgPSBwYXJhbXMudGV4dCB8fCBcIlwiO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgaWYgKHBhcmFtcy5oaWdobGlnaHRJZCA+IC0xKSB7XG4gICAgICB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgdGhpcy4jY3JlYXRlRnJlZU91dGxpbmVzKHBhcmFtcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jYm94ZXMpIHtcbiAgICAgIHRoaXMuI2FuY2hvck5vZGUgPSBwYXJhbXMuYW5jaG9yTm9kZTtcbiAgICAgIHRoaXMuI2FuY2hvck9mZnNldCA9IHBhcmFtcy5hbmNob3JPZmZzZXQ7XG4gICAgICB0aGlzLiNmb2N1c05vZGUgPSBwYXJhbXMuZm9jdXNOb2RlO1xuICAgICAgdGhpcy4jZm9jdXNPZmZzZXQgPSBwYXJhbXMuZm9jdXNPZmZzZXQ7XG4gICAgICB0aGlzLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICAgIHRoaXMucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgIH1cbiAgfVxuICBnZXQgdGVsZW1ldHJ5SW5pdGlhbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogXCJhZGRlZFwiLFxuICAgICAgdHlwZTogdGhpcy4jaXNGcmVlSGlnaGxpZ2h0ID8gXCJmcmVlX2hpZ2hsaWdodFwiIDogXCJoaWdobGlnaHRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQodGhpcy5jb2xvciksXG4gICAgICB0aGlja25lc3M6IHRoaXMuI3RoaWNrbmVzcyxcbiAgICAgIG1ldGhvZE9mQ3JlYXRpb246IHRoaXMuI21ldGhvZE9mQ3JlYXRpb25cbiAgICB9O1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICBjb2xvcjogdGhpcy5fdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9yTmFtZXMuZ2V0KHRoaXMuY29sb3IpXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlck9mQ29sb3JzOiBkYXRhLmdldChcImNvbG9yXCIpLnNpemVcbiAgICB9O1xuICB9XG4gICNjcmVhdGVPdXRsaW5lcygpIHtcbiAgICBjb25zdCBvdXRsaW5lciA9IG5ldyBIaWdobGlnaHRPdXRsaW5lcih0aGlzLiNib3hlcywgMC4wMDEpO1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gb3V0bGluZXIuZ2V0T3V0bGluZXMoKTtcbiAgICAoe1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55LFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCk7XG4gICAgY29uc3Qgb3V0bGluZXJGb3JPdXRsaW5lID0gbmV3IEhpZ2hsaWdodE91dGxpbmVyKHRoaXMuI2JveGVzLCAwLjAwMjUsIDAuMDAxLCB0aGlzLl91aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiKTtcbiAgICB0aGlzLiNmb2N1c091dGxpbmVzID0gb3V0bGluZXJGb3JPdXRsaW5lLmdldE91dGxpbmVzKCk7XG4gICAgY29uc3Qge1xuICAgICAgbGFzdFBvaW50XG4gICAgfSA9IHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94O1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0gdGhpcy54KSAvIHRoaXMud2lkdGgsIChsYXN0UG9pbnRbMV0gLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHRdO1xuICB9XG4gICNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgIGhpZ2hsaWdodE91dGxpbmVzLFxuICAgIGhpZ2hsaWdodElkLFxuICAgIGNsaXBQYXRoSWRcbiAgfSkge1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gaGlnaGxpZ2h0T3V0bGluZXM7XG4gICAgY29uc3QgZXh0cmFUaGlja25lc3MgPSAxLjU7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IGhpZ2hsaWdodE91dGxpbmVzLmdldE5ld091dGxpbmUodGhpcy4jdGhpY2tuZXNzIC8gMiArIGV4dHJhVGhpY2tuZXNzLCAwLjAwMjUpO1xuICAgIGlmIChoaWdobGlnaHRJZCA+PSAwKSB7XG4gICAgICB0aGlzLiNpZCA9IGhpZ2hsaWdodElkO1xuICAgICAgdGhpcy4jY2xpcFBhdGhJZCA9IGNsaXBQYXRoSWQ7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuZmluYWxpemVMaW5lKGhpZ2hsaWdodElkLCBoaWdobGlnaHRPdXRsaW5lcyk7XG4gICAgICB0aGlzLiNvdXRsaW5lSWQgPSB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuZHJhd091dGxpbmUodGhpcy4jZm9jdXNPdXRsaW5lcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLnBhcmVudC52aWV3cG9ydC5yb3RhdGlvbjtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVMaW5lKHRoaXMuI2lkLCBoaWdobGlnaHRPdXRsaW5lcyk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlQm94KHRoaXMuI2lkLCBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94LCAoYW5nbGUgLSB0aGlzLnJvdGF0aW9uICsgMzYwKSAlIDM2MCkpO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZUxpbmUodGhpcy4jb3V0bGluZUlkLCB0aGlzLiNmb2N1c091dGxpbmVzKTtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVCb3godGhpcy4jb3V0bGluZUlkLCBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jZm9jdXNPdXRsaW5lcy5ib3gsIGFuZ2xlKSk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaGlnaGxpZ2h0T3V0bGluZXMuYm94O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnggPSB5O1xuICAgICAgICAgIHRoaXMueSA9IDEgLSB4O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgdGhpcy54ID0gMSAtIHg7XG4gICAgICAgIHRoaXMueSA9IDEgLSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgdGhpcy54ID0gMSAtIHk7XG4gICAgICAgICAgdGhpcy55ID0geDtcbiAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGFnZVdpZHRoIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsYXN0UG9pbnRcbiAgICB9ID0gdGhpcy4jZm9jdXNPdXRsaW5lcy5ib3g7XG4gICAgdGhpcy4jbGFzdFBvaW50ID0gWyhsYXN0UG9pbnRbMF0gLSB4KSAvIHdpZHRoLCAobGFzdFBvaW50WzFdIC0geSkgLyBoZWlnaHRdO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yIHx8PSB1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzPy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgfHwgXCIjZmZmMDY2XCI7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0RFRkFVTFRfQ09MT1I6XG4gICAgICAgIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTOlxuICAgICAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3MgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRyYW5zbGF0ZUluUGFnZSh4LCB5KSB7fVxuICBnZXQgdG9vbGJhclBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNsYXN0UG9pbnQ7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUjpcbiAgICAgICAgdGhpcy4jdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUzpcbiAgICAgICAgdGhpcy4jdXBkYXRlVGhpY2tuZXNzKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfREVGQVVMVF9DT0xPUiwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3JdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUywgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsIHRoaXMuY29sb3IgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3JdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUywgdGhpcy4jdGhpY2tuZXNzIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzc10sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfRlJFRSwgdGhpcy4jaXNGcmVlSGlnaGxpZ2h0XV07XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2V0Q29sb3JBbmRPcGFjaXR5ID0gKGNvbCwgb3BhKSA9PiB7XG4gICAgICB0aGlzLmNvbG9yID0gY29sO1xuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci5jaGFuZ2VDb2xvcih0aGlzLiNpZCwgY29sKTtcbiAgICAgIHRoaXMuI2NvbG9yUGlja2VyPy51cGRhdGVDb2xvcihjb2wpO1xuICAgICAgdGhpcy4jb3BhY2l0eSA9IG9wYTtcbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIuY2hhbmdlT3BhY2l0eSh0aGlzLiNpZCwgb3BhKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnN0IHNhdmVkT3BhY2l0eSA9IHRoaXMuI29wYWNpdHk7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldENvbG9yQW5kT3BhY2l0eS5iaW5kKHRoaXMsIGNvbG9yLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5KSxcbiAgICAgIHVuZG86IHNldENvbG9yQW5kT3BhY2l0eS5iaW5kKHRoaXMsIHNhdmVkQ29sb3IsIHNhdmVkT3BhY2l0eSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcImNvbG9yX2NoYW5nZWRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQoY29sb3IpXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBzYXZlZFRoaWNrbmVzcyA9IHRoaXMuI3RoaWNrbmVzcztcbiAgICBjb25zdCBzZXRUaGlja25lc3MgPSB0aCA9PiB7XG4gICAgICB0aGlzLiN0aGlja25lc3MgPSB0aDtcbiAgICAgIHRoaXMuI2NoYW5nZVRoaWNrbmVzcyh0aCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0VGhpY2tuZXNzLmJpbmQodGhpcywgdGhpY2tuZXNzKSxcbiAgICAgIHVuZG86IHNldFRoaWNrbmVzcy5iaW5kKHRoaXMsIHNhdmVkVGhpY2tuZXNzKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcInRoaWNrbmVzc19jaGFuZ2VkXCIsXG4gICAgICB0aGlja25lc3NcbiAgICB9LCB0cnVlKTtcbiAgfVxuICBhc3luYyBhZGRFZGl0VG9vbGJhcigpIHtcbiAgICBjb25zdCB0b29sYmFyID0gYXdhaXQgc3VwZXIuYWRkRWRpdFRvb2xiYXIoKTtcbiAgICBpZiAoIXRvb2xiYXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycykge1xuICAgICAgdGhpcy4jY29sb3JQaWNrZXIgPSBuZXcgQ29sb3JQaWNrZXIoe1xuICAgICAgICBlZGl0b3I6IHRoaXNcbiAgICAgIH0pO1xuICAgICAgdG9vbGJhci5hZGRDb2xvclBpY2tlcih0aGlzLiNjb2xvclBpY2tlcik7XG4gICAgfVxuICAgIHJldHVybiB0b29sYmFyO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIHRydWUpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpeEFuZFNldFBvc2l0aW9uKHRoaXMuI2dldFJvdGF0aW9uKCkpO1xuICB9XG4gIGdldEJhc2VUcmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGdldFJlY3QodHgsIHR5KSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFJlY3QodHgsIHR5LCB0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBvbmNlQWRkZWQoKSB7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiZGVsZXRlZFwiXG4gICAgfSk7XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBsZXQgbXVzdEJlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIocGFyZW50KTtcbiAgICAgIG11c3RCZVNlbGVjdGVkID0gIXRoaXMucGFyZW50ICYmIHRoaXMuZGl2Py5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0UGFyZW50KHBhcmVudCk7XG4gICAgdGhpcy5zaG93KHRoaXMuX2lzVmlzaWJsZSk7XG4gICAgaWYgKG11c3RCZVNlbGVjdGVkKSB7XG4gICAgICB0aGlzLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxuICAjY2hhbmdlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGlmICghdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUZyZWVPdXRsaW5lcyh7XG4gICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuZ2V0TmV3T3V0bGluZSh0aGlja25lc3MgLyAyKVxuICAgIH0pO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy4jaWQgPT09IG51bGwgfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy4jaWQpO1xuICAgIHRoaXMuI2lkID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuI291dGxpbmVJZCk7XG4gICAgdGhpcy4jb3V0bGluZUlkID0gbnVsbDtcbiAgfVxuICAjYWRkVG9EcmF3TGF5ZXIocGFyZW50ID0gdGhpcy5wYXJlbnQpIHtcbiAgICBpZiAodGhpcy4jaWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuI2NsaXBQYXRoSWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLCB0aGlzLmNvbG9yLCB0aGlzLiNvcGFjaXR5KSk7XG4gICAgdGhpcy4jb3V0bGluZUlkID0gcGFyZW50LmRyYXdMYXllci5kcmF3T3V0bGluZSh0aGlzLiNmb2N1c091dGxpbmVzKTtcbiAgICBpZiAodGhpcy4jaGlnaGxpZ2h0RGl2KSB7XG4gICAgICB0aGlzLiNoaWdobGlnaHREaXYuc3R5bGUuY2xpcFBhdGggPSB0aGlzLiNjbGlwUGF0aElkO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI3JvdGF0ZUJib3goe1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IDEgLSB5IC0gaGVpZ2h0LFxuICAgICAgICAgIHk6IHgsXG4gICAgICAgICAgd2lkdGg6IGhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHdpZHRoXG4gICAgICAgIH07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiAxIC0geCAtIHdpZHRoLFxuICAgICAgICAgIHk6IDEgLSB5IC0gaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodFxuICAgICAgICB9O1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeSxcbiAgICAgICAgICB5OiAxIC0geCAtIHdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBoZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0OiB3aWR0aFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH07XG4gIH1cbiAgcm90YXRlKGFuZ2xlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJhd0xheWVyXG4gICAgfSA9IHRoaXMucGFyZW50O1xuICAgIGxldCBib3g7XG4gICAgaWYgKHRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgYW5nbGUgPSAoYW5nbGUgLSB0aGlzLnJvdGF0aW9uICsgMzYwKSAlIDM2MDtcbiAgICAgIGJveCA9IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsIGFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94ID0gSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMsIGFuZ2xlKTtcbiAgICB9XG4gICAgZHJhd0xheWVyLnJvdGF0ZSh0aGlzLiNpZCwgYW5nbGUpO1xuICAgIGRyYXdMYXllci5yb3RhdGUodGhpcy4jb3V0bGluZUlkLCBhbmdsZSk7XG4gICAgZHJhd0xheWVyLnVwZGF0ZUJveCh0aGlzLiNpZCwgYm94KTtcbiAgICBkcmF3TGF5ZXIudXBkYXRlQm94KHRoaXMuI291dGxpbmVJZCwgSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LCBhbmdsZSkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgY29uc3QgZGl2ID0gc3VwZXIucmVuZGVyKCk7XG4gICAgaWYgKHRoaXMuI3RleHQpIHtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMuI3RleHQpO1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJtYXJrXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcImZyZWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2tleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgICBzaWduYWw6IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaGlnaGxpZ2h0RGl2ID0gdGhpcy4jaGlnaGxpZ2h0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuYXBwZW5kKGhpZ2hsaWdodERpdik7XG4gICAgaGlnaGxpZ2h0RGl2LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICBoaWdobGlnaHREaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIGhpZ2hsaWdodERpdi5zdHlsZS5jbGlwUGF0aCA9IHRoaXMuI2NsaXBQYXRoSWQ7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICBiaW5kRXZlbnRzKHRoaXMsIHRoaXMuI2hpZ2hsaWdodERpdiwgW1wicG9pbnRlcm92ZXJcIiwgXCJwb2ludGVybGVhdmVcIl0pO1xuICAgIHRoaXMuZW5hYmxlRWRpdGluZygpO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgcG9pbnRlcm92ZXIoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5hZGRDbGFzcyh0aGlzLiNvdXRsaW5lSWQsIFwiaG92ZXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgcG9pbnRlcmxlYXZlKCkge1xuICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlQ2xhc3ModGhpcy4jb3V0bGluZUlkLCBcImhvdmVyZWRcIik7XG4gICAgfVxuICB9XG4gICNrZXlkb3duKGV2ZW50KSB7XG4gICAgSGlnaGxpZ2h0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgX21vdmVDYXJldChkaXJlY3Rpb24pIHtcbiAgICB0aGlzLnBhcmVudC51bnNlbGVjdCh0aGlzKTtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLiNzZXRDYXJldCh0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMuI3NldENhcmV0KGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gICNzZXRDYXJldChzdGFydCkge1xuICAgIGlmICghdGhpcy4jYW5jaG9yTm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb24uc2V0UG9zaXRpb24odGhpcy4jYW5jaG9yTm9kZSwgdGhpcy4jYW5jaG9yT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLnNldFBvc2l0aW9uKHRoaXMuI2ZvY3VzTm9kZSwgdGhpcy4jZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgc3VwZXIuc2VsZWN0KCk7XG4gICAgaWYgKCF0aGlzLiNvdXRsaW5lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci5yZW1vdmVDbGFzcyh0aGlzLiNvdXRsaW5lSWQsIFwiaG92ZXJlZFwiKTtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLmFkZENsYXNzKHRoaXMuI291dGxpbmVJZCwgXCJzZWxlY3RlZFwiKTtcbiAgfVxuICB1bnNlbGVjdCgpIHtcbiAgICBzdXBlci51bnNlbGVjdCgpO1xuICAgIGlmICghdGhpcy4jb3V0bGluZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIucmVtb3ZlQ2xhc3ModGhpcy4jb3V0bGluZUlkLCBcInNlbGVjdGVkXCIpO1xuICAgIGlmICghdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICB0aGlzLiNzZXRDYXJldChmYWxzZSk7XG4gICAgfVxuICB9XG4gIGdldCBfbXVzdEZpeFBvc2l0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy4jaXNGcmVlSGlnaGxpZ2h0O1xuICB9XG4gIHNob3codmlzaWJsZSA9IHRoaXMuX2lzVmlzaWJsZSkge1xuICAgIHN1cGVyLnNob3codmlzaWJsZSk7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuc2hvdyh0aGlzLiNpZCwgdmlzaWJsZSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuc2hvdyh0aGlzLiNvdXRsaW5lSWQsIHZpc2libGUpO1xuICAgIH1cbiAgfVxuICAjZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA/IHRoaXMucm90YXRpb24gOiAwO1xuICB9XG4gICNzZXJpYWxpemVCb3hlcygpIHtcbiAgICBpZiAodGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLiNib3hlcztcbiAgICBjb25zdCBxdWFkUG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShib3hlcy5sZW5ndGggKiA4KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSBvZiBib3hlcykge1xuICAgICAgY29uc3Qgc3ggPSB4ICogcGFnZVdpZHRoICsgcGFnZVg7XG4gICAgICBjb25zdCBzeSA9ICgxIC0geSAtIGhlaWdodCkgKiBwYWdlSGVpZ2h0ICsgcGFnZVk7XG4gICAgICBxdWFkUG9pbnRzW2ldID0gcXVhZFBvaW50c1tpICsgNF0gPSBzeDtcbiAgICAgIHF1YWRQb2ludHNbaSArIDFdID0gcXVhZFBvaW50c1tpICsgM10gPSBzeTtcbiAgICAgIHF1YWRQb2ludHNbaSArIDJdID0gcXVhZFBvaW50c1tpICsgNl0gPSBzeCArIHdpZHRoICogcGFnZVdpZHRoO1xuICAgICAgcXVhZFBvaW50c1tpICsgNV0gPSBxdWFkUG9pbnRzW2kgKyA3XSA9IHN5ICsgaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICAgIGkgKz0gODtcbiAgICB9XG4gICAgcmV0dXJuIHF1YWRQb2ludHM7XG4gIH1cbiAgI3NlcmlhbGl6ZU91dGxpbmVzKHJlY3QpIHtcbiAgICByZXR1cm4gdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuc2VyaWFsaXplKHJlY3QsIHRoaXMuI2dldFJvdGF0aW9uKCkpO1xuICB9XG4gIHN0YXRpYyBzdGFydEhpZ2hsaWdodGluZyhwYXJlbnQsIGlzTFRSLCB7XG4gICAgdGFyZ2V0OiB0ZXh0TGF5ZXIsXG4gICAgeCxcbiAgICB5XG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICB4OiBsYXllclgsXG4gICAgICB5OiBsYXllclksXG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0ZXh0TGF5ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gcGFyZW50LmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICBjb25zdCBwb2ludGVyRG93biA9IGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgdGhpcy4jZW5kSGlnaGxpZ2h0KHBhcmVudCwgZSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHBvaW50ZXJEb3duLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRleHRMYXllci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jaGlnaGxpZ2h0TW92ZS5iaW5kKHRoaXMsIHBhcmVudCksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHQgPSBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSwgW2xheWVyWCwgbGF5ZXJZLCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSwgcGFyZW50LnNjYWxlLCB0aGlzLl9kZWZhdWx0VGhpY2tuZXNzIC8gMiwgaXNMVFIsIDAuMDAxKTtcbiAgICAoe1xuICAgICAgaWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRJZCxcbiAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRDbGlwSWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHRoaXMuX2ZyZWVIaWdobGlnaHQsIHRoaXMuX2RlZmF1bHRDb2xvciwgdGhpcy5fZGVmYXVsdE9wYWNpdHksIHRydWUpKTtcbiAgfVxuICBzdGF0aWMgI2hpZ2hsaWdodE1vdmUocGFyZW50LCBldmVudCkge1xuICAgIGlmICh0aGlzLl9mcmVlSGlnaGxpZ2h0LmFkZChldmVudCkpIHtcbiAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUGF0aCh0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsIHRoaXMuX2ZyZWVIaWdobGlnaHQpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI2VuZEhpZ2hsaWdodChwYXJlbnQsIGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mcmVlSGlnaGxpZ2h0LmlzRW1wdHkoKSkge1xuICAgICAgcGFyZW50LmNyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgZmFsc2UsIHtcbiAgICAgICAgaGlnaGxpZ2h0SWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRJZCxcbiAgICAgICAgaGlnaGxpZ2h0T3V0bGluZXM6IHRoaXMuX2ZyZWVIaWdobGlnaHQuZ2V0T3V0bGluZXMoKSxcbiAgICAgICAgY2xpcFBhdGhJZDogdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZCxcbiAgICAgICAgbWV0aG9kT2ZDcmVhdGlvbjogXCJtYWluX3Rvb2xiYXJcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2ZyZWVIaWdobGlnaHRJZCk7XG4gICAgfVxuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHRJZCA9IC0xO1xuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHQgPSBudWxsO1xuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHRDbGlwSWQgPSBcIlwiO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcXVhZFBvaW50cyxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgcG9wdXBSZWZcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcXVhZFBvaW50cyxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIElua0Fubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIGJvcmRlclN0eWxlOiB7XG4gICAgICAgICAgICByYXdXaWR0aDogdGhpY2tuZXNzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3B1cFJlZlxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oY29sb3IpLFxuICAgICAgICB0aGlja25lc3MsXG4gICAgICAgIGlua0xpc3RzLFxuICAgICAgICBib3hlczogbnVsbCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yLFxuICAgICAgcXVhZFBvaW50cyxcbiAgICAgIGlua0xpc3RzLFxuICAgICAgb3BhY2l0eVxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuY29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5jb2xvcik7XG4gICAgZWRpdG9yLiNvcGFjaXR5ID0gb3BhY2l0eSB8fCAxO1xuICAgIGlmIChpbmtMaXN0cykge1xuICAgICAgZWRpdG9yLiN0aGlja25lc3MgPSBkYXRhLnRoaWNrbmVzcztcbiAgICB9XG4gICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBkYXRhLmlkIHx8IG51bGw7XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gZWRpdG9yLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBpZiAocXVhZFBvaW50cykge1xuICAgICAgY29uc3QgYm94ZXMgPSBlZGl0b3IuI2JveGVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YWRQb2ludHMubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgYm94ZXMucHVzaCh7XG4gICAgICAgICAgeDogKHF1YWRQb2ludHNbaV0gLSBwYWdlWCkgLyBwYWdlV2lkdGgsXG4gICAgICAgICAgeTogMSAtIChxdWFkUG9pbnRzW2kgKyAxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IChxdWFkUG9pbnRzW2kgKyAyXSAtIHF1YWRQb2ludHNbaV0pIC8gcGFnZVdpZHRoLFxuICAgICAgICAgIGhlaWdodDogKHF1YWRQb2ludHNbaSArIDFdIC0gcXVhZFBvaW50c1tpICsgNV0pIC8gcGFnZUhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci4jY3JlYXRlT3V0bGluZXMoKTtcbiAgICAgIGVkaXRvci4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICAgIGVkaXRvci5yb3RhdGUoZWRpdG9yLnJvdGF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGlua0xpc3RzKSB7XG4gICAgICBlZGl0b3IuI2lzRnJlZUhpZ2hsaWdodCA9IHRydWU7XG4gICAgICBjb25zdCBwb2ludHMgPSBpbmtMaXN0c1swXTtcbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBwb2ludHNbMF0gLSBwYWdlWCxcbiAgICAgICAgeTogcGFnZUhlaWdodCAtIChwb2ludHNbMV0gLSBwYWdlWSlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdXRsaW5lciA9IG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIocG9pbnQsIFswLCAwLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLCAxLCBlZGl0b3IuI3RoaWNrbmVzcyAvIDIsIHRydWUsIDAuMDAxKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50LnggPSBwb2ludHNbaV0gLSBwYWdlWDtcbiAgICAgICAgcG9pbnQueSA9IHBhZ2VIZWlnaHQgLSAocG9pbnRzW2kgKyAxXSAtIHBhZ2VZKTtcbiAgICAgICAgb3V0bGluZXIuYWRkKHBvaW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNsaXBQYXRoSWRcbiAgICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcob3V0bGluZXIsIGVkaXRvci5jb2xvciwgZWRpdG9yLl9kZWZhdWx0T3BhY2l0eSwgdHJ1ZSk7XG4gICAgICBlZGl0b3IuI2NyZWF0ZUZyZWVPdXRsaW5lcyh7XG4gICAgICAgIGhpZ2hsaWdodE91dGxpbmVzOiBvdXRsaW5lci5nZXRPdXRsaW5lcygpLFxuICAgICAgICBoaWdobGlnaHRJZDogaWQsXG4gICAgICAgIGNsaXBQYXRoSWRcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSB8fCBpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFJlY3QoMCwgMCk7XG4gICAgY29uc3QgY29sb3IgPSBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLmNvbG9yKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCxcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eTogdGhpcy4jb3BhY2l0eSxcbiAgICAgIHRoaWNrbmVzczogdGhpcy4jdGhpY2tuZXNzLFxuICAgICAgcXVhZFBvaW50czogdGhpcy4jc2VyaWFsaXplQm94ZXMoKSxcbiAgICAgIG91dGxpbmVzOiB0aGlzLiNzZXJpYWxpemVPdXRsaW5lcyhyZWN0KSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMuI2dldFJvdGF0aW9uKCksXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3JcbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFJlY3QoMCwgMClcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9pbmsuanNcblxuXG5cblxuXG5jbGFzcyBJbmtFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2Jhc2VIZWlnaHQgPSAwO1xuICAjYmFzZVdpZHRoID0gMDtcbiAgI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkID0gbnVsbDtcbiAgI2N1cnJlbnRQYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG4gICNkaXNhYmxlRWRpdGluZyA9IGZhbHNlO1xuICAjZHJhd2luZ0FDID0gbnVsbDtcbiAgI2hhc1NvbWV0aGluZ1RvRHJhdyA9IGZhbHNlO1xuICAjaXNDYW52YXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAjb2JzZXJ2ZXIgPSBudWxsO1xuICAjcG9pbnRlcmRvd25BQyA9IG51bGw7XG4gICNyZWFsV2lkdGggPSAwO1xuICAjcmVhbEhlaWdodCA9IDA7XG4gICNyZXF1ZXN0RnJhbWVDYWxsYmFjayA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0T3BhY2l0eSA9IDE7XG4gIHN0YXRpYyBfZGVmYXVsdFRoaWNrbmVzcyA9IDE7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaW5rXCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJpbmtFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgbnVsbDtcbiAgICB0aGlzLnRoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgbnVsbDtcbiAgICB0aGlzLm9wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBudWxsO1xuICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgICB0aGlzLmJlemllclBhdGgyRCA9IFtdO1xuICAgIHRoaXMuYWxsUmF3UGF0aHMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gW107XG4gICAgdGhpcy5zY2FsZUZhY3RvciA9IDE7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSB0aGlzLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1M6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SOlxuICAgICAgICBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFk6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkgPSB2YWx1ZSAvIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTOlxuICAgICAgICB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWTpcbiAgICAgICAgdGhpcy4jdXBkYXRlT3BhY2l0eSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUiwgSW5rRWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWSwgTWF0aC5yb3VuZChJbmtFZGl0b3IuX2RlZmF1bHRPcGFjaXR5ICogMTAwKV1dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgdGhpcy50aGlja25lc3MgfHwgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUiwgdGhpcy5jb2xvciB8fCBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLCBNYXRoLnJvdW5kKDEwMCAqICh0aGlzLm9wYWNpdHkgPz8gSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eSkpXV07XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBzZXRUaGlja25lc3MgPSB0aCA9PiB7XG4gICAgICB0aGlzLnRoaWNrbmVzcyA9IHRoO1xuICAgICAgdGhpcy4jZml0VG9Db250ZW50KCk7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZFRoaWNrbmVzcyA9IHRoaXMudGhpY2tuZXNzO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRUaGlja25lc3MuYmluZCh0aGlzLCB0aGlja25lc3MpLFxuICAgICAgdW5kbzogc2V0VGhpY2tuZXNzLmJpbmQodGhpcywgc2F2ZWRUaGlja25lc3MpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUyxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yID0gY29sID0+IHtcbiAgICAgIHRoaXMuY29sb3IgPSBjb2w7XG4gICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRDb2xvci5iaW5kKHRoaXMsIGNvbG9yKSxcbiAgICAgIHVuZG86IHNldENvbG9yLmJpbmQodGhpcywgc2F2ZWRDb2xvciksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICAjdXBkYXRlT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgY29uc3Qgc2V0T3BhY2l0eSA9IG9wID0+IHtcbiAgICAgIHRoaXMub3BhY2l0eSA9IG9wO1xuICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgfTtcbiAgICBvcGFjaXR5IC89IDEwMDtcbiAgICBjb25zdCBzYXZlZE9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldE9wYWNpdHkuYmluZCh0aGlzLCBvcGFjaXR5KSxcbiAgICAgIHVuZG86IHNldE9wYWNpdHkuYmluZCh0aGlzLCBzYXZlZE9wYWNpdHkpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICB9XG4gICAgdGhpcy4jZml0VG9Db250ZW50KCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmNhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlKCk7XG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgIGlmICh0aGlzLiNjYW52YXNDb250ZXh0TWVudVRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkKTtcbiAgICAgIHRoaXMuI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jb2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLiNvYnNlcnZlciA9IG51bGw7XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQgJiYgcGFyZW50KSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVtb3ZlU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50ICYmIHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgfVxuICAgIHN1cGVyLnNldFBhcmVudChwYXJlbnQpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoICogcGFyZW50V2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlRWRpdGluZyB8fCB0aGlzLmNhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jYWRkUG9pbnRlcmRvd25MaXN0ZW5lcigpO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkgfHwgdGhpcy5jYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSAhdGhpcy5pc0VtcHR5KCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnJlbW92ZShcImVkaXRpbmdcIik7XG4gICAgdGhpcy4jcmVtb3ZlUG9pbnRlcmRvd25MaXN0ZW5lcigpO1xuICB9XG4gIG9uY2VBZGRlZCgpIHtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9ICF0aGlzLmlzRW1wdHkoKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLnBhdGhzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLnBhdGhzWzBdLmxlbmd0aCA9PT0gMDtcbiAgfVxuICAjZ2V0SW5pdGlhbEJCb3goKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50Um90YXRpb24sXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbd2lkdGgsIGhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKHBhcmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzAsIGhlaWdodCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3dpZHRoLCAwLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbMCwgMCwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gICNzZXRTdHJva2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4LFxuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgcGFyZW50U2NhbGUsXG4gICAgICBzY2FsZUZhY3RvclxuICAgIH0gPSB0aGlzO1xuICAgIGN0eC5saW5lV2lkdGggPSB0aGlja25lc3MgKiBwYXJlbnRTY2FsZSAvIHNjYWxlRmFjdG9yO1xuICAgIGN0eC5saW5lQ2FwID0gXCJyb3VuZFwiO1xuICAgIGN0eC5saW5lSm9pbiA9IFwicm91bmRcIjtcbiAgICBjdHgubWl0ZXJMaW1pdCA9IDEwO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGAke2NvbG9yfSR7b3BhY2l0eVRvSGV4KG9wYWNpdHkpfWA7XG4gIH1cbiAgI3N0YXJ0RHJhd2luZyh4LCB5KSB7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbDogdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNyZW1vdmVQb2ludGVyZG93bkxpc3RlbmVyKCk7XG4gICAgdGhpcy4jZHJhd2luZ0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNkcmF3aW5nQUMpO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5jYW52YXNQb2ludGVybGVhdmUuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuY2FudmFzUG9pbnRlcm1vdmUuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLmNhbnZhc1BvaW50ZXJ1cC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gICAgaWYgKCF0aGlzLiNpc0NhbnZhc0luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLiNpc0NhbnZhc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICAgIHRoaXMudGhpY2tuZXNzIHx8PSBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3M7XG4gICAgICB0aGlzLmNvbG9yIHx8PSBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yO1xuICAgICAgdGhpcy5vcGFjaXR5ID8/PSBJbmtFZGl0b3IuX2RlZmF1bHRPcGFjaXR5O1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRQYXRoLnB1c2goW3gsIHldKTtcbiAgICB0aGlzLiNoYXNTb21ldGhpbmdUb0RyYXcgPSBmYWxzZTtcbiAgICB0aGlzLiNzZXRTdHJva2UoKTtcbiAgICB0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuI2RyYXdQb2ludHMoKTtcbiAgICAgIGlmICh0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjaykge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2spO1xuICB9XG4gICNkcmF3KHgsIHkpIHtcbiAgICBjb25zdCBbbGFzdFgsIGxhc3RZXSA9IHRoaXMuY3VycmVudFBhdGguYXQoLTEpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLmxlbmd0aCA+IDEgJiYgeCA9PT0gbGFzdFggJiYgeSA9PT0gbGFzdFkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuICAgIGxldCBwYXRoMkQgPSB0aGlzLiNjdXJyZW50UGF0aDJEO1xuICAgIGN1cnJlbnRQYXRoLnB1c2goW3gsIHldKTtcbiAgICB0aGlzLiNoYXNTb21ldGhpbmdUb0RyYXcgPSB0cnVlO1xuICAgIGlmIChjdXJyZW50UGF0aC5sZW5ndGggPD0gMikge1xuICAgICAgcGF0aDJELm1vdmVUbyguLi5jdXJyZW50UGF0aFswXSk7XG4gICAgICBwYXRoMkQubGluZVRvKHgsIHkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBhdGgubGVuZ3RoID09PSAzKSB7XG4gICAgICB0aGlzLiNjdXJyZW50UGF0aDJEID0gcGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAgICAgcGF0aDJELm1vdmVUbyguLi5jdXJyZW50UGF0aFswXSk7XG4gICAgfVxuICAgIHRoaXMuI21ha2VCZXppZXJDdXJ2ZShwYXRoMkQsIC4uLmN1cnJlbnRQYXRoLmF0KC0zKSwgLi4uY3VycmVudFBhdGguYXQoLTIpLCB4LCB5KTtcbiAgfVxuICAjZW5kUGF0aCgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdFBvaW50ID0gdGhpcy5jdXJyZW50UGF0aC5hdCgtMSk7XG4gICAgdGhpcy4jY3VycmVudFBhdGgyRC5saW5lVG8oLi4ubGFzdFBvaW50KTtcbiAgfVxuICAjc3RvcERyYXdpbmcoeCwgeSkge1xuICAgIHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrID0gbnVsbDtcbiAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgMCksIHRoaXMuY2FudmFzLndpZHRoKTtcbiAgICB5ID0gTWF0aC5taW4oTWF0aC5tYXgoeSwgMCksIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy4jZHJhdyh4LCB5KTtcbiAgICB0aGlzLiNlbmRQYXRoKCk7XG4gICAgbGV0IGJlemllcjtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5sZW5ndGggIT09IDEpIHtcbiAgICAgIGJlemllciA9IHRoaXMuI2dlbmVyYXRlQmV6aWVyUG9pbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHh5ID0gW3gsIHldO1xuICAgICAgYmV6aWVyID0gW1t4eSwgeHkuc2xpY2UoKSwgeHkuc2xpY2UoKSwgeHldXTtcbiAgICB9XG4gICAgY29uc3QgcGF0aDJEID0gdGhpcy4jY3VycmVudFBhdGgyRDtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IFtdO1xuICAgIHRoaXMuI2N1cnJlbnRQYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgdGhpcy5hbGxSYXdQYXRocy5wdXNoKGN1cnJlbnRQYXRoKTtcbiAgICAgIHRoaXMucGF0aHMucHVzaChiZXppZXIpO1xuICAgICAgdGhpcy5iZXppZXJQYXRoMkQucHVzaChwYXRoMkQpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlYnVpbGQodGhpcyk7XG4gICAgfTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgdGhpcy5hbGxSYXdQYXRocy5wb3AoKTtcbiAgICAgIHRoaXMucGF0aHMucG9wKCk7XG4gICAgICB0aGlzLmJlemllclBhdGgyRC5wb3AoKTtcbiAgICAgIGlmICh0aGlzLnBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgICAgICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZml0VG9Db250ZW50KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNkcmF3UG9pbnRzKCkge1xuICAgIGlmICghdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdyA9IGZhbHNlO1xuICAgIGNvbnN0IHRoaWNrbmVzcyA9IE1hdGguY2VpbCh0aGlzLnRoaWNrbmVzcyAqIHRoaXMucGFyZW50U2NhbGUpO1xuICAgIGNvbnN0IGxhc3RQb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNsaWNlKC0zKTtcbiAgICBjb25zdCB4ID0gbGFzdFBvaW50cy5tYXAoeHkgPT4geHlbMF0pO1xuICAgIGNvbnN0IHkgPSBsYXN0UG9pbnRzLm1hcCh4eSA9PiB4eVsxXSk7XG4gICAgY29uc3QgeE1pbiA9IE1hdGgubWluKC4uLngpIC0gdGhpY2tuZXNzO1xuICAgIGNvbnN0IHhNYXggPSBNYXRoLm1heCguLi54KSArIHRoaWNrbmVzcztcbiAgICBjb25zdCB5TWluID0gTWF0aC5taW4oLi4ueSkgLSB0aGlja25lc3M7XG4gICAgY29uc3QgeU1heCA9IE1hdGgubWF4KC4uLnkpICsgdGhpY2tuZXNzO1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eFxuICAgIH0gPSB0aGlzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgdGhpcy5iZXppZXJQYXRoMkQpIHtcbiAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UodGhpcy4jY3VycmVudFBhdGgyRCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICAjbWFrZUJlemllckN1cnZlKHBhdGgyRCwgeDAsIHkwLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGNvbnN0IHByZXZYID0gKHgwICsgeDEpIC8gMjtcbiAgICBjb25zdCBwcmV2WSA9ICh5MCArIHkxKSAvIDI7XG4gICAgY29uc3QgeDMgPSAoeDEgKyB4MikgLyAyO1xuICAgIGNvbnN0IHkzID0gKHkxICsgeTIpIC8gMjtcbiAgICBwYXRoMkQuYmV6aWVyQ3VydmVUbyhwcmV2WCArIDIgKiAoeDEgLSBwcmV2WCkgLyAzLCBwcmV2WSArIDIgKiAoeTEgLSBwcmV2WSkgLyAzLCB4MyArIDIgKiAoeDEgLSB4MykgLyAzLCB5MyArIDIgKiAoeTEgLSB5MykgLyAzLCB4MywgeTMpO1xuICB9XG4gICNnZW5lcmF0ZUJlemllclBvaW50cygpIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5jdXJyZW50UGF0aDtcbiAgICBpZiAocGF0aC5sZW5ndGggPD0gMikge1xuICAgICAgcmV0dXJuIFtbcGF0aFswXSwgcGF0aFswXSwgcGF0aC5hdCgtMSksIHBhdGguYXQoLTEpXV07XG4gICAgfVxuICAgIGNvbnN0IGJlemllclBvaW50cyA9IFtdO1xuICAgIGxldCBpO1xuICAgIGxldCBbeDAsIHkwXSA9IHBhdGhbMF07XG4gICAgZm9yIChpID0gMTsgaSA8IHBhdGgubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICBjb25zdCBbeDEsIHkxXSA9IHBhdGhbaV07XG4gICAgICBjb25zdCBbeDIsIHkyXSA9IHBhdGhbaSArIDFdO1xuICAgICAgY29uc3QgeDMgPSAoeDEgKyB4MikgLyAyO1xuICAgICAgY29uc3QgeTMgPSAoeTEgKyB5MikgLyAyO1xuICAgICAgY29uc3QgY29udHJvbDEgPSBbeDAgKyAyICogKHgxIC0geDApIC8gMywgeTAgKyAyICogKHkxIC0geTApIC8gM107XG4gICAgICBjb25zdCBjb250cm9sMiA9IFt4MyArIDIgKiAoeDEgLSB4MykgLyAzLCB5MyArIDIgKiAoeTEgLSB5MykgLyAzXTtcbiAgICAgIGJlemllclBvaW50cy5wdXNoKFtbeDAsIHkwXSwgY29udHJvbDEsIGNvbnRyb2wyLCBbeDMsIHkzXV0pO1xuICAgICAgW3gwLCB5MF0gPSBbeDMsIHkzXTtcbiAgICB9XG4gICAgY29uc3QgW3gxLCB5MV0gPSBwYXRoW2ldO1xuICAgIGNvbnN0IFt4MiwgeTJdID0gcGF0aFtpICsgMV07XG4gICAgY29uc3QgY29udHJvbDEgPSBbeDAgKyAyICogKHgxIC0geDApIC8gMywgeTAgKyAyICogKHkxIC0geTApIC8gM107XG4gICAgY29uc3QgY29udHJvbDIgPSBbeDIgKyAyICogKHgxIC0geDIpIC8gMywgeTIgKyAyICogKHkxIC0geTIpIC8gM107XG4gICAgYmV6aWVyUG9pbnRzLnB1c2goW1t4MCwgeTBdLCBjb250cm9sMSwgY29udHJvbDIsIFt4MiwgeTJdXSk7XG4gICAgcmV0dXJuIGJlemllclBvaW50cztcbiAgfVxuICAjcmVkcmF3KCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy4jdXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NldFN0cm9rZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIGN0eFxuICAgIH0gPSB0aGlzO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuI3VwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLmJlemllclBhdGgyRCkge1xuICAgICAgY3R4LnN0cm9rZShwYXRoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5jb21taXQoKTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICB0aGlzLiNkaXNhYmxlRWRpdGluZyA9IHRydWU7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImRpc2FibGVkXCIpO1xuICAgIHRoaXMuI2ZpdFRvQ29udGVudCh0cnVlKTtcbiAgICB0aGlzLnNlbGVjdCgpO1xuICAgIHRoaXMucGFyZW50LmFkZElua0VkaXRvcklmTmVlZGVkKHRydWUpO1xuICAgIHRoaXMubW92ZUluRE9NKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5mb2N1c2luKGV2ZW50KTtcbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gIH1cbiAgI2FkZFBvaW50ZXJkb3duTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMuI3BvaW50ZXJkb3duQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcG9pbnRlcmRvd25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jcG9pbnRlcmRvd25BQyk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuY2FudmFzUG9pbnRlcmRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZVBvaW50ZXJkb3duTGlzdGVuZXIoKSB7XG4gICAgdGhpcy5wb2ludGVyZG93bkFDPy5hYm9ydCgpO1xuICAgIHRoaXMucG9pbnRlcmRvd25BQyA9IG51bGw7XG4gIH1cbiAgY2FudmFzUG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8ICF0aGlzLmlzSW5FZGl0TW9kZSgpIHx8IHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLiNzdGFydERyYXdpbmcoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gIH1cbiAgY2FudmFzUG9pbnRlcm1vdmUoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2RyYXcoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gIH1cbiAgY2FudmFzUG9pbnRlcnVwKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiNlbmREcmF3aW5nKGV2ZW50KTtcbiAgfVxuICBjYW52YXNQb2ludGVybGVhdmUoZXZlbnQpIHtcbiAgICB0aGlzLiNlbmREcmF3aW5nKGV2ZW50KTtcbiAgfVxuICAjZW5kRHJhd2luZyhldmVudCkge1xuICAgIHRoaXMuI2RyYXdpbmdBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNkcmF3aW5nQUMgPSBudWxsO1xuICAgIHRoaXMuI2FkZFBvaW50ZXJkb3duTGlzdGVuZXIoKTtcbiAgICBpZiAodGhpcy4jY2FudmFzQ29udGV4dE1lbnVUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNjYW52YXNDb250ZXh0TWVudVRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRoaXMuI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNjYW52YXNDb250ZXh0TWVudVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSk7XG4gICAgfSwgMTApO1xuICAgIHRoaXMuI3N0b3BEcmF3aW5nKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpO1xuICAgIHRoaXMuc2V0SW5CYWNrZ3JvdW5kKCk7XG4gIH1cbiAgI2NyZWF0ZUNhbnZhcygpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuY2FudmFzLmNsYXNzTmFtZSA9IFwiaW5rRWRpdG9yQ2FudmFzXCI7XG4gICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtaW5rLWNhbnZhc1wiKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5jYW52YXMpO1xuICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICB9XG4gICNjcmVhdGVPYnNlcnZlcigpIHtcbiAgICB0aGlzLiNvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0O1xuICAgICAgaWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiNvYnNlcnZlci5vYnNlcnZlKHRoaXMuZGl2KTtcbiAgICB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jb2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuI29ic2VydmVyID0gbnVsbDtcbiAgICB9LCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0VtcHR5KCkgJiYgdGhpcy4jZGlzYWJsZUVkaXRpbmc7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1pbmtcIik7XG4gICAgY29uc3QgW3gsIHksIHcsIGhdID0gdGhpcy4jZ2V0SW5pdGlhbEJCb3goKTtcbiAgICB0aGlzLnNldEF0KHgsIHksIDAsIDApO1xuICAgIHRoaXMuc2V0RGltcyh3LCBoKTtcbiAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXRBc3BlY3RSYXRpbyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImVkaXRpbmdcIik7XG4gICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gICNzZXRDYW52YXNEaW1zKCkge1xuICAgIGlmICghdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmNlaWwodGhpcy53aWR0aCAqIHBhcmVudFdpZHRoKTtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIHRoaXMuI3VwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJvdW5kZWRXaWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGNvbnN0IHJvdW5kZWRIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgaWYgKHRoaXMuI3JlYWxXaWR0aCA9PT0gcm91bmRlZFdpZHRoICYmIHRoaXMuI3JlYWxIZWlnaHQgPT09IHJvdW5kZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVhbFdpZHRoID0gcm91bmRlZFdpZHRoO1xuICAgIHRoaXMuI3JlYWxIZWlnaHQgPSByb3VuZGVkSGVpZ2h0O1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNzZXRTY2FsZUZhY3Rvcih3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIHRoaXMuI3JlZHJhdygpO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICB0aGlzLmZpeERpbXMoKTtcbiAgfVxuICAjc2V0U2NhbGVGYWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCk7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JXID0gKHdpZHRoIC0gcGFkZGluZykgLyB0aGlzLiNiYXNlV2lkdGg7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JIID0gKGhlaWdodCAtIHBhZGRpbmcpIC8gdGhpcy4jYmFzZUhlaWdodDtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gTWF0aC5taW4oc2NhbGVGYWN0b3JXLCBzY2FsZUZhY3RvckgpO1xuICB9XG4gICN1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuI2dldFBhZGRpbmcoKSAvIDI7XG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHRoaXMuc2NhbGVGYWN0b3IsIDAsIDAsIHRoaXMuc2NhbGVGYWN0b3IsIHRoaXMudHJhbnNsYXRpb25YICogdGhpcy5zY2FsZUZhY3RvciArIHBhZGRpbmcsIHRoaXMudHJhbnNsYXRpb25ZICogdGhpcy5zY2FsZUZhY3RvciArIHBhZGRpbmcpO1xuICB9XG4gIHN0YXRpYyAjYnVpbGRQYXRoMkQoYmV6aWVyKSB7XG4gICAgY29uc3QgcGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJlemllci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSA9IGJlemllcltpXTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uZmlyc3QpO1xuICAgICAgfVxuICAgICAgcGF0aDJELmJlemllckN1cnZlVG8oY29udHJvbDFbMF0sIGNvbnRyb2wxWzFdLCBjb250cm9sMlswXSwgY29udHJvbDJbMV0sIHNlY29uZFswXSwgc2Vjb25kWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgyRDtcbiAgfVxuICBzdGF0aWMgI3RvUERGQ29vcmRpbmF0ZXMocG9pbnRzLCByZWN0LCByb3RhdGlvbikge1xuICAgIGNvbnN0IFtibFgsIGJsWSwgdHJYLCB0clldID0gcmVjdDtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldICs9IGJsWDtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0gdHJZIC0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSBwb2ludHNbaSArIDFdICsgYmxYO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB4ICsgYmxZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldID0gdHJYIC0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gKz0gYmxZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clggLSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSB4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBzdGF0aWMgI2Zyb21QREZDb29yZGluYXRlcyhwb2ludHMsIHJlY3QsIHJvdGF0aW9uKSB7XG4gICAgY29uc3QgW2JsWCwgYmxZLCB0clgsIHRyWV0gPSByZWN0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gLT0gYmxYO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSBwb2ludHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHBvaW50c1tpICsgMV0gLSBibFk7XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHggLSBibFg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clggLSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSAtPSBibFk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHRyWSAtIHBvaW50c1tpICsgMV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWCAtIHg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gICNzZXJpYWxpemVQYXRocyhzLCB0eCwgdHksIHJlY3QpIHtcbiAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnRoaWNrbmVzcyAvIDI7XG4gICAgY29uc3Qgc2hpZnRYID0gcyAqIHR4ICsgcGFkZGluZztcbiAgICBjb25zdCBzaGlmdFkgPSBzICogdHkgKyBwYWRkaW5nO1xuICAgIGZvciAoY29uc3QgYmV6aWVyIG9mIHRoaXMucGF0aHMpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSBiZXppZXIubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSA9IGJlemllcltqXTtcbiAgICAgICAgaWYgKGZpcnN0WzBdID09PSBzZWNvbmRbMF0gJiYgZmlyc3RbMV0gPT09IHNlY29uZFsxXSAmJiBqaiA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IHAwID0gcyAqIGZpcnN0WzBdICsgc2hpZnRYO1xuICAgICAgICAgIGNvbnN0IHAxID0gcyAqIGZpcnN0WzFdICsgc2hpZnRZO1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHAwLCBwMSk7XG4gICAgICAgICAgcG9pbnRzLnB1c2gocDAsIHAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwMTAgPSBzICogZmlyc3RbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHAxMSA9IHMgKiBmaXJzdFsxXSArIHNoaWZ0WTtcbiAgICAgICAgY29uc3QgcDIwID0gcyAqIGNvbnRyb2wxWzBdICsgc2hpZnRYO1xuICAgICAgICBjb25zdCBwMjEgPSBzICogY29udHJvbDFbMV0gKyBzaGlmdFk7XG4gICAgICAgIGNvbnN0IHAzMCA9IHMgKiBjb250cm9sMlswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDMxID0gcyAqIGNvbnRyb2wyWzFdICsgc2hpZnRZO1xuICAgICAgICBjb25zdCBwNDAgPSBzICogc2Vjb25kWzBdICsgc2hpZnRYO1xuICAgICAgICBjb25zdCBwNDEgPSBzICogc2Vjb25kWzFdICsgc2hpZnRZO1xuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHAxMCwgcDExKTtcbiAgICAgICAgICBwb2ludHMucHVzaChwMTAsIHAxMSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1c2gocDIwLCBwMjEsIHAzMCwgcDMxLCBwNDAsIHA0MSk7XG4gICAgICAgIHBvaW50cy5wdXNoKHAyMCwgcDIxKTtcbiAgICAgICAgaWYgKGogPT09IGpqIC0gMSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHA0MCwgcDQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgIGJlemllcjogSW5rRWRpdG9yLiN0b1BERkNvb3JkaW5hdGVzKGJ1ZmZlciwgcmVjdCwgdGhpcy5yb3RhdGlvbiksXG4gICAgICAgIHBvaW50czogSW5rRWRpdG9yLiN0b1BERkNvb3JkaW5hdGVzKHBvaW50cywgcmVjdCwgdGhpcy5yb3RhdGlvbilcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG4gIH1cbiAgI2dldEJib3goKSB7XG4gICAgbGV0IHhNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgeE1heCA9IC1JbmZpbml0eTtcbiAgICBsZXQgeU1pbiA9IEluZmluaXR5O1xuICAgIGxldCB5TWF4ID0gLUluZmluaXR5O1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLnBhdGhzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtmaXJzdCwgY29udHJvbDEsIGNvbnRyb2wyLCBzZWNvbmRdIG9mIHBhdGgpIHtcbiAgICAgICAgY29uc3QgYmJveCA9IFV0aWwuYmV6aWVyQm91bmRpbmdCb3goLi4uZmlyc3QsIC4uLmNvbnRyb2wxLCAuLi5jb250cm9sMiwgLi4uc2Vjb25kKTtcbiAgICAgICAgeE1pbiA9IE1hdGgubWluKHhNaW4sIGJib3hbMF0pO1xuICAgICAgICB5TWluID0gTWF0aC5taW4oeU1pbiwgYmJveFsxXSk7XG4gICAgICAgIHhNYXggPSBNYXRoLm1heCh4TWF4LCBiYm94WzJdKTtcbiAgICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIGJib3hbM10pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3hNaW4sIHlNaW4sIHhNYXgsIHlNYXhdO1xuICB9XG4gICNnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNkaXNhYmxlRWRpdGluZyA/IE1hdGguY2VpbCh0aGlzLnRoaWNrbmVzcyAqIHRoaXMucGFyZW50U2NhbGUpIDogMDtcbiAgfVxuICAjZml0VG9Db250ZW50KGZpcnN0VGltZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jZ2V0QmJveCgpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCk7XG4gICAgdGhpcy4jYmFzZVdpZHRoID0gTWF0aC5tYXgoQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFsyXSAtIGJib3hbMF0pO1xuICAgIHRoaXMuI2Jhc2VIZWlnaHQgPSBNYXRoLm1heChBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFLCBiYm94WzNdIC0gYmJveFsxXSk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwocGFkZGluZyArIHRoaXMuI2Jhc2VXaWR0aCAqIHRoaXMuc2NhbGVGYWN0b3IpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChwYWRkaW5nICsgdGhpcy4jYmFzZUhlaWdodCAqIHRoaXMuc2NhbGVGYWN0b3IpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLnNldEFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHByZXZUcmFuc2xhdGlvblggPSB0aGlzLnRyYW5zbGF0aW9uWDtcbiAgICBjb25zdCBwcmV2VHJhbnNsYXRpb25ZID0gdGhpcy50cmFuc2xhdGlvblk7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSAtYmJveFswXTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IC1iYm94WzFdO1xuICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICB0aGlzLiNyZWFsV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLiNyZWFsSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB1bnNjYWxlZFBhZGRpbmcgPSBmaXJzdFRpbWUgPyBwYWRkaW5nIC8gdGhpcy5zY2FsZUZhY3RvciAvIDIgOiAwO1xuICAgIHRoaXMudHJhbnNsYXRlKHByZXZUcmFuc2xhdGlvblggLSB0aGlzLnRyYW5zbGF0aW9uWCAtIHVuc2NhbGVkUGFkZGluZywgcHJldlRyYW5zbGF0aW9uWSAtIHRoaXMudHJhbnNsYXRpb25ZIC0gdW5zY2FsZWRQYWRkaW5nKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIElua0Fubm90YXRpb25FbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci50aGlja25lc3MgPSBkYXRhLnRoaWNrbmVzcztcbiAgICBlZGl0b3IuY29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5kYXRhLmNvbG9yKTtcbiAgICBlZGl0b3Iub3BhY2l0eSA9IGRhdGEub3BhY2l0eTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCB3aWR0aCA9IGVkaXRvci53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlZGl0b3IuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IGVkaXRvci5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCBwYWRkaW5nID0gZGF0YS50aGlja25lc3MgLyAyO1xuICAgIGVkaXRvci4jZGlzYWJsZUVkaXRpbmcgPSB0cnVlO1xuICAgIGVkaXRvci4jcmVhbFdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgZWRpdG9yLiNyZWFsSGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhzLFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgZm9yIChsZXQge1xuICAgICAgYmV6aWVyXG4gICAgfSBvZiBwYXRocykge1xuICAgICAgYmV6aWVyID0gSW5rRWRpdG9yLiNmcm9tUERGQ29vcmRpbmF0ZXMoYmV6aWVyLCByZWN0LCByb3RhdGlvbik7XG4gICAgICBjb25zdCBwYXRoID0gW107XG4gICAgICBlZGl0b3IucGF0aHMucHVzaChwYXRoKTtcbiAgICAgIGxldCBwMCA9IHNjYWxlRmFjdG9yICogKGJlemllclswXSAtIHBhZGRpbmcpO1xuICAgICAgbGV0IHAxID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyWzFdIC0gcGFkZGluZyk7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBiZXppZXIubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICBjb25zdCBwMTAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaV0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDExID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyAxXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMjAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDJdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAyMSA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgM10gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDMwID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyA0XSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMzEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDVdIC0gcGFkZGluZyk7XG4gICAgICAgIHBhdGgucHVzaChbW3AwLCBwMV0sIFtwMTAsIHAxMV0sIFtwMjAsIHAyMV0sIFtwMzAsIHAzMV1dKTtcbiAgICAgICAgcDAgPSBwMzA7XG4gICAgICAgIHAxID0gcDMxO1xuICAgICAgfVxuICAgICAgY29uc3QgcGF0aDJEID0gdGhpcy4jYnVpbGRQYXRoMkQocGF0aCk7XG4gICAgICBlZGl0b3IuYmV6aWVyUGF0aDJELnB1c2gocGF0aDJEKTtcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IGVkaXRvci4jZ2V0QmJveCgpO1xuICAgIGVkaXRvci4jYmFzZVdpZHRoID0gTWF0aC5tYXgoQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFsyXSAtIGJib3hbMF0pO1xuICAgIGVkaXRvci4jYmFzZUhlaWdodCA9IE1hdGgubWF4KEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbM10gLSBiYm94WzFdKTtcbiAgICBlZGl0b3IuI3NldFNjYWxlRmFjdG9yKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFJlY3QoMCwgMCk7XG4gICAgY29uc3QgY29sb3IgPSBBbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLmN0eC5zdHJva2VTdHlsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkssXG4gICAgICBjb2xvcixcbiAgICAgIHRoaWNrbmVzczogdGhpcy50aGlja25lc3MsXG4gICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXG4gICAgICBwYXRoczogdGhpcy4jc2VyaWFsaXplUGF0aHModGhpcy5zY2FsZUZhY3RvciAvIHRoaXMucGFyZW50U2NhbGUsIHRoaXMudHJhbnNsYXRpb25YLCB0aGlzLnRyYW5zbGF0aW9uWSwgcmVjdCksXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9zdGFtcC5qc1xuXG5cblxuXG5jbGFzcyBTdGFtcEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYml0bWFwID0gbnVsbDtcbiAgI2JpdG1hcElkID0gbnVsbDtcbiAgI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAjYml0bWFwVXJsID0gbnVsbDtcbiAgI2JpdG1hcEZpbGUgPSBudWxsO1xuICAjYml0bWFwRmlsZU5hbWUgPSBcIlwiO1xuICAjY2FudmFzID0gbnVsbDtcbiAgI29ic2VydmVyID0gbnVsbDtcbiAgI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICNpc1N2ZyA9IGZhbHNlO1xuICAjaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgc3RhdGljIF90eXBlID0gXCJzdGFtcFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJzdGFtcEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jYml0bWFwVXJsID0gcGFyYW1zLmJpdG1hcFVybDtcbiAgICB0aGlzLiNiaXRtYXBGaWxlID0gcGFyYW1zLmJpdG1hcEZpbGU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0ZWRUeXBlcygpIHtcbiAgICBjb25zdCB0eXBlcyA9IFtcImFwbmdcIiwgXCJhdmlmXCIsIFwiYm1wXCIsIFwiZ2lmXCIsIFwianBlZ1wiLCBcInBuZ1wiLCBcInN2Zyt4bWxcIiwgXCJ3ZWJwXCIsIFwieC1pY29uXCJdO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJzdXBwb3J0ZWRUeXBlc1wiLCB0eXBlcy5tYXAodHlwZSA9PiBgaW1hZ2UvJHt0eXBlfWApKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRlZFR5cGVzU3RyKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJzdXBwb3J0ZWRUeXBlc1N0clwiLCB0aGlzLnN1cHBvcnRlZFR5cGVzLmpvaW4oXCIsXCIpKTtcbiAgfVxuICBzdGF0aWMgaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKG1pbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRUeXBlcy5pbmNsdWRlcyhtaW1lKTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgcGFyZW50LnBhc3RlRWRpdG9yKEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLCB7XG4gICAgICBiaXRtYXBGaWxlOiBpdGVtLmdldEFzRmlsZSgpXG4gICAgfSk7XG4gIH1cbiAgYWx0VGV4dEZpbmlzaCgpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgc3VwZXIuYWx0VGV4dEZpbmlzaCgpO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RhbXBcIixcbiAgICAgIGhhc0FsdFRleHQ6ICEhdGhpcy5hbHRUZXh0RGF0YT8uYWx0VGV4dFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoZGF0YSkge1xuICAgIGNvbnN0IGhhc0FsdFRleHRTdGF0cyA9IGRhdGEuZ2V0KFwiaGFzQWx0VGV4dFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQWx0VGV4dDogaGFzQWx0VGV4dFN0YXRzLmdldCh0cnVlKSA/PyAwLFxuICAgICAgaGFzTm9BbHRUZXh0OiBoYXNBbHRUZXh0U3RhdHMuZ2V0KGZhbHNlKSA/PyAwXG4gICAgfTtcbiAgfVxuICAjZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCBmcm9tSWQgPSBmYWxzZSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYml0bWFwID0gZGF0YS5iaXRtYXA7XG4gICAgaWYgKCFmcm9tSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gZGF0YS5pZDtcbiAgICAgIHRoaXMuI2lzU3ZnID0gZGF0YS5pc1N2ZztcbiAgICB9XG4gICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgdGhpcy4jYml0bWFwRmlsZU5hbWUgPSBkYXRhLmZpbGUubmFtZTtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gIH1cbiAgI2dldEJpdG1hcERvbmUoKSB7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGlmICghdGhpcy4jY2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSAmJiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgJiYgdGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLl9lZGl0VG9vbGJhci5oaWRlKCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcywgdHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgJiYgdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93ICYmIHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmltYWdlX2FkZGVkXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBhbHRfdGV4dF9tb2RhbDogZmFsc2UsXG4gICAgICAgICAgYWx0X3RleHRfdHlwZTogXCJlbXB0eVwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5tbEd1ZXNzQWx0VGV4dCgpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIGFzeW5jIG1sR3Vlc3NBbHRUZXh0KGltYWdlRGF0YSA9IG51bGwsIHVwZGF0ZUFsdFRleHREYXRhID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmhhc0FsdFRleHREYXRhKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtbE1hbmFnZXJcbiAgICB9ID0gdGhpcy5fdWlNYW5hZ2VyO1xuICAgIGlmICghbWxNYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBNTC5cIik7XG4gICAgfVxuICAgIGlmICghKGF3YWl0IG1sTWFuYWdlci5pc0VuYWJsZWRGb3IoXCJhbHRUZXh0XCIpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTUwgaXNuJ3QgZW5hYmxlZCBmb3IgYWx0IHRleHQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1hZ2VEYXRhIHx8IHRoaXMuY29weUNhbnZhcyhudWxsLCBudWxsLCB0cnVlKS5pbWFnZURhdGE7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtbE1hbmFnZXIuZ3Vlc3Moe1xuICAgICAgbmFtZTogXCJhbHRUZXh0XCIsXG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNoYW5uZWxzOiBkYXRhLmxlbmd0aCAvICh3aWR0aCAqIGhlaWdodClcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmNhbmNlbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub3V0cHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCByZXNwb25zZSBmcm9tIHRoZSBBSSBzZXJ2aWNlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgYWx0VGV4dCA9IHJlc3BvbnNlLm91dHB1dDtcbiAgICBhd2FpdCB0aGlzLnNldEd1ZXNzZWRBbHRUZXh0KGFsdFRleHQpO1xuICAgIGlmICh1cGRhdGVBbHRUZXh0RGF0YSAmJiAhdGhpcy5oYXNBbHRUZXh0RGF0YSgpKSB7XG4gICAgICB0aGlzLmFsdFRleHREYXRhID0ge1xuICAgICAgICBhbHQ6IGFsdFRleHQsXG4gICAgICAgIGRlY29yYXRpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYWx0VGV4dDtcbiAgfVxuICAjZ2V0Qml0bWFwKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21JZCh0aGlzLiNiaXRtYXBJZCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSwgdHJ1ZSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcFVybCkge1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jYml0bWFwVXJsO1xuICAgICAgdGhpcy4jYml0bWFwVXJsID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbVVybCh1cmwpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlKSB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy4jYml0bWFwRmlsZTtcbiAgICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShmaWxlKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgaW5wdXQuYWNjZXB0ID0gU3RhbXBFZGl0b3Iuc3VwcG9ydGVkVHlwZXNTdHI7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghaW5wdXQuZmlsZXMgfHwgaW5wdXQuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShpbnB1dC5maWxlc1swXSk7XG4gICAgICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5pbWFnZV9zZWxlY3RlZFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBhbHRfdGV4dF9tb2RhbDogdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2FuY2VsXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICBpbnB1dC5jbGljaygpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcCA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmRlbGV0ZUlkKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIHRoaXMuI2NhbnZhcz8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNjYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy4jb2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuI29ic2VydmVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLiNyZXNpemVUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBJZCAmJiB0aGlzLiNjYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZCgpIHtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhKHRoaXMuI2JpdG1hcFByb21pc2UgfHwgdGhpcy4jYml0bWFwIHx8IHRoaXMuI2JpdG1hcFVybCB8fCB0aGlzLiNiaXRtYXBGaWxlIHx8IHRoaXMuI2JpdG1hcElkKTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmRpdi5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJmaWd1cmVcIik7XG4gICAgdGhpcy5hZGRBbHRUZXh0QnV0dG9uKCk7XG4gICAgaWYgKHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy53aWR0aCAmJiAhdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gICNjcmVhdGVDYW52YXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgTUFYX1JBVElPID0gMC43NTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgd2lkdGggPSB0aGlzLndpZHRoICogcGFnZVdpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAod2lkdGggPiBNQVhfUkFUSU8gKiBwYWdlV2lkdGggfHwgaGVpZ2h0ID4gTUFYX1JBVElPICogcGFnZUhlaWdodCkge1xuICAgICAgY29uc3QgZmFjdG9yID0gTWF0aC5taW4oTUFYX1JBVElPICogcGFnZVdpZHRoIC8gd2lkdGgsIE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQgLyBoZWlnaHQpO1xuICAgICAgd2lkdGggKj0gZmFjdG9yO1xuICAgICAgaGVpZ2h0ICo9IGZhY3RvcjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyh3aWR0aCAqIHBhcmVudFdpZHRoIC8gcGFnZVdpZHRoLCBoZWlnaHQgKiBwYXJlbnRIZWlnaHQgLyBwYWdlSGVpZ2h0KTtcbiAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyhmYWxzZSk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKTtcbiAgICB0aGlzLmFkZENvbnRhaW5lcihjYW52YXMpO1xuICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgfHwgIXRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdyB8fCB0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jZHJhd0JpdG1hcCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLiNjcmVhdGVPYnNlcnZlcigpO1xuICAgIGlmICghdGhpcy4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgICAgdGhpcy4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcImluc2VydGVkX2ltYWdlXCJcbiAgICB9KTtcbiAgICBpZiAodGhpcy4jYml0bWFwRmlsZU5hbWUpIHtcbiAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMuI2JpdG1hcEZpbGVOYW1lKTtcbiAgICB9XG4gIH1cbiAgY29weUNhbnZhcyhtYXhEYXRhRGltZW5zaW9uLCBtYXhQcmV2aWV3RGltZW5zaW9uLCBjcmVhdGVJbWFnZURhdGEgPSBmYWxzZSkge1xuICAgIGlmICghbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgbWF4RGF0YURpbWVuc2lvbiA9IDIyNDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGNvbnN0IG91dHB1dFNjYWxlID0gbmV3IE91dHB1dFNjYWxlKCk7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICBsZXQgd2lkdGggPSBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodCA9IGJpdG1hcEhlaWdodDtcbiAgICBsZXQgY2FudmFzID0gbnVsbDtcbiAgICBpZiAobWF4UHJldmlld0RpbWVuc2lvbikge1xuICAgICAgaWYgKGJpdG1hcFdpZHRoID4gbWF4UHJldmlld0RpbWVuc2lvbiB8fCBiaXRtYXBIZWlnaHQgPiBtYXhQcmV2aWV3RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4UHJldmlld0RpbWVuc2lvbiAvIGJpdG1hcFdpZHRoLCBtYXhQcmV2aWV3RGltZW5zaW9uIC8gYml0bWFwSGVpZ2h0KTtcbiAgICAgICAgd2lkdGggPSBNYXRoLmZsb29yKGJpdG1hcFdpZHRoICogcmF0aW8pO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGJpdG1hcEhlaWdodCAqIHJhdGlvKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIG91dHB1dFNjYWxlLnN4KTtcbiAgICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogb3V0cHV0U2NhbGUuc3kpO1xuICAgICAgaWYgKCF0aGlzLiNpc1N2Zykge1xuICAgICAgICBiaXRtYXAgPSB0aGlzLiNzY2FsZUJpdG1hcChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZmlsdGVyID0gdGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlcjtcbiAgICAgIGxldCB3aGl0ZSA9IFwid2hpdGVcIixcbiAgICAgICAgYmxhY2sgPSBcIiNjZmNmZDhcIjtcbiAgICAgIGlmICh0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyICE9PSBcIm5vbmVcIikge1xuICAgICAgICBibGFjayA9IFwiYmxhY2tcIjtcbiAgICAgIH0gZWxzZSBpZiAod2luZG93Lm1hdGNoTWVkaWE/LihcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcykge1xuICAgICAgICB3aGl0ZSA9IFwiIzhmOGY5ZFwiO1xuICAgICAgICBibGFjayA9IFwiIzQyNDE0ZFwiO1xuICAgICAgfVxuICAgICAgY29uc3QgYm94RGltID0gMTU7XG4gICAgICBjb25zdCBib3hEaW1XaWR0aCA9IGJveERpbSAqIG91dHB1dFNjYWxlLnN4O1xuICAgICAgY29uc3QgYm94RGltSGVpZ2h0ID0gYm94RGltICogb3V0cHV0U2NhbGUuc3k7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhib3hEaW1XaWR0aCAqIDIsIGJveERpbUhlaWdodCAqIDIpO1xuICAgICAgY29uc3QgcGF0dGVybkN0eCA9IHBhdHRlcm4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSB3aGl0ZTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoMCwgMCwgYm94RGltV2lkdGggKiAyLCBib3hEaW1IZWlnaHQgKiAyKTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gYmxhY2s7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KDAsIDAsIGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQpO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdChib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0LCBib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuLCBcInJlcGVhdFwiKTtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIH1cbiAgICBsZXQgaW1hZ2VEYXRhID0gbnVsbDtcbiAgICBpZiAoY3JlYXRlSW1hZ2VEYXRhKSB7XG4gICAgICBsZXQgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0O1xuICAgICAgaWYgKG91dHB1dFNjYWxlLnN5bW1ldHJpYyAmJiBiaXRtYXAud2lkdGggPCBtYXhEYXRhRGltZW5zaW9uICYmIGJpdG1hcC5oZWlnaHQgPCBtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICAgIGRhdGFXaWR0aCA9IGJpdG1hcC53aWR0aDtcbiAgICAgICAgZGF0YUhlaWdodCA9IGJpdG1hcC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgICAgIGlmIChiaXRtYXBXaWR0aCA+IG1heERhdGFEaW1lbnNpb24gfHwgYml0bWFwSGVpZ2h0ID4gbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4RGF0YURpbWVuc2lvbiAvIGJpdG1hcFdpZHRoLCBtYXhEYXRhRGltZW5zaW9uIC8gYml0bWFwSGVpZ2h0KTtcbiAgICAgICAgICBkYXRhV2lkdGggPSBNYXRoLmZsb29yKGJpdG1hcFdpZHRoICogcmF0aW8pO1xuICAgICAgICAgIGRhdGFIZWlnaHQgPSBNYXRoLmZsb29yKGJpdG1hcEhlaWdodCAqIHJhdGlvKTtcbiAgICAgICAgICBpZiAoIXRoaXMuI2lzU3ZnKSB7XG4gICAgICAgICAgICBiaXRtYXAgPSB0aGlzLiNzY2FsZUJpdG1hcChkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuQ3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBvZmZzY3JlZW5DdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgaW1hZ2VEYXRhID0ge1xuICAgICAgICB3aWR0aDogZGF0YVdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGRhdGFIZWlnaHQsXG4gICAgICAgIGRhdGE6IG9mZnNjcmVlbkN0eC5nZXRJbWFnZURhdGEoMCwgMCwgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KS5kYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBpbWFnZURhdGFcbiAgICB9O1xuICB9XG4gICNzZXREaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0gbnVsbDtcbiAgICBpZiAodGhpcy4jcmVzaXplVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jcmVzaXplVGltZW91dElkKTtcbiAgICB9XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMjAwO1xuICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuI2RyYXdCaXRtYXAod2lkdGgsIGhlaWdodCk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgfVxuICAjc2NhbGVCaXRtYXAod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodDogYml0bWFwSGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBsZXQgbmV3V2lkdGggPSBiaXRtYXBXaWR0aDtcbiAgICBsZXQgbmV3SGVpZ2h0ID0gYml0bWFwSGVpZ2h0O1xuICAgIGxldCBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgd2hpbGUgKG5ld1dpZHRoID4gMiAqIHdpZHRoIHx8IG5ld0hlaWdodCA+IDIgKiBoZWlnaHQpIHtcbiAgICAgIGNvbnN0IHByZXZXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgY29uc3QgcHJldkhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIGlmIChuZXdXaWR0aCA+IDIgKiB3aWR0aCkge1xuICAgICAgICBuZXdXaWR0aCA9IG5ld1dpZHRoID49IDE2Mzg0ID8gTWF0aC5mbG9vcihuZXdXaWR0aCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdXaWR0aCAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0hlaWdodCA+IDIgKiBoZWlnaHQpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0ID49IDE2Mzg0ID8gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKSAtIDEgOiBNYXRoLmNlaWwobmV3SGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgYml0bWFwID0gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gYml0bWFwO1xuICB9XG4gICNkcmF3Qml0bWFwKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBvdXRwdXRTY2FsZSA9IG5ldyBPdXRwdXRTY2FsZSgpO1xuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogb3V0cHV0U2NhbGUuc3gpO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBvdXRwdXRTY2FsZS5zeSk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzO1xuICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gc2NhbGVkV2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gc2NhbGVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzY2FsZWRIZWlnaHQ7XG4gICAgY29uc3QgYml0bWFwID0gdGhpcy4jaXNTdmcgPyB0aGlzLiNiaXRtYXAgOiB0aGlzLiNzY2FsZUJpdG1hcChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICB9XG4gIGdldEltYWdlRm9yQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FudmFzO1xuICB9XG4gICNzZXJpYWxpemVCaXRtYXAodG9VcmwpIHtcbiAgICBpZiAodG9VcmwpIHtcbiAgICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldFN2Z1VybCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgKHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jYml0bWFwKTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCk7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogcGFnZVdpZHRoICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0ICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDAsIHRoaXMuI2JpdG1hcC53aWR0aCwgdGhpcy4jYml0bWFwLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXMuI2JpdG1hcCk7XG4gIH1cbiAgI2NyZWF0ZU9ic2VydmVyKCkge1xuICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBjb25zdCByZWN0ID0gZW50cmllc1swXS5jb250ZW50UmVjdDtcbiAgICAgIGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuI3NldERpbWVuc2lvbnMocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI29ic2VydmVyLm9ic2VydmUodGhpcy5kaXYpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiNvYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy4jb2JzZXJ2ZXIgPSBudWxsO1xuICAgIH0sIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBzdHJ1Y3RQYXJlbnQsXG4gICAgICAgICAgcG9wdXBSZWZcbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiY2FudmFzXCIpO1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tQ2FudmFzKGNvbnRhaW5lci5pZCwgY2FudmFzKTtcbiAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgIGNvbnN0IGFsdFRleHQgPSAoYXdhaXQgcGFyZW50Ll9zdHJ1Y3RUcmVlLmdldEFyaWFBdHRyaWJ1dGVzKGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gKSk/LmdldChcImFyaWEtbGFiZWxcIikgfHwgXCJcIjtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLFxuICAgICAgICBiaXRtYXBJZDogaW1hZ2VEYXRhLmlkLFxuICAgICAgICBiaXRtYXA6IGltYWdlRGF0YS5iaXRtYXAsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIGFjY2Vzc2liaWxpdHlEYXRhOiB7XG4gICAgICAgICAgZGVjb3JhdGl2ZTogZmFsc2UsXG4gICAgICAgICAgYWx0VGV4dFxuICAgICAgICB9LFxuICAgICAgICBpc1N2ZzogZmFsc2UsXG4gICAgICAgIHN0cnVjdFBhcmVudCxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBjb25zdCB7XG4gICAgICByZWN0LFxuICAgICAgYml0bWFwLFxuICAgICAgYml0bWFwVXJsLFxuICAgICAgYml0bWFwSWQsXG4gICAgICBpc1N2ZyxcbiAgICAgIGFjY2Vzc2liaWxpdHlEYXRhXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGJpdG1hcElkICYmIHVpTWFuYWdlci5pbWFnZU1hbmFnZXIuaXNWYWxpZElkKGJpdG1hcElkKSkge1xuICAgICAgZWRpdG9yLiNiaXRtYXBJZCA9IGJpdG1hcElkO1xuICAgICAgaWYgKGJpdG1hcCkge1xuICAgICAgICBlZGl0b3IuI2JpdG1hcCA9IGJpdG1hcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLiNiaXRtYXBVcmwgPSBiaXRtYXBVcmw7XG4gICAgfVxuICAgIGVkaXRvci4jaXNTdmcgPSBpc1N2ZztcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgZWRpdG9yLndpZHRoID0gKHJlY3RbMl0gLSByZWN0WzBdKSAvIHBhcmVudFdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSAocmVjdFszXSAtIHJlY3RbMV0pIC8gcGFyZW50SGVpZ2h0O1xuICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZGF0YS5pZCB8fCBudWxsO1xuICAgIGlmIChhY2Nlc3NpYmlsaXR5RGF0YSkge1xuICAgICAgZWRpdG9yLmFsdFRleHREYXRhID0gYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgfVxuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBlZGl0b3IuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gISFpbml0aWFsRGF0YTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSwgY29udGV4dCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsXG4gICAgICBiaXRtYXBJZDogdGhpcy4jYml0bWFwSWQsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdDogdGhpcy5nZXRSZWN0KDAsIDApLFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBpc1N2ZzogdGhpcy4jaXNTdmcsXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXBVcmwgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAodHJ1ZSk7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0gdGhpcy5zZXJpYWxpemVBbHRUZXh0KHRydWUpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRlY29yYXRpdmUsXG4gICAgICBhbHRUZXh0XG4gICAgfSA9IHRoaXMuc2VyaWFsaXplQWx0VGV4dChmYWxzZSk7XG4gICAgaWYgKCFkZWNvcmF0aXZlICYmIGFsdFRleHQpIHtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwiRmlndXJlXCIsXG4gICAgICAgIGFsdDogYWx0VGV4dFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpO1xuICAgICAgaWYgKGNoYW5nZXMuaXNTYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZXMuaXNTYW1lQWx0VGV4dCkge1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEuc3RydWN0UGFyZW50ID0gdGhpcy5faW5pdGlhbERhdGEuc3RydWN0UGFyZW50ID8/IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29udGV4dC5zdGFtcHMgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBhcmVhID0gdGhpcy4jaXNTdmcgPyAoc2VyaWFsaXplZC5yZWN0WzJdIC0gc2VyaWFsaXplZC5yZWN0WzBdKSAqIChzZXJpYWxpemVkLnJlY3RbM10gLSBzZXJpYWxpemVkLnJlY3RbMV0pIDogbnVsbDtcbiAgICBpZiAoIWNvbnRleHQuc3RhbXBzLmhhcyh0aGlzLiNiaXRtYXBJZCkpIHtcbiAgICAgIGNvbnRleHQuc3RhbXBzLnNldCh0aGlzLiNiaXRtYXBJZCwge1xuICAgICAgICBhcmVhLFxuICAgICAgICBzZXJpYWxpemVkXG4gICAgICB9KTtcbiAgICAgIHNlcmlhbGl6ZWQuYml0bWFwID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICBjb25zdCBwcmV2RGF0YSA9IGNvbnRleHQuc3RhbXBzLmdldCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICBpZiAoYXJlYSA+IHByZXZEYXRhLmFyZWEpIHtcbiAgICAgICAgcHJldkRhdGEuYXJlYSA9IGFyZWE7XG4gICAgICAgIHByZXZEYXRhLnNlcmlhbGl6ZWQuYml0bWFwLmNsb3NlKCk7XG4gICAgICAgIHByZXZEYXRhLnNlcmlhbGl6ZWQuYml0bWFwID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICByZWN0LFxuICAgICAgcGFnZUluZGV4LFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgYWx0VGV4dFxuICAgICAgfVxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICBjb25zdCBpc1NhbWVSZWN0ID0gc2VyaWFsaXplZC5yZWN0LmV2ZXJ5KCh4LCBpKSA9PiBNYXRoLmFicyh4IC0gcmVjdFtpXSkgPCAxKTtcbiAgICBjb25zdCBpc1NhbWVQYWdlSW5kZXggPSBzZXJpYWxpemVkLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4O1xuICAgIGNvbnN0IGlzU2FtZUFsdFRleHQgPSAoc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YT8uYWx0IHx8IFwiXCIpID09PSBhbHRUZXh0O1xuICAgIHJldHVybiB7XG4gICAgICBpc1NhbWU6IGlzU2FtZVJlY3QgJiYgaXNTYW1lUGFnZUluZGV4ICYmIGlzU2FtZUFsdFRleHQsXG4gICAgICBpc1NhbWVBbHRUZXh0XG4gICAgfTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdDogdGhpcy5nZXRSZWN0KDAsIDApXG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2Fubm90YXRpb25fZWRpdG9yX2xheWVyLmpzXG5cblxuXG5cblxuXG5cbmNsYXNzIEFubm90YXRpb25FZGl0b3JMYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgI2FsbG93Q2xpY2sgPSBmYWxzZTtcbiAgI2Fubm90YXRpb25MYXllciA9IG51bGw7XG4gICNjbGlja0FDID0gbnVsbDtcbiAgI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgI2VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAjaXNDbGVhbmluZ1VwID0gZmFsc2U7XG4gICNpc0Rpc2FibGluZyA9IGZhbHNlO1xuICAjdGV4dExheWVyID0gbnVsbDtcbiAgI3RleHRTZWxlY3Rpb25BQyA9IG51bGw7XG4gICN1aU1hbmFnZXI7XG4gIHN0YXRpYyBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgc3RhdGljICNlZGl0b3JUeXBlcyA9IG5ldyBNYXAoW0ZyZWVUZXh0RWRpdG9yLCBJbmtFZGl0b3IsIFN0YW1wRWRpdG9yLCBIaWdobGlnaHRFZGl0b3JdLm1hcCh0eXBlID0+IFt0eXBlLl9lZGl0b3JUeXBlLCB0eXBlXSkpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdWlNYW5hZ2VyLFxuICAgIHBhZ2VJbmRleCxcbiAgICBkaXYsXG4gICAgc3RydWN0VHJlZUxheWVyLFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25MYXllcixcbiAgICBkcmF3TGF5ZXIsXG4gICAgdGV4dExheWVyLFxuICAgIHZpZXdwb3J0LFxuICAgIGwxMG5cbiAgfSkge1xuICAgIGNvbnN0IGVkaXRvclR5cGVzID0gWy4uLkFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCldO1xuICAgIGlmICghQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgZWRpdG9yVHlwZS5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHVpTWFuYWdlci5yZWdpc3RlckVkaXRvclR5cGVzKGVkaXRvclR5cGVzKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIgPSBhbm5vdGF0aW9uTGF5ZXI7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuI3RleHRMYXllciA9IHRleHRMYXllcjtcbiAgICB0aGlzLmRyYXdMYXllciA9IGRyYXdMYXllcjtcbiAgICB0aGlzLl9zdHJ1Y3RUcmVlID0gc3RydWN0VHJlZUxheWVyO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRMYXllcih0aGlzKTtcbiAgfVxuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdG9ycy5zaXplID09PSAwO1xuICB9XG4gIGdldCBpc0ludmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VtcHR5ICYmIHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihtb2RlKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVRvb2xiYXIobW9kZSk7XG4gIH1cbiAgdXBkYXRlTW9kZShtb2RlID0gdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSkge1xuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgICAgICB0aGlzLnRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOlxuICAgICAgICB0aGlzLmFkZElua0VkaXRvcklmTmVlZGVkKGZhbHNlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHRoaXMuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmVuYWJsZUNsaWNrKCk7XG4gICAgfVxuICAgIHRoaXMudG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NMaXN0XG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpKSB7XG4gICAgICBjbGFzc0xpc3QudG9nZ2xlKGAke2VkaXRvclR5cGUuX3R5cGV9RWRpdGluZ2AsIG1vZGUgPT09IGVkaXRvclR5cGUuX2VkaXRvclR5cGUpO1xuICAgIH1cbiAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBoYXNUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgcmV0dXJuIHRleHRMYXllciA9PT0gdGhpcy4jdGV4dExheWVyPy5kaXY7XG4gIH1cbiAgYWRkSW5rRWRpdG9ySWZOZWVkZWQoaXNDb21taXR0aW5nKSB7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLklOSykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzQ29tbWl0dGluZykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICAgIGVkaXRvci5zZXRJbkJhY2tncm91bmQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgb2Zmc2V0WDogMCxcbiAgICAgIG9mZnNldFk6IDBcbiAgICB9LCBmYWxzZSk7XG4gICAgZWRpdG9yLnNldEluQmFja2dyb3VuZCgpO1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZyk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgdG9nZ2xlRHJhd2luZyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZHJhd2luZ1wiLCAhZW5hYmxlZCk7XG4gIH1cbiAgdG9nZ2xlUG9pbnRlckV2ZW50cyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuICB9XG4gIHRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgfVxuICBhc3luYyBlbmFibGUoKSB7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICBjb25zdCBhbm5vdGF0aW9uRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgICAgZWRpdG9yLnNob3codHJ1ZSk7XG4gICAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uTGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGVkaXRhYmxlcykge1xuICAgICAgZWRpdGFibGUuaGlkZSgpO1xuICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkcy5oYXMoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCB0aGlzLmRlc2VyaWFsaXplKGVkaXRhYmxlKTtcbiAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgfVxuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICBjb25zdCBjaGFuZ2VkQW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcmVzZXRBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLnNlcmlhbGl6ZSgpICE9PSBudWxsKSB7XG4gICAgICAgIGNoYW5nZWRBbm5vdGF0aW9ucy5zZXQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQsIGVkaXRvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRBbm5vdGF0aW9ucy5zZXQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQsIGVkaXRvcik7XG4gICAgICB9XG4gICAgICB0aGlzLmdldEVkaXRhYmxlQW5ub3RhdGlvbihlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk/LnNob3coKTtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2Fubm90YXRpb25MYXllcikge1xuICAgICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZWRpdGFibGUuZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChpZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWRpdG9yID0gcmVzZXRBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgZWRpdG9yLnJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUpO1xuICAgICAgICAgIGVkaXRvci5zaG93KGZhbHNlKTtcbiAgICAgICAgICBlZGl0YWJsZS5zaG93KCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yID0gY2hhbmdlZEFubm90YXRpb25zLmdldChpZCk7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgICAgICAgIGlmIChlZGl0b3IucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUpKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2hvdyhmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVkaXRhYmxlLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzTGlzdFxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgY2xhc3NMaXN0LnJlbW92ZShgJHtlZGl0b3JUeXBlLl90eXBlfUVkaXRpbmdgKTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIHRoaXMudG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICB0aGlzLiNpc0Rpc2FibGluZyA9IGZhbHNlO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI/LmdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkgfHwgbnVsbDtcbiAgfVxuICBzZXRBY3RpdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY3VycmVudEFjdGl2ZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKTtcbiAgICBpZiAoY3VycmVudEFjdGl2ZSA9PT0gZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRBY3RpdmVFZGl0b3IoZWRpdG9yKTtcbiAgfVxuICBlbmFibGVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgaWYgKHRoaXMuI3RleHRMYXllcj8uZGl2ICYmICF0aGlzLiN0ZXh0U2VsZWN0aW9uQUMpIHtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiN0ZXh0U2VsZWN0aW9uQUMpO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jdGV4dExheWVyUG9pbnRlckRvd24uYmluZCh0aGlzKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0aW5nXCIpO1xuICAgIH1cbiAgfVxuICBkaXNhYmxlVGV4dFNlbGVjdGlvbigpIHtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IDA7XG4gICAgaWYgKHRoaXMuI3RleHRMYXllcj8uZGl2ICYmIHRoaXMuI3RleHRTZWxlY3Rpb25BQykge1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDLmFib3J0KCk7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMgPSBudWxsO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlnaGxpZ2h0aW5nXCIpO1xuICAgIH1cbiAgfVxuICAjdGV4dExheWVyUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3RBbGwoKTtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXRcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKHRhcmdldCA9PT0gdGhpcy4jdGV4dExheWVyLmRpdiB8fCAodGFyZ2V0LmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwiaW1nXCIgfHwgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImVuZE9mQ29udGVudFwiKSkgJiYgdGhpcy4jdGV4dExheWVyLmRpdi5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzTWFjXG4gICAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlXCIpO1xuICAgICAgdGhpcy50b2dnbGVEcmF3aW5nKCk7XG4gICAgICBIaWdobGlnaHRFZGl0b3Iuc3RhcnRIaWdobGlnaHRpbmcodGhpcywgdGhpcy4jdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiwge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuI3RleHRMYXllci5kaXYsXG4gICAgICAgIHg6IGV2ZW50LngsXG4gICAgICAgIHk6IGV2ZW50LnlcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZnJlZVwiKTtcbiAgICAgICAgdGhpcy50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgICAgfSwge1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUNsaWNrKCkge1xuICAgIGlmICh0aGlzLiNjbGlja0FDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NsaWNrQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2NsaWNrQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLnBvaW50ZXJkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5wb2ludGVydXAuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgZGlzYWJsZUNsaWNrKCkge1xuICAgIHRoaXMuI2NsaWNrQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jY2xpY2tBQyA9IG51bGw7XG4gIH1cbiAgYXR0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gICAgfSA9IGVkaXRvcjtcbiAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiB0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gICAgaWYgKCF0aGlzLiNpc0Rpc2FibGluZyAmJiBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICByZW1vdmUoZWRpdG9yKSB7XG4gICAgdGhpcy5kZXRhY2goZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRWRpdG9yKGVkaXRvcik7XG4gICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLiNpc0NsZWFuaW5nVXApIHtcbiAgICAgIHRoaXMuYWRkSW5rRWRpdG9ySWZOZWVkZWQoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBjaGFuZ2VQYXJlbnQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgJiYgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgQW5ub3RhdGlvbkVkaXRvci5kZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5wYXJlbnQ/LmRldGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5zZXRQYXJlbnQodGhpcyk7XG4gICAgaWYgKGVkaXRvci5kaXYgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChlZGl0b3IuZGl2KTtcbiAgICB9XG4gIH1cbiAgYWRkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSB0aGlzICYmIGVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGNvbnN0IGRpdiA9IGVkaXRvci5yZW5kZXIoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChkaXYpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IHRydWU7XG4gICAgfVxuICAgIGVkaXRvci5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIGVkaXRvci5vbmNlQWRkZWQoKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgIGVkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KGVkaXRvci50ZWxlbWV0cnlJbml0aWFsRGF0YSk7XG4gIH1cbiAgbW92ZUVkaXRvckluRE9NKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpICYmICF0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCkge1xuICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgaWYgKCFlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgZWRpdG9yLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgZWRpdG9yLl9zdHJ1Y3RUcmVlUGFyZW50SWQgPSB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ubW92ZUVsZW1lbnRJbkRPTSh0aGlzLmRpdiwgZWRpdG9yLmRpdiwgZWRpdG9yLmNvbnRlbnREaXYsIHRydWUpO1xuICB9XG4gIGFkZE9yUmVidWlsZChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLm5lZWRzVG9CZVJlYnVpbHQoKSkge1xuICAgICAgZWRpdG9yLnBhcmVudCB8fD0gdGhpcztcbiAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgICBlZGl0b3Iuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhZGRVbmRvYWJsZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiBlZGl0b3IuX3VpTWFuYWdlci5yZWJ1aWxkKGVkaXRvcik7XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGdldE5leHRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmdldElkKCk7XG4gIH1cbiAgZ2V0ICNjdXJyZW50RWRpdG9yVHlwZSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy5nZXQodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSk7XG4gIH1cbiAgY29tYmluZWRTaWduYWwoYWMpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgfVxuICAjY3JlYXRlTmV3RWRpdG9yKHBhcmFtcykge1xuICAgIGNvbnN0IGVkaXRvclR5cGUgPSB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZTtcbiAgICByZXR1cm4gZWRpdG9yVHlwZSA/IG5ldyBlZGl0b3JUeXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcihwYXJhbXMpIDogbnVsbDtcbiAgfVxuICBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudEVkaXRvclR5cGU/LmNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCk7XG4gIH1cbiAgcGFzdGVFZGl0b3IobW9kZSwgcGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVRvb2xiYXIobW9kZSk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZU1vZGUobW9kZSk7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9ID0gdGhpcy4jZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogb2Zmc2V0WCxcbiAgICAgIHk6IG9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQ6IHRydWUsXG4gICAgICAuLi5wYXJhbXNcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgcmV0dXJuIChhd2FpdCBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLmdldChkYXRhLmFubm90YXRpb25UeXBlID8/IGRhdGEuYW5ub3RhdGlvbkVkaXRvclR5cGUpPy5kZXNlcmlhbGl6ZShkYXRhLCB0aGlzLCB0aGlzLiN1aU1hbmFnZXIpKSB8fCBudWxsO1xuICB9XG4gIGNyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgaXNDZW50ZXJlZCwgZGF0YSA9IHt9KSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5leHRJZCgpO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2NyZWF0ZU5ld0VkaXRvcih7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBpZCxcbiAgICAgIHg6IGV2ZW50Lm9mZnNldFgsXG4gICAgICB5OiBldmVudC5vZmZzZXRZLFxuICAgICAgdWlNYW5hZ2VyOiB0aGlzLiN1aU1hbmFnZXIsXG4gICAgICBpc0NlbnRlcmVkLFxuICAgICAgLi4uZGF0YVxuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgI2dldENlbnRlclBvaW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdGxYID0gTWF0aC5tYXgoMCwgeCk7XG4gICAgY29uc3QgdGxZID0gTWF0aC5tYXgoMCwgeSk7XG4gICAgY29uc3QgYnJYID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIHggKyB3aWR0aCk7XG4gICAgY29uc3QgYnJZID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBjb25zdCBjZW50ZXJYID0gKHRsWCArIGJyWCkgLyAyIC0geDtcbiAgICBjb25zdCBjZW50ZXJZID0gKHRsWSArIGJyWSkgLyAyIC0geTtcbiAgICBjb25zdCBbb2Zmc2V0WCwgb2Zmc2V0WV0gPSB0aGlzLnZpZXdwb3J0LnJvdGF0aW9uICUgMTgwID09PSAwID8gW2NlbnRlclgsIGNlbnRlclldIDogW2NlbnRlclksIGNlbnRlclhdO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH07XG4gIH1cbiAgYWRkTmV3RWRpdG9yKCkge1xuICAgIHRoaXMuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHRoaXMuI2dldENlbnRlclBvaW50KCksIHRydWUpO1xuICB9XG4gIHNldFNlbGVjdGVkKGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIHRvZ2dsZVNlbGVjdGVkKGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci50b2dnbGVTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdChlZGl0b3IpO1xuICB9XG4gIHBvaW50ZXJ1cChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuI2FsbG93Q2xpY2spIHtcbiAgICAgIHRoaXMuI2FsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVApIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdEFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgZmFsc2UpO1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCkge1xuICAgICAgdGhpcy5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSB0cnVlO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKTtcbiAgICB0aGlzLiNhbGxvd0NsaWNrID0gIWVkaXRvciB8fCBlZGl0b3IuaXNFbXB0eSgpO1xuICB9XG4gIGZpbmROZXdQYXJlbnQoZWRpdG9yLCB4LCB5KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiN1aU1hbmFnZXIuZmluZFBhcmVudCh4LCB5KTtcbiAgICBpZiAobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGF5ZXIuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpPy5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICAgIGVkaXRvci5zZXRQYXJlbnQobnVsbCk7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy4jZWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVMYXllcih0aGlzKTtcbiAgfVxuICAjY2xlYW51cCgpIHtcbiAgICB0aGlzLiNpc0NsZWFuaW5nVXAgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jaXNDbGVhbmluZ1VwID0gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHNldExheWVyRGltZW5zaW9ucyh0aGlzLmRpdiwgdmlld3BvcnQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3JzKHRoaXMucGFnZUluZGV4KSkge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTW9kZSgpO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBjb25zdCBvbGRSb3RhdGlvbiA9IHRoaXMudmlld3BvcnQucm90YXRpb247XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuZGl2LCB7XG4gICAgICByb3RhdGlvblxuICAgIH0pO1xuICAgIGlmIChvbGRSb3RhdGlvbiAhPT0gcm90YXRpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkSW5rRWRpdG9ySWZOZWVkZWQoZmFsc2UpO1xuICB9XG4gIGdldCBwYWdlRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMudmlld3BvcnQucmF3RGltcztcbiAgICByZXR1cm4gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gIH1cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2RyYXdfbGF5ZXIuanNcblxuXG5jbGFzcyBEcmF3TGF5ZXIge1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI2lkID0gMDtcbiAgI21hcHBpbmcgPSBuZXcgTWFwKCk7XG4gICN0b1VwZGF0ZSA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhZ2VJbmRleFxuICB9KSB7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmICghdGhpcy4jcGFyZW50KSB7XG4gICAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNwYXJlbnQgIT09IHBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI21hcHBpbmcuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCByb290IG9mIHRoaXMuI21hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgICAgICByb290LnJlbW92ZSgpO1xuICAgICAgICAgIHBhcmVudC5hcHBlbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBfc3ZnRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3N2Z0ZhY3RvcnlcIiwgbmV3IERPTVNWR0ZhY3RvcnkoKSk7XG4gIH1cbiAgc3RhdGljICNzZXRCb3goZWxlbWVudCwge1xuICAgIHggPSAwLFxuICAgIHkgPSAwLFxuICAgIHdpZHRoID0gMSxcbiAgICBoZWlnaHQgPSAxXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogeX0lYDtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogeH0lYDtcbiAgICBzdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRofSVgO1xuICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodH0lYDtcbiAgfVxuICAjY3JlYXRlU1ZHKGJveCkge1xuICAgIGNvbnN0IHN2ZyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGUoMSwgMSwgdHJ1ZSk7XG4gICAgdGhpcy4jcGFyZW50LmFwcGVuZChzdmcpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgICBEcmF3TGF5ZXIuI3NldEJveChzdmcsIGJveCk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICAjY3JlYXRlQ2xpcFBhdGgoZGVmcywgcGF0aElkKSB7XG4gICAgY29uc3QgY2xpcFBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBjb25zdCBjbGlwUGF0aElkID0gYGNsaXBfJHtwYXRoSWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBjbGlwUGF0aElkKTtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJjbGlwUGF0aFVuaXRzXCIsIFwib2JqZWN0Qm91bmRpbmdCb3hcIik7XG4gICAgY29uc3QgY2xpcFBhdGhVc2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICBjbGlwUGF0aC5hcHBlbmQoY2xpcFBhdGhVc2UpO1xuICAgIGNsaXBQYXRoVXNlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICBjbGlwUGF0aFVzZS5jbGFzc0xpc3QuYWRkKFwiY2xpcFwiKTtcbiAgICByZXR1cm4gY2xpcFBhdGhJZDtcbiAgfVxuICBkcmF3KG91dGxpbmVzLCBjb2xvciwgb3BhY2l0eSwgaXNQYXRoVXBkYXRhYmxlID0gZmFsc2UpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI2lkKys7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2NyZWF0ZVNWRyhvdXRsaW5lcy5ib3gpO1xuICAgIHJvb3QuY2xhc3NMaXN0LmFkZCguLi5vdXRsaW5lcy5jbGFzc05hbWVzRm9yRHJhd2luZyk7XG4gICAgY29uc3QgZGVmcyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICByb290LmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBwYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKHBhdGgpO1xuICAgIGNvbnN0IHBhdGhJZCA9IGBwYXRoX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBwYXRoSWQpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCBvdXRsaW5lcy50b1NWR1BhdGgoKSk7XG4gICAgaWYgKGlzUGF0aFVwZGF0YWJsZSkge1xuICAgICAgdGhpcy4jdG9VcGRhdGUuc2V0KGlkLCBwYXRoKTtcbiAgICB9XG4gICAgY29uc3QgY2xpcFBhdGhJZCA9IHRoaXMuI2NyZWF0ZUNsaXBQYXRoKGRlZnMsIHBhdGhJZCk7XG4gICAgY29uc3QgdXNlID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgcm9vdC5hcHBlbmQodXNlKTtcbiAgICByb290LnNldEF0dHJpYnV0ZShcImZpbGxcIiwgY29sb3IpO1xuICAgIHJvb3Quc2V0QXR0cmlidXRlKFwiZmlsbC1vcGFjaXR5XCIsIG9wYWNpdHkpO1xuICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgdGhpcy4jbWFwcGluZy5zZXQoaWQsIHJvb3QpO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIGNsaXBQYXRoSWQ6IGB1cmwoIyR7Y2xpcFBhdGhJZH0pYFxuICAgIH07XG4gIH1cbiAgZHJhd091dGxpbmUob3V0bGluZXMpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI2lkKys7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2NyZWF0ZVNWRyhvdXRsaW5lcy5ib3gpO1xuICAgIHJvb3QuY2xhc3NMaXN0LmFkZCguLi5vdXRsaW5lcy5jbGFzc05hbWVzRm9yT3V0bGluaW5nKTtcbiAgICBjb25zdCBkZWZzID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHJvb3QuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IHBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQocGF0aCk7XG4gICAgY29uc3QgcGF0aElkID0gYHBhdGhfcCR7dGhpcy5wYWdlSW5kZXh9XyR7aWR9YDtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIHBhdGhJZCk7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIG91dGxpbmVzLnRvU1ZHUGF0aCgpKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcInZlY3Rvci1lZmZlY3RcIiwgXCJub24tc2NhbGluZy1zdHJva2VcIik7XG4gICAgbGV0IG1hc2tJZDtcbiAgICBpZiAob3V0bGluZXMubXVzdFJlbW92ZVNlbGZJbnRlcnNlY3Rpb25zKSB7XG4gICAgICBjb25zdCBtYXNrID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJtYXNrXCIpO1xuICAgICAgZGVmcy5hcHBlbmQobWFzayk7XG4gICAgICBtYXNrSWQgPSBgbWFza19wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBtYXNrSWQpO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoXCJtYXNrVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInJlY3RcIik7XG4gICAgICBtYXNrLmFwcGVuZChyZWN0KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxXCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIxXCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwid2hpdGVcIik7XG4gICAgICBjb25zdCB1c2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICAgIG1hc2suYXBwZW5kKHVzZSk7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgICAgdXNlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIm5vbmVcIik7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcImJsYWNrXCIpO1xuICAgICAgdXNlLnNldEF0dHJpYnV0ZShcImZpbGwtcnVsZVwiLCBcIm5vbnplcm9cIik7XG4gICAgICB1c2UuY2xhc3NMaXN0LmFkZChcIm1hc2tcIik7XG4gICAgfVxuICAgIGNvbnN0IHVzZTEgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICByb290LmFwcGVuZCh1c2UxKTtcbiAgICB1c2UxLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICBpZiAobWFza0lkKSB7XG4gICAgICB1c2UxLnNldEF0dHJpYnV0ZShcIm1hc2tcIiwgYHVybCgjJHttYXNrSWR9KWApO1xuICAgIH1cbiAgICBjb25zdCB1c2UyID0gdXNlMS5jbG9uZU5vZGUoKTtcbiAgICByb290LmFwcGVuZCh1c2UyKTtcbiAgICB1c2UxLmNsYXNzTGlzdC5hZGQoXCJtYWluT3V0bGluZVwiKTtcbiAgICB1c2UyLmNsYXNzTGlzdC5hZGQoXCJzZWNvbmRhcnlPdXRsaW5lXCIpO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZmluYWxpemVMaW5lKGlkLCBsaW5lKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMuI3RvVXBkYXRlLmdldChpZCk7XG4gICAgdGhpcy4jdG9VcGRhdGUuZGVsZXRlKGlkKTtcbiAgICB0aGlzLnVwZGF0ZUJveChpZCwgbGluZS5ib3gpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCBsaW5lLnRvU1ZHUGF0aCgpKTtcbiAgfVxuICB1cGRhdGVMaW5lKGlkLCBsaW5lKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI21hcHBpbmcuZ2V0KGlkKTtcbiAgICBjb25zdCBkZWZzID0gcm9vdC5maXJzdENoaWxkO1xuICAgIGNvbnN0IHBhdGggPSBkZWZzLmZpcnN0Q2hpbGQ7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIGxpbmUudG9TVkdQYXRoKCkpO1xuICB9XG4gIHVwZGF0ZVBhdGgoaWQsIGxpbmUpIHtcbiAgICB0aGlzLiN0b1VwZGF0ZS5nZXQoaWQpLnNldEF0dHJpYnV0ZShcImRcIiwgbGluZS50b1NWR1BhdGgoKSk7XG4gIH1cbiAgdXBkYXRlQm94KGlkLCBib3gpIHtcbiAgICBEcmF3TGF5ZXIuI3NldEJveCh0aGlzLiNtYXBwaW5nLmdldChpZCksIGJveCk7XG4gIH1cbiAgc2hvdyhpZCwgdmlzaWJsZSkge1xuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsICF2aXNpYmxlKTtcbiAgfVxuICByb3RhdGUoaWQsIGFuZ2xlKSB7XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCBhbmdsZSk7XG4gIH1cbiAgY2hhbmdlQ29sb3IoaWQsIGNvbG9yKSB7XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgY29sb3IpO1xuICB9XG4gIGNoYW5nZU9wYWNpdHkoaWQsIG9wYWNpdHkpIHtcbiAgICB0aGlzLiNtYXBwaW5nLmdldChpZCkuc2V0QXR0cmlidXRlKFwiZmlsbC1vcGFjaXR5XCIsIG9wYWNpdHkpO1xuICB9XG4gIGFkZENsYXNzKGlkLCBjbGFzc05hbWUpIHtcbiAgICB0aGlzLiNtYXBwaW5nLmdldChpZCkuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGlkLCBjbGFzc05hbWUpIHtcbiAgICB0aGlzLiNtYXBwaW5nLmdldChpZCkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICB9XG4gIGdldFNWR1Jvb3QoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwcGluZy5nZXQoaWQpO1xuICB9XG4gIHJlbW92ZShpZCkge1xuICAgIHRoaXMuI3RvVXBkYXRlLmRlbGV0ZShpZCk7XG4gICAgaWYgKHRoaXMuI3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNtYXBwaW5nLmdldChpZCkucmVtb3ZlKCk7XG4gICAgdGhpcy4jbWFwcGluZy5kZWxldGUoaWQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jcGFyZW50ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2YgdGhpcy4jbWFwcGluZy52YWx1ZXMoKSkge1xuICAgICAgcm9vdC5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy4jbWFwcGluZy5jbGVhcigpO1xuICAgIHRoaXMuI3RvVXBkYXRlLmNsZWFyKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL3BkZi5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBwZGZqc1ZlcnNpb24gPSBcIjQuOC42OVwiO1xuY29uc3QgcGRmanNCdWlsZCA9IFwiMzYzNGRhYjEwXCI7XG5cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWJvcnRFeGNlcHRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFib3J0RXhjZXB0aW9uO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFubm90YXRpb25FZGl0b3JMYXllcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yVHlwZSA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbkVkaXRvclR5cGU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25MYXllciA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbkxheWVyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uTW9kZSA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbk1vZGU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbG9yUGlja2VyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Db2xvclBpY2tlcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRE9NU1ZHRmFjdG9yeSA9IF9fd2VicGFja19leHBvcnRzX18uRE9NU1ZHRmFjdG9yeTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRHJhd0xheWVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5EcmF3TGF5ZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ZlYXR1cmVUZXN0ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5GZWF0dXJlVGVzdDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2xvYmFsV29ya2VyT3B0aW9ucyA9IF9fd2VicGFja19leHBvcnRzX18uR2xvYmFsV29ya2VyT3B0aW9ucztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSW1hZ2VLaW5kID0gX193ZWJwYWNrX2V4cG9ydHNfXy5JbWFnZUtpbmQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ludmFsaWRQREZFeGNlcHRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLkludmFsaWRQREZFeGNlcHRpb247XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX01pc3NpbmdQREZFeGNlcHRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLk1pc3NpbmdQREZFeGNlcHRpb247XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX09QUyA9IF9fd2VicGFja19leHBvcnRzX18uT1BTO1xudmFyIF9fd2VicGFja19leHBvcnRzX19PdXRwdXRTY2FsZSA9IF9fd2VicGFja19leHBvcnRzX18uT3V0cHV0U2NhbGU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BERkRhdGFSYW5nZVRyYW5zcG9ydCA9IF9fd2VicGFja19leHBvcnRzX18uUERGRGF0YVJhbmdlVHJhbnNwb3J0O1xudmFyIF9fd2VicGFja19leHBvcnRzX19QREZEYXRlU3RyaW5nID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QREZEYXRlU3RyaW5nO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QREZXb3JrZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBERldvcmtlcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGFzc3dvcmRSZXNwb25zZXMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBhc3N3b3JkUmVzcG9uc2VzO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QZXJtaXNzaW9uRmxhZyA9IF9fd2VicGFja19leHBvcnRzX18uUGVybWlzc2lvbkZsYWc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BpeGVsc1BlckluY2ggPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBpeGVsc1BlckluY2g7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uO1xudmFyIF9fd2VicGFja19leHBvcnRzX19UZXh0TGF5ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlRleHRMYXllcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1V0aWwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlV0aWw7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1ZlcmJvc2l0eUxldmVsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5WZXJib3NpdHlMZXZlbDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fWGZhTGF5ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlhmYUxheWVyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19idWlsZCA9IF9fd2VicGFja19leHBvcnRzX18uYnVpbGQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2NyZWF0ZVZhbGlkQWJzb2x1dGVVcmwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2ZldGNoRGF0YSA9IF9fd2VicGFja19leHBvcnRzX18uZmV0Y2hEYXRhO1xudmFyIF9fd2VicGFja19leHBvcnRzX19nZXREb2N1bWVudCA9IF9fd2VicGFja19leHBvcnRzX18uZ2V0RG9jdW1lbnQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2dldEZpbGVuYW1lRnJvbVVybCA9IF9fd2VicGFja19leHBvcnRzX18uZ2V0RmlsZW5hbWVGcm9tVXJsO1xudmFyIF9fd2VicGFja19leHBvcnRzX19nZXRQZGZGaWxlbmFtZUZyb21VcmwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmdldFBkZkZpbGVuYW1lRnJvbVVybDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0WGZhUGFnZVZpZXdwb3J0ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5nZXRYZmFQYWdlVmlld3BvcnQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2lzRGF0YVNjaGVtZSA9IF9fd2VicGFja19leHBvcnRzX18uaXNEYXRhU2NoZW1lO1xudmFyIF9fd2VicGFja19leHBvcnRzX19pc1BkZkZpbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmlzUGRmRmlsZTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fbm9Db250ZXh0TWVudSA9IF9fd2VicGFja19leHBvcnRzX18ubm9Db250ZXh0TWVudTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fbm9ybWFsaXplVW5pY29kZSA9IF9fd2VicGFja19leHBvcnRzX18ubm9ybWFsaXplVW5pY29kZTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fc2V0TGF5ZXJEaW1lbnNpb25zID0gX193ZWJwYWNrX2V4cG9ydHNfXy5zZXRMYXllckRpbWVuc2lvbnM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX3NoYWRvdyA9IF9fd2VicGFja19leHBvcnRzX18uc2hhZG93O1xudmFyIF9fd2VicGFja19leHBvcnRzX192ZXJzaW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy52ZXJzaW9uO1xuZXhwb3J0IHsgX193ZWJwYWNrX2V4cG9ydHNfX0Fib3J0RXhjZXB0aW9uIGFzIEFib3J0RXhjZXB0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvckxheWVyIGFzIEFubm90YXRpb25FZGl0b3JMYXllciwgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlIGFzIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvclR5cGUgYXMgQW5ub3RhdGlvbkVkaXRvclR5cGUsIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIGFzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uTGF5ZXIgYXMgQW5ub3RhdGlvbkxheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbk1vZGUgYXMgQW5ub3RhdGlvbk1vZGUsIF9fd2VicGFja19leHBvcnRzX19Db2xvclBpY2tlciBhcyBDb2xvclBpY2tlciwgX193ZWJwYWNrX2V4cG9ydHNfX0RPTVNWR0ZhY3RvcnkgYXMgRE9NU1ZHRmFjdG9yeSwgX193ZWJwYWNrX2V4cG9ydHNfX0RyYXdMYXllciBhcyBEcmF3TGF5ZXIsIF9fd2VicGFja19leHBvcnRzX19GZWF0dXJlVGVzdCBhcyBGZWF0dXJlVGVzdCwgX193ZWJwYWNrX2V4cG9ydHNfX0dsb2JhbFdvcmtlck9wdGlvbnMgYXMgR2xvYmFsV29ya2VyT3B0aW9ucywgX193ZWJwYWNrX2V4cG9ydHNfX0ltYWdlS2luZCBhcyBJbWFnZUtpbmQsIF9fd2VicGFja19leHBvcnRzX19JbnZhbGlkUERGRXhjZXB0aW9uIGFzIEludmFsaWRQREZFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19NaXNzaW5nUERGRXhjZXB0aW9uIGFzIE1pc3NpbmdQREZFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19PUFMgYXMgT1BTLCBfX3dlYnBhY2tfZXhwb3J0c19fT3V0cHV0U2NhbGUgYXMgT3V0cHV0U2NhbGUsIF9fd2VicGFja19leHBvcnRzX19QREZEYXRhUmFuZ2VUcmFuc3BvcnQgYXMgUERGRGF0YVJhbmdlVHJhbnNwb3J0LCBfX3dlYnBhY2tfZXhwb3J0c19fUERGRGF0ZVN0cmluZyBhcyBQREZEYXRlU3RyaW5nLCBfX3dlYnBhY2tfZXhwb3J0c19fUERGV29ya2VyIGFzIFBERldvcmtlciwgX193ZWJwYWNrX2V4cG9ydHNfX1Bhc3N3b3JkUmVzcG9uc2VzIGFzIFBhc3N3b3JkUmVzcG9uc2VzLCBfX3dlYnBhY2tfZXhwb3J0c19fUGVybWlzc2lvbkZsYWcgYXMgUGVybWlzc2lvbkZsYWcsIF9fd2VicGFja19leHBvcnRzX19QaXhlbHNQZXJJbmNoIGFzIFBpeGVsc1BlckluY2gsIF9fd2VicGFja19leHBvcnRzX19SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gYXMgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fVGV4dExheWVyIGFzIFRleHRMYXllciwgX193ZWJwYWNrX2V4cG9ydHNfX1VuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiBhcyBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19VdGlsIGFzIFV0aWwsIF9fd2VicGFja19leHBvcnRzX19WZXJib3NpdHlMZXZlbCBhcyBWZXJib3NpdHlMZXZlbCwgX193ZWJwYWNrX2V4cG9ydHNfX1hmYUxheWVyIGFzIFhmYUxheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fYnVpbGQgYXMgYnVpbGQsIF9fd2VicGFja19leHBvcnRzX19jcmVhdGVWYWxpZEFic29sdXRlVXJsIGFzIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwsIF9fd2VicGFja19leHBvcnRzX19mZXRjaERhdGEgYXMgZmV0Y2hEYXRhLCBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RG9jdW1lbnQgYXMgZ2V0RG9jdW1lbnQsIF9fd2VicGFja19leHBvcnRzX19nZXRGaWxlbmFtZUZyb21VcmwgYXMgZ2V0RmlsZW5hbWVGcm9tVXJsLCBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0UGRmRmlsZW5hbWVGcm9tVXJsIGFzIGdldFBkZkZpbGVuYW1lRnJvbVVybCwgX193ZWJwYWNrX2V4cG9ydHNfX2dldFhmYVBhZ2VWaWV3cG9ydCBhcyBnZXRYZmFQYWdlVmlld3BvcnQsIF9fd2VicGFja19leHBvcnRzX19pc0RhdGFTY2hlbWUgYXMgaXNEYXRhU2NoZW1lLCBfX3dlYnBhY2tfZXhwb3J0c19faXNQZGZGaWxlIGFzIGlzUGRmRmlsZSwgX193ZWJwYWNrX2V4cG9ydHNfX25vQ29udGV4dE1lbnUgYXMgbm9Db250ZXh0TWVudSwgX193ZWJwYWNrX2V4cG9ydHNfX25vcm1hbGl6ZVVuaWNvZGUgYXMgbm9ybWFsaXplVW5pY29kZSwgX193ZWJwYWNrX2V4cG9ydHNfX3NldExheWVyRGltZW5zaW9ucyBhcyBzZXRMYXllckRpbWVuc2lvbnMsIF9fd2VicGFja19leHBvcnRzX19zaGFkb3cgYXMgc2hhZG93LCBfX3dlYnBhY2tfZXhwb3J0c19fdmVyc2lvbiBhcyB2ZXJzaW9uIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBkZi5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/pdfjs-dist/build/pdf.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/_internal/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/swr/dist/_internal/index.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INFINITE_PREFIX: function() { return /* binding */ INFINITE_PREFIX; },\n/* harmony export */   IS_REACT_LEGACY: function() { return /* binding */ IS_REACT_LEGACY; },\n/* harmony export */   IS_SERVER: function() { return /* binding */ IS_SERVER; },\n/* harmony export */   OBJECT: function() { return /* binding */ OBJECT; },\n/* harmony export */   SWRConfig: function() { return /* binding */ SWRConfig; },\n/* harmony export */   SWRGlobalState: function() { return /* binding */ SWRGlobalState; },\n/* harmony export */   UNDEFINED: function() { return /* binding */ UNDEFINED; },\n/* harmony export */   cache: function() { return /* binding */ cache; },\n/* harmony export */   compare: function() { return /* binding */ compare; },\n/* harmony export */   createCacheHelper: function() { return /* binding */ createCacheHelper; },\n/* harmony export */   defaultConfig: function() { return /* binding */ defaultConfig; },\n/* harmony export */   defaultConfigOptions: function() { return /* binding */ defaultConfigOptions; },\n/* harmony export */   getTimestamp: function() { return /* binding */ getTimestamp; },\n/* harmony export */   hasRequestAnimationFrame: function() { return /* binding */ hasRequestAnimationFrame; },\n/* harmony export */   initCache: function() { return /* binding */ initCache; },\n/* harmony export */   internalMutate: function() { return /* binding */ internalMutate; },\n/* harmony export */   isDocumentDefined: function() { return /* binding */ isDocumentDefined; },\n/* harmony export */   isFunction: function() { return /* binding */ isFunction; },\n/* harmony export */   isPromiseLike: function() { return /* binding */ isPromiseLike; },\n/* harmony export */   isUndefined: function() { return /* binding */ isUndefined; },\n/* harmony export */   isWindowDefined: function() { return /* binding */ isWindowDefined; },\n/* harmony export */   mergeConfigs: function() { return /* binding */ mergeConfigs; },\n/* harmony export */   mergeObjects: function() { return /* binding */ mergeObjects; },\n/* harmony export */   mutate: function() { return /* binding */ mutate; },\n/* harmony export */   noop: function() { return /* binding */ noop; },\n/* harmony export */   normalize: function() { return /* binding */ normalize; },\n/* harmony export */   preload: function() { return /* binding */ preload; },\n/* harmony export */   preset: function() { return /* binding */ preset; },\n/* harmony export */   rAF: function() { return /* binding */ rAF; },\n/* harmony export */   revalidateEvents: function() { return /* binding */ events; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   slowConnection: function() { return /* binding */ slowConnection; },\n/* harmony export */   stableHash: function() { return /* binding */ stableHash; },\n/* harmony export */   subscribeCallback: function() { return /* binding */ subscribeCallback; },\n/* harmony export */   useIsomorphicLayoutEffect: function() { return /* binding */ useIsomorphicLayoutEffect; },\n/* harmony export */   useSWRConfig: function() { return /* binding */ useSWRConfig; },\n/* harmony export */   withArgs: function() { return /* binding */ withArgs; },\n/* harmony export */   withMiddleware: function() { return /* binding */ withMiddleware; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\nconst mergeObjects = (a, b)=>({\n        ...a,\n        ...b\n    });\nconst isPromiseLike = (x)=>isFunction(x.then);\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const constructor = arg && arg.constructor;\n    const isDate = constructor == Date;\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\n\nconst EMPTY_CACHE = {};\nconst INITIAL_CACHE = {};\nconst STR_UNDEFINED = 'undefined';\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = typeof window != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst hasRequestAnimationFrame = ()=>isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key)=>{\n    const state = SWRGlobalState.get(cache);\n    return [\n        // Getter\n        ()=>!isUndefined(key) && cache.get(key) || EMPTY_CACHE,\n        // Setter\n        (info)=>{\n            if (!isUndefined(key)) {\n                const prev = cache.get(key);\n                // Before writing to the store, we keep the value in the initial cache\n                // if it's not there yet.\n                if (!(key in INITIAL_CACHE)) {\n                    INITIAL_CACHE[key] = prev;\n                }\n                state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n            }\n        },\n        // Subscriber\n        state[6],\n        // Get server cache snapshot\n        ()=>{\n            if (!isUndefined(key)) {\n                // If the cache was updated on the client, we return the stored initial value.\n                if (key in INITIAL_CACHE) return INITIAL_CACHE[key];\n            }\n            // If we haven't done any client-side updates, we return the current value.\n            return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;\n        }\n    ];\n} // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }\n;\n\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */ let online = true;\nconst isOnline = ()=>online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [\n    window.addEventListener.bind(window),\n    window.removeEventListener.bind(window)\n] : [\n    noop,\n    noop\n];\nconst isVisible = ()=>{\n    const visibilityState = isDocumentDefined && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nconst initFocus = (callback)=>{\n    // focus revalidate\n    if (isDocumentDefined) {\n        document.addEventListener('visibilitychange', callback);\n    }\n    onWindowEvent('focus', callback);\n    return ()=>{\n        if (isDocumentDefined) {\n            document.removeEventListener('visibilitychange', callback);\n        }\n        offWindowEvent('focus', callback);\n    };\n};\nconst initReconnect = (callback)=>{\n    // revalidate on reconnected\n    const onOnline = ()=>{\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    const onOffline = ()=>{\n        online = false;\n    };\n    onWindowEvent('online', onOnline);\n    onWindowEvent('offline', onOffline);\n    return ()=>{\n        offWindowEvent('online', onOnline);\n        offWindowEvent('offline', onOffline);\n    };\n};\nconst preset = {\n    isOnline,\n    isVisible\n};\nconst defaultConfigOptions = {\n    initFocus,\n    initReconnect\n};\n\nconst IS_REACT_LEGACY = !react__WEBPACK_IMPORTED_MODULE_0__.useId;\nconst IS_SERVER = !isWindowDefined || 'Deno' in window;\n// Polyfill requestAnimationFrame\nconst rAF = (f)=>hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && ([\n    'slow-2g',\n    '2g'\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = ()=>++__timestamp;\n\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\nconst ERROR_REVALIDATE_EVENT = 3;\n\nvar events = {\n  __proto__: null,\n  ERROR_REVALIDATE_EVENT: ERROR_REVALIDATE_EVENT,\n  FOCUS_EVENT: FOCUS_EVENT,\n  MUTATE_EVENT: MUTATE_EVENT,\n  RECONNECT_EVENT: RECONNECT_EVENT\n};\n\nasync function internalMutate(...args) {\n    const [cache, _key, _data, _opts] = args;\n    // When passing as a boolean, it's explicitly used to disable/enable\n    // revalidation.\n    const options = mergeObjects({\n        populateCache: true,\n        throwOnError: true\n    }, typeof _opts === 'boolean' ? {\n        revalidate: _opts\n    } : _opts || {});\n    let populateCache = options.populateCache;\n    const rollbackOnErrorOption = options.rollbackOnError;\n    let optimisticData = options.optimisticData;\n    const rollbackOnError = (error)=>{\n        return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n    };\n    const throwOnError = options.throwOnError;\n    // If the second argument is a key filter, return the mutation results for all\n    // filtered keys.\n    if (isFunction(_key)) {\n        const keyFilter = _key;\n        const matchedKeys = [];\n        const it = cache.keys();\n        for (const key of it){\n            if (// Skip the special useSWRInfinite and useSWRSubscription keys.\n            !/^\\$(inf|sub)\\$/.test(key) && keyFilter(cache.get(key)._k)) {\n                matchedKeys.push(key);\n            }\n        }\n        return Promise.all(matchedKeys.map(mutateByKey));\n    }\n    return mutateByKey(_key);\n    async function mutateByKey(_k) {\n        // Serialize key\n        const [key] = serialize(_k);\n        if (!key) return;\n        const [get, set] = createCacheHelper(cache, key);\n        const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache);\n        const startRevalidate = ()=>{\n            const revalidators = EVENT_REVALIDATORS[key];\n            const revalidate = isFunction(options.revalidate) ? options.revalidate(get().data, _k) : options.revalidate !== false;\n            if (revalidate) {\n                // Invalidate the key by deleting the concurrent request markers so new\n                // requests will not be deduped.\n                delete FETCH[key];\n                delete PRELOAD[key];\n                if (revalidators && revalidators[0]) {\n                    return revalidators[0](MUTATE_EVENT).then(()=>get().data);\n                }\n            }\n            return get().data;\n        };\n        // If there is no new data provided, revalidate the key with current state.\n        if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return startRevalidate();\n        }\n        let data = _data;\n        let error;\n        // Update global timestamps.\n        const beforeMutationTs = getTimestamp();\n        MUTATION[key] = [\n            beforeMutationTs,\n            0\n        ];\n        const hasOptimisticData = !isUndefined(optimisticData);\n        const state = get();\n        // `displayedData` is the current value on screen. It could be the optimistic value\n        // that is going to be overridden by a `committedData`, or get reverted back.\n        // `committedData` is the validated value that comes from a fetch or mutation.\n        const displayedData = state.data;\n        const currentData = state._c;\n        const committedData = isUndefined(currentData) ? displayedData : currentData;\n        // Do optimistic data update.\n        if (hasOptimisticData) {\n            optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;\n            // When we set optimistic data, backup the current committedData data in `_c`.\n            set({\n                data: optimisticData,\n                _c: committedData\n            });\n        }\n        if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n                data = data(committedData);\n            } catch (err) {\n                // If it throws an error synchronously, we shouldn't update the cache.\n                error = err;\n            }\n        }\n        // `data` is a promise/thenable, resolve the final data first.\n        if (data && isPromiseLike(data)) {\n            // This means that the mutation is async, we need to check timestamps to\n            // avoid race conditions.\n            data = await data.catch((err)=>{\n                error = err;\n            });\n            // Check if other mutations have occurred since we've started this mutation.\n            // If there's a race we don't update cache or broadcast the change,\n            // just return the data.\n            if (beforeMutationTs !== MUTATION[key][0]) {\n                if (error) throw error;\n                return data;\n            } else if (error && hasOptimisticData && rollbackOnError(error)) {\n                // Rollback. Always populate the cache in this case but without\n                // transforming the data.\n                populateCache = true;\n                // Reset data to be the latest committed data, and clear the `_c` value.\n                set({\n                    data: committedData,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // If we should write back the cache after request.\n        if (populateCache) {\n            if (!error) {\n                // Transform the result into data.\n                if (isFunction(populateCache)) {\n                    const populateCachedData = populateCache(data, committedData);\n                    set({\n                        data: populateCachedData,\n                        error: UNDEFINED,\n                        _c: UNDEFINED\n                    });\n                } else {\n                    // Only update cached data and reset the error if there's no error. Data can be `undefined` here.\n                    set({\n                        data,\n                        error: UNDEFINED,\n                        _c: UNDEFINED\n                    });\n                }\n            }\n        }\n        // Reset the timestamp to mark the mutation has ended.\n        MUTATION[key][1] = getTimestamp();\n        // Update existing SWR Hooks' internal states:\n        Promise.resolve(startRevalidate()).then(()=>{\n            // The mutation and revalidation are ended, we can clear it since the data is\n            // not an optimistic value anymore.\n            set({\n                _c: UNDEFINED\n            });\n        });\n        // Throw error or return data\n        if (error) {\n            if (throwOnError) throw error;\n            return;\n        }\n        return data;\n    }\n}\n\nconst revalidateAllKeys = (revalidators, type)=>{\n    for(const key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nconst initCache = (provider, options)=>{\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that is bound to\n    // the cache.\n    // The provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        const opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        const EVENT_REVALIDATORS = {};\n        const mutate = internalMutate.bind(UNDEFINED, provider);\n        let unmount = noop;\n        const subscriptions = {};\n        const subscribe = (key, callback)=>{\n            const subs = subscriptions[key] || [];\n            subscriptions[key] = subs;\n            subs.push(callback);\n            return ()=>subs.splice(subs.indexOf(callback), 1);\n        };\n        const setter = (key, value, prev)=>{\n            provider.set(key, value);\n            const subs = subscriptions[key];\n            if (subs) {\n                for (const fn of subs){\n                    fn(value, prev);\n                }\n            }\n        };\n        const initProvider = ()=>{\n            if (!SWRGlobalState.has(provider)) {\n                // Update the state if it's new, or if the provider has been extended.\n                SWRGlobalState.set(provider, [\n                    EVENT_REVALIDATORS,\n                    {},\n                    {},\n                    {},\n                    mutate,\n                    setter,\n                    subscribe\n                ]);\n                if (!IS_SERVER) {\n                    // When listening to the native events for auto revalidations,\n                    // we intentionally put a delay (setTimeout) here to make sure they are\n                    // fired after immediate JavaScript executions, which can be\n                    // React's state updates.\n                    // This avoids some unnecessary revalidations such as\n                    // https://github.com/vercel/swr/issues/1680.\n                    const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n                    const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n                    unmount = ()=>{\n                        releaseFocus && releaseFocus();\n                        releaseReconnect && releaseReconnect();\n                        // When un-mounting, we need to remove the cache provider from the state\n                        // storage too because it's a side-effect. Otherwise, when re-mounting we\n                        // will not re-register those event listeners.\n                        SWRGlobalState.delete(provider);\n                    };\n                }\n            }\n        };\n        initProvider();\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            initProvider,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts)=>{\n    const maxRetryCount = config.errorRetryCount;\n    const currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\nconst compare = (currentData, newData)=>stableHash(currentData) == stableHash(newData);\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare,\n    isPaused: ()=>false,\n    cache,\n    mutate,\n    fallback: {}\n}, // use web preset by default\npreset);\n\nconst mergeConfigs = (a, b)=>{\n    // Need to create a new object to avoid mutating the original here.\n    const v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        const { use: u1, fallback: f1 } = a;\n        const { use: u2, fallback: f2 } = b;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\n\nconst SWRConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst SWRConfig = (props)=>{\n    const { value } = props;\n    const parentConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext);\n    const isFunctionalConfig = isFunction(value);\n    const config = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>isFunctionalConfig ? value(parentConfig) : value, [\n        isFunctionalConfig,\n        parentConfig,\n        value\n    ]);\n    // Extend parent context values and middleware.\n    const extendedConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [\n        isFunctionalConfig,\n        parentConfig,\n        config\n    ]);\n    // Should not use the inherited provider.\n    const provider = config && config.provider;\n    // initialize the cache only on first access.\n    const cacheContextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(UNDEFINED);\n    if (provider && !cacheContextRef.current) {\n        cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);\n    }\n    const cacheContext = cacheContextRef.current;\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(()=>{\n        if (cacheContext) {\n            cacheContext[2] && cacheContext[2]();\n            return cacheContext[3];\n        }\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n\nconst INFINITE_PREFIX = '$inf$';\n\n// @ts-expect-error\nconst enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\nconst setupDevTools = ()=>{\n    if (enableDevtools) {\n        // @ts-expect-error\n        window.__SWR_DEVTOOLS_REACT__ = react__WEBPACK_IMPORTED_MODULE_0__;\n    }\n};\n\nconst normalize = (args)=>{\n    return isFunction(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\n\nconst useSWRConfig = ()=>{\n    return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n};\n\nconst preload = (key_, fetcher)=>{\n    const [key, fnArg] = serialize(key_);\n    const [, , , PRELOAD] = SWRGlobalState.get(cache);\n    // Prevent preload to be called multiple times before used.\n    if (PRELOAD[key]) return PRELOAD[key];\n    const req = fetcher(fnArg);\n    PRELOAD[key] = req;\n    return req;\n};\nconst middleware = (useSWRNext)=>(key_, fetcher_, config)=>{\n        // fetcher might be a sync function, so this should not be an async function\n        const fetcher = fetcher_ && ((...args)=>{\n            const [key] = serialize(key_);\n            const [, , , PRELOAD] = SWRGlobalState.get(cache);\n            if (key.startsWith(INFINITE_PREFIX)) {\n                // we want the infinite fetcher to be called.\n                // handling of the PRELOAD cache happens there.\n                return fetcher_(...args);\n            }\n            const req = PRELOAD[key];\n            if (isUndefined(req)) return fetcher_(...args);\n            delete PRELOAD[key];\n            return req;\n        });\n        return useSWRNext(key_, fetcher, config);\n    };\n\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware);\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nconst withArgs = (hook)=>{\n    return function useSWRArgs(...args) {\n        // Get the default and inherited configuration.\n        const fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        const [key, fn, _config] = normalize(args);\n        // Merge configurations.\n        const config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        let next = hook;\n        const { use } = config;\n        const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n        for(let i = middleware.length; i--;){\n            next = middleware[i](next);\n        }\n        return next(key, fn || config.fetcher || null, config);\n    };\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nconst subscribeCallback = (key, callbacks, callback)=>{\n    const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return ()=>{\n        const index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\n\n// Create a custom hook with a middleware\nconst withMiddleware = (useSWR, middleware)=>{\n    return (...args)=>{\n        const [key, fn, config] = normalize(args);\n        const uses = (config.use || []).concat(middleware);\n        return useSWR(key, fn, {\n            ...config,\n            use: uses\n        });\n    };\n};\n\nsetupDevTools();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9faW50ZXJuYWwvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxSDs7QUFFckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxZQUFZO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHdDQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0Q0FBUyxHQUFHLGtEQUFlO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixvREFBYSxHQUFHO0FBQ3pDO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLHlCQUF5QixpREFBVTtBQUNuQztBQUNBLG1CQUFtQiw4Q0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLG9EQUFhO0FBQ3hCO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQ0FBSztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsaURBQVU7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFZ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9faW50ZXJuYWwvaW5kZXgubWpzPzQwMDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCB1c2VSZWYsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5cbi8vIFNoYXJlZCBzdGF0ZSBiZXR3ZWVuIHNlcnZlciBjb21wb25lbnRzIGFuZCBjbGllbnQgY29tcG9uZW50c1xuY29uc3Qgbm9vcCA9ICgpPT57fTtcbi8vIFVzaW5nIG5vb3AoKSBhcyB0aGUgdW5kZWZpbmVkIHZhbHVlIGFzIHVuZGVmaW5lZCBjYW4gYmUgcmVwbGFjZWRcbi8vIGJ5IHNvbWV0aGluZyBlbHNlLiBQcmV0dGllciBpZ25vcmUgYW5kIGV4dHJhIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkgaGVyZVxuLy8gdG8gZW5zdXJlIHRoYXQgdHNjIGRvZXNuJ3QgcmVtb3ZlIHRoZSBfX05PSU5MSU5FX18gY29tbWVudC5cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgVU5ERUZJTkVEID0gLyojX19OT0lOTElORV9fKi8gbm9vcCgpO1xuY29uc3QgT0JKRUNUID0gT2JqZWN0O1xuY29uc3QgaXNVbmRlZmluZWQgPSAodik9PnYgPT09IFVOREVGSU5FRDtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodik9PnR5cGVvZiB2ID09ICdmdW5jdGlvbic7XG5jb25zdCBtZXJnZU9iamVjdHMgPSAoYSwgYik9Pih7XG4gICAgICAgIC4uLmEsXG4gICAgICAgIC4uLmJcbiAgICB9KTtcbmNvbnN0IGlzUHJvbWlzZUxpa2UgPSAoeCk9PmlzRnVuY3Rpb24oeC50aGVuKTtcblxuLy8gdXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIG9iamVjdC0+a2V5IG1hcHBpbmdcbi8vIHNvIHRoZSBvYmplY3RzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlYWtNYXAgdXNlcyBhIGhhc2h0YWJsZSB1bmRlciB0aGUgaG9vZCwgc28gdGhlIGxvb2t1cFxuLy8gY29tcGxleGl0eSBpcyBhbG1vc3QgTygxKS5cbmNvbnN0IHRhYmxlID0gbmV3IFdlYWtNYXAoKTtcbi8vIGNvdW50ZXIgb2YgdGhlIGtleVxubGV0IGNvdW50ZXIgPSAwO1xuLy8gQSBzdGFibGUgaGFzaCBpbXBsZW1lbnRhdGlvbiB0aGF0IHN1cHBvcnRzOlxuLy8gLSBGYXN0IGFuZCBlbnN1cmVzIHVuaXF1ZSBoYXNoIHByb3BlcnRpZXNcbi8vIC0gSGFuZGxlcyB1bnNlcmlhbGl6YWJsZSB2YWx1ZXNcbi8vIC0gSGFuZGxlcyBvYmplY3Qga2V5IG9yZGVyaW5nXG4vLyAtIEdlbmVyYXRlcyBzaG9ydCByZXN1bHRzXG4vL1xuLy8gVGhpcyBpcyBub3QgYSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9uLCBhbmQgdGhlIHJlc3VsdCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZVxuLy8gcGFyc2FibGUuXG5jb25zdCBzdGFibGVIYXNoID0gKGFyZyk9PntcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZztcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGFyZyAmJiBhcmcuY29uc3RydWN0b3I7XG4gICAgY29uc3QgaXNEYXRlID0gY29uc3RydWN0b3IgPT0gRGF0ZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBpbmRleDtcbiAgICBpZiAoT0JKRUNUKGFyZykgPT09IGFyZyAmJiAhaXNEYXRlICYmIGNvbnN0cnVjdG9yICE9IFJlZ0V4cCkge1xuICAgICAgICAvLyBPYmplY3QvZnVuY3Rpb24sIG5vdCBudWxsL2RhdGUvcmVnZXhwLiBVc2UgV2Vha01hcCB0byBzdG9yZSB0aGUgaWQgZmlyc3QuXG4gICAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBoYXNoZWQsIGRpcmVjdGx5IHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgICByZXN1bHQgPSB0YWJsZS5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGhhc2ggZmlyc3QgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3Rpb24gYmVmb3JlIGVudGVyaW5nIHRoZVxuICAgICAgICAvLyByZWN1cnNpdmUgYHN0YWJsZUhhc2hgIGNhbGxzLlxuICAgICAgICAvLyBGb3Igb3RoZXIgb2JqZWN0cyBsaWtlIHNldCBhbmQgbWFwLCB3ZSB1c2UgdGhpcyBpZCBkaXJlY3RseSBhcyB0aGUgaGFzaC5cbiAgICAgICAgcmVzdWx0ID0gKytjb3VudGVyICsgJ34nO1xuICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIEFycmF5LlxuICAgICAgICAgICAgcmVzdWx0ID0gJ0AnO1xuICAgICAgICAgICAgZm9yKGluZGV4ID0gMDsgaW5kZXggPCBhcmcubGVuZ3RoOyBpbmRleCsrKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09IE9CSkVDVCkge1xuICAgICAgICAgICAgLy8gT2JqZWN0LCBzb3J0IGtleXMuXG4gICAgICAgICAgICByZXN1bHQgPSAnIyc7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT0JKRUNULmtleXMoYXJnKS5zb3J0KCk7XG4gICAgICAgICAgICB3aGlsZSghaXNVbmRlZmluZWQoaW5kZXggPSBrZXlzLnBvcCgpKSl7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gaW5kZXggKyAnOicgKyBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0RhdGUgPyBhcmcudG9KU09OKCkgOiB0eXBlID09ICdzeW1ib2wnID8gYXJnLnRvU3RyaW5nKCkgOiB0eXBlID09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkoYXJnKSA6ICcnICsgYXJnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gR2xvYmFsIHN0YXRlIHVzZWQgdG8gZGVkdXBsaWNhdGUgcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVyc1xuY29uc3QgU1dSR2xvYmFsU3RhdGUgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBFTVBUWV9DQUNIRSA9IHt9O1xuY29uc3QgSU5JVElBTF9DQUNIRSA9IHt9O1xuY29uc3QgU1RSX1VOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xuLy8gTk9URTogVXNlIHRoZSBmdW5jdGlvbiB0byBndWFyYW50ZWUgaXQncyByZS1ldmFsdWF0ZWQgYmV0d2VlbiBqc2RvbSBhbmQgbm9kZSBydW50aW1lIGZvciB0ZXN0cy5cbmNvbnN0IGlzV2luZG93RGVmaW5lZCA9IHR5cGVvZiB3aW5kb3cgIT0gU1RSX1VOREVGSU5FRDtcbmNvbnN0IGlzRG9jdW1lbnREZWZpbmVkID0gdHlwZW9mIGRvY3VtZW50ICE9IFNUUl9VTkRFRklORUQ7XG5jb25zdCBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoKT0+aXNXaW5kb3dEZWZpbmVkICYmIHR5cGVvZiB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddICE9IFNUUl9VTkRFRklORUQ7XG5jb25zdCBjcmVhdGVDYWNoZUhlbHBlciA9IChjYWNoZSwga2V5KT0+e1xuICAgIGNvbnN0IHN0YXRlID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBHZXR0ZXJcbiAgICAgICAgKCk9PiFpc1VuZGVmaW5lZChrZXkpICYmIGNhY2hlLmdldChrZXkpIHx8IEVNUFRZX0NBQ0hFLFxuICAgICAgICAvLyBTZXR0ZXJcbiAgICAgICAgKGluZm8pPT57XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgLy8gQmVmb3JlIHdyaXRpbmcgdG8gdGhlIHN0b3JlLCB3ZSBrZWVwIHRoZSB2YWx1ZSBpbiB0aGUgaW5pdGlhbCBjYWNoZVxuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHRoZXJlIHlldC5cbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gSU5JVElBTF9DQUNIRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgSU5JVElBTF9DQUNIRVtrZXldID0gcHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGVbNV0oa2V5LCBtZXJnZU9iamVjdHMocHJldiwgaW5mbyksIHByZXYgfHwgRU1QVFlfQ0FDSEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBTdWJzY3JpYmVyXG4gICAgICAgIHN0YXRlWzZdLFxuICAgICAgICAvLyBHZXQgc2VydmVyIGNhY2hlIHNuYXBzaG90XG4gICAgICAgICgpPT57XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2FjaGUgd2FzIHVwZGF0ZWQgb24gdGhlIGNsaWVudCwgd2UgcmV0dXJuIHRoZSBzdG9yZWQgaW5pdGlhbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIElOSVRJQUxfQ0FDSEUpIHJldHVybiBJTklUSUFMX0NBQ0hFW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IGRvbmUgYW55IGNsaWVudC1zaWRlIHVwZGF0ZXMsIHdlIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAhaXNVbmRlZmluZWQoa2V5KSAmJiBjYWNoZS5nZXQoa2V5KSB8fCBFTVBUWV9DQUNIRTtcbiAgICAgICAgfVxuICAgIF07XG59IC8vIGV4cG9ydCB7IFVOREVGSU5FRCwgT0JKRUNULCBpc1VuZGVmaW5lZCwgaXNGdW5jdGlvbiwgbWVyZ2VPYmplY3RzLCBpc1Byb21pc2VMaWtlIH1cbjtcblxuLyoqXG4gKiBEdWUgdG8gdGhlIGJ1ZyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02NzgwNzUsXG4gKiBpdCdzIG5vdCByZWxpYWJsZSB0byBkZXRlY3QgaWYgdGhlIGJyb3dzZXIgaXMgY3VycmVudGx5IG9ubGluZSBvciBvZmZsaW5lXG4gKiBiYXNlZCBvbiBgbmF2aWdhdG9yLm9uTGluZWAuXG4gKiBBcyBhIHdvcmthcm91bmQsIHdlIGFsd2F5cyBhc3N1bWUgaXQncyBvbmxpbmUgb24gdGhlIGZpcnN0IGxvYWQsIGFuZCBjaGFuZ2VcbiAqIHRoZSBzdGF0dXMgdXBvbiBgb25saW5lYCBvciBgb2ZmbGluZWAgZXZlbnRzLlxuICovIGxldCBvbmxpbmUgPSB0cnVlO1xuY29uc3QgaXNPbmxpbmUgPSAoKT0+b25saW5lO1xuLy8gRm9yIG5vZGUgYW5kIFJlYWN0IE5hdGl2ZSwgYGFkZC9yZW1vdmVFdmVudExpc3RlbmVyYCBkb2Vzbid0IGV4aXN0IG9uIHdpbmRvdy5cbmNvbnN0IFtvbldpbmRvd0V2ZW50LCBvZmZXaW5kb3dFdmVudF0gPSBpc1dpbmRvd0RlZmluZWQgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyBbXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpLFxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQod2luZG93KVxuXSA6IFtcbiAgICBub29wLFxuICAgIG5vb3Bcbl07XG5jb25zdCBpc1Zpc2libGUgPSAoKT0+e1xuICAgIGNvbnN0IHZpc2liaWxpdHlTdGF0ZSA9IGlzRG9jdW1lbnREZWZpbmVkICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmlzaWJpbGl0eVN0YXRlKSB8fCB2aXNpYmlsaXR5U3RhdGUgIT09ICdoaWRkZW4nO1xufTtcbmNvbnN0IGluaXRGb2N1cyA9IChjYWxsYmFjayk9PntcbiAgICAvLyBmb2N1cyByZXZhbGlkYXRlXG4gICAgaWYgKGlzRG9jdW1lbnREZWZpbmVkKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIG9uV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBpZiAoaXNEb2N1bWVudERlZmluZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xuICAgIH07XG59O1xuY29uc3QgaW5pdFJlY29ubmVjdCA9IChjYWxsYmFjayk9PntcbiAgICAvLyByZXZhbGlkYXRlIG9uIHJlY29ubmVjdGVkXG4gICAgY29uc3Qgb25PbmxpbmUgPSAoKT0+e1xuICAgICAgICBvbmxpbmUgPSB0cnVlO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgLy8gbm90aGluZyB0byByZXZhbGlkYXRlLCBqdXN0IHVwZGF0ZSB0aGUgc3RhdHVzXG4gICAgY29uc3Qgb25PZmZsaW5lID0gKCk9PntcbiAgICAgICAgb25saW5lID0gZmFsc2U7XG4gICAgfTtcbiAgICBvbldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XG4gICAgb25XaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcbiAgICB9O1xufTtcbmNvbnN0IHByZXNldCA9IHtcbiAgICBpc09ubGluZSxcbiAgICBpc1Zpc2libGVcbn07XG5jb25zdCBkZWZhdWx0Q29uZmlnT3B0aW9ucyA9IHtcbiAgICBpbml0Rm9jdXMsXG4gICAgaW5pdFJlY29ubmVjdFxufTtcblxuY29uc3QgSVNfUkVBQ1RfTEVHQUNZID0gIVJlYWN0LnVzZUlkO1xuY29uc3QgSVNfU0VSVkVSID0gIWlzV2luZG93RGVmaW5lZCB8fCAnRGVubycgaW4gd2luZG93O1xuLy8gUG9seWZpbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5jb25zdCByQUYgPSAoZik9Pmhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSgpID8gd2luZG93WydyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXShmKSA6IHNldFRpbWVvdXQoZiwgMSk7XG4vLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuLy8gVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbi8vIHVzZUxheW91dEVmZmVjdCBpbiB0aGUgYnJvd3Nlci5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBJU19TRVJWRVIgPyB1c2VFZmZlY3QgOiB1c2VMYXlvdXRFZmZlY3Q7XG4vLyBUaGlzIGFzc2lnbm1lbnQgaXMgdG8gZXh0ZW5kIHRoZSBOYXZpZ2F0b3IgdHlwZSB0byB1c2UgZWZmZWN0aXZlVHlwZS5cbmNvbnN0IG5hdmlnYXRvckNvbm5lY3Rpb24gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuY29ubmVjdGlvbjtcbi8vIEFkanVzdCB0aGUgY29uZmlnIGJhc2VkIG9uIHNsb3cgY29ubmVjdGlvbiBzdGF0dXMgKDw9IDcwS2JwcykuXG5jb25zdCBzbG93Q29ubmVjdGlvbiA9ICFJU19TRVJWRVIgJiYgbmF2aWdhdG9yQ29ubmVjdGlvbiAmJiAoW1xuICAgICdzbG93LTJnJyxcbiAgICAnMmcnXG5dLmluY2x1ZGVzKG5hdmlnYXRvckNvbm5lY3Rpb24uZWZmZWN0aXZlVHlwZSkgfHwgbmF2aWdhdG9yQ29ubmVjdGlvbi5zYXZlRGF0YSk7XG5cbmNvbnN0IHNlcmlhbGl6ZSA9IChrZXkpPT57XG4gICAgaWYgKGlzRnVuY3Rpb24oa2V5KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAga2V5ID0ga2V5KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gZGVwZW5kZW5jaWVzIG5vdCByZWFkeVxuICAgICAgICAgICAga2V5ID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlIHRoZSBvcmlnaW5hbCBrZXkgYXMgdGhlIGFyZ3VtZW50IG9mIGZldGNoZXIuIFRoaXMgY2FuIGJlIGEgc3RyaW5nIG9yIGFuXG4gICAgLy8gYXJyYXkgb2YgdmFsdWVzLlxuICAgIGNvbnN0IGFyZ3MgPSBrZXk7XG4gICAgLy8gSWYga2V5IGlzIG5vdCBmYWxzeSwgb3Igbm90IGFuIGVtcHR5IGFycmF5LCBoYXNoIGl0LlxuICAgIGtleSA9IHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAoQXJyYXkuaXNBcnJheShrZXkpID8ga2V5Lmxlbmd0aCA6IGtleSkgPyBzdGFibGVIYXNoKGtleSkgOiAnJztcbiAgICByZXR1cm4gW1xuICAgICAgICBrZXksXG4gICAgICAgIGFyZ3NcbiAgICBdO1xufTtcblxuLy8gR2xvYmFsIHRpbWVzdGFtcC5cbmxldCBfX3RpbWVzdGFtcCA9IDA7XG5jb25zdCBnZXRUaW1lc3RhbXAgPSAoKT0+KytfX3RpbWVzdGFtcDtcblxuY29uc3QgRk9DVVNfRVZFTlQgPSAwO1xuY29uc3QgUkVDT05ORUNUX0VWRU5UID0gMTtcbmNvbnN0IE1VVEFURV9FVkVOVCA9IDI7XG5jb25zdCBFUlJPUl9SRVZBTElEQVRFX0VWRU5UID0gMztcblxudmFyIGV2ZW50cyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBFUlJPUl9SRVZBTElEQVRFX0VWRU5UOiBFUlJPUl9SRVZBTElEQVRFX0VWRU5ULFxuICBGT0NVU19FVkVOVDogRk9DVVNfRVZFTlQsXG4gIE1VVEFURV9FVkVOVDogTVVUQVRFX0VWRU5ULFxuICBSRUNPTk5FQ1RfRVZFTlQ6IFJFQ09OTkVDVF9FVkVOVFxufTtcblxuYXN5bmMgZnVuY3Rpb24gaW50ZXJuYWxNdXRhdGUoLi4uYXJncykge1xuICAgIGNvbnN0IFtjYWNoZSwgX2tleSwgX2RhdGEsIF9vcHRzXSA9IGFyZ3M7XG4gICAgLy8gV2hlbiBwYXNzaW5nIGFzIGEgYm9vbGVhbiwgaXQncyBleHBsaWNpdGx5IHVzZWQgdG8gZGlzYWJsZS9lbmFibGVcbiAgICAvLyByZXZhbGlkYXRpb24uXG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyh7XG4gICAgICAgIHBvcHVsYXRlQ2FjaGU6IHRydWUsXG4gICAgICAgIHRocm93T25FcnJvcjogdHJ1ZVxuICAgIH0sIHR5cGVvZiBfb3B0cyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICByZXZhbGlkYXRlOiBfb3B0c1xuICAgIH0gOiBfb3B0cyB8fCB7fSk7XG4gICAgbGV0IHBvcHVsYXRlQ2FjaGUgPSBvcHRpb25zLnBvcHVsYXRlQ2FjaGU7XG4gICAgY29uc3Qgcm9sbGJhY2tPbkVycm9yT3B0aW9uID0gb3B0aW9ucy5yb2xsYmFja09uRXJyb3I7XG4gICAgbGV0IG9wdGltaXN0aWNEYXRhID0gb3B0aW9ucy5vcHRpbWlzdGljRGF0YTtcbiAgICBjb25zdCByb2xsYmFja09uRXJyb3IgPSAoZXJyb3IpPT57XG4gICAgICAgIHJldHVybiB0eXBlb2Ygcm9sbGJhY2tPbkVycm9yT3B0aW9uID09PSAnZnVuY3Rpb24nID8gcm9sbGJhY2tPbkVycm9yT3B0aW9uKGVycm9yKSA6IHJvbGxiYWNrT25FcnJvck9wdGlvbiAhPT0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCB0aHJvd09uRXJyb3IgPSBvcHRpb25zLnRocm93T25FcnJvcjtcbiAgICAvLyBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEga2V5IGZpbHRlciwgcmV0dXJuIHRoZSBtdXRhdGlvbiByZXN1bHRzIGZvciBhbGxcbiAgICAvLyBmaWx0ZXJlZCBrZXlzLlxuICAgIGlmIChpc0Z1bmN0aW9uKF9rZXkpKSB7XG4gICAgICAgIGNvbnN0IGtleUZpbHRlciA9IF9rZXk7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRLZXlzID0gW107XG4gICAgICAgIGNvbnN0IGl0ID0gY2FjaGUua2V5cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBpdCl7XG4gICAgICAgICAgICBpZiAoLy8gU2tpcCB0aGUgc3BlY2lhbCB1c2VTV1JJbmZpbml0ZSBhbmQgdXNlU1dSU3Vic2NyaXB0aW9uIGtleXMuXG4gICAgICAgICAgICAhL15cXCQoaW5mfHN1YilcXCQvLnRlc3Qoa2V5KSAmJiBrZXlGaWx0ZXIoY2FjaGUuZ2V0KGtleSkuX2spKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZEtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChtYXRjaGVkS2V5cy5tYXAobXV0YXRlQnlLZXkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG11dGF0ZUJ5S2V5KF9rZXkpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIG11dGF0ZUJ5S2V5KF9rKSB7XG4gICAgICAgIC8vIFNlcmlhbGl6ZSBrZXlcbiAgICAgICAgY29uc3QgW2tleV0gPSBzZXJpYWxpemUoX2spO1xuICAgICAgICBpZiAoIWtleSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBbZ2V0LCBzZXRdID0gY3JlYXRlQ2FjaGVIZWxwZXIoY2FjaGUsIGtleSk7XG4gICAgICAgIGNvbnN0IFtFVkVOVF9SRVZBTElEQVRPUlMsIE1VVEFUSU9OLCBGRVRDSCwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgICAgICBjb25zdCBzdGFydFJldmFsaWRhdGUgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3QgcmV2YWxpZGF0b3JzID0gRVZFTlRfUkVWQUxJREFUT1JTW2tleV07XG4gICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gaXNGdW5jdGlvbihvcHRpb25zLnJldmFsaWRhdGUpID8gb3B0aW9ucy5yZXZhbGlkYXRlKGdldCgpLmRhdGEsIF9rKSA6IG9wdGlvbnMucmV2YWxpZGF0ZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgdGhlIGtleSBieSBkZWxldGluZyB0aGUgY29uY3VycmVudCByZXF1ZXN0IG1hcmtlcnMgc28gbmV3XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdHMgd2lsbCBub3QgYmUgZGVkdXBlZC5cbiAgICAgICAgICAgICAgICBkZWxldGUgRkVUQ0hba2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgUFJFTE9BRFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRvcnNbMF0oTVVUQVRFX0VWRU5UKS50aGVuKCgpPT5nZXQoKS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0KCkuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbmV3IGRhdGEgcHJvdmlkZWQsIHJldmFsaWRhdGUgdGhlIGtleSB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgYW5kIGJyb2FkY2FzdCBzdGF0ZS5cbiAgICAgICAgICAgIHJldHVybiBzdGFydFJldmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IF9kYXRhO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgdGltZXN0YW1wcy5cbiAgICAgICAgY29uc3QgYmVmb3JlTXV0YXRpb25UcyA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICBNVVRBVElPTltrZXldID0gW1xuICAgICAgICAgICAgYmVmb3JlTXV0YXRpb25UcyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaGFzT3B0aW1pc3RpY0RhdGEgPSAhaXNVbmRlZmluZWQob3B0aW1pc3RpY0RhdGEpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAvLyBgZGlzcGxheWVkRGF0YWAgaXMgdGhlIGN1cnJlbnQgdmFsdWUgb24gc2NyZWVuLiBJdCBjb3VsZCBiZSB0aGUgb3B0aW1pc3RpYyB2YWx1ZVxuICAgICAgICAvLyB0aGF0IGlzIGdvaW5nIHRvIGJlIG92ZXJyaWRkZW4gYnkgYSBgY29tbWl0dGVkRGF0YWAsIG9yIGdldCByZXZlcnRlZCBiYWNrLlxuICAgICAgICAvLyBgY29tbWl0dGVkRGF0YWAgaXMgdGhlIHZhbGlkYXRlZCB2YWx1ZSB0aGF0IGNvbWVzIGZyb20gYSBmZXRjaCBvciBtdXRhdGlvbi5cbiAgICAgICAgY29uc3QgZGlzcGxheWVkRGF0YSA9IHN0YXRlLmRhdGE7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREYXRhID0gc3RhdGUuX2M7XG4gICAgICAgIGNvbnN0IGNvbW1pdHRlZERhdGEgPSBpc1VuZGVmaW5lZChjdXJyZW50RGF0YSkgPyBkaXNwbGF5ZWREYXRhIDogY3VycmVudERhdGE7XG4gICAgICAgIC8vIERvIG9wdGltaXN0aWMgZGF0YSB1cGRhdGUuXG4gICAgICAgIGlmIChoYXNPcHRpbWlzdGljRGF0YSkge1xuICAgICAgICAgICAgb3B0aW1pc3RpY0RhdGEgPSBpc0Z1bmN0aW9uKG9wdGltaXN0aWNEYXRhKSA/IG9wdGltaXN0aWNEYXRhKGNvbW1pdHRlZERhdGEsIGRpc3BsYXllZERhdGEpIDogb3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIHNldCBvcHRpbWlzdGljIGRhdGEsIGJhY2t1cCB0aGUgY3VycmVudCBjb21taXR0ZWREYXRhIGRhdGEgaW4gYF9jYC5cbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgZGF0YTogb3B0aW1pc3RpY0RhdGEsXG4gICAgICAgICAgICAgICAgX2M6IGNvbW1pdHRlZERhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgICAgICAvLyBgZGF0YWAgaXMgYSBmdW5jdGlvbiwgY2FsbCBpdCBwYXNzaW5nIGN1cnJlbnQgY2FjaGUgdmFsdWUuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhKGNvbW1pdHRlZERhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgdGhyb3dzIGFuIGVycm9yIHN5bmNocm9ub3VzbHksIHdlIHNob3VsZG4ndCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGBkYXRhYCBpcyBhIHByb21pc2UvdGhlbmFibGUsIHJlc29sdmUgdGhlIGZpbmFsIGRhdGEgZmlyc3QuXG4gICAgICAgIGlmIChkYXRhICYmIGlzUHJvbWlzZUxpa2UoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgbXV0YXRpb24gaXMgYXN5bmMsIHdlIG5lZWQgdG8gY2hlY2sgdGltZXN0YW1wcyB0b1xuICAgICAgICAgICAgLy8gYXZvaWQgcmFjZSBjb25kaXRpb25zLlxuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IGRhdGEuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb3RoZXIgbXV0YXRpb25zIGhhdmUgb2NjdXJyZWQgc2luY2Ugd2UndmUgc3RhcnRlZCB0aGlzIG11dGF0aW9uLlxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxuICAgICAgICAgICAgLy8ganVzdCByZXR1cm4gdGhlIGRhdGEuXG4gICAgICAgICAgICBpZiAoYmVmb3JlTXV0YXRpb25UcyAhPT0gTVVUQVRJT05ba2V5XVswXSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yICYmIGhhc09wdGltaXN0aWNEYXRhICYmIHJvbGxiYWNrT25FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAvLyBSb2xsYmFjay4gQWx3YXlzIHBvcHVsYXRlIHRoZSBjYWNoZSBpbiB0aGlzIGNhc2UgYnV0IHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1pbmcgdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSB0byBiZSB0aGUgbGF0ZXN0IGNvbW1pdHRlZCBkYXRhLCBhbmQgY2xlYXIgdGhlIGBfY2AgdmFsdWUuXG4gICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY29tbWl0dGVkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgX2M6IFVOREVGSU5FRFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIHNob3VsZCB3cml0ZSBiYWNrIHRoZSBjYWNoZSBhZnRlciByZXF1ZXN0LlxuICAgICAgICBpZiAocG9wdWxhdGVDYWNoZSkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgcmVzdWx0IGludG8gZGF0YS5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwb3B1bGF0ZUNhY2hlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3B1bGF0ZUNhY2hlZERhdGEgPSBwb3B1bGF0ZUNhY2hlKGRhdGEsIGNvbW1pdHRlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcG9wdWxhdGVDYWNoZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFVOREVGSU5FRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jOiBVTkRFRklORURcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgY2FjaGVkIGRhdGEgYW5kIHJlc2V0IHRoZSBlcnJvciBpZiB0aGVyZSdzIG5vIGVycm9yLiBEYXRhIGNhbiBiZSBgdW5kZWZpbmVkYCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBVTkRFRklORUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYzogVU5ERUZJTkVEXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIHRvIG1hcmsgdGhlIG11dGF0aW9uIGhhcyBlbmRlZC5cbiAgICAgICAgTVVUQVRJT05ba2V5XVsxXSA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgU1dSIEhvb2tzJyBpbnRlcm5hbCBzdGF0ZXM6XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShzdGFydFJldmFsaWRhdGUoKSkudGhlbigoKT0+e1xuICAgICAgICAgICAgLy8gVGhlIG11dGF0aW9uIGFuZCByZXZhbGlkYXRpb24gYXJlIGVuZGVkLCB3ZSBjYW4gY2xlYXIgaXQgc2luY2UgdGhlIGRhdGEgaXNcbiAgICAgICAgICAgIC8vIG5vdCBhbiBvcHRpbWlzdGljIHZhbHVlIGFueW1vcmUuXG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIF9jOiBVTkRFRklORURcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhyb3cgZXJyb3Igb3IgcmV0dXJuIGRhdGFcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5cbmNvbnN0IHJldmFsaWRhdGVBbGxLZXlzID0gKHJldmFsaWRhdG9ycywgdHlwZSk9PntcbiAgICBmb3IoY29uc3Qga2V5IGluIHJldmFsaWRhdG9ycyl7XG4gICAgICAgIGlmIChyZXZhbGlkYXRvcnNba2V5XVswXSkgcmV2YWxpZGF0b3JzW2tleV1bMF0odHlwZSk7XG4gICAgfVxufTtcbmNvbnN0IGluaXRDYWNoZSA9IChwcm92aWRlciwgb3B0aW9ucyk9PntcbiAgICAvLyBUaGUgZ2xvYmFsIHN0YXRlIGZvciBhIHNwZWNpZmljIHByb3ZpZGVyIHdpbGwgYmUgdXNlZCB0byBkZWR1cGxpY2F0ZVxuICAgIC8vIHJlcXVlc3RzIGFuZCBzdG9yZSBsaXN0ZW5lcnMuIEFzIHdlbGwgYXMgYSBtdXRhdGUgZnVuY3Rpb24gdGhhdCBpcyBib3VuZCB0b1xuICAgIC8vIHRoZSBjYWNoZS5cbiAgICAvLyBUaGUgcHJvdmlkZXIncyBnbG9iYWwgc3RhdGUgbWlnaHQgYmUgYWxyZWFkeSBpbml0aWFsaXplZC4gTGV0J3MgdHJ5IHRvIGdldCB0aGVcbiAgICAvLyBnbG9iYWwgc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlciBmaXJzdC5cbiAgICBpZiAoIVNXUkdsb2JhbFN0YXRlLmhhcyhwcm92aWRlcikpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZ2xvYmFsIHN0YXRlIGJvdW5kIHRvIHRoZSBwcm92aWRlciwgY3JlYXRlIGEgbmV3IG9uZSB3aXRoIHRoZVxuICAgICAgICAvLyBuZXcgbXV0YXRlIGZ1bmN0aW9uLlxuICAgICAgICBjb25zdCBFVkVOVF9SRVZBTElEQVRPUlMgPSB7fTtcbiAgICAgICAgY29uc3QgbXV0YXRlID0gaW50ZXJuYWxNdXRhdGUuYmluZChVTkRFRklORUQsIHByb3ZpZGVyKTtcbiAgICAgICAgbGV0IHVubW91bnQgPSBub29wO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0ge307XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IChrZXksIGNhbGxiYWNrKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3VicyA9IHN1YnNjcmlwdGlvbnNba2V5XSB8fCBbXTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnNba2V5XSA9IHN1YnM7XG4gICAgICAgICAgICBzdWJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuICgpPT5zdWJzLnNwbGljZShzdWJzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0dGVyID0gKGtleSwgdmFsdWUsIHByZXYpPT57XG4gICAgICAgICAgICBwcm92aWRlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBzdWJzID0gc3Vic2NyaXB0aW9uc1trZXldO1xuICAgICAgICAgICAgaWYgKHN1YnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIHN1YnMpe1xuICAgICAgICAgICAgICAgICAgICBmbih2YWx1ZSwgcHJldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbml0UHJvdmlkZXIgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKCFTV1JHbG9iYWxTdGF0ZS5oYXMocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSBpZiBpdCdzIG5ldywgb3IgaWYgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGV4dGVuZGVkLlxuICAgICAgICAgICAgICAgIFNXUkdsb2JhbFN0YXRlLnNldChwcm92aWRlciwgW1xuICAgICAgICAgICAgICAgICAgICBFVkVOVF9SRVZBTElEQVRPUlMsXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyLFxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBpZiAoIUlTX1NFUlZFUikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGxpc3RlbmluZyB0byB0aGUgbmF0aXZlIGV2ZW50cyBmb3IgYXV0byByZXZhbGlkYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBpbnRlbnRpb25hbGx5IHB1dCBhIGRlbGF5IChzZXRUaW1lb3V0KSBoZXJlIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlZCBhZnRlciBpbW1lZGlhdGUgSmF2YVNjcmlwdCBleGVjdXRpb25zLCB3aGljaCBjYW4gYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhY3QncyBzdGF0ZSB1cGRhdGVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBzb21lIHVubmVjZXNzYXJ5IHJldmFsaWRhdGlvbnMgc3VjaCBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9pc3N1ZXMvMTY4MC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsZWFzZUZvY3VzID0gb3B0cy5pbml0Rm9jdXMoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgRk9DVVNfRVZFTlQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VSZWNvbm5lY3QgPSBvcHRzLmluaXRSZWNvbm5lY3Qoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgUkVDT05ORUNUX0VWRU5UKSkpO1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50ID0gKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VGb2N1cyAmJiByZWxlYXNlRm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VSZWNvbm5lY3QgJiYgcmVsZWFzZVJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bi1tb3VudGluZywgd2UgbmVlZCB0byByZW1vdmUgdGhlIGNhY2hlIHByb3ZpZGVyIGZyb20gdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yYWdlIHRvbyBiZWNhdXNlIGl0J3MgYSBzaWRlLWVmZmVjdC4gT3RoZXJ3aXNlLCB3aGVuIHJlLW1vdW50aW5nIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdCByZS1yZWdpc3RlciB0aG9zZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBTV1JHbG9iYWxTdGF0ZS5kZWxldGUocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW5pdFByb3ZpZGVyKCk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgcHJvdmlkZXIsIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBpdCBhbmQgc2V0dXAgRE9NIGV2ZW50c1xuICAgICAgICAvLyBsaXN0ZW5lcnMgZm9yIGBmb2N1c2AgYW5kIGByZWNvbm5lY3RgIGFjdGlvbnMuXG4gICAgICAgIC8vIFdlIG1pZ2h0IHdhbnQgdG8gaW5qZWN0IGFuIGV4dHJhIGxheWVyIG9uIHRvcCBvZiBgcHJvdmlkZXJgIGluIHRoZSBmdXR1cmUsXG4gICAgICAgIC8vIHN1Y2ggYXMga2V5IHNlcmlhbGl6YXRpb24sIGF1dG8gR0MsIGV0Yy5cbiAgICAgICAgLy8gRm9yIG5vdywgaXQncyBqdXN0IGEgYE1hcGAgaW50ZXJmYWNlIHdpdGhvdXQgYW55IG1vZGlmaWNhdGlvbnMuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIGluaXRQcm92aWRlcixcbiAgICAgICAgICAgIHVubW91bnRcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIFNXUkdsb2JhbFN0YXRlLmdldChwcm92aWRlcilbNF1cbiAgICBdO1xufTtcblxuLy8gZXJyb3IgcmV0cnlcbmNvbnN0IG9uRXJyb3JSZXRyeSA9IChfLCBfXywgY29uZmlnLCByZXZhbGlkYXRlLCBvcHRzKT0+e1xuICAgIGNvbnN0IG1heFJldHJ5Q291bnQgPSBjb25maWcuZXJyb3JSZXRyeUNvdW50O1xuICAgIGNvbnN0IGN1cnJlbnRSZXRyeUNvdW50ID0gb3B0cy5yZXRyeUNvdW50O1xuICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICBjb25zdCB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjUpICogKDEgPDwgKGN1cnJlbnRSZXRyeUNvdW50IDwgOCA/IGN1cnJlbnRSZXRyeUNvdW50IDogOCkpKSAqIGNvbmZpZy5lcnJvclJldHJ5SW50ZXJ2YWw7XG4gICAgaWYgKCFpc1VuZGVmaW5lZChtYXhSZXRyeUNvdW50KSAmJiBjdXJyZW50UmV0cnlDb3VudCA+IG1heFJldHJ5Q291bnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KHJldmFsaWRhdGUsIHRpbWVvdXQsIG9wdHMpO1xufTtcbmNvbnN0IGNvbXBhcmUgPSAoY3VycmVudERhdGEsIG5ld0RhdGEpPT5zdGFibGVIYXNoKGN1cnJlbnREYXRhKSA9PSBzdGFibGVIYXNoKG5ld0RhdGEpO1xuLy8gRGVmYXVsdCBjYWNoZSBwcm92aWRlclxuY29uc3QgW2NhY2hlLCBtdXRhdGVdID0gaW5pdENhY2hlKG5ldyBNYXAoKSk7XG4vLyBEZWZhdWx0IGNvbmZpZ1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IG1lcmdlT2JqZWN0cyh7XG4gICAgLy8gZXZlbnRzXG4gICAgb25Mb2FkaW5nU2xvdzogbm9vcCxcbiAgICBvblN1Y2Nlc3M6IG5vb3AsXG4gICAgb25FcnJvcjogbm9vcCxcbiAgICBvbkVycm9yUmV0cnksXG4gICAgb25EaXNjYXJkZWQ6IG5vb3AsXG4gICAgLy8gc3dpdGNoZXNcbiAgICByZXZhbGlkYXRlT25Gb2N1czogdHJ1ZSxcbiAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6IHRydWUsXG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6IHRydWUsXG4gICAgc2hvdWxkUmV0cnlPbkVycm9yOiB0cnVlLFxuICAgIC8vIHRpbWVvdXRzXG4gICAgZXJyb3JSZXRyeUludGVydmFsOiBzbG93Q29ubmVjdGlvbiA/IDEwMDAwIDogNTAwMCxcbiAgICBmb2N1c1Rocm90dGxlSW50ZXJ2YWw6IDUgKiAxMDAwLFxuICAgIGRlZHVwaW5nSW50ZXJ2YWw6IDIgKiAxMDAwLFxuICAgIGxvYWRpbmdUaW1lb3V0OiBzbG93Q29ubmVjdGlvbiA/IDUwMDAgOiAzMDAwLFxuICAgIC8vIHByb3ZpZGVyc1xuICAgIGNvbXBhcmUsXG4gICAgaXNQYXVzZWQ6ICgpPT5mYWxzZSxcbiAgICBjYWNoZSxcbiAgICBtdXRhdGUsXG4gICAgZmFsbGJhY2s6IHt9XG59LCAvLyB1c2Ugd2ViIHByZXNldCBieSBkZWZhdWx0XG5wcmVzZXQpO1xuXG5jb25zdCBtZXJnZUNvbmZpZ3MgPSAoYSwgYik9PntcbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIGhlcmUuXG4gICAgY29uc3QgdiA9IG1lcmdlT2JqZWN0cyhhLCBiKTtcbiAgICAvLyBJZiB0d28gY29uZmlncyBhcmUgcHJvdmlkZWQsIG1lcmdlIHRoZWlyIGB1c2VgIGFuZCBgZmFsbGJhY2tgIG9wdGlvbnMuXG4gICAgaWYgKGIpIHtcbiAgICAgICAgY29uc3QgeyB1c2U6IHUxLCBmYWxsYmFjazogZjEgfSA9IGE7XG4gICAgICAgIGNvbnN0IHsgdXNlOiB1MiwgZmFsbGJhY2s6IGYyIH0gPSBiO1xuICAgICAgICBpZiAodTEgJiYgdTIpIHtcbiAgICAgICAgICAgIHYudXNlID0gdTEuY29uY2F0KHUyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZjEgJiYgZjIpIHtcbiAgICAgICAgICAgIHYuZmFsbGJhY2sgPSBtZXJnZU9iamVjdHMoZjEsIGYyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbmNvbnN0IFNXUkNvbmZpZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbmNvbnN0IFNXUkNvbmZpZyA9IChwcm9wcyk9PntcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBwcm9wcztcbiAgICBjb25zdCBwYXJlbnRDb25maWcgPSB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpO1xuICAgIGNvbnN0IGlzRnVuY3Rpb25hbENvbmZpZyA9IGlzRnVuY3Rpb24odmFsdWUpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHVzZU1lbW8oKCk9PmlzRnVuY3Rpb25hbENvbmZpZyA/IHZhbHVlKHBhcmVudENvbmZpZykgOiB2YWx1ZSwgW1xuICAgICAgICBpc0Z1bmN0aW9uYWxDb25maWcsXG4gICAgICAgIHBhcmVudENvbmZpZyxcbiAgICAgICAgdmFsdWVcbiAgICBdKTtcbiAgICAvLyBFeHRlbmQgcGFyZW50IGNvbnRleHQgdmFsdWVzIGFuZCBtaWRkbGV3YXJlLlxuICAgIGNvbnN0IGV4dGVuZGVkQ29uZmlnID0gdXNlTWVtbygoKT0+aXNGdW5jdGlvbmFsQ29uZmlnID8gY29uZmlnIDogbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSwgW1xuICAgICAgICBpc0Z1bmN0aW9uYWxDb25maWcsXG4gICAgICAgIHBhcmVudENvbmZpZyxcbiAgICAgICAgY29uZmlnXG4gICAgXSk7XG4gICAgLy8gU2hvdWxkIG5vdCB1c2UgdGhlIGluaGVyaXRlZCBwcm92aWRlci5cbiAgICBjb25zdCBwcm92aWRlciA9IGNvbmZpZyAmJiBjb25maWcucHJvdmlkZXI7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgY2FjaGUgb25seSBvbiBmaXJzdCBhY2Nlc3MuXG4gICAgY29uc3QgY2FjaGVDb250ZXh0UmVmID0gdXNlUmVmKFVOREVGSU5FRCk7XG4gICAgaWYgKHByb3ZpZGVyICYmICFjYWNoZUNvbnRleHRSZWYuY3VycmVudCkge1xuICAgICAgICBjYWNoZUNvbnRleHRSZWYuY3VycmVudCA9IGluaXRDYWNoZShwcm92aWRlcihleHRlbmRlZENvbmZpZy5jYWNoZSB8fCBjYWNoZSksIGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlQ29udGV4dCA9IGNhY2hlQ29udGV4dFJlZi5jdXJyZW50O1xuICAgIC8vIE92ZXJyaWRlIHRoZSBjYWNoZSBpZiBhIG5ldyBwcm92aWRlciBpcyBnaXZlbi5cbiAgICBpZiAoY2FjaGVDb250ZXh0KSB7XG4gICAgICAgIGV4dGVuZGVkQ29uZmlnLmNhY2hlID0gY2FjaGVDb250ZXh0WzBdO1xuICAgICAgICBleHRlbmRlZENvbmZpZy5tdXRhdGUgPSBjYWNoZUNvbnRleHRbMV07XG4gICAgfVxuICAgIC8vIFVuc3Vic2NyaWJlIGV2ZW50cy5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChjYWNoZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGNhY2hlQ29udGV4dFsyXSAmJiBjYWNoZUNvbnRleHRbMl0oKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUNvbnRleHRbM107XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoU1dSQ29uZmlnQ29udGV4dC5Qcm92aWRlciwgbWVyZ2VPYmplY3RzKHByb3BzLCB7XG4gICAgICAgIHZhbHVlOiBleHRlbmRlZENvbmZpZ1xuICAgIH0pKTtcbn07XG5cbmNvbnN0IElORklOSVRFX1BSRUZJWCA9ICckaW5mJCc7XG5cbi8vIEB0cy1leHBlY3QtZXJyb3JcbmNvbnN0IGVuYWJsZURldnRvb2xzID0gaXNXaW5kb3dEZWZpbmVkICYmIHdpbmRvdy5fX1NXUl9ERVZUT09MU19VU0VfXztcbmNvbnN0IHVzZSA9IGVuYWJsZURldnRvb2xzID8gd2luZG93Ll9fU1dSX0RFVlRPT0xTX1VTRV9fIDogW107XG5jb25zdCBzZXR1cERldlRvb2xzID0gKCk9PntcbiAgICBpZiAoZW5hYmxlRGV2dG9vbHMpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB3aW5kb3cuX19TV1JfREVWVE9PTFNfUkVBQ1RfXyA9IFJlYWN0O1xuICAgIH1cbn07XG5cbmNvbnN0IG5vcm1hbGl6ZSA9IChhcmdzKT0+e1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGFyZ3NbMV0pID8gW1xuICAgICAgICBhcmdzWzBdLFxuICAgICAgICBhcmdzWzFdLFxuICAgICAgICBhcmdzWzJdIHx8IHt9XG4gICAgXSA6IFtcbiAgICAgICAgYXJnc1swXSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgKGFyZ3NbMV0gPT09IG51bGwgPyBhcmdzWzJdIDogYXJnc1sxXSkgfHwge31cbiAgICBdO1xufTtcblxuY29uc3QgdXNlU1dSQ29uZmlnID0gKCk9PntcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWcsIHVzZUNvbnRleHQoU1dSQ29uZmlnQ29udGV4dCkpO1xufTtcblxuY29uc3QgcHJlbG9hZCA9IChrZXlfLCBmZXRjaGVyKT0+e1xuICAgIGNvbnN0IFtrZXksIGZuQXJnXSA9IHNlcmlhbGl6ZShrZXlfKTtcbiAgICBjb25zdCBbLCAsICwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgIC8vIFByZXZlbnQgcHJlbG9hZCB0byBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIHVzZWQuXG4gICAgaWYgKFBSRUxPQURba2V5XSkgcmV0dXJuIFBSRUxPQURba2V5XTtcbiAgICBjb25zdCByZXEgPSBmZXRjaGVyKGZuQXJnKTtcbiAgICBQUkVMT0FEW2tleV0gPSByZXE7XG4gICAgcmV0dXJuIHJlcTtcbn07XG5jb25zdCBtaWRkbGV3YXJlID0gKHVzZVNXUk5leHQpPT4oa2V5XywgZmV0Y2hlcl8sIGNvbmZpZyk9PntcbiAgICAgICAgLy8gZmV0Y2hlciBtaWdodCBiZSBhIHN5bmMgZnVuY3Rpb24sIHNvIHRoaXMgc2hvdWxkIG5vdCBiZSBhbiBhc3luYyBmdW5jdGlvblxuICAgICAgICBjb25zdCBmZXRjaGVyID0gZmV0Y2hlcl8gJiYgKCguLi5hcmdzKT0+e1xuICAgICAgICAgICAgY29uc3QgW2tleV0gPSBzZXJpYWxpemUoa2V5Xyk7XG4gICAgICAgICAgICBjb25zdCBbLCAsICwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKElORklOSVRFX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRoZSBpbmZpbml0ZSBmZXRjaGVyIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGluZyBvZiB0aGUgUFJFTE9BRCBjYWNoZSBoYXBwZW5zIHRoZXJlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaGVyXyguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IFBSRUxPQURba2V5XTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChyZXEpKSByZXR1cm4gZmV0Y2hlcl8oLi4uYXJncyk7XG4gICAgICAgICAgICBkZWxldGUgUFJFTE9BRFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1c2VTV1JOZXh0KGtleV8sIGZldGNoZXIsIGNvbmZpZyk7XG4gICAgfTtcblxuY29uc3QgQlVJTFRfSU5fTUlERExFV0FSRSA9IHVzZS5jb25jYXQobWlkZGxld2FyZSk7XG5cbi8vIEl0J3MgdHJpY2t5IHRvIHBhc3MgZ2VuZXJpYyB0eXBlcyBhcyBwYXJhbWV0ZXJzLCBzbyB3ZSBqdXN0IGRpcmVjdGx5IG92ZXJyaWRlXG4vLyB0aGUgdHlwZXMgaGVyZS5cbmNvbnN0IHdpdGhBcmdzID0gKGhvb2spPT57XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVNXUkFyZ3MoLi4uYXJncykge1xuICAgICAgICAvLyBHZXQgdGhlIGRlZmF1bHQgYW5kIGluaGVyaXRlZCBjb25maWd1cmF0aW9uLlxuICAgICAgICBjb25zdCBmYWxsYmFja0NvbmZpZyA9IHVzZVNXUkNvbmZpZygpO1xuICAgICAgICAvLyBOb3JtYWxpemUgYXJndW1lbnRzLlxuICAgICAgICBjb25zdCBba2V5LCBmbiwgX2NvbmZpZ10gPSBub3JtYWxpemUoYXJncyk7XG4gICAgICAgIC8vIE1lcmdlIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICBjb25zdCBjb25maWcgPSBtZXJnZUNvbmZpZ3MoZmFsbGJhY2tDb25maWcsIF9jb25maWcpO1xuICAgICAgICAvLyBBcHBseSBtaWRkbGV3YXJlXG4gICAgICAgIGxldCBuZXh0ID0gaG9vaztcbiAgICAgICAgY29uc3QgeyB1c2UgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZSA9ICh1c2UgfHwgW10pLmNvbmNhdChCVUlMVF9JTl9NSURETEVXQVJFKTtcbiAgICAgICAgZm9yKGxldCBpID0gbWlkZGxld2FyZS5sZW5ndGg7IGktLTspe1xuICAgICAgICAgICAgbmV4dCA9IG1pZGRsZXdhcmVbaV0obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoa2V5LCBmbiB8fCBjb25maWcuZmV0Y2hlciB8fCBudWxsLCBjb25maWcpO1xuICAgIH07XG59O1xuXG4vLyBBZGQgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhIGxpc3Qgb2Yga2V5ZWQgY2FsbGJhY2sgZnVuY3Rpb25zIGFuZCByZXR1cm5cbi8vIHRoZSB1bnN1YnNjcmliZSBmdW5jdGlvbi5cbmNvbnN0IHN1YnNjcmliZUNhbGxiYWNrID0gKGtleSwgY2FsbGJhY2tzLCBjYWxsYmFjayk9PntcbiAgICBjb25zdCBrZXllZFJldmFsaWRhdG9ycyA9IGNhbGxiYWNrc1trZXldIHx8IChjYWxsYmFja3Nba2V5XSA9IFtdKTtcbiAgICBrZXllZFJldmFsaWRhdG9ycy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgY29uc3QgaW5kZXggPSBrZXllZFJldmFsaWRhdG9ycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIC8vIE8oMSk6IGZhc3RlciB0aGFuIHNwbGljZVxuICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnNbaW5kZXhdID0ga2V5ZWRSZXZhbGlkYXRvcnNba2V5ZWRSZXZhbGlkYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9ycy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vLyBDcmVhdGUgYSBjdXN0b20gaG9vayB3aXRoIGEgbWlkZGxld2FyZVxuY29uc3Qgd2l0aE1pZGRsZXdhcmUgPSAodXNlU1dSLCBtaWRkbGV3YXJlKT0+e1xuICAgIHJldHVybiAoLi4uYXJncyk9PntcbiAgICAgICAgY29uc3QgW2tleSwgZm4sIGNvbmZpZ10gPSBub3JtYWxpemUoYXJncyk7XG4gICAgICAgIGNvbnN0IHVzZXMgPSAoY29uZmlnLnVzZSB8fCBbXSkuY29uY2F0KG1pZGRsZXdhcmUpO1xuICAgICAgICByZXR1cm4gdXNlU1dSKGtleSwgZm4sIHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIHVzZTogdXNlc1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuc2V0dXBEZXZUb29scygpO1xuXG5leHBvcnQgeyBJTkZJTklURV9QUkVGSVgsIElTX1JFQUNUX0xFR0FDWSwgSVNfU0VSVkVSLCBPQkpFQ1QsIFNXUkNvbmZpZywgU1dSR2xvYmFsU3RhdGUsIFVOREVGSU5FRCwgY2FjaGUsIGNvbXBhcmUsIGNyZWF0ZUNhY2hlSGVscGVyLCBkZWZhdWx0Q29uZmlnLCBkZWZhdWx0Q29uZmlnT3B0aW9ucywgZ2V0VGltZXN0YW1wLCBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGluaXRDYWNoZSwgaW50ZXJuYWxNdXRhdGUsIGlzRG9jdW1lbnREZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2VMaWtlLCBpc1VuZGVmaW5lZCwgaXNXaW5kb3dEZWZpbmVkLCBtZXJnZUNvbmZpZ3MsIG1lcmdlT2JqZWN0cywgbXV0YXRlLCBub29wLCBub3JtYWxpemUsIHByZWxvYWQsIHByZXNldCwgckFGLCBldmVudHMgYXMgcmV2YWxpZGF0ZUV2ZW50cywgc2VyaWFsaXplLCBzbG93Q29ubmVjdGlvbiwgc3RhYmxlSGFzaCwgc3Vic2NyaWJlQ2FsbGJhY2ssIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIHVzZVNXUkNvbmZpZywgd2l0aEFyZ3MsIHdpdGhNaWRkbGV3YXJlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/_internal/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/core/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swr/dist/core/index.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SWRConfig: function() { return /* binding */ SWRConfig; },\n/* harmony export */   \"default\": function() { return /* binding */ useSWR; },\n/* harmony export */   mutate: function() { return /* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_3__.mutate; },\n/* harmony export */   preload: function() { return /* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_3__.preload; },\n/* harmony export */   unstable_serialize: function() { return /* binding */ unstable_serialize; },\n/* harmony export */   useSWRConfig: function() { return /* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_3__.useSWRConfig; }\n/* harmony export */ });\n/* harmony import */ var client_only__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! client-only */ \"(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var swr_internal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swr/_internal */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/index.mjs\");\n\n\n\n\n\n\nconst unstable_serialize = (key)=>(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.serialize)(key)[0];\n\n/// <reference types=\"react/experimental\" />\nconst use = react__WEBPACK_IMPORTED_MODULE_1__.use || ((promise)=>{\n    if (promise.status === 'pending') {\n        throw promise;\n    } else if (promise.status === 'fulfilled') {\n        return promise.value;\n    } else if (promise.status === 'rejected') {\n        throw promise.reason;\n    } else {\n        promise.status = 'pending';\n        promise.then((v)=>{\n            promise.status = 'fulfilled';\n            promise.value = v;\n        }, (e)=>{\n            promise.status = 'rejected';\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nconst WITH_DEDUPE = {\n    dedupe: true\n};\nconst useSWRHandler = (_key, fetcher, config)=>{\n    const { cache, compare, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData } = config;\n    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = swr_internal__WEBPACK_IMPORTED_MODULE_3__.SWRGlobalState.get(cache);\n    // `key` is the identifier of the SWR internal state,\n    // `fnArg` is the argument/arguments parsed from the key, which will be passed\n    // to the fetcher.\n    // All of them are derived from `_key`.\n    const [key, fnArg] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.serialize)(_key);\n    // If it's the initial render of this hook.\n    const initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // If the hook is unmounted already. This will be used to prevent some effects\n    // to be called after unmounting.\n    const unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Refs to keep the key and config.\n    const keyRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(key);\n    const fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(fetcher);\n    const configRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(config);\n    const getConfig = ()=>configRef.current;\n    const isActive = ()=>getConfig().isVisible() && getConfig().isOnline();\n    const [getCache, setCache, subscribeCache, getInitialCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.createCacheHelper)(cache, key);\n    const stateDependencies = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({}).current;\n    const fallback = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(fallbackData) ? config.fallback[key] : fallbackData;\n    const isEqual = (prev, current)=>{\n        for(const _ in stateDependencies){\n            const t = _;\n            if (t === 'data') {\n                if (!compare(prev[t], current[t])) {\n                    if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(prev[t])) {\n                        return false;\n                    }\n                    if (!compare(returnedData, current[t])) {\n                        return false;\n                    }\n                }\n            } else {\n                if (current[t] !== prev[t]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const shouldStartRequest = (()=>{\n            if (!key) return false;\n            if (!fetcher) return false;\n            // If `revalidateOnMount` is set, we take the value directly.\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(revalidateOnMount)) return revalidateOnMount;\n            // If it's paused, we skip revalidation.\n            if (getConfig().isPaused()) return false;\n            if (suspense) return false;\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(revalidateIfStale)) return revalidateIfStale;\n            return true;\n        })();\n        // Get the cache and merge it with expected states.\n        const getSelectedCache = (state)=>{\n            // We only select the needed fields from the state.\n            const snapshot = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.mergeObjects)(state);\n            delete snapshot._k;\n            if (!shouldStartRequest) {\n                return snapshot;\n            }\n            return {\n                isValidating: true,\n                isLoading: true,\n                ...snapshot\n            };\n        };\n        const cachedData = getCache();\n        const initialData = getInitialCache();\n        const clientSnapshot = getSelectedCache(cachedData);\n        const serverSnapshot = cachedData === initialData ? clientSnapshot : getSelectedCache(initialData);\n        // To make sure that we are returning the same object reference to avoid\n        // unnecessary re-renders, we keep the previous snapshot and use deep\n        // comparison to check if we need to return a new one.\n        let memorizedSnapshot = clientSnapshot;\n        return [\n            ()=>{\n                const newSnapshot = getSelectedCache(getCache());\n                const compareResult = isEqual(newSnapshot, memorizedSnapshot);\n                if (compareResult) {\n                    // Mentally, we should always return the `memorizedSnapshot` here\n                    // as there's no change between the new and old snapshots.\n                    // However, since the `isEqual` function only compares selected fields,\n                    // the values of the unselected fields might be changed. That's\n                    // simply because we didn't track them.\n                    // To support the case in https://github.com/vercel/swr/pull/2576,\n                    // we need to update these fields in the `memorizedSnapshot` too\n                    // with direct mutations to ensure the snapshot is always up-to-date\n                    // even for the unselected fields, but only trigger re-renders when\n                    // the selected fields are changed.\n                    memorizedSnapshot.data = newSnapshot.data;\n                    memorizedSnapshot.isLoading = newSnapshot.isLoading;\n                    memorizedSnapshot.isValidating = newSnapshot.isValidating;\n                    memorizedSnapshot.error = newSnapshot.error;\n                    return memorizedSnapshot;\n                } else {\n                    memorizedSnapshot = newSnapshot;\n                    return newSnapshot;\n                }\n            },\n            ()=>serverSnapshot\n        ];\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        cache,\n        key\n    ]);\n    // Get the current state that SWR should return.\n    const cached = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((callback)=>subscribeCache(key, (current, prev)=>{\n            if (!isEqual(prev, current)) callback();\n        }), // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        cache,\n        key\n    ]), getSnapshot[0], getSnapshot[1]);\n    const isInitialMount = !initialMountedRef.current;\n    const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;\n    const cachedData = cached.data;\n    const data = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cachedData) ? fallback : cachedData;\n    const error = cached.error;\n    // Use a ref to store previously returned data. Use the initial data as its initial value.\n    const laggyDataRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(data);\n    const returnedData = keepPreviousData ? (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cachedData) ? laggyDataRef.current : cachedData : data;\n    // - Suspense mode and there's stale data for the initial render.\n    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n    // - `revalidateIfStale` is enabled but `data` is not defined.\n    const shouldDoInitialRevalidation = (()=>{\n        // if a key already has revalidators and also has error, we should not trigger revalidation\n        if (hasRevalidator && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(error)) return false;\n        // If `revalidateOnMount` is set, we take the value directly.\n        if (isInitialMount && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(revalidateOnMount)) return revalidateOnMount;\n        // If it's paused, we skip revalidation.\n        if (getConfig().isPaused()) return false;\n        // Under suspense mode, it will always fetch on render if there is no\n        // stale data so no need to revalidate immediately mount it again.\n        // If data exists, only revalidate if `revalidateIfStale` is true.\n        if (suspense) return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) ? false : revalidateIfStale;\n        // If there is no stale data, we need to revalidate when mount;\n        // If `revalidateIfStale` is set to true, we will always revalidate.\n        return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) || revalidateIfStale;\n    })();\n    // Resolve the default validating state:\n    // If it's able to validate, and it should revalidate when mount, this will be true.\n    const defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation);\n    const isValidating = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cached.isValidating) ? defaultValidatingState : cached.isValidating;\n    const isLoading = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cached.isLoading) ? defaultValidatingState : cached.isLoading;\n    // The revalidation function is a carefully crafted wrapper of the original\n    // `fetcher`, to correctly handle the many edge cases.\n    const revalidate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (revalidateOpts)=>{\n        const currentFetcher = fetcherRef.current;\n        if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n            return false;\n        }\n        let newData;\n        let startAt;\n        let loading = true;\n        const opts = revalidateOpts || {};\n        // If there is no ongoing concurrent request, or `dedupe` is not set, a\n        // new request should be initiated.\n        const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n        /*\n         For React 17\n         Do unmount check for calls:\n         If key has changed during the revalidation, or the component has been\n         unmounted, old dispatch and old event callbacks should not take any\n         effect\n\n        For React 18\n        only check if key has changed\n        https://github.com/reactwg/react-18/discussions/82\n      */ const callbackSafeguard = ()=>{\n            if (swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_REACT_LEGACY) {\n                return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n            }\n            return key === keyRef.current;\n        };\n        // The final state object when the request finishes.\n        const finalState = {\n            isValidating: false,\n            isLoading: false\n        };\n        const finishRequestAndUpdateState = ()=>{\n            setCache(finalState);\n        };\n        const cleanupState = ()=>{\n            // Check if it's still the same request before deleting it.\n            const requestInfo = FETCH[key];\n            if (requestInfo && requestInfo[1] === startAt) {\n                delete FETCH[key];\n            }\n        };\n        // Start fetching. Change the `isValidating` state, update the cache.\n        const initialState = {\n            isValidating: true\n        };\n        // It is in the `isLoading` state, if and only if there is no cached data.\n        // This bypasses fallback data and laggy data.\n        if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(getCache().data)) {\n            initialState.isLoading = true;\n        }\n        try {\n            if (shouldStartNewRequest) {\n                setCache(initialState);\n                // If no cache is being rendered currently (it shows a blank page),\n                // we trigger the loading slow event.\n                if (config.loadingTimeout && (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(getCache().data)) {\n                    setTimeout(()=>{\n                        if (loading && callbackSafeguard()) {\n                            getConfig().onLoadingSlow(key, config);\n                        }\n                    }, config.loadingTimeout);\n                }\n                // Start the request and save the timestamp.\n                // Key must be truthy if entering here.\n                FETCH[key] = [\n                    currentFetcher(fnArg),\n                    (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.getTimestamp)()\n                ];\n            }\n            [newData, startAt] = FETCH[key];\n            newData = await newData;\n            if (shouldStartNewRequest) {\n                // If the request isn't interrupted, clean it up after the\n                // deduplication interval.\n                setTimeout(cleanupState, config.dedupingInterval);\n            }\n            // If there're other ongoing request(s), started after the current one,\n            // we need to ignore the current one to avoid possible race conditions:\n            //   req1------------------>res1        (current one)\n            //        req2---------------->res2\n            // the request that fired later will always be kept.\n            // The timestamp maybe be `undefined` or a number\n            if (!FETCH[key] || FETCH[key][1] !== startAt) {\n                if (shouldStartNewRequest) {\n                    if (callbackSafeguard()) {\n                        getConfig().onDiscarded(key);\n                    }\n                }\n                return false;\n            }\n            // Clear error.\n            finalState.error = swr_internal__WEBPACK_IMPORTED_MODULE_3__.UNDEFINED;\n            // If there're other mutations(s), that overlapped with the current revalidation:\n            // case 1:\n            //   req------------------>res\n            //       mutate------>end\n            // case 2:\n            //         req------------>res\n            //   mutate------>end\n            // case 3:\n            //   req------------------>res\n            //       mutate-------...---------->\n            // we have to ignore the revalidation result (res) because it's no longer fresh.\n            // meanwhile, a new revalidation should be triggered when the mutation ends.\n            const mutationInfo = MUTATION[key];\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(mutationInfo) && // case 1\n            (startAt <= mutationInfo[0] || // case 2\n            startAt <= mutationInfo[1] || // case 3\n            mutationInfo[1] === 0)) {\n                finishRequestAndUpdateState();\n                if (shouldStartNewRequest) {\n                    if (callbackSafeguard()) {\n                        getConfig().onDiscarded(key);\n                    }\n                }\n                return false;\n            }\n            // Deep compare with the latest state to avoid extra re-renders.\n            // For local state, compare and assign.\n            const cacheData = getCache().data;\n            // Since the compare fn could be custom fn\n            // cacheData might be different from newData even when compare fn returns True\n            finalState.data = compare(cacheData, newData) ? cacheData : newData;\n            // Trigger the successful callback if it's the original request.\n            if (shouldStartNewRequest) {\n                if (callbackSafeguard()) {\n                    getConfig().onSuccess(newData, key, config);\n                }\n            }\n        } catch (err) {\n            cleanupState();\n            const currentConfig = getConfig();\n            const { shouldRetryOnError } = currentConfig;\n            // Not paused, we continue handling the error. Otherwise, discard it.\n            if (!currentConfig.isPaused()) {\n                // Get a new error, don't use deep comparison for errors.\n                finalState.error = err;\n                // Error event and retry logic. Only for the actual request, not\n                // deduped ones.\n                if (shouldStartNewRequest && callbackSafeguard()) {\n                    currentConfig.onError(err, key, currentConfig);\n                    if (shouldRetryOnError === true || (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isFunction)(shouldRetryOnError) && shouldRetryOnError(err)) {\n                        if (!getConfig().revalidateOnFocus || !getConfig().revalidateOnReconnect || isActive()) {\n                            // If it's inactive, stop. It will auto-revalidate when\n                            // refocusing or reconnecting.\n                            // When retrying, deduplication is always enabled.\n                            currentConfig.onErrorRetry(err, key, currentConfig, (_opts)=>{\n                                const revalidators = EVENT_REVALIDATORS[key];\n                                if (revalidators && revalidators[0]) {\n                                    revalidators[0](swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.ERROR_REVALIDATE_EVENT, _opts);\n                                }\n                            }, {\n                                retryCount: (opts.retryCount || 0) + 1,\n                                dedupe: true\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        // Mark loading as stopped.\n        loading = false;\n        // Update the current hook's state.\n        finishRequestAndUpdateState();\n        return true;\n    }, // `setState` is immutable, and `eventsCallback`, `fnArg`, and\n    // `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        key,\n        cache\n    ]);\n    // Similar to the global mutate but bound to the current cache and key.\n    // `cache` isn't allowed to change during the lifecycle.\n    const boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(// Use callback to make sure `keyRef.current` returns latest result every time\n    (...args)=>{\n        return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.internalMutate)(cache, keyRef.current, ...args);\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // The logic for updating refs.\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(()=>{\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        // Handle laggy data updates. If there's cached data of the current key,\n        // it'll be the correct reference.\n        if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cachedData)) {\n            laggyDataRef.current = cachedData;\n        }\n    });\n    // After mounted or key changed.\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(()=>{\n        if (!key) return;\n        const softRevalidate = revalidate.bind(swr_internal__WEBPACK_IMPORTED_MODULE_3__.UNDEFINED, WITH_DEDUPE);\n        // Expose revalidators to global event listeners. So we can trigger\n        // revalidation from the outside.\n        let nextFocusRevalidatedAt = 0;\n        const onRevalidate = (type, opts = {})=>{\n            if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.FOCUS_EVENT) {\n                const now = Date.now();\n                if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n                    softRevalidate();\n                }\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.RECONNECT_EVENT) {\n                if (getConfig().revalidateOnReconnect && isActive()) {\n                    softRevalidate();\n                }\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.MUTATE_EVENT) {\n                return revalidate();\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.ERROR_REVALIDATE_EVENT) {\n                return revalidate(opts);\n            }\n            return;\n        };\n        const unsubEvents = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.subscribeCallback)(key, EVENT_REVALIDATORS, onRevalidate);\n        // Mark the component as mounted and update corresponding refs.\n        unmountedRef.current = false;\n        keyRef.current = key;\n        initialMountedRef.current = true;\n        // Keep the original key in the cache.\n        setCache({\n            _k: fnArg\n        });\n        // Trigger a revalidation\n        if (shouldDoInitialRevalidation) {\n            if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) || swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_SERVER) {\n                // Revalidate immediately.\n                softRevalidate();\n            } else {\n                // Delay the revalidate if we have data to return so we won't block\n                // rendering.\n                (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.rAF)(softRevalidate);\n            }\n        }\n        return ()=>{\n            // Mark it as unmounted.\n            unmountedRef.current = true;\n            unsubEvents();\n        };\n    }, [\n        key\n    ]);\n    // Polling\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(()=>{\n        let timer;\n        function next() {\n            // Use the passed interval\n            // ...or invoke the function with the updated data to get the interval\n            const interval = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isFunction)(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;\n            // We only start the next interval if `refreshInterval` is not 0, and:\n            // - `force` is true, which is the start of polling\n            // - or `timer` is not 0, which means the effect wasn't canceled\n            if (interval && timer !== -1) {\n                timer = setTimeout(execute, interval);\n            }\n        }\n        function execute() {\n            // Check if it's OK to execute:\n            // Only revalidate when the page is visible, online, and not errored.\n            if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n                revalidate(WITH_DEDUPE).then(next);\n            } else {\n                // Schedule the next interval to check again.\n                next();\n            }\n        }\n        next();\n        return ()=>{\n            if (timer) {\n                clearTimeout(timer);\n                timer = -1;\n            }\n        };\n    }, [\n        refreshInterval,\n        refreshWhenHidden,\n        refreshWhenOffline,\n        key\n    ]);\n    // Display debug info in React DevTools.\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(returnedData);\n    // In Suspense mode, we can't return the empty `data` state.\n    // If there is an `error`, the `error` needs to be thrown to the error boundary.\n    // If there is no `error`, the `revalidation` promise needs to be thrown to\n    // the suspense boundary.\n    if (suspense && (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) && key) {\n        // SWR should throw when trying to use Suspense on the server with React 18,\n        // without providing any initial data. See:\n        // https://github.com/vercel/swr/issues/1832\n        if (!swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_REACT_LEGACY && swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_SERVER) {\n            throw new Error('Fallback data is required when using suspense in SSR.');\n        }\n        // Always update fetcher and config refs even with the Suspense mode.\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        unmountedRef.current = false;\n        const req = PRELOAD[key];\n        if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(req)) {\n            const promise = boundMutate(req);\n            use(promise);\n        }\n        if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(error)) {\n            const promise = revalidate(WITH_DEDUPE);\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(returnedData)) {\n                promise.status = 'fulfilled';\n                promise.value = true;\n            }\n            use(promise);\n        } else {\n            throw error;\n        }\n    }\n    return {\n        mutate: boundMutate,\n        get data () {\n            stateDependencies.data = true;\n            return returnedData;\n        },\n        get error () {\n            stateDependencies.error = true;\n            return error;\n        },\n        get isValidating () {\n            stateDependencies.isValidating = true;\n            return isValidating;\n        },\n        get isLoading () {\n            stateDependencies.isLoading = true;\n            return isLoading;\n        }\n    };\n};\nconst SWRConfig = swr_internal__WEBPACK_IMPORTED_MODULE_3__.OBJECT.defineProperty(swr_internal__WEBPACK_IMPORTED_MODULE_3__.SWRConfig, 'defaultValue', {\n    value: swr_internal__WEBPACK_IMPORTED_MODULE_3__.defaultConfig\n});\n/**\n * A hook to fetch data.\n *\n * @link https://swr.vercel.app\n * @example\n * ```jsx\n * import useSWR from 'swr'\n * function Profile() {\n *   const { data, error, isLoading } = useSWR('/api/user', fetcher)\n *   if (error) return <div>failed to load</div>\n *   if (isLoading) return <div>loading...</div>\n *   return <div>hello {data.name}!</div>\n * }\n * ```\n */ const useSWR = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.withArgs)(useSWRHandler);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9jb3JlL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXFCO0FBQzZEO0FBQ0w7QUFDNE87QUFDM1A7O0FBRTlELGtDQUFrQyx1REFBUzs7QUFFM0M7QUFDQSxZQUFZLHNDQUFnQjtBQUM1QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUpBQXlKO0FBQ3JLLDJEQUEyRCx3REFBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1REFBUztBQUNsQztBQUNBLDhCQUE4Qiw2Q0FBTTtBQUNwQztBQUNBO0FBQ0EseUJBQXlCLDZDQUFNO0FBQy9CO0FBQ0EsbUJBQW1CLDZDQUFNO0FBQ3pCLHVCQUF1Qiw2Q0FBTTtBQUM3QixzQkFBc0IsNkNBQU07QUFDNUI7QUFDQTtBQUNBLGtFQUFrRSwrREFBaUI7QUFDbkYsOEJBQThCLDZDQUFNLEdBQUc7QUFDdkMscUJBQXFCLHlEQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBVztBQUM1QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJGQUFvQixDQUFDLGtEQUFXO0FBQ25EO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFXO0FBQzVCO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQU07QUFDL0IsNENBQTRDLHlEQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQVc7QUFDMUM7QUFDQSwrQkFBK0IseURBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5REFBVztBQUN4QztBQUNBO0FBQ0EsZUFBZSx5REFBVztBQUMxQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlEQUFXO0FBQ3BDLHNCQUFzQix5REFBVztBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLGtEQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlEQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx3REFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwREFBZ0I7QUFDcEU7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrREFBVztBQUNuQztBQUNBLGVBQWUsNERBQWM7QUFDN0IsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLHVFQUF5QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVc7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksdUVBQXlCO0FBQzdCO0FBQ0EsK0NBQStDLG1EQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qyx3QkFBd0IsMERBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQiwwREFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUIsMERBQWdCO0FBQy9DO0FBQ0EsY0FBYyxpQkFBaUIsMERBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFXLFVBQVUsbURBQVM7QUFDOUM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0RBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5REFBZSxJQUFJLG1EQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5REFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFXO0FBQ3ZCO0FBQ0EsaUJBQWlCLHlEQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQU0sZ0JBQWdCLG1EQUFXO0FBQ25ELFdBQVcsdURBQWE7QUFDeEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQixzREFBUTs7QUFFaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9kaXN0L2NvcmUvaW5kZXgubWpzP2YzZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjbGllbnQtb25seSc7XG5pbXBvcnQgUmVhY3RFeHBvcnRzLCB7IHVzZVJlZiwgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIHVzZURlYnVnVmFsdWUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanMnO1xuaW1wb3J0IHsgc2VyaWFsaXplLCBPQkpFQ1QsIFNXUkNvbmZpZyBhcyBTV1JDb25maWckMSwgZGVmYXVsdENvbmZpZywgd2l0aEFyZ3MsIFNXUkdsb2JhbFN0YXRlLCBjcmVhdGVDYWNoZUhlbHBlciwgaXNVbmRlZmluZWQsIGdldFRpbWVzdGFtcCwgVU5ERUZJTkVELCBpc0Z1bmN0aW9uLCByZXZhbGlkYXRlRXZlbnRzLCBpbnRlcm5hbE11dGF0ZSwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgc3Vic2NyaWJlQ2FsbGJhY2ssIElTX1NFUlZFUiwgckFGLCBJU19SRUFDVF9MRUdBQ1ksIG1lcmdlT2JqZWN0cyB9IGZyb20gJ3N3ci9faW50ZXJuYWwnO1xuZXhwb3J0IHsgbXV0YXRlLCBwcmVsb2FkLCB1c2VTV1JDb25maWcgfSBmcm9tICdzd3IvX2ludGVybmFsJztcblxuY29uc3QgdW5zdGFibGVfc2VyaWFsaXplID0gKGtleSk9PnNlcmlhbGl6ZShrZXkpWzBdO1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlYWN0L2V4cGVyaW1lbnRhbFwiIC8+XG5jb25zdCB1c2UgPSBSZWFjdEV4cG9ydHMudXNlIHx8ICgocHJvbWlzZSk9PntcbiAgICBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICB0aHJvdyBwcm9taXNlO1xuICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgICAgdGhyb3cgcHJvbWlzZS5yZWFzb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSAncGVuZGluZyc7XG4gICAgICAgIHByb21pc2UudGhlbigodik9PntcbiAgICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgICAgICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICAgICAgfSwgKGUpPT57XG4gICAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICBwcm9taXNlLnJlYXNvbiA9IGU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBwcm9taXNlO1xuICAgIH1cbn0pO1xuY29uc3QgV0lUSF9ERURVUEUgPSB7XG4gICAgZGVkdXBlOiB0cnVlXG59O1xuY29uc3QgdXNlU1dSSGFuZGxlciA9IChfa2V5LCBmZXRjaGVyLCBjb25maWcpPT57XG4gICAgY29uc3QgeyBjYWNoZSwgY29tcGFyZSwgc3VzcGVuc2UsIGZhbGxiYWNrRGF0YSwgcmV2YWxpZGF0ZU9uTW91bnQsIHJldmFsaWRhdGVJZlN0YWxlLCByZWZyZXNoSW50ZXJ2YWwsIHJlZnJlc2hXaGVuSGlkZGVuLCByZWZyZXNoV2hlbk9mZmxpbmUsIGtlZXBQcmV2aW91c0RhdGEgfSA9IGNvbmZpZztcbiAgICBjb25zdCBbRVZFTlRfUkVWQUxJREFUT1JTLCBNVVRBVElPTiwgRkVUQ0gsIFBSRUxPQURdID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICAvLyBga2V5YCBpcyB0aGUgaWRlbnRpZmllciBvZiB0aGUgU1dSIGludGVybmFsIHN0YXRlLFxuICAgIC8vIGBmbkFyZ2AgaXMgdGhlIGFyZ3VtZW50L2FyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUga2V5LCB3aGljaCB3aWxsIGJlIHBhc3NlZFxuICAgIC8vIHRvIHRoZSBmZXRjaGVyLlxuICAgIC8vIEFsbCBvZiB0aGVtIGFyZSBkZXJpdmVkIGZyb20gYF9rZXlgLlxuICAgIGNvbnN0IFtrZXksIGZuQXJnXSA9IHNlcmlhbGl6ZShfa2V5KTtcbiAgICAvLyBJZiBpdCdzIHRoZSBpbml0aWFsIHJlbmRlciBvZiB0aGlzIGhvb2suXG4gICAgY29uc3QgaW5pdGlhbE1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIElmIHRoZSBob29rIGlzIHVubW91bnRlZCBhbHJlYWR5LiBUaGlzIHdpbGwgYmUgdXNlZCB0byBwcmV2ZW50IHNvbWUgZWZmZWN0c1xuICAgIC8vIHRvIGJlIGNhbGxlZCBhZnRlciB1bm1vdW50aW5nLlxuICAgIGNvbnN0IHVubW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gUmVmcyB0byBrZWVwIHRoZSBrZXkgYW5kIGNvbmZpZy5cbiAgICBjb25zdCBrZXlSZWYgPSB1c2VSZWYoa2V5KTtcbiAgICBjb25zdCBmZXRjaGVyUmVmID0gdXNlUmVmKGZldGNoZXIpO1xuICAgIGNvbnN0IGNvbmZpZ1JlZiA9IHVzZVJlZihjb25maWcpO1xuICAgIGNvbnN0IGdldENvbmZpZyA9ICgpPT5jb25maWdSZWYuY3VycmVudDtcbiAgICBjb25zdCBpc0FjdGl2ZSA9ICgpPT5nZXRDb25maWcoKS5pc1Zpc2libGUoKSAmJiBnZXRDb25maWcoKS5pc09ubGluZSgpO1xuICAgIGNvbnN0IFtnZXRDYWNoZSwgc2V0Q2FjaGUsIHN1YnNjcmliZUNhY2hlLCBnZXRJbml0aWFsQ2FjaGVdID0gY3JlYXRlQ2FjaGVIZWxwZXIoY2FjaGUsIGtleSk7XG4gICAgY29uc3Qgc3RhdGVEZXBlbmRlbmNpZXMgPSB1c2VSZWYoe30pLmN1cnJlbnQ7XG4gICAgY29uc3QgZmFsbGJhY2sgPSBpc1VuZGVmaW5lZChmYWxsYmFja0RhdGEpID8gY29uZmlnLmZhbGxiYWNrW2tleV0gOiBmYWxsYmFja0RhdGE7XG4gICAgY29uc3QgaXNFcXVhbCA9IChwcmV2LCBjdXJyZW50KT0+e1xuICAgICAgICBmb3IoY29uc3QgXyBpbiBzdGF0ZURlcGVuZGVuY2llcyl7XG4gICAgICAgICAgICBjb25zdCB0ID0gXztcbiAgICAgICAgICAgIGlmICh0ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmUocHJldlt0XSwgY3VycmVudFt0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChwcmV2W3RdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShyZXR1cm5lZERhdGEsIGN1cnJlbnRbdF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50W3RdICE9PSBwcmV2W3RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IHVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3Qgc2hvdWxkU3RhcnRSZXF1ZXN0ID0gKCgpPT57XG4gICAgICAgICAgICBpZiAoIWtleSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFmZXRjaGVyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBJZiBgcmV2YWxpZGF0ZU9uTW91bnRgIGlzIHNldCwgd2UgdGFrZSB0aGUgdmFsdWUgZGlyZWN0bHkuXG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHJldmFsaWRhdGVPbk1vdW50KSkgcmV0dXJuIHJldmFsaWRhdGVPbk1vdW50O1xuICAgICAgICAgICAgLy8gSWYgaXQncyBwYXVzZWQsIHdlIHNraXAgcmV2YWxpZGF0aW9uLlxuICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChyZXZhbGlkYXRlSWZTdGFsZSkpIHJldHVybiByZXZhbGlkYXRlSWZTdGFsZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSgpO1xuICAgICAgICAvLyBHZXQgdGhlIGNhY2hlIGFuZCBtZXJnZSBpdCB3aXRoIGV4cGVjdGVkIHN0YXRlcy5cbiAgICAgICAgY29uc3QgZ2V0U2VsZWN0ZWRDYWNoZSA9IChzdGF0ZSk9PntcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgc2VsZWN0IHRoZSBuZWVkZWQgZmllbGRzIGZyb20gdGhlIHN0YXRlLlxuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBtZXJnZU9iamVjdHMoc3RhdGUpO1xuICAgICAgICAgICAgZGVsZXRlIHNuYXBzaG90Ll9rO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRTdGFydFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4uc25hcHNob3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSBnZXRDYWNoZSgpO1xuICAgICAgICBjb25zdCBpbml0aWFsRGF0YSA9IGdldEluaXRpYWxDYWNoZSgpO1xuICAgICAgICBjb25zdCBjbGllbnRTbmFwc2hvdCA9IGdldFNlbGVjdGVkQ2FjaGUoY2FjaGVkRGF0YSk7XG4gICAgICAgIGNvbnN0IHNlcnZlclNuYXBzaG90ID0gY2FjaGVkRGF0YSA9PT0gaW5pdGlhbERhdGEgPyBjbGllbnRTbmFwc2hvdCA6IGdldFNlbGVjdGVkQ2FjaGUoaW5pdGlhbERhdGEpO1xuICAgICAgICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB3ZSBhcmUgcmV0dXJuaW5nIHRoZSBzYW1lIG9iamVjdCByZWZlcmVuY2UgdG8gYXZvaWRcbiAgICAgICAgLy8gdW5uZWNlc3NhcnkgcmUtcmVuZGVycywgd2Uga2VlcCB0aGUgcHJldmlvdXMgc25hcHNob3QgYW5kIHVzZSBkZWVwXG4gICAgICAgIC8vIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgd2UgbmVlZCB0byByZXR1cm4gYSBuZXcgb25lLlxuICAgICAgICBsZXQgbWVtb3JpemVkU25hcHNob3QgPSBjbGllbnRTbmFwc2hvdDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U25hcHNob3QgPSBnZXRTZWxlY3RlZENhY2hlKGdldENhY2hlKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVSZXN1bHQgPSBpc0VxdWFsKG5ld1NuYXBzaG90LCBtZW1vcml6ZWRTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWVudGFsbHksIHdlIHNob3VsZCBhbHdheXMgcmV0dXJuIHRoZSBgbWVtb3JpemVkU25hcHNob3RgIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlcmUncyBubyBjaGFuZ2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBvbGQgc25hcHNob3RzLlxuICAgICAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGUgYGlzRXF1YWxgIGZ1bmN0aW9uIG9ubHkgY29tcGFyZXMgc2VsZWN0ZWQgZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWVzIG9mIHRoZSB1bnNlbGVjdGVkIGZpZWxkcyBtaWdodCBiZSBjaGFuZ2VkLiBUaGF0J3NcbiAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGx5IGJlY2F1c2Ugd2UgZGlkbid0IHRyYWNrIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHN1cHBvcnQgdGhlIGNhc2UgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvcHVsbC8yNTc2LFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGVzZSBmaWVsZHMgaW4gdGhlIGBtZW1vcml6ZWRTbmFwc2hvdGAgdG9vXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggZGlyZWN0IG11dGF0aW9ucyB0byBlbnN1cmUgdGhlIHNuYXBzaG90IGlzIGFsd2F5cyB1cC10by1kYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gZm9yIHRoZSB1bnNlbGVjdGVkIGZpZWxkcywgYnV0IG9ubHkgdHJpZ2dlciByZS1yZW5kZXJzIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlbGVjdGVkIGZpZWxkcyBhcmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QuZGF0YSA9IG5ld1NuYXBzaG90LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yaXplZFNuYXBzaG90LmlzTG9hZGluZyA9IG5ld1NuYXBzaG90LmlzTG9hZGluZztcbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QuaXNWYWxpZGF0aW5nID0gbmV3U25hcHNob3QuaXNWYWxpZGF0aW5nO1xuICAgICAgICAgICAgICAgICAgICBtZW1vcml6ZWRTbmFwc2hvdC5lcnJvciA9IG5ld1NuYXBzaG90LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtb3JpemVkU25hcHNob3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QgPSBuZXdTbmFwc2hvdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NuYXBzaG90O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKT0+c2VydmVyU25hcHNob3RcbiAgICAgICAgXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBjYWNoZSxcbiAgICAgICAga2V5XG4gICAgXSk7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlIHRoYXQgU1dSIHNob3VsZCByZXR1cm4uXG4gICAgY29uc3QgY2FjaGVkID0gdXNlU3luY0V4dGVybmFsU3RvcmUodXNlQ2FsbGJhY2soKGNhbGxiYWNrKT0+c3Vic2NyaWJlQ2FjaGUoa2V5LCAoY3VycmVudCwgcHJldik9PntcbiAgICAgICAgICAgIGlmICghaXNFcXVhbChwcmV2LCBjdXJyZW50KSkgY2FsbGJhY2soKTtcbiAgICAgICAgfSksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBrZXlcbiAgICBdKSwgZ2V0U25hcHNob3RbMF0sIGdldFNuYXBzaG90WzFdKTtcbiAgICBjb25zdCBpc0luaXRpYWxNb3VudCA9ICFpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IGhhc1JldmFsaWRhdG9yID0gRVZFTlRfUkVWQUxJREFUT1JTW2tleV0gJiYgRVZFTlRfUkVWQUxJREFUT1JTW2tleV0ubGVuZ3RoID4gMDtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gY2FjaGVkLmRhdGE7XG4gICAgY29uc3QgZGF0YSA9IGlzVW5kZWZpbmVkKGNhY2hlZERhdGEpID8gZmFsbGJhY2sgOiBjYWNoZWREYXRhO1xuICAgIGNvbnN0IGVycm9yID0gY2FjaGVkLmVycm9yO1xuICAgIC8vIFVzZSBhIHJlZiB0byBzdG9yZSBwcmV2aW91c2x5IHJldHVybmVkIGRhdGEuIFVzZSB0aGUgaW5pdGlhbCBkYXRhIGFzIGl0cyBpbml0aWFsIHZhbHVlLlxuICAgIGNvbnN0IGxhZ2d5RGF0YVJlZiA9IHVzZVJlZihkYXRhKTtcbiAgICBjb25zdCByZXR1cm5lZERhdGEgPSBrZWVwUHJldmlvdXNEYXRhID8gaXNVbmRlZmluZWQoY2FjaGVkRGF0YSkgPyBsYWdneURhdGFSZWYuY3VycmVudCA6IGNhY2hlZERhdGEgOiBkYXRhO1xuICAgIC8vIC0gU3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUncyBzdGFsZSBkYXRhIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgLy8gLSBOb3Qgc3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUgaXMgbm8gZmFsbGJhY2sgZGF0YSBhbmQgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkLlxuICAgIC8vIC0gYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkIGJ1dCBgZGF0YWAgaXMgbm90IGRlZmluZWQuXG4gICAgY29uc3Qgc2hvdWxkRG9Jbml0aWFsUmV2YWxpZGF0aW9uID0gKCgpPT57XG4gICAgICAgIC8vIGlmIGEga2V5IGFscmVhZHkgaGFzIHJldmFsaWRhdG9ycyBhbmQgYWxzbyBoYXMgZXJyb3IsIHdlIHNob3VsZCBub3QgdHJpZ2dlciByZXZhbGlkYXRpb25cbiAgICAgICAgaWYgKGhhc1JldmFsaWRhdG9yICYmICFpc1VuZGVmaW5lZChlcnJvcikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVPbk1vdW50YCBpcyBzZXQsIHdlIHRha2UgdGhlIHZhbHVlIGRpcmVjdGx5LlxuICAgICAgICBpZiAoaXNJbml0aWFsTW91bnQgJiYgIWlzVW5kZWZpbmVkKHJldmFsaWRhdGVPbk1vdW50KSkgcmV0dXJuIHJldmFsaWRhdGVPbk1vdW50O1xuICAgICAgICAvLyBJZiBpdCdzIHBhdXNlZCwgd2Ugc2tpcCByZXZhbGlkYXRpb24uXG4gICAgICAgIGlmIChnZXRDb25maWcoKS5pc1BhdXNlZCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFVuZGVyIHN1c3BlbnNlIG1vZGUsIGl0IHdpbGwgYWx3YXlzIGZldGNoIG9uIHJlbmRlciBpZiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdGFsZSBkYXRhIHNvIG5vIG5lZWQgdG8gcmV2YWxpZGF0ZSBpbW1lZGlhdGVseSBtb3VudCBpdCBhZ2Fpbi5cbiAgICAgICAgLy8gSWYgZGF0YSBleGlzdHMsIG9ubHkgcmV2YWxpZGF0ZSBpZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHRydWUuXG4gICAgICAgIGlmIChzdXNwZW5zZSkgcmV0dXJuIGlzVW5kZWZpbmVkKGRhdGEpID8gZmFsc2UgOiByZXZhbGlkYXRlSWZTdGFsZTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gc3RhbGUgZGF0YSwgd2UgbmVlZCB0byByZXZhbGlkYXRlIHdoZW4gbW91bnQ7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgc2V0IHRvIHRydWUsIHdlIHdpbGwgYWx3YXlzIHJldmFsaWRhdGUuXG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSB8fCByZXZhbGlkYXRlSWZTdGFsZTtcbiAgICB9KSgpO1xuICAgIC8vIFJlc29sdmUgdGhlIGRlZmF1bHQgdmFsaWRhdGluZyBzdGF0ZTpcbiAgICAvLyBJZiBpdCdzIGFibGUgdG8gdmFsaWRhdGUsIGFuZCBpdCBzaG91bGQgcmV2YWxpZGF0ZSB3aGVuIG1vdW50LCB0aGlzIHdpbGwgYmUgdHJ1ZS5cbiAgICBjb25zdCBkZWZhdWx0VmFsaWRhdGluZ1N0YXRlID0gISEoa2V5ICYmIGZldGNoZXIgJiYgaXNJbml0aWFsTW91bnQgJiYgc2hvdWxkRG9Jbml0aWFsUmV2YWxpZGF0aW9uKTtcbiAgICBjb25zdCBpc1ZhbGlkYXRpbmcgPSBpc1VuZGVmaW5lZChjYWNoZWQuaXNWYWxpZGF0aW5nKSA/IGRlZmF1bHRWYWxpZGF0aW5nU3RhdGUgOiBjYWNoZWQuaXNWYWxpZGF0aW5nO1xuICAgIGNvbnN0IGlzTG9hZGluZyA9IGlzVW5kZWZpbmVkKGNhY2hlZC5pc0xvYWRpbmcpID8gZGVmYXVsdFZhbGlkYXRpbmdTdGF0ZSA6IGNhY2hlZC5pc0xvYWRpbmc7XG4gICAgLy8gVGhlIHJldmFsaWRhdGlvbiBmdW5jdGlvbiBpcyBhIGNhcmVmdWxseSBjcmFmdGVkIHdyYXBwZXIgb2YgdGhlIG9yaWdpbmFsXG4gICAgLy8gYGZldGNoZXJgLCB0byBjb3JyZWN0bHkgaGFuZGxlIHRoZSBtYW55IGVkZ2UgY2FzZXMuXG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChyZXZhbGlkYXRlT3B0cyk9PntcbiAgICAgICAgY29uc3QgY3VycmVudEZldGNoZXIgPSBmZXRjaGVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICgha2V5IHx8ICFjdXJyZW50RmV0Y2hlciB8fCB1bm1vdW50ZWRSZWYuY3VycmVudCB8fCBnZXRDb25maWcoKS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0RhdGE7XG4gICAgICAgIGxldCBzdGFydEF0O1xuICAgICAgICBsZXQgbG9hZGluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IG9wdHMgPSByZXZhbGlkYXRlT3B0cyB8fCB7fTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gb25nb2luZyBjb25jdXJyZW50IHJlcXVlc3QsIG9yIGBkZWR1cGVgIGlzIG5vdCBzZXQsIGFcbiAgICAgICAgLy8gbmV3IHJlcXVlc3Qgc2hvdWxkIGJlIGluaXRpYXRlZC5cbiAgICAgICAgY29uc3Qgc2hvdWxkU3RhcnROZXdSZXF1ZXN0ID0gIUZFVENIW2tleV0gfHwgIW9wdHMuZGVkdXBlO1xuICAgICAgICAvKlxuICAgICAgICAgRm9yIFJlYWN0IDE3XG4gICAgICAgICBEbyB1bm1vdW50IGNoZWNrIGZvciBjYWxsczpcbiAgICAgICAgIElmIGtleSBoYXMgY2hhbmdlZCBkdXJpbmcgdGhlIHJldmFsaWRhdGlvbiwgb3IgdGhlIGNvbXBvbmVudCBoYXMgYmVlblxuICAgICAgICAgdW5tb3VudGVkLCBvbGQgZGlzcGF0Y2ggYW5kIG9sZCBldmVudCBjYWxsYmFja3Mgc2hvdWxkIG5vdCB0YWtlIGFueVxuICAgICAgICAgZWZmZWN0XG5cbiAgICAgICAgRm9yIFJlYWN0IDE4XG4gICAgICAgIG9ubHkgY2hlY2sgaWYga2V5IGhhcyBjaGFuZ2VkXG4gICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdHdnL3JlYWN0LTE4L2Rpc2N1c3Npb25zLzgyXG4gICAgICAqLyBjb25zdCBjYWxsYmFja1NhZmVndWFyZCA9ICgpPT57XG4gICAgICAgICAgICBpZiAoSVNfUkVBQ1RfTEVHQUNZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1bm1vdW50ZWRSZWYuY3VycmVudCAmJiBrZXkgPT09IGtleVJlZi5jdXJyZW50ICYmIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSBrZXlSZWYuY3VycmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlIGZpbmFsIHN0YXRlIG9iamVjdCB3aGVuIHRoZSByZXF1ZXN0IGZpbmlzaGVzLlxuICAgICAgICBjb25zdCBmaW5hbFN0YXRlID0ge1xuICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlID0gKCk9PntcbiAgICAgICAgICAgIHNldENhY2hlKGZpbmFsU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwU3RhdGUgPSAoKT0+e1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBzdGlsbCB0aGUgc2FtZSByZXF1ZXN0IGJlZm9yZSBkZWxldGluZyBpdC5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gRkVUQ0hba2V5XTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SW5mbyAmJiByZXF1ZXN0SW5mb1sxXSA9PT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBTdGFydCBmZXRjaGluZy4gQ2hhbmdlIHRoZSBgaXNWYWxpZGF0aW5nYCBzdGF0ZSwgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIC8vIEl0IGlzIGluIHRoZSBgaXNMb2FkaW5nYCBzdGF0ZSwgaWYgYW5kIG9ubHkgaWYgdGhlcmUgaXMgbm8gY2FjaGVkIGRhdGEuXG4gICAgICAgIC8vIFRoaXMgYnlwYXNzZXMgZmFsbGJhY2sgZGF0YSBhbmQgbGFnZ3kgZGF0YS5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGdldENhY2hlKCkuZGF0YSkpIHtcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZS5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgc2V0Q2FjaGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBjYWNoZSBpcyBiZWluZyByZW5kZXJlZCBjdXJyZW50bHkgKGl0IHNob3dzIGEgYmxhbmsgcGFnZSksXG4gICAgICAgICAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgbG9hZGluZyBzbG93IGV2ZW50LlxuICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9hZGluZ1RpbWVvdXQgJiYgaXNVbmRlZmluZWQoZ2V0Q2FjaGUoKS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGluZyAmJiBjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25Mb2FkaW5nU2xvdyhrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGNvbmZpZy5sb2FkaW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXF1ZXN0IGFuZCBzYXZlIHRoZSB0aW1lc3RhbXAuXG4gICAgICAgICAgICAgICAgLy8gS2V5IG11c3QgYmUgdHJ1dGh5IGlmIGVudGVyaW5nIGhlcmUuXG4gICAgICAgICAgICAgICAgRkVUQ0hba2V5XSA9IFtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZldGNoZXIoZm5BcmcpLFxuICAgICAgICAgICAgICAgICAgICBnZXRUaW1lc3RhbXAoKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbbmV3RGF0YSwgc3RhcnRBdF0gPSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgbmV3RGF0YSA9IGF3YWl0IG5ld0RhdGE7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXNuJ3QgaW50ZXJydXB0ZWQsIGNsZWFuIGl0IHVwIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlZHVwbGljYXRpb24gaW50ZXJ2YWwuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbnVwU3RhdGUsIGNvbmZpZy5kZWR1cGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3JlIG90aGVyIG9uZ29pbmcgcmVxdWVzdChzKSwgc3RhcnRlZCBhZnRlciB0aGUgY3VycmVudCBvbmUsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgLy8gICByZXExLS0tLS0tLS0tLS0tLS0tLS0tPnJlczEgICAgICAgIChjdXJyZW50IG9uZSlcbiAgICAgICAgICAgIC8vICAgICAgICByZXEyLS0tLS0tLS0tLS0tLS0tLT5yZXMyXG4gICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXG4gICAgICAgICAgICAvLyBUaGUgdGltZXN0YW1wIG1heWJlIGJlIGB1bmRlZmluZWRgIG9yIGEgbnVtYmVyXG4gICAgICAgICAgICBpZiAoIUZFVENIW2tleV0gfHwgRkVUQ0hba2V5XVsxXSAhPT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXIgZXJyb3IuXG4gICAgICAgICAgICBmaW5hbFN0YXRlLmVycm9yID0gVU5ERUZJTkVEO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncmUgb3RoZXIgbXV0YXRpb25zKHMpLCB0aGF0IG92ZXJsYXBwZWQgd2l0aCB0aGUgY3VycmVudCByZXZhbGlkYXRpb246XG4gICAgICAgICAgICAvLyBjYXNlIDE6XG4gICAgICAgICAgICAvLyAgIHJlcS0tLS0tLS0tLS0tLS0tLS0tLT5yZXNcbiAgICAgICAgICAgIC8vICAgICAgIG11dGF0ZS0tLS0tLT5lbmRcbiAgICAgICAgICAgIC8vIGNhc2UgMjpcbiAgICAgICAgICAgIC8vICAgICAgICAgcmVxLS0tLS0tLS0tLS0tPnJlc1xuICAgICAgICAgICAgLy8gICBtdXRhdGUtLS0tLS0+ZW5kXG4gICAgICAgICAgICAvLyBjYXNlIDM6XG4gICAgICAgICAgICAvLyAgIHJlcS0tLS0tLS0tLS0tLS0tLS0tLT5yZXNcbiAgICAgICAgICAgIC8vICAgICAgIG11dGF0ZS0tLS0tLS0uLi4tLS0tLS0tLS0tPlxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBpZ25vcmUgdGhlIHJldmFsaWRhdGlvbiByZXN1bHQgKHJlcykgYmVjYXVzZSBpdCdzIG5vIGxvbmdlciBmcmVzaC5cbiAgICAgICAgICAgIC8vIG1lYW53aGlsZSwgYSBuZXcgcmV2YWxpZGF0aW9uIHNob3VsZCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgbXV0YXRpb24gZW5kcy5cbiAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uSW5mbyA9IE1VVEFUSU9OW2tleV07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKG11dGF0aW9uSW5mbykgJiYgLy8gY2FzZSAxXG4gICAgICAgICAgICAoc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMF0gfHwgLy8gY2FzZSAyXG4gICAgICAgICAgICBzdGFydEF0IDw9IG11dGF0aW9uSW5mb1sxXSB8fCAvLyBjYXNlIDNcbiAgICAgICAgICAgIG11dGF0aW9uSW5mb1sxXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkRpc2NhcmRlZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZXAgY29tcGFyZSB3aXRoIHRoZSBsYXRlc3Qgc3RhdGUgdG8gYXZvaWQgZXh0cmEgcmUtcmVuZGVycy5cbiAgICAgICAgICAgIC8vIEZvciBsb2NhbCBzdGF0ZSwgY29tcGFyZSBhbmQgYXNzaWduLlxuICAgICAgICAgICAgY29uc3QgY2FjaGVEYXRhID0gZ2V0Q2FjaGUoKS5kYXRhO1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIGNvbXBhcmUgZm4gY291bGQgYmUgY3VzdG9tIGZuXG4gICAgICAgICAgICAvLyBjYWNoZURhdGEgbWlnaHQgYmUgZGlmZmVyZW50IGZyb20gbmV3RGF0YSBldmVuIHdoZW4gY29tcGFyZSBmbiByZXR1cm5zIFRydWVcbiAgICAgICAgICAgIGZpbmFsU3RhdGUuZGF0YSA9IGNvbXBhcmUoY2FjaGVEYXRhLCBuZXdEYXRhKSA/IGNhY2hlRGF0YSA6IG5ld0RhdGE7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBzdWNjZXNzZnVsIGNhbGxiYWNrIGlmIGl0J3MgdGhlIG9yaWdpbmFsIHJlcXVlc3QuXG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25TdWNjZXNzKG5ld0RhdGEsIGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2xlYW51cFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29uZmlnID0gZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICBjb25zdCB7IHNob3VsZFJldHJ5T25FcnJvciB9ID0gY3VycmVudENvbmZpZztcbiAgICAgICAgICAgIC8vIE5vdCBwYXVzZWQsIHdlIGNvbnRpbnVlIGhhbmRsaW5nIHRoZSBlcnJvci4gT3RoZXJ3aXNlLCBkaXNjYXJkIGl0LlxuICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29uZmlnLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgZXJyb3IsIGRvbid0IHVzZSBkZWVwIGNvbXBhcmlzb24gZm9yIGVycm9ycy5cbiAgICAgICAgICAgICAgICBmaW5hbFN0YXRlLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIGV2ZW50IGFuZCByZXRyeSBsb2dpYy4gT25seSBmb3IgdGhlIGFjdHVhbCByZXF1ZXN0LCBub3RcbiAgICAgICAgICAgICAgICAvLyBkZWR1cGVkIG9uZXMuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCAmJiBjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWcub25FcnJvcihlcnIsIGtleSwgY3VycmVudENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZXRyeU9uRXJyb3IgPT09IHRydWUgfHwgaXNGdW5jdGlvbihzaG91bGRSZXRyeU9uRXJyb3IpICYmIHNob3VsZFJldHJ5T25FcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdldENvbmZpZygpLnJldmFsaWRhdGVPbkZvY3VzIHx8ICFnZXRDb25maWcoKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgfHwgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgaW5hY3RpdmUsIHN0b3AuIEl0IHdpbGwgYXV0by1yZXZhbGlkYXRlIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWZvY3VzaW5nIG9yIHJlY29ubmVjdGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJldHJ5aW5nLCBkZWR1cGxpY2F0aW9uIGlzIGFsd2F5cyBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWcub25FcnJvclJldHJ5KGVyciwga2V5LCBjdXJyZW50Q29uZmlnLCAoX29wdHMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdG9ycyA9IEVWRU5UX1JFVkFMSURBVE9SU1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV2YWxpZGF0b3JzICYmIHJldmFsaWRhdG9yc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0b3JzWzBdKHJldmFsaWRhdGVFdmVudHMuRVJST1JfUkVWQUxJREFURV9FVkVOVCwgX29wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUNvdW50OiAob3B0cy5yZXRyeUNvdW50IHx8IDApICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdXBlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFyayBsb2FkaW5nIGFzIHN0b3BwZWQuXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGhvb2sncyBzdGF0ZS5cbiAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIC8vIGBzZXRTdGF0ZWAgaXMgaW1tdXRhYmxlLCBhbmQgYGV2ZW50c0NhbGxiYWNrYCwgYGZuQXJnYCwgYW5kXG4gICAgLy8gYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxuICAgIC8vIHRoZSBkZXBzIGFycmF5LlxuICAgIC8vXG4gICAgLy8gRklYTUU6XG4gICAgLy8gYGZuYCBhbmQgYGNvbmZpZ2AgbWlnaHQgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIGxpZmVjeWNsZSxcbiAgICAvLyBidXQgdGhleSBtaWdodCBiZSBjaGFuZ2VkIGV2ZXJ5IHJlbmRlciBsaWtlIHRoaXMuXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXG4gICAgLy8gU28gd2Ugb21pdCB0aGUgdmFsdWVzIGZyb20gdGhlIGRlcHMgYXJyYXlcbiAgICAvLyBldmVuIHRob3VnaCBpdCBtaWdodCBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW1xuICAgICAgICBrZXksXG4gICAgICAgIGNhY2hlXG4gICAgXSk7XG4gICAgLy8gU2ltaWxhciB0byB0aGUgZ2xvYmFsIG11dGF0ZSBidXQgYm91bmQgdG8gdGhlIGN1cnJlbnQgY2FjaGUgYW5kIGtleS5cbiAgICAvLyBgY2FjaGVgIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlLlxuICAgIGNvbnN0IGJvdW5kTXV0YXRlID0gdXNlQ2FsbGJhY2soLy8gVXNlIGNhbGxiYWNrIHRvIG1ha2Ugc3VyZSBga2V5UmVmLmN1cnJlbnRgIHJldHVybnMgbGF0ZXN0IHJlc3VsdCBldmVyeSB0aW1lXG4gICAgKC4uLmFyZ3MpPT57XG4gICAgICAgIHJldHVybiBpbnRlcm5hbE11dGF0ZShjYWNoZSwga2V5UmVmLmN1cnJlbnQsIC4uLmFyZ3MpO1xuICAgIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXSk7XG4gICAgLy8gVGhlIGxvZ2ljIGZvciB1cGRhdGluZyByZWZzLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgZmV0Y2hlclJlZi5jdXJyZW50ID0gZmV0Y2hlcjtcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XG4gICAgICAgIC8vIEhhbmRsZSBsYWdneSBkYXRhIHVwZGF0ZXMuIElmIHRoZXJlJ3MgY2FjaGVkIGRhdGEgb2YgdGhlIGN1cnJlbnQga2V5LFxuICAgICAgICAvLyBpdCdsbCBiZSB0aGUgY29ycmVjdCByZWZlcmVuY2UuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoY2FjaGVkRGF0YSkpIHtcbiAgICAgICAgICAgIGxhZ2d5RGF0YVJlZi5jdXJyZW50ID0gY2FjaGVkRGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFmdGVyIG1vdW50ZWQgb3Iga2V5IGNoYW5nZWQuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoIWtleSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBzb2Z0UmV2YWxpZGF0ZSA9IHJldmFsaWRhdGUuYmluZChVTkRFRklORUQsIFdJVEhfREVEVVBFKTtcbiAgICAgICAgLy8gRXhwb3NlIHJldmFsaWRhdG9ycyB0byBnbG9iYWwgZXZlbnQgbGlzdGVuZXJzLiBTbyB3ZSBjYW4gdHJpZ2dlclxuICAgICAgICAvLyByZXZhbGlkYXRpb24gZnJvbSB0aGUgb3V0c2lkZS5cbiAgICAgICAgbGV0IG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSAwO1xuICAgICAgICBjb25zdCBvblJldmFsaWRhdGUgPSAodHlwZSwgb3B0cyA9IHt9KT0+e1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gcmV2YWxpZGF0ZUV2ZW50cy5GT0NVU19FVkVOVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLnJldmFsaWRhdGVPbkZvY3VzICYmIG5vdyA+IG5leHRGb2N1c1JldmFsaWRhdGVkQXQgJiYgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ID0gbm93ICsgZ2V0Q29uZmlnKCkuZm9jdXNUaHJvdHRsZUludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSByZXZhbGlkYXRlRXZlbnRzLlJFQ09OTkVDVF9FVkVOVCkge1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgJiYgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSByZXZhbGlkYXRlRXZlbnRzLk1VVEFURV9FVkVOVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gcmV2YWxpZGF0ZUV2ZW50cy5FUlJPUl9SRVZBTElEQVRFX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUob3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVuc3ViRXZlbnRzID0gc3Vic2NyaWJlQ2FsbGJhY2soa2V5LCBFVkVOVF9SRVZBTElEQVRPUlMsIG9uUmV2YWxpZGF0ZSk7XG4gICAgICAgIC8vIE1hcmsgdGhlIGNvbXBvbmVudCBhcyBtb3VudGVkIGFuZCB1cGRhdGUgY29ycmVzcG9uZGluZyByZWZzLlxuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBrZXlSZWYuY3VycmVudCA9IGtleTtcbiAgICAgICAgaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIGtleSBpbiB0aGUgY2FjaGUuXG4gICAgICAgIHNldENhY2hlKHtcbiAgICAgICAgICAgIF9rOiBmbkFyZ1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHJpZ2dlciBhIHJldmFsaWRhdGlvblxuICAgICAgICBpZiAoc2hvdWxkRG9Jbml0aWFsUmV2YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZGF0YSkgfHwgSVNfU0VSVkVSKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV2YWxpZGF0ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEZWxheSB0aGUgcmV2YWxpZGF0ZSBpZiB3ZSBoYXZlIGRhdGEgdG8gcmV0dXJuIHNvIHdlIHdvbid0IGJsb2NrXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nLlxuICAgICAgICAgICAgICAgIHJBRihzb2Z0UmV2YWxpZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAvLyBNYXJrIGl0IGFzIHVubW91bnRlZC5cbiAgICAgICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVuc3ViRXZlbnRzKCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBrZXlcbiAgICBdKTtcbiAgICAvLyBQb2xsaW5nXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBsZXQgdGltZXI7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHBhc3NlZCBpbnRlcnZhbFxuICAgICAgICAgICAgLy8gLi4ub3IgaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSB1cGRhdGVkIGRhdGEgdG8gZ2V0IHRoZSBpbnRlcnZhbFxuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBpc0Z1bmN0aW9uKHJlZnJlc2hJbnRlcnZhbCkgPyByZWZyZXNoSW50ZXJ2YWwoZ2V0Q2FjaGUoKS5kYXRhKSA6IHJlZnJlc2hJbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgc3RhcnQgdGhlIG5leHQgaW50ZXJ2YWwgaWYgYHJlZnJlc2hJbnRlcnZhbGAgaXMgbm90IDAsIGFuZDpcbiAgICAgICAgICAgIC8vIC0gYGZvcmNlYCBpcyB0cnVlLCB3aGljaCBpcyB0aGUgc3RhcnQgb2YgcG9sbGluZ1xuICAgICAgICAgICAgLy8gLSBvciBgdGltZXJgIGlzIG5vdCAwLCB3aGljaCBtZWFucyB0aGUgZWZmZWN0IHdhc24ndCBjYW5jZWxlZFxuICAgICAgICAgICAgaWYgKGludGVydmFsICYmIHRpbWVyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChleGVjdXRlLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgT0sgdG8gZXhlY3V0ZTpcbiAgICAgICAgICAgIC8vIE9ubHkgcmV2YWxpZGF0ZSB3aGVuIHRoZSBwYWdlIGlzIHZpc2libGUsIG9ubGluZSwgYW5kIG5vdCBlcnJvcmVkLlxuICAgICAgICAgICAgaWYgKCFnZXRDYWNoZSgpLmVycm9yICYmIChyZWZyZXNoV2hlbkhpZGRlbiB8fCBnZXRDb25maWcoKS5pc1Zpc2libGUoKSkgJiYgKHJlZnJlc2hXaGVuT2ZmbGluZSB8fCBnZXRDb25maWcoKS5pc09ubGluZSgpKSkge1xuICAgICAgICAgICAgICAgIHJldmFsaWRhdGUoV0lUSF9ERURVUEUpLnRoZW4obmV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBuZXh0IGludGVydmFsIHRvIGNoZWNrIGFnYWluLlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcmVmcmVzaEludGVydmFsLFxuICAgICAgICByZWZyZXNoV2hlbkhpZGRlbixcbiAgICAgICAgcmVmcmVzaFdoZW5PZmZsaW5lLFxuICAgICAgICBrZXlcbiAgICBdKTtcbiAgICAvLyBEaXNwbGF5IGRlYnVnIGluZm8gaW4gUmVhY3QgRGV2VG9vbHMuXG4gICAgdXNlRGVidWdWYWx1ZShyZXR1cm5lZERhdGEpO1xuICAgIC8vIEluIFN1c3BlbnNlIG1vZGUsIHdlIGNhbid0IHJldHVybiB0aGUgZW1wdHkgYGRhdGFgIHN0YXRlLlxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGBlcnJvcmAsIHRoZSBgZXJyb3JgIG5lZWRzIHRvIGJlIHRocm93biB0byB0aGUgZXJyb3IgYm91bmRhcnkuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYGVycm9yYCwgdGhlIGByZXZhbGlkYXRpb25gIHByb21pc2UgbmVlZHMgdG8gYmUgdGhyb3duIHRvXG4gICAgLy8gdGhlIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgIGlmIChzdXNwZW5zZSAmJiBpc1VuZGVmaW5lZChkYXRhKSAmJiBrZXkpIHtcbiAgICAgICAgLy8gU1dSIHNob3VsZCB0aHJvdyB3aGVuIHRyeWluZyB0byB1c2UgU3VzcGVuc2Ugb24gdGhlIHNlcnZlciB3aXRoIFJlYWN0IDE4LFxuICAgICAgICAvLyB3aXRob3V0IHByb3ZpZGluZyBhbnkgaW5pdGlhbCBkYXRhLiBTZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvc3dyL2lzc3Vlcy8xODMyXG4gICAgICAgIGlmICghSVNfUkVBQ1RfTEVHQUNZICYmIElTX1NFUlZFUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWxsYmFjayBkYXRhIGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgc3VzcGVuc2UgaW4gU1NSLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMgZXZlbiB3aXRoIHRoZSBTdXNwZW5zZSBtb2RlLlxuICAgICAgICBmZXRjaGVyUmVmLmN1cnJlbnQgPSBmZXRjaGVyO1xuICAgICAgICBjb25maWdSZWYuY3VycmVudCA9IGNvbmZpZztcbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVxID0gUFJFTE9BRFtrZXldO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHJlcSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBib3VuZE11dGF0ZShyZXEpO1xuICAgICAgICAgICAgdXNlKHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChlcnJvcikpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSByZXZhbGlkYXRlKFdJVEhfREVEVVBFKTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQocmV0dXJuZWREYXRhKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2UocHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtdXRhdGU6IGJvdW5kTXV0YXRlLFxuICAgICAgICBnZXQgZGF0YSAoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5kYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5lZERhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBlcnJvciAoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5lcnJvciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc1ZhbGlkYXRpbmcgKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNWYWxpZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkYXRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc0xvYWRpbmcgKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpc0xvYWRpbmc7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmNvbnN0IFNXUkNvbmZpZyA9IE9CSkVDVC5kZWZpbmVQcm9wZXJ0eShTV1JDb25maWckMSwgJ2RlZmF1bHRWYWx1ZScsIHtcbiAgICB2YWx1ZTogZGVmYXVsdENvbmZpZ1xufSk7XG4vKipcbiAqIEEgaG9vayB0byBmZXRjaCBkYXRhLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vc3dyLnZlcmNlbC5hcHBcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJ1xuICogZnVuY3Rpb24gUHJvZmlsZSgpIHtcbiAqICAgY29uc3QgeyBkYXRhLCBlcnJvciwgaXNMb2FkaW5nIH0gPSB1c2VTV1IoJy9hcGkvdXNlcicsIGZldGNoZXIpXG4gKiAgIGlmIChlcnJvcikgcmV0dXJuIDxkaXY+ZmFpbGVkIHRvIGxvYWQ8L2Rpdj5cbiAqICAgaWYgKGlzTG9hZGluZykgcmV0dXJuIDxkaXY+bG9hZGluZy4uLjwvZGl2PlxuICogICByZXR1cm4gPGRpdj5oZWxsbyB7ZGF0YS5uYW1lfSE8L2Rpdj5cbiAqIH1cbiAqIGBgYFxuICovIGNvbnN0IHVzZVNXUiA9IHdpdGhBcmdzKHVzZVNXUkhhbmRsZXIpO1xuXG5leHBvcnQgeyBTV1JDb25maWcsIHVzZVNXUiBhcyBkZWZhdWx0LCB1bnN0YWJsZV9zZXJpYWxpemUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/core/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/infinite/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swr/dist/infinite/index.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ useSWRInfinite; },\n/* harmony export */   infinite: function() { return /* binding */ infinite; },\n/* harmony export */   unstable_serialize: function() { return /* binding */ unstable_serialize; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var client_only__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client-only */ \"(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var swr_internal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swr/_internal */ \"(app-pages-browser)/./node_modules/swr/dist/_internal/index.mjs\");\n\n\n\n\n\n/// <reference types=\"react/experimental\" />\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === 'pending') {\n        throw promise;\n    } else if (promise.status === 'fulfilled') {\n        return promise.value;\n    } else if (promise.status === 'rejected') {\n        throw promise.reason;\n    } else {\n        promise.status = 'pending';\n        promise.then((v)=>{\n            promise.status = 'fulfilled';\n            promise.value = v;\n        }, (e)=>{\n            promise.status = 'rejected';\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nconst WITH_DEDUPE = {\n    dedupe: true\n};\nconst useSWRHandler = (_key, fetcher, config)=>{\n    const { cache, compare, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData } = config;\n    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = swr_internal__WEBPACK_IMPORTED_MODULE_3__.SWRGlobalState.get(cache);\n    // `key` is the identifier of the SWR internal state,\n    // `fnArg` is the argument/arguments parsed from the key, which will be passed\n    // to the fetcher.\n    // All of them are derived from `_key`.\n    const [key, fnArg] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.serialize)(_key);\n    // If it's the initial render of this hook.\n    const initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // If the hook is unmounted already. This will be used to prevent some effects\n    // to be called after unmounting.\n    const unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Refs to keep the key and config.\n    const keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n    const fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n    const configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n    const getConfig = ()=>configRef.current;\n    const isActive = ()=>getConfig().isVisible() && getConfig().isOnline();\n    const [getCache, setCache, subscribeCache, getInitialCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.createCacheHelper)(cache, key);\n    const stateDependencies = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({}).current;\n    const fallback = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(fallbackData) ? config.fallback[key] : fallbackData;\n    const isEqual = (prev, current)=>{\n        for(const _ in stateDependencies){\n            const t = _;\n            if (t === 'data') {\n                if (!compare(prev[t], current[t])) {\n                    if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(prev[t])) {\n                        return false;\n                    }\n                    if (!compare(returnedData, current[t])) {\n                        return false;\n                    }\n                }\n            } else {\n                if (current[t] !== prev[t]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const shouldStartRequest = (()=>{\n            if (!key) return false;\n            if (!fetcher) return false;\n            // If `revalidateOnMount` is set, we take the value directly.\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(revalidateOnMount)) return revalidateOnMount;\n            // If it's paused, we skip revalidation.\n            if (getConfig().isPaused()) return false;\n            if (suspense) return false;\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(revalidateIfStale)) return revalidateIfStale;\n            return true;\n        })();\n        // Get the cache and merge it with expected states.\n        const getSelectedCache = (state)=>{\n            // We only select the needed fields from the state.\n            const snapshot = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.mergeObjects)(state);\n            delete snapshot._k;\n            if (!shouldStartRequest) {\n                return snapshot;\n            }\n            return {\n                isValidating: true,\n                isLoading: true,\n                ...snapshot\n            };\n        };\n        const cachedData = getCache();\n        const initialData = getInitialCache();\n        const clientSnapshot = getSelectedCache(cachedData);\n        const serverSnapshot = cachedData === initialData ? clientSnapshot : getSelectedCache(initialData);\n        // To make sure that we are returning the same object reference to avoid\n        // unnecessary re-renders, we keep the previous snapshot and use deep\n        // comparison to check if we need to return a new one.\n        let memorizedSnapshot = clientSnapshot;\n        return [\n            ()=>{\n                const newSnapshot = getSelectedCache(getCache());\n                const compareResult = isEqual(newSnapshot, memorizedSnapshot);\n                if (compareResult) {\n                    // Mentally, we should always return the `memorizedSnapshot` here\n                    // as there's no change between the new and old snapshots.\n                    // However, since the `isEqual` function only compares selected fields,\n                    // the values of the unselected fields might be changed. That's\n                    // simply because we didn't track them.\n                    // To support the case in https://github.com/vercel/swr/pull/2576,\n                    // we need to update these fields in the `memorizedSnapshot` too\n                    // with direct mutations to ensure the snapshot is always up-to-date\n                    // even for the unselected fields, but only trigger re-renders when\n                    // the selected fields are changed.\n                    memorizedSnapshot.data = newSnapshot.data;\n                    memorizedSnapshot.isLoading = newSnapshot.isLoading;\n                    memorizedSnapshot.isValidating = newSnapshot.isValidating;\n                    memorizedSnapshot.error = newSnapshot.error;\n                    return memorizedSnapshot;\n                } else {\n                    memorizedSnapshot = newSnapshot;\n                    return newSnapshot;\n                }\n            },\n            ()=>serverSnapshot\n        ];\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        cache,\n        key\n    ]);\n    // Get the current state that SWR should return.\n    const cached = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>subscribeCache(key, (current, prev)=>{\n            if (!isEqual(prev, current)) callback();\n        }), // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        cache,\n        key\n    ]), getSnapshot[0], getSnapshot[1]);\n    const isInitialMount = !initialMountedRef.current;\n    const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;\n    const cachedData = cached.data;\n    const data = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cachedData) ? fallback : cachedData;\n    const error = cached.error;\n    // Use a ref to store previously returned data. Use the initial data as its initial value.\n    const laggyDataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(data);\n    const returnedData = keepPreviousData ? (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cachedData) ? laggyDataRef.current : cachedData : data;\n    // - Suspense mode and there's stale data for the initial render.\n    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n    // - `revalidateIfStale` is enabled but `data` is not defined.\n    const shouldDoInitialRevalidation = (()=>{\n        // if a key already has revalidators and also has error, we should not trigger revalidation\n        if (hasRevalidator && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(error)) return false;\n        // If `revalidateOnMount` is set, we take the value directly.\n        if (isInitialMount && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(revalidateOnMount)) return revalidateOnMount;\n        // If it's paused, we skip revalidation.\n        if (getConfig().isPaused()) return false;\n        // Under suspense mode, it will always fetch on render if there is no\n        // stale data so no need to revalidate immediately mount it again.\n        // If data exists, only revalidate if `revalidateIfStale` is true.\n        if (suspense) return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) ? false : revalidateIfStale;\n        // If there is no stale data, we need to revalidate when mount;\n        // If `revalidateIfStale` is set to true, we will always revalidate.\n        return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) || revalidateIfStale;\n    })();\n    // Resolve the default validating state:\n    // If it's able to validate, and it should revalidate when mount, this will be true.\n    const defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation);\n    const isValidating = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cached.isValidating) ? defaultValidatingState : cached.isValidating;\n    const isLoading = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cached.isLoading) ? defaultValidatingState : cached.isLoading;\n    // The revalidation function is a carefully crafted wrapper of the original\n    // `fetcher`, to correctly handle the many edge cases.\n    const revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (revalidateOpts)=>{\n        const currentFetcher = fetcherRef.current;\n        if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n            return false;\n        }\n        let newData;\n        let startAt;\n        let loading = true;\n        const opts = revalidateOpts || {};\n        // If there is no ongoing concurrent request, or `dedupe` is not set, a\n        // new request should be initiated.\n        const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n        /*\n         For React 17\n         Do unmount check for calls:\n         If key has changed during the revalidation, or the component has been\n         unmounted, old dispatch and old event callbacks should not take any\n         effect\n\n        For React 18\n        only check if key has changed\n        https://github.com/reactwg/react-18/discussions/82\n      */ const callbackSafeguard = ()=>{\n            if (swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_REACT_LEGACY) {\n                return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n            }\n            return key === keyRef.current;\n        };\n        // The final state object when the request finishes.\n        const finalState = {\n            isValidating: false,\n            isLoading: false\n        };\n        const finishRequestAndUpdateState = ()=>{\n            setCache(finalState);\n        };\n        const cleanupState = ()=>{\n            // Check if it's still the same request before deleting it.\n            const requestInfo = FETCH[key];\n            if (requestInfo && requestInfo[1] === startAt) {\n                delete FETCH[key];\n            }\n        };\n        // Start fetching. Change the `isValidating` state, update the cache.\n        const initialState = {\n            isValidating: true\n        };\n        // It is in the `isLoading` state, if and only if there is no cached data.\n        // This bypasses fallback data and laggy data.\n        if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(getCache().data)) {\n            initialState.isLoading = true;\n        }\n        try {\n            if (shouldStartNewRequest) {\n                setCache(initialState);\n                // If no cache is being rendered currently (it shows a blank page),\n                // we trigger the loading slow event.\n                if (config.loadingTimeout && (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(getCache().data)) {\n                    setTimeout(()=>{\n                        if (loading && callbackSafeguard()) {\n                            getConfig().onLoadingSlow(key, config);\n                        }\n                    }, config.loadingTimeout);\n                }\n                // Start the request and save the timestamp.\n                // Key must be truthy if entering here.\n                FETCH[key] = [\n                    currentFetcher(fnArg),\n                    (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.getTimestamp)()\n                ];\n            }\n            [newData, startAt] = FETCH[key];\n            newData = await newData;\n            if (shouldStartNewRequest) {\n                // If the request isn't interrupted, clean it up after the\n                // deduplication interval.\n                setTimeout(cleanupState, config.dedupingInterval);\n            }\n            // If there're other ongoing request(s), started after the current one,\n            // we need to ignore the current one to avoid possible race conditions:\n            //   req1------------------>res1        (current one)\n            //        req2---------------->res2\n            // the request that fired later will always be kept.\n            // The timestamp maybe be `undefined` or a number\n            if (!FETCH[key] || FETCH[key][1] !== startAt) {\n                if (shouldStartNewRequest) {\n                    if (callbackSafeguard()) {\n                        getConfig().onDiscarded(key);\n                    }\n                }\n                return false;\n            }\n            // Clear error.\n            finalState.error = swr_internal__WEBPACK_IMPORTED_MODULE_3__.UNDEFINED;\n            // If there're other mutations(s), that overlapped with the current revalidation:\n            // case 1:\n            //   req------------------>res\n            //       mutate------>end\n            // case 2:\n            //         req------------>res\n            //   mutate------>end\n            // case 3:\n            //   req------------------>res\n            //       mutate-------...---------->\n            // we have to ignore the revalidation result (res) because it's no longer fresh.\n            // meanwhile, a new revalidation should be triggered when the mutation ends.\n            const mutationInfo = MUTATION[key];\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(mutationInfo) && // case 1\n            (startAt <= mutationInfo[0] || // case 2\n            startAt <= mutationInfo[1] || // case 3\n            mutationInfo[1] === 0)) {\n                finishRequestAndUpdateState();\n                if (shouldStartNewRequest) {\n                    if (callbackSafeguard()) {\n                        getConfig().onDiscarded(key);\n                    }\n                }\n                return false;\n            }\n            // Deep compare with the latest state to avoid extra re-renders.\n            // For local state, compare and assign.\n            const cacheData = getCache().data;\n            // Since the compare fn could be custom fn\n            // cacheData might be different from newData even when compare fn returns True\n            finalState.data = compare(cacheData, newData) ? cacheData : newData;\n            // Trigger the successful callback if it's the original request.\n            if (shouldStartNewRequest) {\n                if (callbackSafeguard()) {\n                    getConfig().onSuccess(newData, key, config);\n                }\n            }\n        } catch (err) {\n            cleanupState();\n            const currentConfig = getConfig();\n            const { shouldRetryOnError } = currentConfig;\n            // Not paused, we continue handling the error. Otherwise, discard it.\n            if (!currentConfig.isPaused()) {\n                // Get a new error, don't use deep comparison for errors.\n                finalState.error = err;\n                // Error event and retry logic. Only for the actual request, not\n                // deduped ones.\n                if (shouldStartNewRequest && callbackSafeguard()) {\n                    currentConfig.onError(err, key, currentConfig);\n                    if (shouldRetryOnError === true || (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isFunction)(shouldRetryOnError) && shouldRetryOnError(err)) {\n                        if (!getConfig().revalidateOnFocus || !getConfig().revalidateOnReconnect || isActive()) {\n                            // If it's inactive, stop. It will auto-revalidate when\n                            // refocusing or reconnecting.\n                            // When retrying, deduplication is always enabled.\n                            currentConfig.onErrorRetry(err, key, currentConfig, (_opts)=>{\n                                const revalidators = EVENT_REVALIDATORS[key];\n                                if (revalidators && revalidators[0]) {\n                                    revalidators[0](swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.ERROR_REVALIDATE_EVENT, _opts);\n                                }\n                            }, {\n                                retryCount: (opts.retryCount || 0) + 1,\n                                dedupe: true\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        // Mark loading as stopped.\n        loading = false;\n        // Update the current hook's state.\n        finishRequestAndUpdateState();\n        return true;\n    }, // `setState` is immutable, and `eventsCallback`, `fnArg`, and\n    // `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        key,\n        cache\n    ]);\n    // Similar to the global mutate but bound to the current cache and key.\n    // `cache` isn't allowed to change during the lifecycle.\n    const boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(// Use callback to make sure `keyRef.current` returns latest result every time\n    (...args)=>{\n        return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.internalMutate)(cache, keyRef.current, ...args);\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // The logic for updating refs.\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(()=>{\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        // Handle laggy data updates. If there's cached data of the current key,\n        // it'll be the correct reference.\n        if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cachedData)) {\n            laggyDataRef.current = cachedData;\n        }\n    });\n    // After mounted or key changed.\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(()=>{\n        if (!key) return;\n        const softRevalidate = revalidate.bind(swr_internal__WEBPACK_IMPORTED_MODULE_3__.UNDEFINED, WITH_DEDUPE);\n        // Expose revalidators to global event listeners. So we can trigger\n        // revalidation from the outside.\n        let nextFocusRevalidatedAt = 0;\n        const onRevalidate = (type, opts = {})=>{\n            if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.FOCUS_EVENT) {\n                const now = Date.now();\n                if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n                    softRevalidate();\n                }\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.RECONNECT_EVENT) {\n                if (getConfig().revalidateOnReconnect && isActive()) {\n                    softRevalidate();\n                }\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.MUTATE_EVENT) {\n                return revalidate();\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_3__.revalidateEvents.ERROR_REVALIDATE_EVENT) {\n                return revalidate(opts);\n            }\n            return;\n        };\n        const unsubEvents = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.subscribeCallback)(key, EVENT_REVALIDATORS, onRevalidate);\n        // Mark the component as mounted and update corresponding refs.\n        unmountedRef.current = false;\n        keyRef.current = key;\n        initialMountedRef.current = true;\n        // Keep the original key in the cache.\n        setCache({\n            _k: fnArg\n        });\n        // Trigger a revalidation\n        if (shouldDoInitialRevalidation) {\n            if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) || swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_SERVER) {\n                // Revalidate immediately.\n                softRevalidate();\n            } else {\n                // Delay the revalidate if we have data to return so we won't block\n                // rendering.\n                (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.rAF)(softRevalidate);\n            }\n        }\n        return ()=>{\n            // Mark it as unmounted.\n            unmountedRef.current = true;\n            unsubEvents();\n        };\n    }, [\n        key\n    ]);\n    // Polling\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(()=>{\n        let timer;\n        function next() {\n            // Use the passed interval\n            // ...or invoke the function with the updated data to get the interval\n            const interval = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isFunction)(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;\n            // We only start the next interval if `refreshInterval` is not 0, and:\n            // - `force` is true, which is the start of polling\n            // - or `timer` is not 0, which means the effect wasn't canceled\n            if (interval && timer !== -1) {\n                timer = setTimeout(execute, interval);\n            }\n        }\n        function execute() {\n            // Check if it's OK to execute:\n            // Only revalidate when the page is visible, online, and not errored.\n            if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n                revalidate(WITH_DEDUPE).then(next);\n            } else {\n                // Schedule the next interval to check again.\n                next();\n            }\n        }\n        next();\n        return ()=>{\n            if (timer) {\n                clearTimeout(timer);\n                timer = -1;\n            }\n        };\n    }, [\n        refreshInterval,\n        refreshWhenHidden,\n        refreshWhenOffline,\n        key\n    ]);\n    // Display debug info in React DevTools.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(returnedData);\n    // In Suspense mode, we can't return the empty `data` state.\n    // If there is an `error`, the `error` needs to be thrown to the error boundary.\n    // If there is no `error`, the `revalidation` promise needs to be thrown to\n    // the suspense boundary.\n    if (suspense && (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data) && key) {\n        // SWR should throw when trying to use Suspense on the server with React 18,\n        // without providing any initial data. See:\n        // https://github.com/vercel/swr/issues/1832\n        if (!swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_REACT_LEGACY && swr_internal__WEBPACK_IMPORTED_MODULE_3__.IS_SERVER) {\n            throw new Error('Fallback data is required when using suspense in SSR.');\n        }\n        // Always update fetcher and config refs even with the Suspense mode.\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        unmountedRef.current = false;\n        const req = PRELOAD[key];\n        if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(req)) {\n            const promise = boundMutate(req);\n            use(promise);\n        }\n        if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(error)) {\n            const promise = revalidate(WITH_DEDUPE);\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(returnedData)) {\n                promise.status = 'fulfilled';\n                promise.value = true;\n            }\n            use(promise);\n        } else {\n            throw error;\n        }\n    }\n    return {\n        mutate: boundMutate,\n        get data () {\n            stateDependencies.data = true;\n            return returnedData;\n        },\n        get error () {\n            stateDependencies.error = true;\n            return error;\n        },\n        get isValidating () {\n            stateDependencies.isValidating = true;\n            return isValidating;\n        },\n        get isLoading () {\n            stateDependencies.isLoading = true;\n            return isLoading;\n        }\n    };\n};\nswr_internal__WEBPACK_IMPORTED_MODULE_3__.OBJECT.defineProperty(swr_internal__WEBPACK_IMPORTED_MODULE_3__.SWRConfig, 'defaultValue', {\n    value: swr_internal__WEBPACK_IMPORTED_MODULE_3__.defaultConfig\n});\n/**\n * A hook to fetch data.\n *\n * @link https://swr.vercel.app\n * @example\n * ```jsx\n * import useSWR from 'swr'\n * function Profile() {\n *   const { data, error, isLoading } = useSWR('/api/user', fetcher)\n *   if (error) return <div>failed to load</div>\n *   if (isLoading) return <div>loading...</div>\n *   return <div>hello {data.name}!</div>\n * }\n * ```\n */ const useSWR = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.withArgs)(useSWRHandler);\n\nconst getFirstPageKey = (getKey)=>{\n    return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.serialize)(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = (getKey)=>{\n    return swr_internal__WEBPACK_IMPORTED_MODULE_3__.INFINITE_PREFIX + getFirstPageKey(getKey);\n};\n\n// We have to several type castings here because `useSWRInfinite` is a special\n// hook where `key` and return type are not like the normal `useSWR` types.\n// const INFINITE_PREFIX = '$inf$'\nconst EMPTY_PROMISE = Promise.resolve();\n// export const unstable_serialize = (getKey: SWRInfiniteKeyLoader) => {\n//   return INFINITE_PREFIX + getFirstPageKey(getKey)\n// }\nconst infinite = (useSWRNext)=>(getKey, fn, config)=>{\n        const didMountRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n        const { cache: cache$1, initialSize = 1, revalidateAll = false, persistSize = false, revalidateFirstPage = true, revalidateOnMount = false, parallel = false } = config;\n        const [, , , PRELOAD] = swr_internal__WEBPACK_IMPORTED_MODULE_3__.SWRGlobalState.get(swr_internal__WEBPACK_IMPORTED_MODULE_3__.cache);\n        // The serialized key of the first page. This key will be used to store\n        // metadata of this SWR infinite hook.\n        let infiniteKey;\n        try {\n            infiniteKey = getFirstPageKey(getKey);\n            if (infiniteKey) infiniteKey = swr_internal__WEBPACK_IMPORTED_MODULE_3__.INFINITE_PREFIX + infiniteKey;\n        } catch (err) {\n        // Not ready yet.\n        }\n        const [get, set, subscribeCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.createCacheHelper)(cache$1, infiniteKey);\n        const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n            const size = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(get()._l) ? initialSize : get()._l;\n            return size;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            cache$1,\n            infiniteKey,\n            initialSize\n        ]);\n        (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n            if (infiniteKey) return subscribeCache(infiniteKey, ()=>{\n                callback();\n            });\n            return ()=>{};\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            cache$1,\n            infiniteKey\n        ]), getSnapshot, getSnapshot);\n        const resolvePageSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n            const cachedPageSize = get()._l;\n            return (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cachedPageSize) ? initialSize : cachedPageSize;\n        // `cache` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            initialSize\n        ]);\n        // keep the last page size to restore it with the persistSize option\n        const lastPageSizeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(resolvePageSize());\n        // When the page key changes, we reset the page size if it's not persisted\n        (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(()=>{\n            if (!didMountRef.current) {\n                didMountRef.current = true;\n                return;\n            }\n            if (infiniteKey) {\n                // If the key has been changed, we keep the current page size if persistSize is enabled\n                // Otherwise, we reset the page size to cached pageSize\n                set({\n                    _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n                });\n            }\n        // `initialSize` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            cache$1\n        ]);\n        // Needs to check didMountRef during mounting, not in the fetcher\n        const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n        // Actual SWR hook to load all pages in one fetcher.\n        const swr = useSWRNext(infiniteKey, async (key)=>{\n            // get the revalidate context\n            const forceRevalidateAll = get()._i;\n            const shouldRevalidatePage = get()._r;\n            set({\n                _r: swr_internal__WEBPACK_IMPORTED_MODULE_3__.UNDEFINED\n            });\n            // return an array of page data\n            const data = [];\n            const pageSize = resolvePageSize();\n            const [getCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.createCacheHelper)(cache$1, key);\n            const cacheData = getCache().data;\n            const revalidators = [];\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                const [pageKey, pageArg] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.serialize)(getKey(i, parallel ? null : previousPageData));\n                if (!pageKey) {\n                    break;\n                }\n                const [getSWRCache, setSWRCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.createCacheHelper)(cache$1, pageKey);\n                // Get the cached page data.\n                let pageData = getSWRCache().data;\n                // should fetch (or revalidate) if:\n                // - `revalidateAll` is enabled\n                // - `mutate()` called\n                // - the cache is missing\n                // - it's the first page and it's not the initial render\n                // - `revalidateOnMount` is enabled and it's on mount\n                // - cache for that page has changed\n                const shouldFetchPage = revalidateAll || forceRevalidateAll || (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(pageData) || revalidateFirstPage && !i && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cacheData) || shouldRevalidateOnMount || cacheData && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(cacheData[i]) && !config.compare(cacheData[i], pageData);\n                if (fn && (typeof shouldRevalidatePage === 'function' ? shouldRevalidatePage(pageData, pageArg) : shouldFetchPage)) {\n                    const revalidate = async ()=>{\n                        const hasPreloadedRequest = pageKey in PRELOAD;\n                        if (!hasPreloadedRequest) {\n                            pageData = await fn(pageArg);\n                        } else {\n                            const req = PRELOAD[pageKey];\n                            // delete the preload cache key before resolving it\n                            // in case there's an error\n                            delete PRELOAD[pageKey];\n                            // get the page data from the preload cache\n                            pageData = await req;\n                        }\n                        setSWRCache({\n                            data: pageData,\n                            _k: pageArg\n                        });\n                        data[i] = pageData;\n                    };\n                    if (parallel) {\n                        revalidators.push(revalidate);\n                    } else {\n                        await revalidate();\n                    }\n                } else {\n                    data[i] = pageData;\n                }\n                if (!parallel) {\n                    previousPageData = pageData;\n                }\n            }\n            // flush all revalidateions in parallel\n            if (parallel) {\n                await Promise.all(revalidators.map((r)=>r()));\n            }\n            // once we executed the data fetching based on the context, clear the context\n            set({\n                _i: swr_internal__WEBPACK_IMPORTED_MODULE_3__.UNDEFINED\n            });\n            // return the data\n            return data;\n        }, config);\n        const mutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(// eslint-disable-next-line func-names\n        function(data, opts) {\n            // When passing as a boolean, it's explicitly used to disable/enable\n            // revalidation.\n            const options = typeof opts === 'boolean' ? {\n                revalidate: opts\n            } : opts || {};\n            // Default to true.\n            const shouldRevalidate = options.revalidate !== false;\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            if (shouldRevalidate) {\n                if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data)) {\n                    // We only revalidate the pages that are changed\n                    set({\n                        _i: false,\n                        _r: options.revalidate\n                    });\n                } else {\n                    // Calling `mutate()`, we revalidate all pages\n                    set({\n                        _i: true,\n                        _r: options.revalidate\n                    });\n                }\n            }\n            return arguments.length ? swr.mutate(data, {\n                ...options,\n                revalidate: shouldRevalidate\n            }) : swr.mutate();\n        }, // swr.mutate is always the same reference\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1\n        ]);\n        // Extend the SWR API\n        const setSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((arg)=>{\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            const [, changeSize] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.createCacheHelper)(cache$1, infiniteKey);\n            let size;\n            if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isFunction)(arg)) {\n                size = arg(resolvePageSize());\n            } else if (typeof arg == 'number') {\n                size = arg;\n            }\n            if (typeof size != 'number') return EMPTY_PROMISE;\n            changeSize({\n                _l: size\n            });\n            lastPageSizeRef.current = size;\n            // Calculate the page data after the size change.\n            const data = [];\n            const [getInfiniteCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.createCacheHelper)(cache$1, infiniteKey);\n            let previousPageData = null;\n            for(let i = 0; i < size; ++i){\n                const [pageKey] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.serialize)(getKey(i, previousPageData));\n                const [getCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.createCacheHelper)(cache$1, pageKey);\n                // Get the cached page data.\n                const pageData = pageKey ? getCache().data : swr_internal__WEBPACK_IMPORTED_MODULE_3__.UNDEFINED;\n                // Call `mutate` with infinte cache data if we can't get it from the page cache.\n                if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(pageData)) {\n                    return mutate(getInfiniteCache().data);\n                }\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            return mutate(data);\n        }, // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1,\n            mutate,\n            resolvePageSize\n        ]);\n        // Use getter functions to avoid unnecessary re-renders caused by triggering\n        // all the getters of the returned swr object.\n        return {\n            size: resolvePageSize(),\n            setSize,\n            mutate,\n            get data () {\n                return swr.data;\n            },\n            get error () {\n                return swr.error;\n            },\n            get isValidating () {\n                return swr.isValidating;\n            },\n            get isLoading () {\n                return swr.isLoading;\n            }\n        };\n    };\nconst useSWRInfinite = (0,swr_internal__WEBPACK_IMPORTED_MODULE_3__.withMiddleware)(useSWR, infinite);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9pbmZpbml0ZS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrRjtBQUM3RDtBQUN3RDtBQUNxUTs7QUFFbFY7QUFDQSxZQUFZLHNDQUFnQjtBQUM1QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUpBQXlKO0FBQ3JLLDJEQUEyRCx3REFBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1REFBUztBQUNsQztBQUNBLDhCQUE4Qiw2Q0FBTTtBQUNwQztBQUNBO0FBQ0EseUJBQXlCLDZDQUFNO0FBQy9CO0FBQ0EsbUJBQW1CLDZDQUFNO0FBQ3pCLHVCQUF1Qiw2Q0FBTTtBQUM3QixzQkFBc0IsNkNBQU07QUFDNUI7QUFDQTtBQUNBLGtFQUFrRSwrREFBaUI7QUFDbkYsOEJBQThCLDZDQUFNLEdBQUc7QUFDdkMscUJBQXFCLHlEQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBVztBQUM1QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJGQUFvQixDQUFDLGtEQUFXO0FBQ25EO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFXO0FBQzVCO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQU07QUFDL0IsNENBQTRDLHlEQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQVc7QUFDMUM7QUFDQSwrQkFBK0IseURBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5REFBVztBQUN4QztBQUNBO0FBQ0EsZUFBZSx5REFBVztBQUMxQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlEQUFXO0FBQ3BDLHNCQUFzQix5REFBVztBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLGtEQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlEQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx3REFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwREFBZ0I7QUFDcEU7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrREFBVztBQUNuQztBQUNBLGVBQWUsNERBQWM7QUFDN0IsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLHVFQUF5QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVc7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksdUVBQXlCO0FBQzdCO0FBQ0EsK0NBQStDLG1EQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qyx3QkFBd0IsMERBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQiwwREFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUIsMERBQWdCO0FBQy9DO0FBQ0EsY0FBYyxpQkFBaUIsMERBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFXLFVBQVUsbURBQVM7QUFDOUM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0RBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5REFBZSxJQUFJLG1EQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5REFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFXO0FBQ3ZCO0FBQ0EsaUJBQWlCLHlEQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBTSxnQkFBZ0IsbURBQVM7QUFDL0IsV0FBVyx1REFBYTtBQUN4QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0EsbUJBQW1CLHNEQUFROztBQUUzQjtBQUNBLFdBQVcsdURBQVM7QUFDcEI7QUFDQTtBQUNBLFdBQVcseURBQWU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBTTtBQUNsQyxnQkFBZ0IsdUpBQXVKO0FBQ3ZLLGdDQUFnQyx3REFBYyxLQUFLLCtDQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseURBQWU7QUFDMUQsVUFBVTtBQUNWO0FBQ0E7QUFDQSwyQ0FBMkMsK0RBQWlCO0FBQzVELDRCQUE0QixrREFBVztBQUN2Qyx5QkFBeUIseURBQVc7QUFDcEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkZBQW9CLENBQUMsa0RBQVc7QUFDeEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBVztBQUMzQztBQUNBLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZDQUFNO0FBQ3RDO0FBQ0EsUUFBUSx1RUFBeUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFTO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0RBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDLDJDQUEyQyx1REFBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsK0RBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSx5REFBVyw0Q0FBNEMseURBQVcsd0RBQXdELHlEQUFXO0FBQ3BOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVM7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLGtEQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5REFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFXO0FBQ25DO0FBQ0E7QUFDQSxtQ0FBbUMsK0RBQWlCO0FBQ3BEO0FBQ0EsZ0JBQWdCLHdEQUFVO0FBQzFCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtEQUFpQjtBQUN4RDtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLGtDQUFrQyx1REFBUztBQUMzQyxtQ0FBbUMsK0RBQWlCO0FBQ3BEO0FBQ0EsNkRBQTZELG1EQUFTO0FBQ3RFO0FBQ0Esb0JBQW9CLHlEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQWM7O0FBRThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9pbmZpbml0ZS9pbmRleC5tanM/MzE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3RFeHBvcnRzLCB7IHVzZVJlZiwgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIHVzZURlYnVnVmFsdWUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgJ2NsaWVudC1vbmx5JztcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qcyc7XG5pbXBvcnQgeyBPQkpFQ1QsIFNXUkNvbmZpZywgZGVmYXVsdENvbmZpZywgd2l0aEFyZ3MsIFNXUkdsb2JhbFN0YXRlLCBzZXJpYWxpemUsIGNyZWF0ZUNhY2hlSGVscGVyLCBpc1VuZGVmaW5lZCwgZ2V0VGltZXN0YW1wLCBVTkRFRklORUQsIGlzRnVuY3Rpb24sIHJldmFsaWRhdGVFdmVudHMsIGludGVybmFsTXV0YXRlLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCBzdWJzY3JpYmVDYWxsYmFjaywgSVNfU0VSVkVSLCByQUYsIElTX1JFQUNUX0xFR0FDWSwgbWVyZ2VPYmplY3RzLCBJTkZJTklURV9QUkVGSVgsIHdpdGhNaWRkbGV3YXJlLCBjYWNoZSB9IGZyb20gJ3N3ci9faW50ZXJuYWwnO1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlYWN0L2V4cGVyaW1lbnRhbFwiIC8+XG5jb25zdCB1c2UgPSBSZWFjdEV4cG9ydHMudXNlIHx8ICgocHJvbWlzZSk9PntcbiAgICBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICB0aHJvdyBwcm9taXNlO1xuICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgICAgdGhyb3cgcHJvbWlzZS5yZWFzb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSAncGVuZGluZyc7XG4gICAgICAgIHByb21pc2UudGhlbigodik9PntcbiAgICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgICAgICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICAgICAgfSwgKGUpPT57XG4gICAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICBwcm9taXNlLnJlYXNvbiA9IGU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBwcm9taXNlO1xuICAgIH1cbn0pO1xuY29uc3QgV0lUSF9ERURVUEUgPSB7XG4gICAgZGVkdXBlOiB0cnVlXG59O1xuY29uc3QgdXNlU1dSSGFuZGxlciA9IChfa2V5LCBmZXRjaGVyLCBjb25maWcpPT57XG4gICAgY29uc3QgeyBjYWNoZSwgY29tcGFyZSwgc3VzcGVuc2UsIGZhbGxiYWNrRGF0YSwgcmV2YWxpZGF0ZU9uTW91bnQsIHJldmFsaWRhdGVJZlN0YWxlLCByZWZyZXNoSW50ZXJ2YWwsIHJlZnJlc2hXaGVuSGlkZGVuLCByZWZyZXNoV2hlbk9mZmxpbmUsIGtlZXBQcmV2aW91c0RhdGEgfSA9IGNvbmZpZztcbiAgICBjb25zdCBbRVZFTlRfUkVWQUxJREFUT1JTLCBNVVRBVElPTiwgRkVUQ0gsIFBSRUxPQURdID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICAvLyBga2V5YCBpcyB0aGUgaWRlbnRpZmllciBvZiB0aGUgU1dSIGludGVybmFsIHN0YXRlLFxuICAgIC8vIGBmbkFyZ2AgaXMgdGhlIGFyZ3VtZW50L2FyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUga2V5LCB3aGljaCB3aWxsIGJlIHBhc3NlZFxuICAgIC8vIHRvIHRoZSBmZXRjaGVyLlxuICAgIC8vIEFsbCBvZiB0aGVtIGFyZSBkZXJpdmVkIGZyb20gYF9rZXlgLlxuICAgIGNvbnN0IFtrZXksIGZuQXJnXSA9IHNlcmlhbGl6ZShfa2V5KTtcbiAgICAvLyBJZiBpdCdzIHRoZSBpbml0aWFsIHJlbmRlciBvZiB0aGlzIGhvb2suXG4gICAgY29uc3QgaW5pdGlhbE1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIElmIHRoZSBob29rIGlzIHVubW91bnRlZCBhbHJlYWR5LiBUaGlzIHdpbGwgYmUgdXNlZCB0byBwcmV2ZW50IHNvbWUgZWZmZWN0c1xuICAgIC8vIHRvIGJlIGNhbGxlZCBhZnRlciB1bm1vdW50aW5nLlxuICAgIGNvbnN0IHVubW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gUmVmcyB0byBrZWVwIHRoZSBrZXkgYW5kIGNvbmZpZy5cbiAgICBjb25zdCBrZXlSZWYgPSB1c2VSZWYoa2V5KTtcbiAgICBjb25zdCBmZXRjaGVyUmVmID0gdXNlUmVmKGZldGNoZXIpO1xuICAgIGNvbnN0IGNvbmZpZ1JlZiA9IHVzZVJlZihjb25maWcpO1xuICAgIGNvbnN0IGdldENvbmZpZyA9ICgpPT5jb25maWdSZWYuY3VycmVudDtcbiAgICBjb25zdCBpc0FjdGl2ZSA9ICgpPT5nZXRDb25maWcoKS5pc1Zpc2libGUoKSAmJiBnZXRDb25maWcoKS5pc09ubGluZSgpO1xuICAgIGNvbnN0IFtnZXRDYWNoZSwgc2V0Q2FjaGUsIHN1YnNjcmliZUNhY2hlLCBnZXRJbml0aWFsQ2FjaGVdID0gY3JlYXRlQ2FjaGVIZWxwZXIoY2FjaGUsIGtleSk7XG4gICAgY29uc3Qgc3RhdGVEZXBlbmRlbmNpZXMgPSB1c2VSZWYoe30pLmN1cnJlbnQ7XG4gICAgY29uc3QgZmFsbGJhY2sgPSBpc1VuZGVmaW5lZChmYWxsYmFja0RhdGEpID8gY29uZmlnLmZhbGxiYWNrW2tleV0gOiBmYWxsYmFja0RhdGE7XG4gICAgY29uc3QgaXNFcXVhbCA9IChwcmV2LCBjdXJyZW50KT0+e1xuICAgICAgICBmb3IoY29uc3QgXyBpbiBzdGF0ZURlcGVuZGVuY2llcyl7XG4gICAgICAgICAgICBjb25zdCB0ID0gXztcbiAgICAgICAgICAgIGlmICh0ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmUocHJldlt0XSwgY3VycmVudFt0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChwcmV2W3RdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShyZXR1cm5lZERhdGEsIGN1cnJlbnRbdF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50W3RdICE9PSBwcmV2W3RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IHVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3Qgc2hvdWxkU3RhcnRSZXF1ZXN0ID0gKCgpPT57XG4gICAgICAgICAgICBpZiAoIWtleSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFmZXRjaGVyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBJZiBgcmV2YWxpZGF0ZU9uTW91bnRgIGlzIHNldCwgd2UgdGFrZSB0aGUgdmFsdWUgZGlyZWN0bHkuXG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHJldmFsaWRhdGVPbk1vdW50KSkgcmV0dXJuIHJldmFsaWRhdGVPbk1vdW50O1xuICAgICAgICAgICAgLy8gSWYgaXQncyBwYXVzZWQsIHdlIHNraXAgcmV2YWxpZGF0aW9uLlxuICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChyZXZhbGlkYXRlSWZTdGFsZSkpIHJldHVybiByZXZhbGlkYXRlSWZTdGFsZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSgpO1xuICAgICAgICAvLyBHZXQgdGhlIGNhY2hlIGFuZCBtZXJnZSBpdCB3aXRoIGV4cGVjdGVkIHN0YXRlcy5cbiAgICAgICAgY29uc3QgZ2V0U2VsZWN0ZWRDYWNoZSA9IChzdGF0ZSk9PntcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgc2VsZWN0IHRoZSBuZWVkZWQgZmllbGRzIGZyb20gdGhlIHN0YXRlLlxuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBtZXJnZU9iamVjdHMoc3RhdGUpO1xuICAgICAgICAgICAgZGVsZXRlIHNuYXBzaG90Ll9rO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRTdGFydFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4uc25hcHNob3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSBnZXRDYWNoZSgpO1xuICAgICAgICBjb25zdCBpbml0aWFsRGF0YSA9IGdldEluaXRpYWxDYWNoZSgpO1xuICAgICAgICBjb25zdCBjbGllbnRTbmFwc2hvdCA9IGdldFNlbGVjdGVkQ2FjaGUoY2FjaGVkRGF0YSk7XG4gICAgICAgIGNvbnN0IHNlcnZlclNuYXBzaG90ID0gY2FjaGVkRGF0YSA9PT0gaW5pdGlhbERhdGEgPyBjbGllbnRTbmFwc2hvdCA6IGdldFNlbGVjdGVkQ2FjaGUoaW5pdGlhbERhdGEpO1xuICAgICAgICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB3ZSBhcmUgcmV0dXJuaW5nIHRoZSBzYW1lIG9iamVjdCByZWZlcmVuY2UgdG8gYXZvaWRcbiAgICAgICAgLy8gdW5uZWNlc3NhcnkgcmUtcmVuZGVycywgd2Uga2VlcCB0aGUgcHJldmlvdXMgc25hcHNob3QgYW5kIHVzZSBkZWVwXG4gICAgICAgIC8vIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgd2UgbmVlZCB0byByZXR1cm4gYSBuZXcgb25lLlxuICAgICAgICBsZXQgbWVtb3JpemVkU25hcHNob3QgPSBjbGllbnRTbmFwc2hvdDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U25hcHNob3QgPSBnZXRTZWxlY3RlZENhY2hlKGdldENhY2hlKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVSZXN1bHQgPSBpc0VxdWFsKG5ld1NuYXBzaG90LCBtZW1vcml6ZWRTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWVudGFsbHksIHdlIHNob3VsZCBhbHdheXMgcmV0dXJuIHRoZSBgbWVtb3JpemVkU25hcHNob3RgIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlcmUncyBubyBjaGFuZ2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBvbGQgc25hcHNob3RzLlxuICAgICAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGUgYGlzRXF1YWxgIGZ1bmN0aW9uIG9ubHkgY29tcGFyZXMgc2VsZWN0ZWQgZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWVzIG9mIHRoZSB1bnNlbGVjdGVkIGZpZWxkcyBtaWdodCBiZSBjaGFuZ2VkLiBUaGF0J3NcbiAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGx5IGJlY2F1c2Ugd2UgZGlkbid0IHRyYWNrIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHN1cHBvcnQgdGhlIGNhc2UgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvcHVsbC8yNTc2LFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGVzZSBmaWVsZHMgaW4gdGhlIGBtZW1vcml6ZWRTbmFwc2hvdGAgdG9vXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggZGlyZWN0IG11dGF0aW9ucyB0byBlbnN1cmUgdGhlIHNuYXBzaG90IGlzIGFsd2F5cyB1cC10by1kYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gZm9yIHRoZSB1bnNlbGVjdGVkIGZpZWxkcywgYnV0IG9ubHkgdHJpZ2dlciByZS1yZW5kZXJzIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlbGVjdGVkIGZpZWxkcyBhcmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QuZGF0YSA9IG5ld1NuYXBzaG90LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yaXplZFNuYXBzaG90LmlzTG9hZGluZyA9IG5ld1NuYXBzaG90LmlzTG9hZGluZztcbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QuaXNWYWxpZGF0aW5nID0gbmV3U25hcHNob3QuaXNWYWxpZGF0aW5nO1xuICAgICAgICAgICAgICAgICAgICBtZW1vcml6ZWRTbmFwc2hvdC5lcnJvciA9IG5ld1NuYXBzaG90LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtb3JpemVkU25hcHNob3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QgPSBuZXdTbmFwc2hvdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NuYXBzaG90O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKT0+c2VydmVyU25hcHNob3RcbiAgICAgICAgXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBjYWNoZSxcbiAgICAgICAga2V5XG4gICAgXSk7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlIHRoYXQgU1dSIHNob3VsZCByZXR1cm4uXG4gICAgY29uc3QgY2FjaGVkID0gdXNlU3luY0V4dGVybmFsU3RvcmUodXNlQ2FsbGJhY2soKGNhbGxiYWNrKT0+c3Vic2NyaWJlQ2FjaGUoa2V5LCAoY3VycmVudCwgcHJldik9PntcbiAgICAgICAgICAgIGlmICghaXNFcXVhbChwcmV2LCBjdXJyZW50KSkgY2FsbGJhY2soKTtcbiAgICAgICAgfSksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBrZXlcbiAgICBdKSwgZ2V0U25hcHNob3RbMF0sIGdldFNuYXBzaG90WzFdKTtcbiAgICBjb25zdCBpc0luaXRpYWxNb3VudCA9ICFpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IGhhc1JldmFsaWRhdG9yID0gRVZFTlRfUkVWQUxJREFUT1JTW2tleV0gJiYgRVZFTlRfUkVWQUxJREFUT1JTW2tleV0ubGVuZ3RoID4gMDtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gY2FjaGVkLmRhdGE7XG4gICAgY29uc3QgZGF0YSA9IGlzVW5kZWZpbmVkKGNhY2hlZERhdGEpID8gZmFsbGJhY2sgOiBjYWNoZWREYXRhO1xuICAgIGNvbnN0IGVycm9yID0gY2FjaGVkLmVycm9yO1xuICAgIC8vIFVzZSBhIHJlZiB0byBzdG9yZSBwcmV2aW91c2x5IHJldHVybmVkIGRhdGEuIFVzZSB0aGUgaW5pdGlhbCBkYXRhIGFzIGl0cyBpbml0aWFsIHZhbHVlLlxuICAgIGNvbnN0IGxhZ2d5RGF0YVJlZiA9IHVzZVJlZihkYXRhKTtcbiAgICBjb25zdCByZXR1cm5lZERhdGEgPSBrZWVwUHJldmlvdXNEYXRhID8gaXNVbmRlZmluZWQoY2FjaGVkRGF0YSkgPyBsYWdneURhdGFSZWYuY3VycmVudCA6IGNhY2hlZERhdGEgOiBkYXRhO1xuICAgIC8vIC0gU3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUncyBzdGFsZSBkYXRhIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgLy8gLSBOb3Qgc3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUgaXMgbm8gZmFsbGJhY2sgZGF0YSBhbmQgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkLlxuICAgIC8vIC0gYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkIGJ1dCBgZGF0YWAgaXMgbm90IGRlZmluZWQuXG4gICAgY29uc3Qgc2hvdWxkRG9Jbml0aWFsUmV2YWxpZGF0aW9uID0gKCgpPT57XG4gICAgICAgIC8vIGlmIGEga2V5IGFscmVhZHkgaGFzIHJldmFsaWRhdG9ycyBhbmQgYWxzbyBoYXMgZXJyb3IsIHdlIHNob3VsZCBub3QgdHJpZ2dlciByZXZhbGlkYXRpb25cbiAgICAgICAgaWYgKGhhc1JldmFsaWRhdG9yICYmICFpc1VuZGVmaW5lZChlcnJvcikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVPbk1vdW50YCBpcyBzZXQsIHdlIHRha2UgdGhlIHZhbHVlIGRpcmVjdGx5LlxuICAgICAgICBpZiAoaXNJbml0aWFsTW91bnQgJiYgIWlzVW5kZWZpbmVkKHJldmFsaWRhdGVPbk1vdW50KSkgcmV0dXJuIHJldmFsaWRhdGVPbk1vdW50O1xuICAgICAgICAvLyBJZiBpdCdzIHBhdXNlZCwgd2Ugc2tpcCByZXZhbGlkYXRpb24uXG4gICAgICAgIGlmIChnZXRDb25maWcoKS5pc1BhdXNlZCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFVuZGVyIHN1c3BlbnNlIG1vZGUsIGl0IHdpbGwgYWx3YXlzIGZldGNoIG9uIHJlbmRlciBpZiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdGFsZSBkYXRhIHNvIG5vIG5lZWQgdG8gcmV2YWxpZGF0ZSBpbW1lZGlhdGVseSBtb3VudCBpdCBhZ2Fpbi5cbiAgICAgICAgLy8gSWYgZGF0YSBleGlzdHMsIG9ubHkgcmV2YWxpZGF0ZSBpZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHRydWUuXG4gICAgICAgIGlmIChzdXNwZW5zZSkgcmV0dXJuIGlzVW5kZWZpbmVkKGRhdGEpID8gZmFsc2UgOiByZXZhbGlkYXRlSWZTdGFsZTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gc3RhbGUgZGF0YSwgd2UgbmVlZCB0byByZXZhbGlkYXRlIHdoZW4gbW91bnQ7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgc2V0IHRvIHRydWUsIHdlIHdpbGwgYWx3YXlzIHJldmFsaWRhdGUuXG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSB8fCByZXZhbGlkYXRlSWZTdGFsZTtcbiAgICB9KSgpO1xuICAgIC8vIFJlc29sdmUgdGhlIGRlZmF1bHQgdmFsaWRhdGluZyBzdGF0ZTpcbiAgICAvLyBJZiBpdCdzIGFibGUgdG8gdmFsaWRhdGUsIGFuZCBpdCBzaG91bGQgcmV2YWxpZGF0ZSB3aGVuIG1vdW50LCB0aGlzIHdpbGwgYmUgdHJ1ZS5cbiAgICBjb25zdCBkZWZhdWx0VmFsaWRhdGluZ1N0YXRlID0gISEoa2V5ICYmIGZldGNoZXIgJiYgaXNJbml0aWFsTW91bnQgJiYgc2hvdWxkRG9Jbml0aWFsUmV2YWxpZGF0aW9uKTtcbiAgICBjb25zdCBpc1ZhbGlkYXRpbmcgPSBpc1VuZGVmaW5lZChjYWNoZWQuaXNWYWxpZGF0aW5nKSA/IGRlZmF1bHRWYWxpZGF0aW5nU3RhdGUgOiBjYWNoZWQuaXNWYWxpZGF0aW5nO1xuICAgIGNvbnN0IGlzTG9hZGluZyA9IGlzVW5kZWZpbmVkKGNhY2hlZC5pc0xvYWRpbmcpID8gZGVmYXVsdFZhbGlkYXRpbmdTdGF0ZSA6IGNhY2hlZC5pc0xvYWRpbmc7XG4gICAgLy8gVGhlIHJldmFsaWRhdGlvbiBmdW5jdGlvbiBpcyBhIGNhcmVmdWxseSBjcmFmdGVkIHdyYXBwZXIgb2YgdGhlIG9yaWdpbmFsXG4gICAgLy8gYGZldGNoZXJgLCB0byBjb3JyZWN0bHkgaGFuZGxlIHRoZSBtYW55IGVkZ2UgY2FzZXMuXG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChyZXZhbGlkYXRlT3B0cyk9PntcbiAgICAgICAgY29uc3QgY3VycmVudEZldGNoZXIgPSBmZXRjaGVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICgha2V5IHx8ICFjdXJyZW50RmV0Y2hlciB8fCB1bm1vdW50ZWRSZWYuY3VycmVudCB8fCBnZXRDb25maWcoKS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0RhdGE7XG4gICAgICAgIGxldCBzdGFydEF0O1xuICAgICAgICBsZXQgbG9hZGluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IG9wdHMgPSByZXZhbGlkYXRlT3B0cyB8fCB7fTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gb25nb2luZyBjb25jdXJyZW50IHJlcXVlc3QsIG9yIGBkZWR1cGVgIGlzIG5vdCBzZXQsIGFcbiAgICAgICAgLy8gbmV3IHJlcXVlc3Qgc2hvdWxkIGJlIGluaXRpYXRlZC5cbiAgICAgICAgY29uc3Qgc2hvdWxkU3RhcnROZXdSZXF1ZXN0ID0gIUZFVENIW2tleV0gfHwgIW9wdHMuZGVkdXBlO1xuICAgICAgICAvKlxuICAgICAgICAgRm9yIFJlYWN0IDE3XG4gICAgICAgICBEbyB1bm1vdW50IGNoZWNrIGZvciBjYWxsczpcbiAgICAgICAgIElmIGtleSBoYXMgY2hhbmdlZCBkdXJpbmcgdGhlIHJldmFsaWRhdGlvbiwgb3IgdGhlIGNvbXBvbmVudCBoYXMgYmVlblxuICAgICAgICAgdW5tb3VudGVkLCBvbGQgZGlzcGF0Y2ggYW5kIG9sZCBldmVudCBjYWxsYmFja3Mgc2hvdWxkIG5vdCB0YWtlIGFueVxuICAgICAgICAgZWZmZWN0XG5cbiAgICAgICAgRm9yIFJlYWN0IDE4XG4gICAgICAgIG9ubHkgY2hlY2sgaWYga2V5IGhhcyBjaGFuZ2VkXG4gICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdHdnL3JlYWN0LTE4L2Rpc2N1c3Npb25zLzgyXG4gICAgICAqLyBjb25zdCBjYWxsYmFja1NhZmVndWFyZCA9ICgpPT57XG4gICAgICAgICAgICBpZiAoSVNfUkVBQ1RfTEVHQUNZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1bm1vdW50ZWRSZWYuY3VycmVudCAmJiBrZXkgPT09IGtleVJlZi5jdXJyZW50ICYmIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSBrZXlSZWYuY3VycmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlIGZpbmFsIHN0YXRlIG9iamVjdCB3aGVuIHRoZSByZXF1ZXN0IGZpbmlzaGVzLlxuICAgICAgICBjb25zdCBmaW5hbFN0YXRlID0ge1xuICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlID0gKCk9PntcbiAgICAgICAgICAgIHNldENhY2hlKGZpbmFsU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwU3RhdGUgPSAoKT0+e1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBzdGlsbCB0aGUgc2FtZSByZXF1ZXN0IGJlZm9yZSBkZWxldGluZyBpdC5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gRkVUQ0hba2V5XTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SW5mbyAmJiByZXF1ZXN0SW5mb1sxXSA9PT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBTdGFydCBmZXRjaGluZy4gQ2hhbmdlIHRoZSBgaXNWYWxpZGF0aW5nYCBzdGF0ZSwgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIC8vIEl0IGlzIGluIHRoZSBgaXNMb2FkaW5nYCBzdGF0ZSwgaWYgYW5kIG9ubHkgaWYgdGhlcmUgaXMgbm8gY2FjaGVkIGRhdGEuXG4gICAgICAgIC8vIFRoaXMgYnlwYXNzZXMgZmFsbGJhY2sgZGF0YSBhbmQgbGFnZ3kgZGF0YS5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGdldENhY2hlKCkuZGF0YSkpIHtcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZS5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgc2V0Q2FjaGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBjYWNoZSBpcyBiZWluZyByZW5kZXJlZCBjdXJyZW50bHkgKGl0IHNob3dzIGEgYmxhbmsgcGFnZSksXG4gICAgICAgICAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgbG9hZGluZyBzbG93IGV2ZW50LlxuICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9hZGluZ1RpbWVvdXQgJiYgaXNVbmRlZmluZWQoZ2V0Q2FjaGUoKS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGluZyAmJiBjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25Mb2FkaW5nU2xvdyhrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGNvbmZpZy5sb2FkaW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXF1ZXN0IGFuZCBzYXZlIHRoZSB0aW1lc3RhbXAuXG4gICAgICAgICAgICAgICAgLy8gS2V5IG11c3QgYmUgdHJ1dGh5IGlmIGVudGVyaW5nIGhlcmUuXG4gICAgICAgICAgICAgICAgRkVUQ0hba2V5XSA9IFtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZldGNoZXIoZm5BcmcpLFxuICAgICAgICAgICAgICAgICAgICBnZXRUaW1lc3RhbXAoKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbbmV3RGF0YSwgc3RhcnRBdF0gPSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgbmV3RGF0YSA9IGF3YWl0IG5ld0RhdGE7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXNuJ3QgaW50ZXJydXB0ZWQsIGNsZWFuIGl0IHVwIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlZHVwbGljYXRpb24gaW50ZXJ2YWwuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbnVwU3RhdGUsIGNvbmZpZy5kZWR1cGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3JlIG90aGVyIG9uZ29pbmcgcmVxdWVzdChzKSwgc3RhcnRlZCBhZnRlciB0aGUgY3VycmVudCBvbmUsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgLy8gICByZXExLS0tLS0tLS0tLS0tLS0tLS0tPnJlczEgICAgICAgIChjdXJyZW50IG9uZSlcbiAgICAgICAgICAgIC8vICAgICAgICByZXEyLS0tLS0tLS0tLS0tLS0tLT5yZXMyXG4gICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXG4gICAgICAgICAgICAvLyBUaGUgdGltZXN0YW1wIG1heWJlIGJlIGB1bmRlZmluZWRgIG9yIGEgbnVtYmVyXG4gICAgICAgICAgICBpZiAoIUZFVENIW2tleV0gfHwgRkVUQ0hba2V5XVsxXSAhPT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXIgZXJyb3IuXG4gICAgICAgICAgICBmaW5hbFN0YXRlLmVycm9yID0gVU5ERUZJTkVEO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncmUgb3RoZXIgbXV0YXRpb25zKHMpLCB0aGF0IG92ZXJsYXBwZWQgd2l0aCB0aGUgY3VycmVudCByZXZhbGlkYXRpb246XG4gICAgICAgICAgICAvLyBjYXNlIDE6XG4gICAgICAgICAgICAvLyAgIHJlcS0tLS0tLS0tLS0tLS0tLS0tLT5yZXNcbiAgICAgICAgICAgIC8vICAgICAgIG11dGF0ZS0tLS0tLT5lbmRcbiAgICAgICAgICAgIC8vIGNhc2UgMjpcbiAgICAgICAgICAgIC8vICAgICAgICAgcmVxLS0tLS0tLS0tLS0tPnJlc1xuICAgICAgICAgICAgLy8gICBtdXRhdGUtLS0tLS0+ZW5kXG4gICAgICAgICAgICAvLyBjYXNlIDM6XG4gICAgICAgICAgICAvLyAgIHJlcS0tLS0tLS0tLS0tLS0tLS0tLT5yZXNcbiAgICAgICAgICAgIC8vICAgICAgIG11dGF0ZS0tLS0tLS0uLi4tLS0tLS0tLS0tPlxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBpZ25vcmUgdGhlIHJldmFsaWRhdGlvbiByZXN1bHQgKHJlcykgYmVjYXVzZSBpdCdzIG5vIGxvbmdlciBmcmVzaC5cbiAgICAgICAgICAgIC8vIG1lYW53aGlsZSwgYSBuZXcgcmV2YWxpZGF0aW9uIHNob3VsZCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgbXV0YXRpb24gZW5kcy5cbiAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uSW5mbyA9IE1VVEFUSU9OW2tleV07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKG11dGF0aW9uSW5mbykgJiYgLy8gY2FzZSAxXG4gICAgICAgICAgICAoc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMF0gfHwgLy8gY2FzZSAyXG4gICAgICAgICAgICBzdGFydEF0IDw9IG11dGF0aW9uSW5mb1sxXSB8fCAvLyBjYXNlIDNcbiAgICAgICAgICAgIG11dGF0aW9uSW5mb1sxXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkRpc2NhcmRlZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZXAgY29tcGFyZSB3aXRoIHRoZSBsYXRlc3Qgc3RhdGUgdG8gYXZvaWQgZXh0cmEgcmUtcmVuZGVycy5cbiAgICAgICAgICAgIC8vIEZvciBsb2NhbCBzdGF0ZSwgY29tcGFyZSBhbmQgYXNzaWduLlxuICAgICAgICAgICAgY29uc3QgY2FjaGVEYXRhID0gZ2V0Q2FjaGUoKS5kYXRhO1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIGNvbXBhcmUgZm4gY291bGQgYmUgY3VzdG9tIGZuXG4gICAgICAgICAgICAvLyBjYWNoZURhdGEgbWlnaHQgYmUgZGlmZmVyZW50IGZyb20gbmV3RGF0YSBldmVuIHdoZW4gY29tcGFyZSBmbiByZXR1cm5zIFRydWVcbiAgICAgICAgICAgIGZpbmFsU3RhdGUuZGF0YSA9IGNvbXBhcmUoY2FjaGVEYXRhLCBuZXdEYXRhKSA/IGNhY2hlRGF0YSA6IG5ld0RhdGE7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBzdWNjZXNzZnVsIGNhbGxiYWNrIGlmIGl0J3MgdGhlIG9yaWdpbmFsIHJlcXVlc3QuXG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25TdWNjZXNzKG5ld0RhdGEsIGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2xlYW51cFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29uZmlnID0gZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICBjb25zdCB7IHNob3VsZFJldHJ5T25FcnJvciB9ID0gY3VycmVudENvbmZpZztcbiAgICAgICAgICAgIC8vIE5vdCBwYXVzZWQsIHdlIGNvbnRpbnVlIGhhbmRsaW5nIHRoZSBlcnJvci4gT3RoZXJ3aXNlLCBkaXNjYXJkIGl0LlxuICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29uZmlnLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgZXJyb3IsIGRvbid0IHVzZSBkZWVwIGNvbXBhcmlzb24gZm9yIGVycm9ycy5cbiAgICAgICAgICAgICAgICBmaW5hbFN0YXRlLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIGV2ZW50IGFuZCByZXRyeSBsb2dpYy4gT25seSBmb3IgdGhlIGFjdHVhbCByZXF1ZXN0LCBub3RcbiAgICAgICAgICAgICAgICAvLyBkZWR1cGVkIG9uZXMuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCAmJiBjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWcub25FcnJvcihlcnIsIGtleSwgY3VycmVudENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZXRyeU9uRXJyb3IgPT09IHRydWUgfHwgaXNGdW5jdGlvbihzaG91bGRSZXRyeU9uRXJyb3IpICYmIHNob3VsZFJldHJ5T25FcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdldENvbmZpZygpLnJldmFsaWRhdGVPbkZvY3VzIHx8ICFnZXRDb25maWcoKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgfHwgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgaW5hY3RpdmUsIHN0b3AuIEl0IHdpbGwgYXV0by1yZXZhbGlkYXRlIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWZvY3VzaW5nIG9yIHJlY29ubmVjdGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJldHJ5aW5nLCBkZWR1cGxpY2F0aW9uIGlzIGFsd2F5cyBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWcub25FcnJvclJldHJ5KGVyciwga2V5LCBjdXJyZW50Q29uZmlnLCAoX29wdHMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdG9ycyA9IEVWRU5UX1JFVkFMSURBVE9SU1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV2YWxpZGF0b3JzICYmIHJldmFsaWRhdG9yc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0b3JzWzBdKHJldmFsaWRhdGVFdmVudHMuRVJST1JfUkVWQUxJREFURV9FVkVOVCwgX29wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUNvdW50OiAob3B0cy5yZXRyeUNvdW50IHx8IDApICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdXBlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFyayBsb2FkaW5nIGFzIHN0b3BwZWQuXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGhvb2sncyBzdGF0ZS5cbiAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIC8vIGBzZXRTdGF0ZWAgaXMgaW1tdXRhYmxlLCBhbmQgYGV2ZW50c0NhbGxiYWNrYCwgYGZuQXJnYCwgYW5kXG4gICAgLy8gYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxuICAgIC8vIHRoZSBkZXBzIGFycmF5LlxuICAgIC8vXG4gICAgLy8gRklYTUU6XG4gICAgLy8gYGZuYCBhbmQgYGNvbmZpZ2AgbWlnaHQgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIGxpZmVjeWNsZSxcbiAgICAvLyBidXQgdGhleSBtaWdodCBiZSBjaGFuZ2VkIGV2ZXJ5IHJlbmRlciBsaWtlIHRoaXMuXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXG4gICAgLy8gU28gd2Ugb21pdCB0aGUgdmFsdWVzIGZyb20gdGhlIGRlcHMgYXJyYXlcbiAgICAvLyBldmVuIHRob3VnaCBpdCBtaWdodCBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW1xuICAgICAgICBrZXksXG4gICAgICAgIGNhY2hlXG4gICAgXSk7XG4gICAgLy8gU2ltaWxhciB0byB0aGUgZ2xvYmFsIG11dGF0ZSBidXQgYm91bmQgdG8gdGhlIGN1cnJlbnQgY2FjaGUgYW5kIGtleS5cbiAgICAvLyBgY2FjaGVgIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlLlxuICAgIGNvbnN0IGJvdW5kTXV0YXRlID0gdXNlQ2FsbGJhY2soLy8gVXNlIGNhbGxiYWNrIHRvIG1ha2Ugc3VyZSBga2V5UmVmLmN1cnJlbnRgIHJldHVybnMgbGF0ZXN0IHJlc3VsdCBldmVyeSB0aW1lXG4gICAgKC4uLmFyZ3MpPT57XG4gICAgICAgIHJldHVybiBpbnRlcm5hbE11dGF0ZShjYWNoZSwga2V5UmVmLmN1cnJlbnQsIC4uLmFyZ3MpO1xuICAgIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXSk7XG4gICAgLy8gVGhlIGxvZ2ljIGZvciB1cGRhdGluZyByZWZzLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgZmV0Y2hlclJlZi5jdXJyZW50ID0gZmV0Y2hlcjtcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XG4gICAgICAgIC8vIEhhbmRsZSBsYWdneSBkYXRhIHVwZGF0ZXMuIElmIHRoZXJlJ3MgY2FjaGVkIGRhdGEgb2YgdGhlIGN1cnJlbnQga2V5LFxuICAgICAgICAvLyBpdCdsbCBiZSB0aGUgY29ycmVjdCByZWZlcmVuY2UuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoY2FjaGVkRGF0YSkpIHtcbiAgICAgICAgICAgIGxhZ2d5RGF0YVJlZi5jdXJyZW50ID0gY2FjaGVkRGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFmdGVyIG1vdW50ZWQgb3Iga2V5IGNoYW5nZWQuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoIWtleSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBzb2Z0UmV2YWxpZGF0ZSA9IHJldmFsaWRhdGUuYmluZChVTkRFRklORUQsIFdJVEhfREVEVVBFKTtcbiAgICAgICAgLy8gRXhwb3NlIHJldmFsaWRhdG9ycyB0byBnbG9iYWwgZXZlbnQgbGlzdGVuZXJzLiBTbyB3ZSBjYW4gdHJpZ2dlclxuICAgICAgICAvLyByZXZhbGlkYXRpb24gZnJvbSB0aGUgb3V0c2lkZS5cbiAgICAgICAgbGV0IG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSAwO1xuICAgICAgICBjb25zdCBvblJldmFsaWRhdGUgPSAodHlwZSwgb3B0cyA9IHt9KT0+e1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gcmV2YWxpZGF0ZUV2ZW50cy5GT0NVU19FVkVOVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLnJldmFsaWRhdGVPbkZvY3VzICYmIG5vdyA+IG5leHRGb2N1c1JldmFsaWRhdGVkQXQgJiYgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ID0gbm93ICsgZ2V0Q29uZmlnKCkuZm9jdXNUaHJvdHRsZUludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSByZXZhbGlkYXRlRXZlbnRzLlJFQ09OTkVDVF9FVkVOVCkge1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgJiYgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSByZXZhbGlkYXRlRXZlbnRzLk1VVEFURV9FVkVOVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gcmV2YWxpZGF0ZUV2ZW50cy5FUlJPUl9SRVZBTElEQVRFX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUob3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVuc3ViRXZlbnRzID0gc3Vic2NyaWJlQ2FsbGJhY2soa2V5LCBFVkVOVF9SRVZBTElEQVRPUlMsIG9uUmV2YWxpZGF0ZSk7XG4gICAgICAgIC8vIE1hcmsgdGhlIGNvbXBvbmVudCBhcyBtb3VudGVkIGFuZCB1cGRhdGUgY29ycmVzcG9uZGluZyByZWZzLlxuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBrZXlSZWYuY3VycmVudCA9IGtleTtcbiAgICAgICAgaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIGtleSBpbiB0aGUgY2FjaGUuXG4gICAgICAgIHNldENhY2hlKHtcbiAgICAgICAgICAgIF9rOiBmbkFyZ1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHJpZ2dlciBhIHJldmFsaWRhdGlvblxuICAgICAgICBpZiAoc2hvdWxkRG9Jbml0aWFsUmV2YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZGF0YSkgfHwgSVNfU0VSVkVSKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV2YWxpZGF0ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEZWxheSB0aGUgcmV2YWxpZGF0ZSBpZiB3ZSBoYXZlIGRhdGEgdG8gcmV0dXJuIHNvIHdlIHdvbid0IGJsb2NrXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nLlxuICAgICAgICAgICAgICAgIHJBRihzb2Z0UmV2YWxpZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAvLyBNYXJrIGl0IGFzIHVubW91bnRlZC5cbiAgICAgICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVuc3ViRXZlbnRzKCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBrZXlcbiAgICBdKTtcbiAgICAvLyBQb2xsaW5nXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBsZXQgdGltZXI7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHBhc3NlZCBpbnRlcnZhbFxuICAgICAgICAgICAgLy8gLi4ub3IgaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSB1cGRhdGVkIGRhdGEgdG8gZ2V0IHRoZSBpbnRlcnZhbFxuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBpc0Z1bmN0aW9uKHJlZnJlc2hJbnRlcnZhbCkgPyByZWZyZXNoSW50ZXJ2YWwoZ2V0Q2FjaGUoKS5kYXRhKSA6IHJlZnJlc2hJbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgc3RhcnQgdGhlIG5leHQgaW50ZXJ2YWwgaWYgYHJlZnJlc2hJbnRlcnZhbGAgaXMgbm90IDAsIGFuZDpcbiAgICAgICAgICAgIC8vIC0gYGZvcmNlYCBpcyB0cnVlLCB3aGljaCBpcyB0aGUgc3RhcnQgb2YgcG9sbGluZ1xuICAgICAgICAgICAgLy8gLSBvciBgdGltZXJgIGlzIG5vdCAwLCB3aGljaCBtZWFucyB0aGUgZWZmZWN0IHdhc24ndCBjYW5jZWxlZFxuICAgICAgICAgICAgaWYgKGludGVydmFsICYmIHRpbWVyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChleGVjdXRlLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgT0sgdG8gZXhlY3V0ZTpcbiAgICAgICAgICAgIC8vIE9ubHkgcmV2YWxpZGF0ZSB3aGVuIHRoZSBwYWdlIGlzIHZpc2libGUsIG9ubGluZSwgYW5kIG5vdCBlcnJvcmVkLlxuICAgICAgICAgICAgaWYgKCFnZXRDYWNoZSgpLmVycm9yICYmIChyZWZyZXNoV2hlbkhpZGRlbiB8fCBnZXRDb25maWcoKS5pc1Zpc2libGUoKSkgJiYgKHJlZnJlc2hXaGVuT2ZmbGluZSB8fCBnZXRDb25maWcoKS5pc09ubGluZSgpKSkge1xuICAgICAgICAgICAgICAgIHJldmFsaWRhdGUoV0lUSF9ERURVUEUpLnRoZW4obmV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBuZXh0IGludGVydmFsIHRvIGNoZWNrIGFnYWluLlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcmVmcmVzaEludGVydmFsLFxuICAgICAgICByZWZyZXNoV2hlbkhpZGRlbixcbiAgICAgICAgcmVmcmVzaFdoZW5PZmZsaW5lLFxuICAgICAgICBrZXlcbiAgICBdKTtcbiAgICAvLyBEaXNwbGF5IGRlYnVnIGluZm8gaW4gUmVhY3QgRGV2VG9vbHMuXG4gICAgdXNlRGVidWdWYWx1ZShyZXR1cm5lZERhdGEpO1xuICAgIC8vIEluIFN1c3BlbnNlIG1vZGUsIHdlIGNhbid0IHJldHVybiB0aGUgZW1wdHkgYGRhdGFgIHN0YXRlLlxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGBlcnJvcmAsIHRoZSBgZXJyb3JgIG5lZWRzIHRvIGJlIHRocm93biB0byB0aGUgZXJyb3IgYm91bmRhcnkuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYGVycm9yYCwgdGhlIGByZXZhbGlkYXRpb25gIHByb21pc2UgbmVlZHMgdG8gYmUgdGhyb3duIHRvXG4gICAgLy8gdGhlIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgIGlmIChzdXNwZW5zZSAmJiBpc1VuZGVmaW5lZChkYXRhKSAmJiBrZXkpIHtcbiAgICAgICAgLy8gU1dSIHNob3VsZCB0aHJvdyB3aGVuIHRyeWluZyB0byB1c2UgU3VzcGVuc2Ugb24gdGhlIHNlcnZlciB3aXRoIFJlYWN0IDE4LFxuICAgICAgICAvLyB3aXRob3V0IHByb3ZpZGluZyBhbnkgaW5pdGlhbCBkYXRhLiBTZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvc3dyL2lzc3Vlcy8xODMyXG4gICAgICAgIGlmICghSVNfUkVBQ1RfTEVHQUNZICYmIElTX1NFUlZFUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWxsYmFjayBkYXRhIGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgc3VzcGVuc2UgaW4gU1NSLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMgZXZlbiB3aXRoIHRoZSBTdXNwZW5zZSBtb2RlLlxuICAgICAgICBmZXRjaGVyUmVmLmN1cnJlbnQgPSBmZXRjaGVyO1xuICAgICAgICBjb25maWdSZWYuY3VycmVudCA9IGNvbmZpZztcbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVxID0gUFJFTE9BRFtrZXldO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHJlcSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBib3VuZE11dGF0ZShyZXEpO1xuICAgICAgICAgICAgdXNlKHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChlcnJvcikpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSByZXZhbGlkYXRlKFdJVEhfREVEVVBFKTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQocmV0dXJuZWREYXRhKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2UocHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtdXRhdGU6IGJvdW5kTXV0YXRlLFxuICAgICAgICBnZXQgZGF0YSAoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5kYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5lZERhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBlcnJvciAoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5lcnJvciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc1ZhbGlkYXRpbmcgKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNWYWxpZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkYXRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc0xvYWRpbmcgKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpc0xvYWRpbmc7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbk9CSkVDVC5kZWZpbmVQcm9wZXJ0eShTV1JDb25maWcsICdkZWZhdWx0VmFsdWUnLCB7XG4gICAgdmFsdWU6IGRlZmF1bHRDb25maWdcbn0pO1xuLyoqXG4gKiBBIGhvb2sgdG8gZmV0Y2ggZGF0YS5cbiAqXG4gKiBAbGluayBodHRwczovL3N3ci52ZXJjZWwuYXBwXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgdXNlU1dSIGZyb20gJ3N3cidcbiAqIGZ1bmN0aW9uIFByb2ZpbGUoKSB7XG4gKiAgIGNvbnN0IHsgZGF0YSwgZXJyb3IsIGlzTG9hZGluZyB9ID0gdXNlU1dSKCcvYXBpL3VzZXInLCBmZXRjaGVyKVxuICogICBpZiAoZXJyb3IpIHJldHVybiA8ZGl2PmZhaWxlZCB0byBsb2FkPC9kaXY+XG4gKiAgIGlmIChpc0xvYWRpbmcpIHJldHVybiA8ZGl2PmxvYWRpbmcuLi48L2Rpdj5cbiAqICAgcmV0dXJuIDxkaXY+aGVsbG8ge2RhdGEubmFtZX0hPC9kaXY+XG4gKiB9XG4gKiBgYGBcbiAqLyBjb25zdCB1c2VTV1IgPSB3aXRoQXJncyh1c2VTV1JIYW5kbGVyKTtcblxuY29uc3QgZ2V0Rmlyc3RQYWdlS2V5ID0gKGdldEtleSk9PntcbiAgICByZXR1cm4gc2VyaWFsaXplKGdldEtleSA/IGdldEtleSgwLCBudWxsKSA6IG51bGwpWzBdO1xufTtcbmNvbnN0IHVuc3RhYmxlX3NlcmlhbGl6ZSA9IChnZXRLZXkpPT57XG4gICAgcmV0dXJuIElORklOSVRFX1BSRUZJWCArIGdldEZpcnN0UGFnZUtleShnZXRLZXkpO1xufTtcblxuLy8gV2UgaGF2ZSB0byBzZXZlcmFsIHR5cGUgY2FzdGluZ3MgaGVyZSBiZWNhdXNlIGB1c2VTV1JJbmZpbml0ZWAgaXMgYSBzcGVjaWFsXG4vLyBob29rIHdoZXJlIGBrZXlgIGFuZCByZXR1cm4gdHlwZSBhcmUgbm90IGxpa2UgdGhlIG5vcm1hbCBgdXNlU1dSYCB0eXBlcy5cbi8vIGNvbnN0IElORklOSVRFX1BSRUZJWCA9ICckaW5mJCdcbmNvbnN0IEVNUFRZX1BST01JU0UgPSBQcm9taXNlLnJlc29sdmUoKTtcbi8vIGV4cG9ydCBjb25zdCB1bnN0YWJsZV9zZXJpYWxpemUgPSAoZ2V0S2V5OiBTV1JJbmZpbml0ZUtleUxvYWRlcikgPT4ge1xuLy8gICByZXR1cm4gSU5GSU5JVEVfUFJFRklYICsgZ2V0Rmlyc3RQYWdlS2V5KGdldEtleSlcbi8vIH1cbmNvbnN0IGluZmluaXRlID0gKHVzZVNXUk5leHQpPT4oZ2V0S2V5LCBmbiwgY29uZmlnKT0+e1xuICAgICAgICBjb25zdCBkaWRNb3VudFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgICAgIGNvbnN0IHsgY2FjaGU6IGNhY2hlJDEsIGluaXRpYWxTaXplID0gMSwgcmV2YWxpZGF0ZUFsbCA9IGZhbHNlLCBwZXJzaXN0U2l6ZSA9IGZhbHNlLCByZXZhbGlkYXRlRmlyc3RQYWdlID0gdHJ1ZSwgcmV2YWxpZGF0ZU9uTW91bnQgPSBmYWxzZSwgcGFyYWxsZWwgPSBmYWxzZSB9ID0gY29uZmlnO1xuICAgICAgICBjb25zdCBbLCAsICwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgICAgICAvLyBUaGUgc2VyaWFsaXplZCBrZXkgb2YgdGhlIGZpcnN0IHBhZ2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byBzdG9yZVxuICAgICAgICAvLyBtZXRhZGF0YSBvZiB0aGlzIFNXUiBpbmZpbml0ZSBob29rLlxuICAgICAgICBsZXQgaW5maW5pdGVLZXk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbmZpbml0ZUtleSA9IGdldEZpcnN0UGFnZUtleShnZXRLZXkpO1xuICAgICAgICAgICAgaWYgKGluZmluaXRlS2V5KSBpbmZpbml0ZUtleSA9IElORklOSVRFX1BSRUZJWCArIGluZmluaXRlS2V5O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gTm90IHJlYWR5IHlldC5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbZ2V0LCBzZXQsIHN1YnNjcmliZUNhY2hlXSA9IGNyZWF0ZUNhY2hlSGVscGVyKGNhY2hlJDEsIGluZmluaXRlS2V5KTtcbiAgICAgICAgY29uc3QgZ2V0U25hcHNob3QgPSB1c2VDYWxsYmFjaygoKT0+e1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGlzVW5kZWZpbmVkKGdldCgpLl9sKSA/IGluaXRpYWxTaXplIDogZ2V0KCkuX2w7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICB9LCBbXG4gICAgICAgICAgICBjYWNoZSQxLFxuICAgICAgICAgICAgaW5maW5pdGVLZXksXG4gICAgICAgICAgICBpbml0aWFsU2l6ZVxuICAgICAgICBdKTtcbiAgICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmUodXNlQ2FsbGJhY2soKGNhbGxiYWNrKT0+e1xuICAgICAgICAgICAgaWYgKGluZmluaXRlS2V5KSByZXR1cm4gc3Vic2NyaWJlQ2FjaGUoaW5maW5pdGVLZXksICgpPT57XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57fTtcbiAgICAgICAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICBbXG4gICAgICAgICAgICBjYWNoZSQxLFxuICAgICAgICAgICAgaW5maW5pdGVLZXlcbiAgICAgICAgXSksIGdldFNuYXBzaG90LCBnZXRTbmFwc2hvdCk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVQYWdlU2l6ZSA9IHVzZUNhbGxiYWNrKCgpPT57XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRQYWdlU2l6ZSA9IGdldCgpLl9sO1xuICAgICAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGNhY2hlZFBhZ2VTaXplKSA/IGluaXRpYWxTaXplIDogY2FjaGVkUGFnZVNpemU7XG4gICAgICAgIC8vIGBjYWNoZWAgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICB9LCBbXG4gICAgICAgICAgICBpbmZpbml0ZUtleSxcbiAgICAgICAgICAgIGluaXRpYWxTaXplXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBrZWVwIHRoZSBsYXN0IHBhZ2Ugc2l6ZSB0byByZXN0b3JlIGl0IHdpdGggdGhlIHBlcnNpc3RTaXplIG9wdGlvblxuICAgICAgICBjb25zdCBsYXN0UGFnZVNpemVSZWYgPSB1c2VSZWYocmVzb2x2ZVBhZ2VTaXplKCkpO1xuICAgICAgICAvLyBXaGVuIHRoZSBwYWdlIGtleSBjaGFuZ2VzLCB3ZSByZXNldCB0aGUgcGFnZSBzaXplIGlmIGl0J3Mgbm90IHBlcnNpc3RlZFxuICAgICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgICAgICBpZiAoIWRpZE1vdW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBkaWRNb3VudFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5maW5pdGVLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUga2V5IGhhcyBiZWVuIGNoYW5nZWQsIHdlIGtlZXAgdGhlIGN1cnJlbnQgcGFnZSBzaXplIGlmIHBlcnNpc3RTaXplIGlzIGVuYWJsZWRcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHJlc2V0IHRoZSBwYWdlIHNpemUgdG8gY2FjaGVkIHBhZ2VTaXplXG4gICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgX2w6IHBlcnNpc3RTaXplID8gbGFzdFBhZ2VTaXplUmVmLmN1cnJlbnQgOiByZXNvbHZlUGFnZVNpemUoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyBgaW5pdGlhbFNpemVgIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgaW5maW5pdGVLZXksXG4gICAgICAgICAgICBjYWNoZSQxXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBOZWVkcyB0byBjaGVjayBkaWRNb3VudFJlZiBkdXJpbmcgbW91bnRpbmcsIG5vdCBpbiB0aGUgZmV0Y2hlclxuICAgICAgICBjb25zdCBzaG91bGRSZXZhbGlkYXRlT25Nb3VudCA9IHJldmFsaWRhdGVPbk1vdW50ICYmICFkaWRNb3VudFJlZi5jdXJyZW50O1xuICAgICAgICAvLyBBY3R1YWwgU1dSIGhvb2sgdG8gbG9hZCBhbGwgcGFnZXMgaW4gb25lIGZldGNoZXIuXG4gICAgICAgIGNvbnN0IHN3ciA9IHVzZVNXUk5leHQoaW5maW5pdGVLZXksIGFzeW5jIChrZXkpPT57XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHJldmFsaWRhdGUgY29udGV4dFxuICAgICAgICAgICAgY29uc3QgZm9yY2VSZXZhbGlkYXRlQWxsID0gZ2V0KCkuX2k7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZXZhbGlkYXRlUGFnZSA9IGdldCgpLl9yO1xuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICBfcjogVU5ERUZJTkVEXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJldHVybiBhbiBhcnJheSBvZiBwYWdlIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VTaXplID0gcmVzb2x2ZVBhZ2VTaXplKCk7XG4gICAgICAgICAgICBjb25zdCBbZ2V0Q2FjaGVdID0gY3JlYXRlQ2FjaGVIZWxwZXIoY2FjaGUkMSwga2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRGF0YSA9IGdldENhY2hlKCkuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdG9ycyA9IFtdO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzUGFnZURhdGEgPSBudWxsO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhZ2VTaXplOyArK2kpe1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwYWdlS2V5LCBwYWdlQXJnXSA9IHNlcmlhbGl6ZShnZXRLZXkoaSwgcGFyYWxsZWwgPyBudWxsIDogcHJldmlvdXNQYWdlRGF0YSkpO1xuICAgICAgICAgICAgICAgIGlmICghcGFnZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW2dldFNXUkNhY2hlLCBzZXRTV1JDYWNoZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSQxLCBwYWdlS2V5KTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNhY2hlZCBwYWdlIGRhdGEuXG4gICAgICAgICAgICAgICAgbGV0IHBhZ2VEYXRhID0gZ2V0U1dSQ2FjaGUoKS5kYXRhO1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBmZXRjaCAob3IgcmV2YWxpZGF0ZSkgaWY6XG4gICAgICAgICAgICAgICAgLy8gLSBgcmV2YWxpZGF0ZUFsbGAgaXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgIC8vIC0gYG11dGF0ZSgpYCBjYWxsZWRcbiAgICAgICAgICAgICAgICAvLyAtIHRoZSBjYWNoZSBpcyBtaXNzaW5nXG4gICAgICAgICAgICAgICAgLy8gLSBpdCdzIHRoZSBmaXJzdCBwYWdlIGFuZCBpdCdzIG5vdCB0aGUgaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICAgICAgICAvLyAtIGByZXZhbGlkYXRlT25Nb3VudGAgaXMgZW5hYmxlZCBhbmQgaXQncyBvbiBtb3VudFxuICAgICAgICAgICAgICAgIC8vIC0gY2FjaGUgZm9yIHRoYXQgcGFnZSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEZldGNoUGFnZSA9IHJldmFsaWRhdGVBbGwgfHwgZm9yY2VSZXZhbGlkYXRlQWxsIHx8IGlzVW5kZWZpbmVkKHBhZ2VEYXRhKSB8fCByZXZhbGlkYXRlRmlyc3RQYWdlICYmICFpICYmICFpc1VuZGVmaW5lZChjYWNoZURhdGEpIHx8IHNob3VsZFJldmFsaWRhdGVPbk1vdW50IHx8IGNhY2hlRGF0YSAmJiAhaXNVbmRlZmluZWQoY2FjaGVEYXRhW2ldKSAmJiAhY29uZmlnLmNvbXBhcmUoY2FjaGVEYXRhW2ldLCBwYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGZuICYmICh0eXBlb2Ygc2hvdWxkUmV2YWxpZGF0ZVBhZ2UgPT09ICdmdW5jdGlvbicgPyBzaG91bGRSZXZhbGlkYXRlUGFnZShwYWdlRGF0YSwgcGFnZUFyZykgOiBzaG91bGRGZXRjaFBhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdGUgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzUHJlbG9hZGVkUmVxdWVzdCA9IHBhZ2VLZXkgaW4gUFJFTE9BRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzUHJlbG9hZGVkUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VEYXRhID0gYXdhaXQgZm4ocGFnZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IFBSRUxPQURbcGFnZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBwcmVsb2FkIGNhY2hlIGtleSBiZWZvcmUgcmVzb2x2aW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIFBSRUxPQURbcGFnZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBwYWdlIGRhdGEgZnJvbSB0aGUgcHJlbG9hZCBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VEYXRhID0gYXdhaXQgcmVxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U1dSQ2FjaGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhZ2VEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9rOiBwYWdlQXJnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBwYWdlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFsbGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRvcnMucHVzaChyZXZhbGlkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBwYWdlRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbGxlbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BhZ2VEYXRhID0gcGFnZURhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmx1c2ggYWxsIHJldmFsaWRhdGVpb25zIGluIHBhcmFsbGVsXG4gICAgICAgICAgICBpZiAocGFyYWxsZWwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXZhbGlkYXRvcnMubWFwKChyKT0+cigpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvbmNlIHdlIGV4ZWN1dGVkIHRoZSBkYXRhIGZldGNoaW5nIGJhc2VkIG9uIHRoZSBjb250ZXh0LCBjbGVhciB0aGUgY29udGV4dFxuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICBfaTogVU5ERUZJTkVEXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZGF0YVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG11dGF0ZSA9IHVzZUNhbGxiYWNrKC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICAgIGZ1bmN0aW9uKGRhdGEsIG9wdHMpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBhcyBhIGJvb2xlYW4sIGl0J3MgZXhwbGljaXRseSB1c2VkIHRvIGRpc2FibGUvZW5hYmxlXG4gICAgICAgICAgICAvLyByZXZhbGlkYXRpb24uXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdHMgPT09ICdib29sZWFuJyA/IHtcbiAgICAgICAgICAgICAgICByZXZhbGlkYXRlOiBvcHRzXG4gICAgICAgICAgICB9IDogb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdHJ1ZS5cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFJldmFsaWRhdGUgPSBvcHRpb25zLnJldmFsaWRhdGUgIT09IGZhbHNlO1xuICAgICAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGUga2V5IGlzIHN0aWxsIGZhbHN5LlxuICAgICAgICAgICAgaWYgKCFpbmZpbml0ZUtleSkgcmV0dXJuIEVNUFRZX1BST01JU0U7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSByZXZhbGlkYXRlIHRoZSBwYWdlcyB0aGF0IGFyZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBfcjogb3B0aW9ucy5yZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGxpbmcgYG11dGF0ZSgpYCwgd2UgcmV2YWxpZGF0ZSBhbGwgcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3I6IG9wdGlvbnMucmV2YWxpZGF0ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHN3ci5tdXRhdGUoZGF0YSwge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZTogc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICAgICAgfSkgOiBzd3IubXV0YXRlKCk7XG4gICAgICAgIH0sIC8vIHN3ci5tdXRhdGUgaXMgYWx3YXlzIHRoZSBzYW1lIHJlZmVyZW5jZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIFtcbiAgICAgICAgICAgIGluZmluaXRlS2V5LFxuICAgICAgICAgICAgY2FjaGUkMVxuICAgICAgICBdKTtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBTV1IgQVBJXG4gICAgICAgIGNvbnN0IHNldFNpemUgPSB1c2VDYWxsYmFjaygoYXJnKT0+e1xuICAgICAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGUga2V5IGlzIHN0aWxsIGZhbHN5LlxuICAgICAgICAgICAgaWYgKCFpbmZpbml0ZUtleSkgcmV0dXJuIEVNUFRZX1BST01JU0U7XG4gICAgICAgICAgICBjb25zdCBbLCBjaGFuZ2VTaXplXSA9IGNyZWF0ZUNhY2hlSGVscGVyKGNhY2hlJDEsIGluZmluaXRlS2V5KTtcbiAgICAgICAgICAgIGxldCBzaXplO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBhcmcocmVzb2x2ZVBhZ2VTaXplKCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPSAnbnVtYmVyJykgcmV0dXJuIEVNUFRZX1BST01JU0U7XG4gICAgICAgICAgICBjaGFuZ2VTaXplKHtcbiAgICAgICAgICAgICAgICBfbDogc2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYXN0UGFnZVNpemVSZWYuY3VycmVudCA9IHNpemU7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBhZ2UgZGF0YSBhZnRlciB0aGUgc2l6ZSBjaGFuZ2UuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgICAgICBjb25zdCBbZ2V0SW5maW5pdGVDYWNoZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSQxLCBpbmZpbml0ZUtleSk7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNQYWdlRGF0YSA9IG51bGw7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2l6ZTsgKytpKXtcbiAgICAgICAgICAgICAgICBjb25zdCBbcGFnZUtleV0gPSBzZXJpYWxpemUoZ2V0S2V5KGksIHByZXZpb3VzUGFnZURhdGEpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbZ2V0Q2FjaGVdID0gY3JlYXRlQ2FjaGVIZWxwZXIoY2FjaGUkMSwgcGFnZUtleSk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjYWNoZWQgcGFnZSBkYXRhLlxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VEYXRhID0gcGFnZUtleSA/IGdldENhY2hlKCkuZGF0YSA6IFVOREVGSU5FRDtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIGBtdXRhdGVgIHdpdGggaW5maW50ZSBjYWNoZSBkYXRhIGlmIHdlIGNhbid0IGdldCBpdCBmcm9tIHRoZSBwYWdlIGNhY2hlLlxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChwYWdlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG11dGF0ZShnZXRJbmZpbml0ZUNhY2hlKCkuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChwYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQYWdlRGF0YSA9IHBhZ2VEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG11dGF0ZShkYXRhKTtcbiAgICAgICAgfSwgLy8gZXhjbHVkZSBnZXRLZXkgZnJvbSB0aGUgZGVwZW5kZW5jaWVzLCB3aGljaCBpc24ndCBhbGxvd2VkIHRvIGNoYW5nZSBkdXJpbmcgdGhlIGxpZmVjeWNsZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIFtcbiAgICAgICAgICAgIGluZmluaXRlS2V5LFxuICAgICAgICAgICAgY2FjaGUkMSxcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIHJlc29sdmVQYWdlU2l6ZVxuICAgICAgICBdKTtcbiAgICAgICAgLy8gVXNlIGdldHRlciBmdW5jdGlvbnMgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmUtcmVuZGVycyBjYXVzZWQgYnkgdHJpZ2dlcmluZ1xuICAgICAgICAvLyBhbGwgdGhlIGdldHRlcnMgb2YgdGhlIHJldHVybmVkIHN3ciBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaXplOiByZXNvbHZlUGFnZVNpemUoKSxcbiAgICAgICAgICAgIHNldFNpemUsXG4gICAgICAgICAgICBtdXRhdGUsXG4gICAgICAgICAgICBnZXQgZGF0YSAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN3ci5kYXRhO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBlcnJvciAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN3ci5lcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaXNWYWxpZGF0aW5nICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3dyLmlzVmFsaWRhdGluZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaXNMb2FkaW5nICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3dyLmlzTG9hZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuY29uc3QgdXNlU1dSSW5maW5pdGUgPSB3aXRoTWlkZGxld2FyZSh1c2VTV1IsIGluZmluaXRlKTtcblxuZXhwb3J0IHsgdXNlU1dSSW5maW5pdGUgYXMgZGVmYXVsdCwgaW5maW5pdGUsIHVuc3RhYmxlX3NlcmlhbGl6ZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/infinite/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/tailwind-merge/dist/bundle-mjs.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTailwindMerge: function() { return /* binding */ createTailwindMerge; },\n/* harmony export */   extendTailwindMerge: function() { return /* binding */ extendTailwindMerge; },\n/* harmony export */   fromTheme: function() { return /* binding */ fromTheme; },\n/* harmony export */   getDefaultConfig: function() { return /* binding */ getDefaultConfig; },\n/* harmony export */   mergeConfigs: function() { return /* binding */ mergeConfigs; },\n/* harmony export */   twJoin: function() { return /* binding */ twJoin; },\n/* harmony export */   twMerge: function() { return /* binding */ twMerge; },\n/* harmony export */   validators: function() { return /* binding */ validators; }\n/* harmony export */ });\nconst CLASS_PART_SEPARATOR = '-';\nconst createClassGroupUtils = config => {\n  const classMap = createClassMap(config);\n  const {\n    conflictingClassGroups,\n    conflictingClassGroupModifiers\n  } = config;\n  const getClassGroupId = className => {\n    const classParts = className.split(CLASS_PART_SEPARATOR);\n    // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.\n    if (classParts[0] === '' && classParts.length !== 1) {\n      classParts.shift();\n    }\n    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);\n  };\n  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {\n    const conflicts = conflictingClassGroups[classGroupId] || [];\n    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {\n      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];\n    }\n    return conflicts;\n  };\n  return {\n    getClassGroupId,\n    getConflictingClassGroupIds\n  };\n};\nconst getGroupRecursive = (classParts, classPartObject) => {\n  if (classParts.length === 0) {\n    return classPartObject.classGroupId;\n  }\n  const currentClassPart = classParts[0];\n  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);\n  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;\n  if (classGroupFromNextClassPart) {\n    return classGroupFromNextClassPart;\n  }\n  if (classPartObject.validators.length === 0) {\n    return undefined;\n  }\n  const classRest = classParts.join(CLASS_PART_SEPARATOR);\n  return classPartObject.validators.find(({\n    validator\n  }) => validator(classRest))?.classGroupId;\n};\nconst arbitraryPropertyRegex = /^\\[(.+)\\]$/;\nconst getGroupIdForArbitraryProperty = className => {\n  if (arbitraryPropertyRegex.test(className)) {\n    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];\n    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));\n    if (property) {\n      // I use two dots here because one dot is used as prefix for class groups in plugins\n      return 'arbitrary..' + property;\n    }\n  }\n};\n/**\n * Exported for testing only\n */\nconst createClassMap = config => {\n  const {\n    theme,\n    prefix\n  } = config;\n  const classMap = {\n    nextPart: new Map(),\n    validators: []\n  };\n  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);\n  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {\n    processClassesRecursively(classGroup, classMap, classGroupId, theme);\n  });\n  return classMap;\n};\nconst processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {\n  classGroup.forEach(classDefinition => {\n    if (typeof classDefinition === 'string') {\n      const classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);\n      classPartObjectToEdit.classGroupId = classGroupId;\n      return;\n    }\n    if (typeof classDefinition === 'function') {\n      if (isThemeGetter(classDefinition)) {\n        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);\n        return;\n      }\n      classPartObject.validators.push({\n        validator: classDefinition,\n        classGroupId\n      });\n      return;\n    }\n    Object.entries(classDefinition).forEach(([key, classGroup]) => {\n      processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);\n    });\n  });\n};\nconst getPart = (classPartObject, path) => {\n  let currentClassPartObject = classPartObject;\n  path.split(CLASS_PART_SEPARATOR).forEach(pathPart => {\n    if (!currentClassPartObject.nextPart.has(pathPart)) {\n      currentClassPartObject.nextPart.set(pathPart, {\n        nextPart: new Map(),\n        validators: []\n      });\n    }\n    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);\n  });\n  return currentClassPartObject;\n};\nconst isThemeGetter = func => func.isThemeGetter;\nconst getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {\n  if (!prefix) {\n    return classGroupEntries;\n  }\n  return classGroupEntries.map(([classGroupId, classGroup]) => {\n    const prefixedClassGroup = classGroup.map(classDefinition => {\n      if (typeof classDefinition === 'string') {\n        return prefix + classDefinition;\n      }\n      if (typeof classDefinition === 'object') {\n        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));\n      }\n      return classDefinition;\n    });\n    return [classGroupId, prefixedClassGroup];\n  });\n};\n\n// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance\nconst createLruCache = maxCacheSize => {\n  if (maxCacheSize < 1) {\n    return {\n      get: () => undefined,\n      set: () => {}\n    };\n  }\n  let cacheSize = 0;\n  let cache = new Map();\n  let previousCache = new Map();\n  const update = (key, value) => {\n    cache.set(key, value);\n    cacheSize++;\n    if (cacheSize > maxCacheSize) {\n      cacheSize = 0;\n      previousCache = cache;\n      cache = new Map();\n    }\n  };\n  return {\n    get(key) {\n      let value = cache.get(key);\n      if (value !== undefined) {\n        return value;\n      }\n      if ((value = previousCache.get(key)) !== undefined) {\n        update(key, value);\n        return value;\n      }\n    },\n    set(key, value) {\n      if (cache.has(key)) {\n        cache.set(key, value);\n      } else {\n        update(key, value);\n      }\n    }\n  };\n};\nconst IMPORTANT_MODIFIER = '!';\nconst createParseClassName = config => {\n  const {\n    separator,\n    experimentalParseClassName\n  } = config;\n  const isSeparatorSingleCharacter = separator.length === 1;\n  const firstSeparatorCharacter = separator[0];\n  const separatorLength = separator.length;\n  // parseClassName inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n  const parseClassName = className => {\n    const modifiers = [];\n    let bracketDepth = 0;\n    let modifierStart = 0;\n    let postfixModifierPosition;\n    for (let index = 0; index < className.length; index++) {\n      let currentCharacter = className[index];\n      if (bracketDepth === 0) {\n        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {\n          modifiers.push(className.slice(modifierStart, index));\n          modifierStart = index + separatorLength;\n          continue;\n        }\n        if (currentCharacter === '/') {\n          postfixModifierPosition = index;\n          continue;\n        }\n      }\n      if (currentCharacter === '[') {\n        bracketDepth++;\n      } else if (currentCharacter === ']') {\n        bracketDepth--;\n      }\n    }\n    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);\n    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);\n    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;\n    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;\n    return {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    };\n  };\n  if (experimentalParseClassName) {\n    return className => experimentalParseClassName({\n      className,\n      parseClassName\n    });\n  }\n  return parseClassName;\n};\n/**\n * Sorts modifiers according to following schema:\n * - Predefined modifiers are sorted alphabetically\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\n */\nconst sortModifiers = modifiers => {\n  if (modifiers.length <= 1) {\n    return modifiers;\n  }\n  const sortedModifiers = [];\n  let unsortedModifiers = [];\n  modifiers.forEach(modifier => {\n    const isArbitraryVariant = modifier[0] === '[';\n    if (isArbitraryVariant) {\n      sortedModifiers.push(...unsortedModifiers.sort(), modifier);\n      unsortedModifiers = [];\n    } else {\n      unsortedModifiers.push(modifier);\n    }\n  });\n  sortedModifiers.push(...unsortedModifiers.sort());\n  return sortedModifiers;\n};\nconst createConfigUtils = config => ({\n  cache: createLruCache(config.cacheSize),\n  parseClassName: createParseClassName(config),\n  ...createClassGroupUtils(config)\n});\nconst SPLIT_CLASSES_REGEX = /\\s+/;\nconst mergeClassList = (classList, configUtils) => {\n  const {\n    parseClassName,\n    getClassGroupId,\n    getConflictingClassGroupIds\n  } = configUtils;\n  /**\n   * Set of classGroupIds in following format:\n   * `{importantModifier}{variantModifiers}{classGroupId}`\n   * @example 'float'\n   * @example 'hover:focus:bg-color'\n   * @example 'md:!pr'\n   */\n  const classGroupsInConflict = [];\n  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);\n  let result = '';\n  for (let index = classNames.length - 1; index >= 0; index -= 1) {\n    const originalClassName = classNames[index];\n    const {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    } = parseClassName(originalClassName);\n    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);\n    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);\n    if (!classGroupId) {\n      if (!hasPostfixModifier) {\n        // Not a Tailwind class\n        result = originalClassName + (result.length > 0 ? ' ' + result : result);\n        continue;\n      }\n      classGroupId = getClassGroupId(baseClassName);\n      if (!classGroupId) {\n        // Not a Tailwind class\n        result = originalClassName + (result.length > 0 ? ' ' + result : result);\n        continue;\n      }\n      hasPostfixModifier = false;\n    }\n    const variantModifier = sortModifiers(modifiers).join(':');\n    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;\n    const classId = modifierId + classGroupId;\n    if (classGroupsInConflict.includes(classId)) {\n      // Tailwind class omitted due to conflict\n      continue;\n    }\n    classGroupsInConflict.push(classId);\n    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);\n    for (let i = 0; i < conflictGroups.length; ++i) {\n      const group = conflictGroups[i];\n      classGroupsInConflict.push(modifierId + group);\n    }\n    // Tailwind class not in conflict\n    result = originalClassName + (result.length > 0 ? ' ' + result : result);\n  }\n  return result;\n};\n\n/**\n * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.\n *\n * Specifically:\n * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js\n * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts\n *\n * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)\n */\nfunction twJoin() {\n  let index = 0;\n  let argument;\n  let resolvedValue;\n  let string = '';\n  while (index < arguments.length) {\n    if (argument = arguments[index++]) {\n      if (resolvedValue = toValue(argument)) {\n        string && (string += ' ');\n        string += resolvedValue;\n      }\n    }\n  }\n  return string;\n}\nconst toValue = mix => {\n  if (typeof mix === 'string') {\n    return mix;\n  }\n  let resolvedValue;\n  let string = '';\n  for (let k = 0; k < mix.length; k++) {\n    if (mix[k]) {\n      if (resolvedValue = toValue(mix[k])) {\n        string && (string += ' ');\n        string += resolvedValue;\n      }\n    }\n  }\n  return string;\n};\nfunction createTailwindMerge(createConfigFirst, ...createConfigRest) {\n  let configUtils;\n  let cacheGet;\n  let cacheSet;\n  let functionToCall = initTailwindMerge;\n  function initTailwindMerge(classList) {\n    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());\n    configUtils = createConfigUtils(config);\n    cacheGet = configUtils.cache.get;\n    cacheSet = configUtils.cache.set;\n    functionToCall = tailwindMerge;\n    return tailwindMerge(classList);\n  }\n  function tailwindMerge(classList) {\n    const cachedResult = cacheGet(classList);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    const result = mergeClassList(classList, configUtils);\n    cacheSet(classList, result);\n    return result;\n  }\n  return function callTailwindMerge() {\n    return functionToCall(twJoin.apply(null, arguments));\n  };\n}\nconst fromTheme = key => {\n  const themeGetter = theme => theme[key] || [];\n  themeGetter.isThemeGetter = true;\n  return themeGetter;\n};\nconst arbitraryValueRegex = /^\\[(?:([a-z-]+):)?(.+)\\]$/i;\nconst fractionRegex = /^\\d+\\/\\d+$/;\nconst stringLengths = /*#__PURE__*/new Set(['px', 'full', 'screen']);\nconst tshirtUnitRegex = /^(\\d+(\\.\\d+)?)?(xs|sm|md|lg|xl)$/;\nconst lengthUnitRegex = /\\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\\b(calc|min|max|clamp)\\(.+\\)|^0$/;\nconst colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\\(.+\\)$/;\n// Shadow always begins with x and y offset separated by underscore optionally prepended by inset\nconst shadowRegex = /^(inset_)?-?((\\d+)?\\.?(\\d+)[a-z]+|0)_-?((\\d+)?\\.?(\\d+)[a-z]+|0)/;\nconst imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\\(.+\\)$/;\nconst isLength = value => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);\nconst isArbitraryLength = value => getIsArbitraryValue(value, 'length', isLengthOnly);\nconst isNumber = value => Boolean(value) && !Number.isNaN(Number(value));\nconst isArbitraryNumber = value => getIsArbitraryValue(value, 'number', isNumber);\nconst isInteger = value => Boolean(value) && Number.isInteger(Number(value));\nconst isPercent = value => value.endsWith('%') && isNumber(value.slice(0, -1));\nconst isArbitraryValue = value => arbitraryValueRegex.test(value);\nconst isTshirtSize = value => tshirtUnitRegex.test(value);\nconst sizeLabels = /*#__PURE__*/new Set(['length', 'size', 'percentage']);\nconst isArbitrarySize = value => getIsArbitraryValue(value, sizeLabels, isNever);\nconst isArbitraryPosition = value => getIsArbitraryValue(value, 'position', isNever);\nconst imageLabels = /*#__PURE__*/new Set(['image', 'url']);\nconst isArbitraryImage = value => getIsArbitraryValue(value, imageLabels, isImage);\nconst isArbitraryShadow = value => getIsArbitraryValue(value, '', isShadow);\nconst isAny = () => true;\nconst getIsArbitraryValue = (value, label, testValue) => {\n  const result = arbitraryValueRegex.exec(value);\n  if (result) {\n    if (result[1]) {\n      return typeof label === 'string' ? result[1] === label : label.has(result[1]);\n    }\n    return testValue(result[2]);\n  }\n  return false;\n};\nconst isLengthOnly = value =>\n// `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.\n// For example, `hsl(0 0% 0%)` would be classified as a length without this check.\n// I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.\nlengthUnitRegex.test(value) && !colorFunctionRegex.test(value);\nconst isNever = () => false;\nconst isShadow = value => shadowRegex.test(value);\nconst isImage = value => imageRegex.test(value);\nconst validators = /*#__PURE__*/Object.defineProperty({\n  __proto__: null,\n  isAny,\n  isArbitraryImage,\n  isArbitraryLength,\n  isArbitraryNumber,\n  isArbitraryPosition,\n  isArbitraryShadow,\n  isArbitrarySize,\n  isArbitraryValue,\n  isInteger,\n  isLength,\n  isNumber,\n  isPercent,\n  isTshirtSize\n}, Symbol.toStringTag, {\n  value: 'Module'\n});\nconst getDefaultConfig = () => {\n  const colors = fromTheme('colors');\n  const spacing = fromTheme('spacing');\n  const blur = fromTheme('blur');\n  const brightness = fromTheme('brightness');\n  const borderColor = fromTheme('borderColor');\n  const borderRadius = fromTheme('borderRadius');\n  const borderSpacing = fromTheme('borderSpacing');\n  const borderWidth = fromTheme('borderWidth');\n  const contrast = fromTheme('contrast');\n  const grayscale = fromTheme('grayscale');\n  const hueRotate = fromTheme('hueRotate');\n  const invert = fromTheme('invert');\n  const gap = fromTheme('gap');\n  const gradientColorStops = fromTheme('gradientColorStops');\n  const gradientColorStopPositions = fromTheme('gradientColorStopPositions');\n  const inset = fromTheme('inset');\n  const margin = fromTheme('margin');\n  const opacity = fromTheme('opacity');\n  const padding = fromTheme('padding');\n  const saturate = fromTheme('saturate');\n  const scale = fromTheme('scale');\n  const sepia = fromTheme('sepia');\n  const skew = fromTheme('skew');\n  const space = fromTheme('space');\n  const translate = fromTheme('translate');\n  const getOverscroll = () => ['auto', 'contain', 'none'];\n  const getOverflow = () => ['auto', 'hidden', 'clip', 'visible', 'scroll'];\n  const getSpacingWithAutoAndArbitrary = () => ['auto', isArbitraryValue, spacing];\n  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];\n  const getLengthWithEmptyAndArbitrary = () => ['', isLength, isArbitraryLength];\n  const getNumberWithAutoAndArbitrary = () => ['auto', isNumber, isArbitraryValue];\n  const getPositions = () => ['bottom', 'center', 'left', 'left-bottom', 'left-top', 'right', 'right-bottom', 'right-top', 'top'];\n  const getLineStyles = () => ['solid', 'dashed', 'dotted', 'double', 'none'];\n  const getBlendModes = () => ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'];\n  const getAlign = () => ['start', 'end', 'center', 'between', 'around', 'evenly', 'stretch'];\n  const getZeroAndEmpty = () => ['', '0', isArbitraryValue];\n  const getBreaks = () => ['auto', 'avoid', 'all', 'avoid-page', 'page', 'left', 'right', 'column'];\n  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];\n  return {\n    cacheSize: 500,\n    separator: ':',\n    theme: {\n      colors: [isAny],\n      spacing: [isLength, isArbitraryLength],\n      blur: ['none', '', isTshirtSize, isArbitraryValue],\n      brightness: getNumberAndArbitrary(),\n      borderColor: [colors],\n      borderRadius: ['none', '', 'full', isTshirtSize, isArbitraryValue],\n      borderSpacing: getSpacingWithArbitrary(),\n      borderWidth: getLengthWithEmptyAndArbitrary(),\n      contrast: getNumberAndArbitrary(),\n      grayscale: getZeroAndEmpty(),\n      hueRotate: getNumberAndArbitrary(),\n      invert: getZeroAndEmpty(),\n      gap: getSpacingWithArbitrary(),\n      gradientColorStops: [colors],\n      gradientColorStopPositions: [isPercent, isArbitraryLength],\n      inset: getSpacingWithAutoAndArbitrary(),\n      margin: getSpacingWithAutoAndArbitrary(),\n      opacity: getNumberAndArbitrary(),\n      padding: getSpacingWithArbitrary(),\n      saturate: getNumberAndArbitrary(),\n      scale: getNumberAndArbitrary(),\n      sepia: getZeroAndEmpty(),\n      skew: getNumberAndArbitrary(),\n      space: getSpacingWithArbitrary(),\n      translate: getSpacingWithArbitrary()\n    },\n    classGroups: {\n      // Layout\n      /**\n       * Aspect Ratio\n       * @see https://tailwindcss.com/docs/aspect-ratio\n       */\n      aspect: [{\n        aspect: ['auto', 'square', 'video', isArbitraryValue]\n      }],\n      /**\n       * Container\n       * @see https://tailwindcss.com/docs/container\n       */\n      container: ['container'],\n      /**\n       * Columns\n       * @see https://tailwindcss.com/docs/columns\n       */\n      columns: [{\n        columns: [isTshirtSize]\n      }],\n      /**\n       * Break After\n       * @see https://tailwindcss.com/docs/break-after\n       */\n      'break-after': [{\n        'break-after': getBreaks()\n      }],\n      /**\n       * Break Before\n       * @see https://tailwindcss.com/docs/break-before\n       */\n      'break-before': [{\n        'break-before': getBreaks()\n      }],\n      /**\n       * Break Inside\n       * @see https://tailwindcss.com/docs/break-inside\n       */\n      'break-inside': [{\n        'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column']\n      }],\n      /**\n       * Box Decoration Break\n       * @see https://tailwindcss.com/docs/box-decoration-break\n       */\n      'box-decoration': [{\n        'box-decoration': ['slice', 'clone']\n      }],\n      /**\n       * Box Sizing\n       * @see https://tailwindcss.com/docs/box-sizing\n       */\n      box: [{\n        box: ['border', 'content']\n      }],\n      /**\n       * Display\n       * @see https://tailwindcss.com/docs/display\n       */\n      display: ['block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'inline-table', 'table-caption', 'table-cell', 'table-column', 'table-column-group', 'table-footer-group', 'table-header-group', 'table-row-group', 'table-row', 'flow-root', 'grid', 'inline-grid', 'contents', 'list-item', 'hidden'],\n      /**\n       * Floats\n       * @see https://tailwindcss.com/docs/float\n       */\n      float: [{\n        float: ['right', 'left', 'none', 'start', 'end']\n      }],\n      /**\n       * Clear\n       * @see https://tailwindcss.com/docs/clear\n       */\n      clear: [{\n        clear: ['left', 'right', 'both', 'none', 'start', 'end']\n      }],\n      /**\n       * Isolation\n       * @see https://tailwindcss.com/docs/isolation\n       */\n      isolation: ['isolate', 'isolation-auto'],\n      /**\n       * Object Fit\n       * @see https://tailwindcss.com/docs/object-fit\n       */\n      'object-fit': [{\n        object: ['contain', 'cover', 'fill', 'none', 'scale-down']\n      }],\n      /**\n       * Object Position\n       * @see https://tailwindcss.com/docs/object-position\n       */\n      'object-position': [{\n        object: [...getPositions(), isArbitraryValue]\n      }],\n      /**\n       * Overflow\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      overflow: [{\n        overflow: getOverflow()\n      }],\n      /**\n       * Overflow X\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      'overflow-x': [{\n        'overflow-x': getOverflow()\n      }],\n      /**\n       * Overflow Y\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      'overflow-y': [{\n        'overflow-y': getOverflow()\n      }],\n      /**\n       * Overscroll Behavior\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      overscroll: [{\n        overscroll: getOverscroll()\n      }],\n      /**\n       * Overscroll Behavior X\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      'overscroll-x': [{\n        'overscroll-x': getOverscroll()\n      }],\n      /**\n       * Overscroll Behavior Y\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      'overscroll-y': [{\n        'overscroll-y': getOverscroll()\n      }],\n      /**\n       * Position\n       * @see https://tailwindcss.com/docs/position\n       */\n      position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],\n      /**\n       * Top / Right / Bottom / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      inset: [{\n        inset: [inset]\n      }],\n      /**\n       * Right / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      'inset-x': [{\n        'inset-x': [inset]\n      }],\n      /**\n       * Top / Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      'inset-y': [{\n        'inset-y': [inset]\n      }],\n      /**\n       * Start\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      start: [{\n        start: [inset]\n      }],\n      /**\n       * End\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      end: [{\n        end: [inset]\n      }],\n      /**\n       * Top\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      top: [{\n        top: [inset]\n      }],\n      /**\n       * Right\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      right: [{\n        right: [inset]\n      }],\n      /**\n       * Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      bottom: [{\n        bottom: [inset]\n      }],\n      /**\n       * Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      left: [{\n        left: [inset]\n      }],\n      /**\n       * Visibility\n       * @see https://tailwindcss.com/docs/visibility\n       */\n      visibility: ['visible', 'invisible', 'collapse'],\n      /**\n       * Z-Index\n       * @see https://tailwindcss.com/docs/z-index\n       */\n      z: [{\n        z: ['auto', isInteger, isArbitraryValue]\n      }],\n      // Flexbox and Grid\n      /**\n       * Flex Basis\n       * @see https://tailwindcss.com/docs/flex-basis\n       */\n      basis: [{\n        basis: getSpacingWithAutoAndArbitrary()\n      }],\n      /**\n       * Flex Direction\n       * @see https://tailwindcss.com/docs/flex-direction\n       */\n      'flex-direction': [{\n        flex: ['row', 'row-reverse', 'col', 'col-reverse']\n      }],\n      /**\n       * Flex Wrap\n       * @see https://tailwindcss.com/docs/flex-wrap\n       */\n      'flex-wrap': [{\n        flex: ['wrap', 'wrap-reverse', 'nowrap']\n      }],\n      /**\n       * Flex\n       * @see https://tailwindcss.com/docs/flex\n       */\n      flex: [{\n        flex: ['1', 'auto', 'initial', 'none', isArbitraryValue]\n      }],\n      /**\n       * Flex Grow\n       * @see https://tailwindcss.com/docs/flex-grow\n       */\n      grow: [{\n        grow: getZeroAndEmpty()\n      }],\n      /**\n       * Flex Shrink\n       * @see https://tailwindcss.com/docs/flex-shrink\n       */\n      shrink: [{\n        shrink: getZeroAndEmpty()\n      }],\n      /**\n       * Order\n       * @see https://tailwindcss.com/docs/order\n       */\n      order: [{\n        order: ['first', 'last', 'none', isInteger, isArbitraryValue]\n      }],\n      /**\n       * Grid Template Columns\n       * @see https://tailwindcss.com/docs/grid-template-columns\n       */\n      'grid-cols': [{\n        'grid-cols': [isAny]\n      }],\n      /**\n       * Grid Column Start / End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-start-end': [{\n        col: ['auto', {\n          span: ['full', isInteger, isArbitraryValue]\n        }, isArbitraryValue]\n      }],\n      /**\n       * Grid Column Start\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-start': [{\n        'col-start': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Column End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-end': [{\n        'col-end': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Template Rows\n       * @see https://tailwindcss.com/docs/grid-template-rows\n       */\n      'grid-rows': [{\n        'grid-rows': [isAny]\n      }],\n      /**\n       * Grid Row Start / End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-start-end': [{\n        row: ['auto', {\n          span: [isInteger, isArbitraryValue]\n        }, isArbitraryValue]\n      }],\n      /**\n       * Grid Row Start\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-start': [{\n        'row-start': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Row End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-end': [{\n        'row-end': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Auto Flow\n       * @see https://tailwindcss.com/docs/grid-auto-flow\n       */\n      'grid-flow': [{\n        'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense']\n      }],\n      /**\n       * Grid Auto Columns\n       * @see https://tailwindcss.com/docs/grid-auto-columns\n       */\n      'auto-cols': [{\n        'auto-cols': ['auto', 'min', 'max', 'fr', isArbitraryValue]\n      }],\n      /**\n       * Grid Auto Rows\n       * @see https://tailwindcss.com/docs/grid-auto-rows\n       */\n      'auto-rows': [{\n        'auto-rows': ['auto', 'min', 'max', 'fr', isArbitraryValue]\n      }],\n      /**\n       * Gap\n       * @see https://tailwindcss.com/docs/gap\n       */\n      gap: [{\n        gap: [gap]\n      }],\n      /**\n       * Gap X\n       * @see https://tailwindcss.com/docs/gap\n       */\n      'gap-x': [{\n        'gap-x': [gap]\n      }],\n      /**\n       * Gap Y\n       * @see https://tailwindcss.com/docs/gap\n       */\n      'gap-y': [{\n        'gap-y': [gap]\n      }],\n      /**\n       * Justify Content\n       * @see https://tailwindcss.com/docs/justify-content\n       */\n      'justify-content': [{\n        justify: ['normal', ...getAlign()]\n      }],\n      /**\n       * Justify Items\n       * @see https://tailwindcss.com/docs/justify-items\n       */\n      'justify-items': [{\n        'justify-items': ['start', 'end', 'center', 'stretch']\n      }],\n      /**\n       * Justify Self\n       * @see https://tailwindcss.com/docs/justify-self\n       */\n      'justify-self': [{\n        'justify-self': ['auto', 'start', 'end', 'center', 'stretch']\n      }],\n      /**\n       * Align Content\n       * @see https://tailwindcss.com/docs/align-content\n       */\n      'align-content': [{\n        content: ['normal', ...getAlign(), 'baseline']\n      }],\n      /**\n       * Align Items\n       * @see https://tailwindcss.com/docs/align-items\n       */\n      'align-items': [{\n        items: ['start', 'end', 'center', 'baseline', 'stretch']\n      }],\n      /**\n       * Align Self\n       * @see https://tailwindcss.com/docs/align-self\n       */\n      'align-self': [{\n        self: ['auto', 'start', 'end', 'center', 'stretch', 'baseline']\n      }],\n      /**\n       * Place Content\n       * @see https://tailwindcss.com/docs/place-content\n       */\n      'place-content': [{\n        'place-content': [...getAlign(), 'baseline']\n      }],\n      /**\n       * Place Items\n       * @see https://tailwindcss.com/docs/place-items\n       */\n      'place-items': [{\n        'place-items': ['start', 'end', 'center', 'baseline', 'stretch']\n      }],\n      /**\n       * Place Self\n       * @see https://tailwindcss.com/docs/place-self\n       */\n      'place-self': [{\n        'place-self': ['auto', 'start', 'end', 'center', 'stretch']\n      }],\n      // Spacing\n      /**\n       * Padding\n       * @see https://tailwindcss.com/docs/padding\n       */\n      p: [{\n        p: [padding]\n      }],\n      /**\n       * Padding X\n       * @see https://tailwindcss.com/docs/padding\n       */\n      px: [{\n        px: [padding]\n      }],\n      /**\n       * Padding Y\n       * @see https://tailwindcss.com/docs/padding\n       */\n      py: [{\n        py: [padding]\n      }],\n      /**\n       * Padding Start\n       * @see https://tailwindcss.com/docs/padding\n       */\n      ps: [{\n        ps: [padding]\n      }],\n      /**\n       * Padding End\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pe: [{\n        pe: [padding]\n      }],\n      /**\n       * Padding Top\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pt: [{\n        pt: [padding]\n      }],\n      /**\n       * Padding Right\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pr: [{\n        pr: [padding]\n      }],\n      /**\n       * Padding Bottom\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pb: [{\n        pb: [padding]\n      }],\n      /**\n       * Padding Left\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pl: [{\n        pl: [padding]\n      }],\n      /**\n       * Margin\n       * @see https://tailwindcss.com/docs/margin\n       */\n      m: [{\n        m: [margin]\n      }],\n      /**\n       * Margin X\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mx: [{\n        mx: [margin]\n      }],\n      /**\n       * Margin Y\n       * @see https://tailwindcss.com/docs/margin\n       */\n      my: [{\n        my: [margin]\n      }],\n      /**\n       * Margin Start\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ms: [{\n        ms: [margin]\n      }],\n      /**\n       * Margin End\n       * @see https://tailwindcss.com/docs/margin\n       */\n      me: [{\n        me: [margin]\n      }],\n      /**\n       * Margin Top\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mt: [{\n        mt: [margin]\n      }],\n      /**\n       * Margin Right\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mr: [{\n        mr: [margin]\n      }],\n      /**\n       * Margin Bottom\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mb: [{\n        mb: [margin]\n      }],\n      /**\n       * Margin Left\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ml: [{\n        ml: [margin]\n      }],\n      /**\n       * Space Between X\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-x': [{\n        'space-x': [space]\n      }],\n      /**\n       * Space Between X Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-x-reverse': ['space-x-reverse'],\n      /**\n       * Space Between Y\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-y': [{\n        'space-y': [space]\n      }],\n      /**\n       * Space Between Y Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-y-reverse': ['space-y-reverse'],\n      // Sizing\n      /**\n       * Width\n       * @see https://tailwindcss.com/docs/width\n       */\n      w: [{\n        w: ['auto', 'min', 'max', 'fit', 'svw', 'lvw', 'dvw', isArbitraryValue, spacing]\n      }],\n      /**\n       * Min-Width\n       * @see https://tailwindcss.com/docs/min-width\n       */\n      'min-w': [{\n        'min-w': [isArbitraryValue, spacing, 'min', 'max', 'fit']\n      }],\n      /**\n       * Max-Width\n       * @see https://tailwindcss.com/docs/max-width\n       */\n      'max-w': [{\n        'max-w': [isArbitraryValue, spacing, 'none', 'full', 'min', 'max', 'fit', 'prose', {\n          screen: [isTshirtSize]\n        }, isTshirtSize]\n      }],\n      /**\n       * Height\n       * @see https://tailwindcss.com/docs/height\n       */\n      h: [{\n        h: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Min-Height\n       * @see https://tailwindcss.com/docs/min-height\n       */\n      'min-h': [{\n        'min-h': [isArbitraryValue, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Max-Height\n       * @see https://tailwindcss.com/docs/max-height\n       */\n      'max-h': [{\n        'max-h': [isArbitraryValue, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Size\n       * @see https://tailwindcss.com/docs/size\n       */\n      size: [{\n        size: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit']\n      }],\n      // Typography\n      /**\n       * Font Size\n       * @see https://tailwindcss.com/docs/font-size\n       */\n      'font-size': [{\n        text: ['base', isTshirtSize, isArbitraryLength]\n      }],\n      /**\n       * Font Smoothing\n       * @see https://tailwindcss.com/docs/font-smoothing\n       */\n      'font-smoothing': ['antialiased', 'subpixel-antialiased'],\n      /**\n       * Font Style\n       * @see https://tailwindcss.com/docs/font-style\n       */\n      'font-style': ['italic', 'not-italic'],\n      /**\n       * Font Weight\n       * @see https://tailwindcss.com/docs/font-weight\n       */\n      'font-weight': [{\n        font: ['thin', 'extralight', 'light', 'normal', 'medium', 'semibold', 'bold', 'extrabold', 'black', isArbitraryNumber]\n      }],\n      /**\n       * Font Family\n       * @see https://tailwindcss.com/docs/font-family\n       */\n      'font-family': [{\n        font: [isAny]\n      }],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-normal': ['normal-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-ordinal': ['ordinal'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-slashed-zero': ['slashed-zero'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-figure': ['lining-nums', 'oldstyle-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-spacing': ['proportional-nums', 'tabular-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-fraction': ['diagonal-fractions', 'stacked-fractons'],\n      /**\n       * Letter Spacing\n       * @see https://tailwindcss.com/docs/letter-spacing\n       */\n      tracking: [{\n        tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest', isArbitraryValue]\n      }],\n      /**\n       * Line Clamp\n       * @see https://tailwindcss.com/docs/line-clamp\n       */\n      'line-clamp': [{\n        'line-clamp': ['none', isNumber, isArbitraryNumber]\n      }],\n      /**\n       * Line Height\n       * @see https://tailwindcss.com/docs/line-height\n       */\n      leading: [{\n        leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose', isLength, isArbitraryValue]\n      }],\n      /**\n       * List Style Image\n       * @see https://tailwindcss.com/docs/list-style-image\n       */\n      'list-image': [{\n        'list-image': ['none', isArbitraryValue]\n      }],\n      /**\n       * List Style Type\n       * @see https://tailwindcss.com/docs/list-style-type\n       */\n      'list-style-type': [{\n        list: ['none', 'disc', 'decimal', isArbitraryValue]\n      }],\n      /**\n       * List Style Position\n       * @see https://tailwindcss.com/docs/list-style-position\n       */\n      'list-style-position': [{\n        list: ['inside', 'outside']\n      }],\n      /**\n       * Placeholder Color\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/placeholder-color\n       */\n      'placeholder-color': [{\n        placeholder: [colors]\n      }],\n      /**\n       * Placeholder Opacity\n       * @see https://tailwindcss.com/docs/placeholder-opacity\n       */\n      'placeholder-opacity': [{\n        'placeholder-opacity': [opacity]\n      }],\n      /**\n       * Text Alignment\n       * @see https://tailwindcss.com/docs/text-align\n       */\n      'text-alignment': [{\n        text: ['left', 'center', 'right', 'justify', 'start', 'end']\n      }],\n      /**\n       * Text Color\n       * @see https://tailwindcss.com/docs/text-color\n       */\n      'text-color': [{\n        text: [colors]\n      }],\n      /**\n       * Text Opacity\n       * @see https://tailwindcss.com/docs/text-opacity\n       */\n      'text-opacity': [{\n        'text-opacity': [opacity]\n      }],\n      /**\n       * Text Decoration\n       * @see https://tailwindcss.com/docs/text-decoration\n       */\n      'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],\n      /**\n       * Text Decoration Style\n       * @see https://tailwindcss.com/docs/text-decoration-style\n       */\n      'text-decoration-style': [{\n        decoration: [...getLineStyles(), 'wavy']\n      }],\n      /**\n       * Text Decoration Thickness\n       * @see https://tailwindcss.com/docs/text-decoration-thickness\n       */\n      'text-decoration-thickness': [{\n        decoration: ['auto', 'from-font', isLength, isArbitraryLength]\n      }],\n      /**\n       * Text Underline Offset\n       * @see https://tailwindcss.com/docs/text-underline-offset\n       */\n      'underline-offset': [{\n        'underline-offset': ['auto', isLength, isArbitraryValue]\n      }],\n      /**\n       * Text Decoration Color\n       * @see https://tailwindcss.com/docs/text-decoration-color\n       */\n      'text-decoration-color': [{\n        decoration: [colors]\n      }],\n      /**\n       * Text Transform\n       * @see https://tailwindcss.com/docs/text-transform\n       */\n      'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],\n      /**\n       * Text Overflow\n       * @see https://tailwindcss.com/docs/text-overflow\n       */\n      'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],\n      /**\n       * Text Wrap\n       * @see https://tailwindcss.com/docs/text-wrap\n       */\n      'text-wrap': [{\n        text: ['wrap', 'nowrap', 'balance', 'pretty']\n      }],\n      /**\n       * Text Indent\n       * @see https://tailwindcss.com/docs/text-indent\n       */\n      indent: [{\n        indent: getSpacingWithArbitrary()\n      }],\n      /**\n       * Vertical Alignment\n       * @see https://tailwindcss.com/docs/vertical-align\n       */\n      'vertical-align': [{\n        align: ['baseline', 'top', 'middle', 'bottom', 'text-top', 'text-bottom', 'sub', 'super', isArbitraryValue]\n      }],\n      /**\n       * Whitespace\n       * @see https://tailwindcss.com/docs/whitespace\n       */\n      whitespace: [{\n        whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces']\n      }],\n      /**\n       * Word Break\n       * @see https://tailwindcss.com/docs/word-break\n       */\n      break: [{\n        break: ['normal', 'words', 'all', 'keep']\n      }],\n      /**\n       * Hyphens\n       * @see https://tailwindcss.com/docs/hyphens\n       */\n      hyphens: [{\n        hyphens: ['none', 'manual', 'auto']\n      }],\n      /**\n       * Content\n       * @see https://tailwindcss.com/docs/content\n       */\n      content: [{\n        content: ['none', isArbitraryValue]\n      }],\n      // Backgrounds\n      /**\n       * Background Attachment\n       * @see https://tailwindcss.com/docs/background-attachment\n       */\n      'bg-attachment': [{\n        bg: ['fixed', 'local', 'scroll']\n      }],\n      /**\n       * Background Clip\n       * @see https://tailwindcss.com/docs/background-clip\n       */\n      'bg-clip': [{\n        'bg-clip': ['border', 'padding', 'content', 'text']\n      }],\n      /**\n       * Background Opacity\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/background-opacity\n       */\n      'bg-opacity': [{\n        'bg-opacity': [opacity]\n      }],\n      /**\n       * Background Origin\n       * @see https://tailwindcss.com/docs/background-origin\n       */\n      'bg-origin': [{\n        'bg-origin': ['border', 'padding', 'content']\n      }],\n      /**\n       * Background Position\n       * @see https://tailwindcss.com/docs/background-position\n       */\n      'bg-position': [{\n        bg: [...getPositions(), isArbitraryPosition]\n      }],\n      /**\n       * Background Repeat\n       * @see https://tailwindcss.com/docs/background-repeat\n       */\n      'bg-repeat': [{\n        bg: ['no-repeat', {\n          repeat: ['', 'x', 'y', 'round', 'space']\n        }]\n      }],\n      /**\n       * Background Size\n       * @see https://tailwindcss.com/docs/background-size\n       */\n      'bg-size': [{\n        bg: ['auto', 'cover', 'contain', isArbitrarySize]\n      }],\n      /**\n       * Background Image\n       * @see https://tailwindcss.com/docs/background-image\n       */\n      'bg-image': [{\n        bg: ['none', {\n          'gradient-to': ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl']\n        }, isArbitraryImage]\n      }],\n      /**\n       * Background Color\n       * @see https://tailwindcss.com/docs/background-color\n       */\n      'bg-color': [{\n        bg: [colors]\n      }],\n      /**\n       * Gradient Color Stops From Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-from-pos': [{\n        from: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops Via Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-via-pos': [{\n        via: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops To Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-to-pos': [{\n        to: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops From\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-from': [{\n        from: [gradientColorStops]\n      }],\n      /**\n       * Gradient Color Stops Via\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-via': [{\n        via: [gradientColorStops]\n      }],\n      /**\n       * Gradient Color Stops To\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-to': [{\n        to: [gradientColorStops]\n      }],\n      // Borders\n      /**\n       * Border Radius\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      rounded: [{\n        rounded: [borderRadius]\n      }],\n      /**\n       * Border Radius Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-s': [{\n        'rounded-s': [borderRadius]\n      }],\n      /**\n       * Border Radius End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-e': [{\n        'rounded-e': [borderRadius]\n      }],\n      /**\n       * Border Radius Top\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-t': [{\n        'rounded-t': [borderRadius]\n      }],\n      /**\n       * Border Radius Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-r': [{\n        'rounded-r': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-b': [{\n        'rounded-b': [borderRadius]\n      }],\n      /**\n       * Border Radius Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-l': [{\n        'rounded-l': [borderRadius]\n      }],\n      /**\n       * Border Radius Start Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-ss': [{\n        'rounded-ss': [borderRadius]\n      }],\n      /**\n       * Border Radius Start End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-se': [{\n        'rounded-se': [borderRadius]\n      }],\n      /**\n       * Border Radius End End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-ee': [{\n        'rounded-ee': [borderRadius]\n      }],\n      /**\n       * Border Radius End Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-es': [{\n        'rounded-es': [borderRadius]\n      }],\n      /**\n       * Border Radius Top Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-tl': [{\n        'rounded-tl': [borderRadius]\n      }],\n      /**\n       * Border Radius Top Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-tr': [{\n        'rounded-tr': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-br': [{\n        'rounded-br': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-bl': [{\n        'rounded-bl': [borderRadius]\n      }],\n      /**\n       * Border Width\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w': [{\n        border: [borderWidth]\n      }],\n      /**\n       * Border Width X\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-x': [{\n        'border-x': [borderWidth]\n      }],\n      /**\n       * Border Width Y\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-y': [{\n        'border-y': [borderWidth]\n      }],\n      /**\n       * Border Width Start\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-s': [{\n        'border-s': [borderWidth]\n      }],\n      /**\n       * Border Width End\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-e': [{\n        'border-e': [borderWidth]\n      }],\n      /**\n       * Border Width Top\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-t': [{\n        'border-t': [borderWidth]\n      }],\n      /**\n       * Border Width Right\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-r': [{\n        'border-r': [borderWidth]\n      }],\n      /**\n       * Border Width Bottom\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-b': [{\n        'border-b': [borderWidth]\n      }],\n      /**\n       * Border Width Left\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-l': [{\n        'border-l': [borderWidth]\n      }],\n      /**\n       * Border Opacity\n       * @see https://tailwindcss.com/docs/border-opacity\n       */\n      'border-opacity': [{\n        'border-opacity': [opacity]\n      }],\n      /**\n       * Border Style\n       * @see https://tailwindcss.com/docs/border-style\n       */\n      'border-style': [{\n        border: [...getLineStyles(), 'hidden']\n      }],\n      /**\n       * Divide Width X\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-x': [{\n        'divide-x': [borderWidth]\n      }],\n      /**\n       * Divide Width X Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-x-reverse': ['divide-x-reverse'],\n      /**\n       * Divide Width Y\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-y': [{\n        'divide-y': [borderWidth]\n      }],\n      /**\n       * Divide Width Y Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-y-reverse': ['divide-y-reverse'],\n      /**\n       * Divide Opacity\n       * @see https://tailwindcss.com/docs/divide-opacity\n       */\n      'divide-opacity': [{\n        'divide-opacity': [opacity]\n      }],\n      /**\n       * Divide Style\n       * @see https://tailwindcss.com/docs/divide-style\n       */\n      'divide-style': [{\n        divide: getLineStyles()\n      }],\n      /**\n       * Border Color\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color': [{\n        border: [borderColor]\n      }],\n      /**\n       * Border Color X\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-x': [{\n        'border-x': [borderColor]\n      }],\n      /**\n       * Border Color Y\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-y': [{\n        'border-y': [borderColor]\n      }],\n      /**\n       * Border Color Top\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-t': [{\n        'border-t': [borderColor]\n      }],\n      /**\n       * Border Color Right\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-r': [{\n        'border-r': [borderColor]\n      }],\n      /**\n       * Border Color Bottom\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-b': [{\n        'border-b': [borderColor]\n      }],\n      /**\n       * Border Color Left\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-l': [{\n        'border-l': [borderColor]\n      }],\n      /**\n       * Divide Color\n       * @see https://tailwindcss.com/docs/divide-color\n       */\n      'divide-color': [{\n        divide: [borderColor]\n      }],\n      /**\n       * Outline Style\n       * @see https://tailwindcss.com/docs/outline-style\n       */\n      'outline-style': [{\n        outline: ['', ...getLineStyles()]\n      }],\n      /**\n       * Outline Offset\n       * @see https://tailwindcss.com/docs/outline-offset\n       */\n      'outline-offset': [{\n        'outline-offset': [isLength, isArbitraryValue]\n      }],\n      /**\n       * Outline Width\n       * @see https://tailwindcss.com/docs/outline-width\n       */\n      'outline-w': [{\n        outline: [isLength, isArbitraryLength]\n      }],\n      /**\n       * Outline Color\n       * @see https://tailwindcss.com/docs/outline-color\n       */\n      'outline-color': [{\n        outline: [colors]\n      }],\n      /**\n       * Ring Width\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      'ring-w': [{\n        ring: getLengthWithEmptyAndArbitrary()\n      }],\n      /**\n       * Ring Width Inset\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      'ring-w-inset': ['ring-inset'],\n      /**\n       * Ring Color\n       * @see https://tailwindcss.com/docs/ring-color\n       */\n      'ring-color': [{\n        ring: [colors]\n      }],\n      /**\n       * Ring Opacity\n       * @see https://tailwindcss.com/docs/ring-opacity\n       */\n      'ring-opacity': [{\n        'ring-opacity': [opacity]\n      }],\n      /**\n       * Ring Offset Width\n       * @see https://tailwindcss.com/docs/ring-offset-width\n       */\n      'ring-offset-w': [{\n        'ring-offset': [isLength, isArbitraryLength]\n      }],\n      /**\n       * Ring Offset Color\n       * @see https://tailwindcss.com/docs/ring-offset-color\n       */\n      'ring-offset-color': [{\n        'ring-offset': [colors]\n      }],\n      // Effects\n      /**\n       * Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow\n       */\n      shadow: [{\n        shadow: ['', 'inner', 'none', isTshirtSize, isArbitraryShadow]\n      }],\n      /**\n       * Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow-color\n       */\n      'shadow-color': [{\n        shadow: [isAny]\n      }],\n      /**\n       * Opacity\n       * @see https://tailwindcss.com/docs/opacity\n       */\n      opacity: [{\n        opacity: [opacity]\n      }],\n      /**\n       * Mix Blend Mode\n       * @see https://tailwindcss.com/docs/mix-blend-mode\n       */\n      'mix-blend': [{\n        'mix-blend': [...getBlendModes(), 'plus-lighter', 'plus-darker']\n      }],\n      /**\n       * Background Blend Mode\n       * @see https://tailwindcss.com/docs/background-blend-mode\n       */\n      'bg-blend': [{\n        'bg-blend': getBlendModes()\n      }],\n      // Filters\n      /**\n       * Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/filter\n       */\n      filter: [{\n        filter: ['', 'none']\n      }],\n      /**\n       * Blur\n       * @see https://tailwindcss.com/docs/blur\n       */\n      blur: [{\n        blur: [blur]\n      }],\n      /**\n       * Brightness\n       * @see https://tailwindcss.com/docs/brightness\n       */\n      brightness: [{\n        brightness: [brightness]\n      }],\n      /**\n       * Contrast\n       * @see https://tailwindcss.com/docs/contrast\n       */\n      contrast: [{\n        contrast: [contrast]\n      }],\n      /**\n       * Drop Shadow\n       * @see https://tailwindcss.com/docs/drop-shadow\n       */\n      'drop-shadow': [{\n        'drop-shadow': ['', 'none', isTshirtSize, isArbitraryValue]\n      }],\n      /**\n       * Grayscale\n       * @see https://tailwindcss.com/docs/grayscale\n       */\n      grayscale: [{\n        grayscale: [grayscale]\n      }],\n      /**\n       * Hue Rotate\n       * @see https://tailwindcss.com/docs/hue-rotate\n       */\n      'hue-rotate': [{\n        'hue-rotate': [hueRotate]\n      }],\n      /**\n       * Invert\n       * @see https://tailwindcss.com/docs/invert\n       */\n      invert: [{\n        invert: [invert]\n      }],\n      /**\n       * Saturate\n       * @see https://tailwindcss.com/docs/saturate\n       */\n      saturate: [{\n        saturate: [saturate]\n      }],\n      /**\n       * Sepia\n       * @see https://tailwindcss.com/docs/sepia\n       */\n      sepia: [{\n        sepia: [sepia]\n      }],\n      /**\n       * Backdrop Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/backdrop-filter\n       */\n      'backdrop-filter': [{\n        'backdrop-filter': ['', 'none']\n      }],\n      /**\n       * Backdrop Blur\n       * @see https://tailwindcss.com/docs/backdrop-blur\n       */\n      'backdrop-blur': [{\n        'backdrop-blur': [blur]\n      }],\n      /**\n       * Backdrop Brightness\n       * @see https://tailwindcss.com/docs/backdrop-brightness\n       */\n      'backdrop-brightness': [{\n        'backdrop-brightness': [brightness]\n      }],\n      /**\n       * Backdrop Contrast\n       * @see https://tailwindcss.com/docs/backdrop-contrast\n       */\n      'backdrop-contrast': [{\n        'backdrop-contrast': [contrast]\n      }],\n      /**\n       * Backdrop Grayscale\n       * @see https://tailwindcss.com/docs/backdrop-grayscale\n       */\n      'backdrop-grayscale': [{\n        'backdrop-grayscale': [grayscale]\n      }],\n      /**\n       * Backdrop Hue Rotate\n       * @see https://tailwindcss.com/docs/backdrop-hue-rotate\n       */\n      'backdrop-hue-rotate': [{\n        'backdrop-hue-rotate': [hueRotate]\n      }],\n      /**\n       * Backdrop Invert\n       * @see https://tailwindcss.com/docs/backdrop-invert\n       */\n      'backdrop-invert': [{\n        'backdrop-invert': [invert]\n      }],\n      /**\n       * Backdrop Opacity\n       * @see https://tailwindcss.com/docs/backdrop-opacity\n       */\n      'backdrop-opacity': [{\n        'backdrop-opacity': [opacity]\n      }],\n      /**\n       * Backdrop Saturate\n       * @see https://tailwindcss.com/docs/backdrop-saturate\n       */\n      'backdrop-saturate': [{\n        'backdrop-saturate': [saturate]\n      }],\n      /**\n       * Backdrop Sepia\n       * @see https://tailwindcss.com/docs/backdrop-sepia\n       */\n      'backdrop-sepia': [{\n        'backdrop-sepia': [sepia]\n      }],\n      // Tables\n      /**\n       * Border Collapse\n       * @see https://tailwindcss.com/docs/border-collapse\n       */\n      'border-collapse': [{\n        border: ['collapse', 'separate']\n      }],\n      /**\n       * Border Spacing\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing': [{\n        'border-spacing': [borderSpacing]\n      }],\n      /**\n       * Border Spacing X\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing-x': [{\n        'border-spacing-x': [borderSpacing]\n      }],\n      /**\n       * Border Spacing Y\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing-y': [{\n        'border-spacing-y': [borderSpacing]\n      }],\n      /**\n       * Table Layout\n       * @see https://tailwindcss.com/docs/table-layout\n       */\n      'table-layout': [{\n        table: ['auto', 'fixed']\n      }],\n      /**\n       * Caption Side\n       * @see https://tailwindcss.com/docs/caption-side\n       */\n      caption: [{\n        caption: ['top', 'bottom']\n      }],\n      // Transitions and Animation\n      /**\n       * Tranisition Property\n       * @see https://tailwindcss.com/docs/transition-property\n       */\n      transition: [{\n        transition: ['none', 'all', '', 'colors', 'opacity', 'shadow', 'transform', isArbitraryValue]\n      }],\n      /**\n       * Transition Duration\n       * @see https://tailwindcss.com/docs/transition-duration\n       */\n      duration: [{\n        duration: getNumberAndArbitrary()\n      }],\n      /**\n       * Transition Timing Function\n       * @see https://tailwindcss.com/docs/transition-timing-function\n       */\n      ease: [{\n        ease: ['linear', 'in', 'out', 'in-out', isArbitraryValue]\n      }],\n      /**\n       * Transition Delay\n       * @see https://tailwindcss.com/docs/transition-delay\n       */\n      delay: [{\n        delay: getNumberAndArbitrary()\n      }],\n      /**\n       * Animation\n       * @see https://tailwindcss.com/docs/animation\n       */\n      animate: [{\n        animate: ['none', 'spin', 'ping', 'pulse', 'bounce', isArbitraryValue]\n      }],\n      // Transforms\n      /**\n       * Transform\n       * @see https://tailwindcss.com/docs/transform\n       */\n      transform: [{\n        transform: ['', 'gpu', 'none']\n      }],\n      /**\n       * Scale\n       * @see https://tailwindcss.com/docs/scale\n       */\n      scale: [{\n        scale: [scale]\n      }],\n      /**\n       * Scale X\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-x': [{\n        'scale-x': [scale]\n      }],\n      /**\n       * Scale Y\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-y': [{\n        'scale-y': [scale]\n      }],\n      /**\n       * Rotate\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      rotate: [{\n        rotate: [isInteger, isArbitraryValue]\n      }],\n      /**\n       * Translate X\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-x': [{\n        'translate-x': [translate]\n      }],\n      /**\n       * Translate Y\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-y': [{\n        'translate-y': [translate]\n      }],\n      /**\n       * Skew X\n       * @see https://tailwindcss.com/docs/skew\n       */\n      'skew-x': [{\n        'skew-x': [skew]\n      }],\n      /**\n       * Skew Y\n       * @see https://tailwindcss.com/docs/skew\n       */\n      'skew-y': [{\n        'skew-y': [skew]\n      }],\n      /**\n       * Transform Origin\n       * @see https://tailwindcss.com/docs/transform-origin\n       */\n      'transform-origin': [{\n        origin: ['center', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left', isArbitraryValue]\n      }],\n      // Interactivity\n      /**\n       * Accent Color\n       * @see https://tailwindcss.com/docs/accent-color\n       */\n      accent: [{\n        accent: ['auto', colors]\n      }],\n      /**\n       * Appearance\n       * @see https://tailwindcss.com/docs/appearance\n       */\n      appearance: [{\n        appearance: ['none', 'auto']\n      }],\n      /**\n       * Cursor\n       * @see https://tailwindcss.com/docs/cursor\n       */\n      cursor: [{\n        cursor: ['auto', 'default', 'pointer', 'wait', 'text', 'move', 'help', 'not-allowed', 'none', 'context-menu', 'progress', 'cell', 'crosshair', 'vertical-text', 'alias', 'copy', 'no-drop', 'grab', 'grabbing', 'all-scroll', 'col-resize', 'row-resize', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'ew-resize', 'ns-resize', 'nesw-resize', 'nwse-resize', 'zoom-in', 'zoom-out', isArbitraryValue]\n      }],\n      /**\n       * Caret Color\n       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities\n       */\n      'caret-color': [{\n        caret: [colors]\n      }],\n      /**\n       * Pointer Events\n       * @see https://tailwindcss.com/docs/pointer-events\n       */\n      'pointer-events': [{\n        'pointer-events': ['none', 'auto']\n      }],\n      /**\n       * Resize\n       * @see https://tailwindcss.com/docs/resize\n       */\n      resize: [{\n        resize: ['none', 'y', 'x', '']\n      }],\n      /**\n       * Scroll Behavior\n       * @see https://tailwindcss.com/docs/scroll-behavior\n       */\n      'scroll-behavior': [{\n        scroll: ['auto', 'smooth']\n      }],\n      /**\n       * Scroll Margin\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-m': [{\n        'scroll-m': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin X\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mx': [{\n        'scroll-mx': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Y\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-my': [{\n        'scroll-my': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Start\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-ms': [{\n        'scroll-ms': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin End\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-me': [{\n        'scroll-me': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Top\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mt': [{\n        'scroll-mt': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Right\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mr': [{\n        'scroll-mr': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Bottom\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mb': [{\n        'scroll-mb': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Left\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-ml': [{\n        'scroll-ml': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-p': [{\n        'scroll-p': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding X\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-px': [{\n        'scroll-px': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Y\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-py': [{\n        'scroll-py': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Start\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-ps': [{\n        'scroll-ps': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding End\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pe': [{\n        'scroll-pe': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Top\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pt': [{\n        'scroll-pt': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Right\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pr': [{\n        'scroll-pr': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Bottom\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pb': [{\n        'scroll-pb': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Left\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pl': [{\n        'scroll-pl': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Snap Align\n       * @see https://tailwindcss.com/docs/scroll-snap-align\n       */\n      'snap-align': [{\n        snap: ['start', 'end', 'center', 'align-none']\n      }],\n      /**\n       * Scroll Snap Stop\n       * @see https://tailwindcss.com/docs/scroll-snap-stop\n       */\n      'snap-stop': [{\n        snap: ['normal', 'always']\n      }],\n      /**\n       * Scroll Snap Type\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      'snap-type': [{\n        snap: ['none', 'x', 'y', 'both']\n      }],\n      /**\n       * Scroll Snap Type Strictness\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      'snap-strictness': [{\n        snap: ['mandatory', 'proximity']\n      }],\n      /**\n       * Touch Action\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      touch: [{\n        touch: ['auto', 'none', 'manipulation']\n      }],\n      /**\n       * Touch Action X\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-x': [{\n        'touch-pan': ['x', 'left', 'right']\n      }],\n      /**\n       * Touch Action Y\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-y': [{\n        'touch-pan': ['y', 'up', 'down']\n      }],\n      /**\n       * Touch Action Pinch Zoom\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-pz': ['touch-pinch-zoom'],\n      /**\n       * User Select\n       * @see https://tailwindcss.com/docs/user-select\n       */\n      select: [{\n        select: ['none', 'text', 'all', 'auto']\n      }],\n      /**\n       * Will Change\n       * @see https://tailwindcss.com/docs/will-change\n       */\n      'will-change': [{\n        'will-change': ['auto', 'scroll', 'contents', 'transform', isArbitraryValue]\n      }],\n      // SVG\n      /**\n       * Fill\n       * @see https://tailwindcss.com/docs/fill\n       */\n      fill: [{\n        fill: [colors, 'none']\n      }],\n      /**\n       * Stroke Width\n       * @see https://tailwindcss.com/docs/stroke-width\n       */\n      'stroke-w': [{\n        stroke: [isLength, isArbitraryLength, isArbitraryNumber]\n      }],\n      /**\n       * Stroke\n       * @see https://tailwindcss.com/docs/stroke\n       */\n      stroke: [{\n        stroke: [colors, 'none']\n      }],\n      // Accessibility\n      /**\n       * Screen Readers\n       * @see https://tailwindcss.com/docs/screen-readers\n       */\n      sr: ['sr-only', 'not-sr-only'],\n      /**\n       * Forced Color Adjust\n       * @see https://tailwindcss.com/docs/forced-color-adjust\n       */\n      'forced-color-adjust': [{\n        'forced-color-adjust': ['auto', 'none']\n      }]\n    },\n    conflictingClassGroups: {\n      overflow: ['overflow-x', 'overflow-y'],\n      overscroll: ['overscroll-x', 'overscroll-y'],\n      inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],\n      'inset-x': ['right', 'left'],\n      'inset-y': ['top', 'bottom'],\n      flex: ['basis', 'grow', 'shrink'],\n      gap: ['gap-x', 'gap-y'],\n      p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],\n      px: ['pr', 'pl'],\n      py: ['pt', 'pb'],\n      m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],\n      mx: ['mr', 'ml'],\n      my: ['mt', 'mb'],\n      size: ['w', 'h'],\n      'font-size': ['leading'],\n      'fvn-normal': ['fvn-ordinal', 'fvn-slashed-zero', 'fvn-figure', 'fvn-spacing', 'fvn-fraction'],\n      'fvn-ordinal': ['fvn-normal'],\n      'fvn-slashed-zero': ['fvn-normal'],\n      'fvn-figure': ['fvn-normal'],\n      'fvn-spacing': ['fvn-normal'],\n      'fvn-fraction': ['fvn-normal'],\n      'line-clamp': ['display', 'overflow'],\n      rounded: ['rounded-s', 'rounded-e', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-ss', 'rounded-se', 'rounded-ee', 'rounded-es', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'],\n      'rounded-s': ['rounded-ss', 'rounded-es'],\n      'rounded-e': ['rounded-se', 'rounded-ee'],\n      'rounded-t': ['rounded-tl', 'rounded-tr'],\n      'rounded-r': ['rounded-tr', 'rounded-br'],\n      'rounded-b': ['rounded-br', 'rounded-bl'],\n      'rounded-l': ['rounded-tl', 'rounded-bl'],\n      'border-spacing': ['border-spacing-x', 'border-spacing-y'],\n      'border-w': ['border-w-s', 'border-w-e', 'border-w-t', 'border-w-r', 'border-w-b', 'border-w-l'],\n      'border-w-x': ['border-w-r', 'border-w-l'],\n      'border-w-y': ['border-w-t', 'border-w-b'],\n      'border-color': ['border-color-t', 'border-color-r', 'border-color-b', 'border-color-l'],\n      'border-color-x': ['border-color-r', 'border-color-l'],\n      'border-color-y': ['border-color-t', 'border-color-b'],\n      'scroll-m': ['scroll-mx', 'scroll-my', 'scroll-ms', 'scroll-me', 'scroll-mt', 'scroll-mr', 'scroll-mb', 'scroll-ml'],\n      'scroll-mx': ['scroll-mr', 'scroll-ml'],\n      'scroll-my': ['scroll-mt', 'scroll-mb'],\n      'scroll-p': ['scroll-px', 'scroll-py', 'scroll-ps', 'scroll-pe', 'scroll-pt', 'scroll-pr', 'scroll-pb', 'scroll-pl'],\n      'scroll-px': ['scroll-pr', 'scroll-pl'],\n      'scroll-py': ['scroll-pt', 'scroll-pb'],\n      touch: ['touch-x', 'touch-y', 'touch-pz'],\n      'touch-x': ['touch'],\n      'touch-y': ['touch'],\n      'touch-pz': ['touch']\n    },\n    conflictingClassGroupModifiers: {\n      'font-size': ['leading']\n    }\n  };\n};\n\n/**\n * @param baseConfig Config where other config will be merged into. This object will be mutated.\n * @param configExtension Partial config to merge into the `baseConfig`.\n */\nconst mergeConfigs = (baseConfig, {\n  cacheSize,\n  prefix,\n  separator,\n  experimentalParseClassName,\n  extend = {},\n  override = {}\n}) => {\n  overrideProperty(baseConfig, 'cacheSize', cacheSize);\n  overrideProperty(baseConfig, 'prefix', prefix);\n  overrideProperty(baseConfig, 'separator', separator);\n  overrideProperty(baseConfig, 'experimentalParseClassName', experimentalParseClassName);\n  for (const configKey in override) {\n    overrideConfigProperties(baseConfig[configKey], override[configKey]);\n  }\n  for (const key in extend) {\n    mergeConfigProperties(baseConfig[key], extend[key]);\n  }\n  return baseConfig;\n};\nconst overrideProperty = (baseObject, overrideKey, overrideValue) => {\n  if (overrideValue !== undefined) {\n    baseObject[overrideKey] = overrideValue;\n  }\n};\nconst overrideConfigProperties = (baseObject, overrideObject) => {\n  if (overrideObject) {\n    for (const key in overrideObject) {\n      overrideProperty(baseObject, key, overrideObject[key]);\n    }\n  }\n};\nconst mergeConfigProperties = (baseObject, mergeObject) => {\n  if (mergeObject) {\n    for (const key in mergeObject) {\n      const mergeValue = mergeObject[key];\n      if (mergeValue !== undefined) {\n        baseObject[key] = (baseObject[key] || []).concat(mergeValue);\n      }\n    }\n  }\n};\nconst extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension === 'function' ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);\nconst twMerge = /*#__PURE__*/createTailwindMerge(getDefaultConfig);\n\n//# sourceMappingURL=bundle-mjs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9kaXN0L2J1bmRsZS1tanMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxPQUFPLG1CQUFtQixrQkFBa0IsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRIO0FBQzVIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9kaXN0L2J1bmRsZS1tanMubWpzPzFmZjYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ0xBU1NfUEFSVF9TRVBBUkFUT1IgPSAnLSc7XG5jb25zdCBjcmVhdGVDbGFzc0dyb3VwVXRpbHMgPSBjb25maWcgPT4ge1xuICBjb25zdCBjbGFzc01hcCA9IGNyZWF0ZUNsYXNzTWFwKGNvbmZpZyk7XG4gIGNvbnN0IHtcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBzLFxuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVyc1xuICB9ID0gY29uZmlnO1xuICBjb25zdCBnZXRDbGFzc0dyb3VwSWQgPSBjbGFzc05hbWUgPT4ge1xuICAgIGNvbnN0IGNsYXNzUGFydHMgPSBjbGFzc05hbWUuc3BsaXQoQ0xBU1NfUEFSVF9TRVBBUkFUT1IpO1xuICAgIC8vIENsYXNzZXMgbGlrZSBgLWluc2V0LTFgIHByb2R1Y2UgYW4gZW1wdHkgc3RyaW5nIGFzIGZpcnN0IGNsYXNzUGFydC4gV2UgYXNzdW1lIHRoYXQgY2xhc3NlcyBmb3IgbmVnYXRpdmUgdmFsdWVzIGFyZSB1c2VkIGNvcnJlY3RseSBhbmQgcmVtb3ZlIGl0IGZyb20gY2xhc3NQYXJ0cy5cbiAgICBpZiAoY2xhc3NQYXJ0c1swXSA9PT0gJycgJiYgY2xhc3NQYXJ0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIGNsYXNzUGFydHMuc2hpZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEdyb3VwUmVjdXJzaXZlKGNsYXNzUGFydHMsIGNsYXNzTWFwKSB8fCBnZXRHcm91cElkRm9yQXJiaXRyYXJ5UHJvcGVydHkoY2xhc3NOYW1lKTtcbiAgfTtcbiAgY29uc3QgZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzID0gKGNsYXNzR3JvdXBJZCwgaGFzUG9zdGZpeE1vZGlmaWVyKSA9PiB7XG4gICAgY29uc3QgY29uZmxpY3RzID0gY29uZmxpY3RpbmdDbGFzc0dyb3Vwc1tjbGFzc0dyb3VwSWRdIHx8IFtdO1xuICAgIGlmIChoYXNQb3N0Zml4TW9kaWZpZXIgJiYgY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzW2NsYXNzR3JvdXBJZF0pIHtcbiAgICAgIHJldHVybiBbLi4uY29uZmxpY3RzLCAuLi5jb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnNbY2xhc3NHcm91cElkXV07XG4gICAgfVxuICAgIHJldHVybiBjb25mbGljdHM7XG4gIH07XG4gIHJldHVybiB7XG4gICAgZ2V0Q2xhc3NHcm91cElkLFxuICAgIGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkc1xuICB9O1xufTtcbmNvbnN0IGdldEdyb3VwUmVjdXJzaXZlID0gKGNsYXNzUGFydHMsIGNsYXNzUGFydE9iamVjdCkgPT4ge1xuICBpZiAoY2xhc3NQYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY2xhc3NQYXJ0T2JqZWN0LmNsYXNzR3JvdXBJZDtcbiAgfVxuICBjb25zdCBjdXJyZW50Q2xhc3NQYXJ0ID0gY2xhc3NQYXJ0c1swXTtcbiAgY29uc3QgbmV4dENsYXNzUGFydE9iamVjdCA9IGNsYXNzUGFydE9iamVjdC5uZXh0UGFydC5nZXQoY3VycmVudENsYXNzUGFydCk7XG4gIGNvbnN0IGNsYXNzR3JvdXBGcm9tTmV4dENsYXNzUGFydCA9IG5leHRDbGFzc1BhcnRPYmplY3QgPyBnZXRHcm91cFJlY3Vyc2l2ZShjbGFzc1BhcnRzLnNsaWNlKDEpLCBuZXh0Q2xhc3NQYXJ0T2JqZWN0KSA6IHVuZGVmaW5lZDtcbiAgaWYgKGNsYXNzR3JvdXBGcm9tTmV4dENsYXNzUGFydCkge1xuICAgIHJldHVybiBjbGFzc0dyb3VwRnJvbU5leHRDbGFzc1BhcnQ7XG4gIH1cbiAgaWYgKGNsYXNzUGFydE9iamVjdC52YWxpZGF0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgY2xhc3NSZXN0ID0gY2xhc3NQYXJ0cy5qb2luKENMQVNTX1BBUlRfU0VQQVJBVE9SKTtcbiAgcmV0dXJuIGNsYXNzUGFydE9iamVjdC52YWxpZGF0b3JzLmZpbmQoKHtcbiAgICB2YWxpZGF0b3JcbiAgfSkgPT4gdmFsaWRhdG9yKGNsYXNzUmVzdCkpPy5jbGFzc0dyb3VwSWQ7XG59O1xuY29uc3QgYXJiaXRyYXJ5UHJvcGVydHlSZWdleCA9IC9eXFxbKC4rKVxcXSQvO1xuY29uc3QgZ2V0R3JvdXBJZEZvckFyYml0cmFyeVByb3BlcnR5ID0gY2xhc3NOYW1lID0+IHtcbiAgaWYgKGFyYml0cmFyeVByb3BlcnR5UmVnZXgudGVzdChjbGFzc05hbWUpKSB7XG4gICAgY29uc3QgYXJiaXRyYXJ5UHJvcGVydHlDbGFzc05hbWUgPSBhcmJpdHJhcnlQcm9wZXJ0eVJlZ2V4LmV4ZWMoY2xhc3NOYW1lKVsxXTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IGFyYml0cmFyeVByb3BlcnR5Q2xhc3NOYW1lPy5zdWJzdHJpbmcoMCwgYXJiaXRyYXJ5UHJvcGVydHlDbGFzc05hbWUuaW5kZXhPZignOicpKTtcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIC8vIEkgdXNlIHR3byBkb3RzIGhlcmUgYmVjYXVzZSBvbmUgZG90IGlzIHVzZWQgYXMgcHJlZml4IGZvciBjbGFzcyBncm91cHMgaW4gcGx1Z2luc1xuICAgICAgcmV0dXJuICdhcmJpdHJhcnkuLicgKyBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nIG9ubHlcbiAqL1xuY29uc3QgY3JlYXRlQ2xhc3NNYXAgPSBjb25maWcgPT4ge1xuICBjb25zdCB7XG4gICAgdGhlbWUsXG4gICAgcHJlZml4XG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IGNsYXNzTWFwID0ge1xuICAgIG5leHRQYXJ0OiBuZXcgTWFwKCksXG4gICAgdmFsaWRhdG9yczogW11cbiAgfTtcbiAgY29uc3QgcHJlZml4ZWRDbGFzc0dyb3VwRW50cmllcyA9IGdldFByZWZpeGVkQ2xhc3NHcm91cEVudHJpZXMoT2JqZWN0LmVudHJpZXMoY29uZmlnLmNsYXNzR3JvdXBzKSwgcHJlZml4KTtcbiAgcHJlZml4ZWRDbGFzc0dyb3VwRW50cmllcy5mb3JFYWNoKChbY2xhc3NHcm91cElkLCBjbGFzc0dyb3VwXSkgPT4ge1xuICAgIHByb2Nlc3NDbGFzc2VzUmVjdXJzaXZlbHkoY2xhc3NHcm91cCwgY2xhc3NNYXAsIGNsYXNzR3JvdXBJZCwgdGhlbWUpO1xuICB9KTtcbiAgcmV0dXJuIGNsYXNzTWFwO1xufTtcbmNvbnN0IHByb2Nlc3NDbGFzc2VzUmVjdXJzaXZlbHkgPSAoY2xhc3NHcm91cCwgY2xhc3NQYXJ0T2JqZWN0LCBjbGFzc0dyb3VwSWQsIHRoZW1lKSA9PiB7XG4gIGNsYXNzR3JvdXAuZm9yRWFjaChjbGFzc0RlZmluaXRpb24gPT4ge1xuICAgIGlmICh0eXBlb2YgY2xhc3NEZWZpbml0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgY2xhc3NQYXJ0T2JqZWN0VG9FZGl0ID0gY2xhc3NEZWZpbml0aW9uID09PSAnJyA/IGNsYXNzUGFydE9iamVjdCA6IGdldFBhcnQoY2xhc3NQYXJ0T2JqZWN0LCBjbGFzc0RlZmluaXRpb24pO1xuICAgICAgY2xhc3NQYXJ0T2JqZWN0VG9FZGl0LmNsYXNzR3JvdXBJZCA9IGNsYXNzR3JvdXBJZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjbGFzc0RlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChpc1RoZW1lR2V0dGVyKGNsYXNzRGVmaW5pdGlvbikpIHtcbiAgICAgICAgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseShjbGFzc0RlZmluaXRpb24odGhlbWUpLCBjbGFzc1BhcnRPYmplY3QsIGNsYXNzR3JvdXBJZCwgdGhlbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjbGFzc1BhcnRPYmplY3QudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgICAgdmFsaWRhdG9yOiBjbGFzc0RlZmluaXRpb24sXG4gICAgICAgIGNsYXNzR3JvdXBJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5lbnRyaWVzKGNsYXNzRGVmaW5pdGlvbikuZm9yRWFjaCgoW2tleSwgY2xhc3NHcm91cF0pID0+IHtcbiAgICAgIHByb2Nlc3NDbGFzc2VzUmVjdXJzaXZlbHkoY2xhc3NHcm91cCwgZ2V0UGFydChjbGFzc1BhcnRPYmplY3QsIGtleSksIGNsYXNzR3JvdXBJZCwgdGhlbWUpO1xuICAgIH0pO1xuICB9KTtcbn07XG5jb25zdCBnZXRQYXJ0ID0gKGNsYXNzUGFydE9iamVjdCwgcGF0aCkgPT4ge1xuICBsZXQgY3VycmVudENsYXNzUGFydE9iamVjdCA9IGNsYXNzUGFydE9iamVjdDtcbiAgcGF0aC5zcGxpdChDTEFTU19QQVJUX1NFUEFSQVRPUikuZm9yRWFjaChwYXRoUGFydCA9PiB7XG4gICAgaWYgKCFjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0Lm5leHRQYXJ0LmhhcyhwYXRoUGFydCkpIHtcbiAgICAgIGN1cnJlbnRDbGFzc1BhcnRPYmplY3QubmV4dFBhcnQuc2V0KHBhdGhQYXJ0LCB7XG4gICAgICAgIG5leHRQYXJ0OiBuZXcgTWFwKCksXG4gICAgICAgIHZhbGlkYXRvcnM6IFtdXG4gICAgICB9KTtcbiAgICB9XG4gICAgY3VycmVudENsYXNzUGFydE9iamVjdCA9IGN1cnJlbnRDbGFzc1BhcnRPYmplY3QubmV4dFBhcnQuZ2V0KHBhdGhQYXJ0KTtcbiAgfSk7XG4gIHJldHVybiBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0O1xufTtcbmNvbnN0IGlzVGhlbWVHZXR0ZXIgPSBmdW5jID0+IGZ1bmMuaXNUaGVtZUdldHRlcjtcbmNvbnN0IGdldFByZWZpeGVkQ2xhc3NHcm91cEVudHJpZXMgPSAoY2xhc3NHcm91cEVudHJpZXMsIHByZWZpeCkgPT4ge1xuICBpZiAoIXByZWZpeCkge1xuICAgIHJldHVybiBjbGFzc0dyb3VwRW50cmllcztcbiAgfVxuICByZXR1cm4gY2xhc3NHcm91cEVudHJpZXMubWFwKChbY2xhc3NHcm91cElkLCBjbGFzc0dyb3VwXSkgPT4ge1xuICAgIGNvbnN0IHByZWZpeGVkQ2xhc3NHcm91cCA9IGNsYXNzR3JvdXAubWFwKGNsYXNzRGVmaW5pdGlvbiA9PiB7XG4gICAgICBpZiAodHlwZW9mIGNsYXNzRGVmaW5pdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIGNsYXNzRGVmaW5pdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2xhc3NEZWZpbml0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNsYXNzRGVmaW5pdGlvbikubWFwKChba2V5LCB2YWx1ZV0pID0+IFtwcmVmaXggKyBrZXksIHZhbHVlXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsYXNzRGVmaW5pdGlvbjtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NsYXNzR3JvdXBJZCwgcHJlZml4ZWRDbGFzc0dyb3VwXTtcbiAgfSk7XG59O1xuXG4vLyBMUlUgY2FjaGUgaW5zcGlyZWQgZnJvbSBoYXNobHJ1IChodHRwczovL2dpdGh1Yi5jb20vZG9taW5pY3RhcnIvaGFzaGxydS9ibG9iL3YxLjAuNC9pbmRleC5qcykgYnV0IG9iamVjdCByZXBsYWNlZCB3aXRoIE1hcCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG5jb25zdCBjcmVhdGVMcnVDYWNoZSA9IG1heENhY2hlU2l6ZSA9PiB7XG4gIGlmIChtYXhDYWNoZVNpemUgPCAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgc2V0OiAoKSA9PiB7fVxuICAgIH07XG4gIH1cbiAgbGV0IGNhY2hlU2l6ZSA9IDA7XG4gIGxldCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgbGV0IHByZXZpb3VzQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHVwZGF0ZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIGNhY2hlU2l6ZSsrO1xuICAgIGlmIChjYWNoZVNpemUgPiBtYXhDYWNoZVNpemUpIHtcbiAgICAgIGNhY2hlU2l6ZSA9IDA7XG4gICAgICBwcmV2aW91c0NhY2hlID0gY2FjaGU7XG4gICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgbGV0IHZhbHVlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoKHZhbHVlID0gcHJldmlvdXNDYWNoZS5nZXQoa2V5KSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cGRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5jb25zdCBJTVBPUlRBTlRfTU9ESUZJRVIgPSAnISc7XG5jb25zdCBjcmVhdGVQYXJzZUNsYXNzTmFtZSA9IGNvbmZpZyA9PiB7XG4gIGNvbnN0IHtcbiAgICBzZXBhcmF0b3IsXG4gICAgZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWVcbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgaXNTZXBhcmF0b3JTaW5nbGVDaGFyYWN0ZXIgPSBzZXBhcmF0b3IubGVuZ3RoID09PSAxO1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckNoYXJhY3RlciA9IHNlcGFyYXRvclswXTtcbiAgY29uc3Qgc2VwYXJhdG9yTGVuZ3RoID0gc2VwYXJhdG9yLmxlbmd0aDtcbiAgLy8gcGFyc2VDbGFzc05hbWUgaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9ibG9iL3YzLjIuMi9zcmMvdXRpbC9zcGxpdEF0VG9wTGV2ZWxPbmx5LmpzXG4gIGNvbnN0IHBhcnNlQ2xhc3NOYW1lID0gY2xhc3NOYW1lID0+IHtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBbXTtcbiAgICBsZXQgYnJhY2tldERlcHRoID0gMDtcbiAgICBsZXQgbW9kaWZpZXJTdGFydCA9IDA7XG4gICAgbGV0IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjbGFzc05hbWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBsZXQgY3VycmVudENoYXJhY3RlciA9IGNsYXNzTmFtZVtpbmRleF07XG4gICAgICBpZiAoYnJhY2tldERlcHRoID09PSAwKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyID09PSBmaXJzdFNlcGFyYXRvckNoYXJhY3RlciAmJiAoaXNTZXBhcmF0b3JTaW5nbGVDaGFyYWN0ZXIgfHwgY2xhc3NOYW1lLnNsaWNlKGluZGV4LCBpbmRleCArIHNlcGFyYXRvckxlbmd0aCkgPT09IHNlcGFyYXRvcikpIHtcbiAgICAgICAgICBtb2RpZmllcnMucHVzaChjbGFzc05hbWUuc2xpY2UobW9kaWZpZXJTdGFydCwgaW5kZXgpKTtcbiAgICAgICAgICBtb2RpZmllclN0YXJ0ID0gaW5kZXggKyBzZXBhcmF0b3JMZW5ndGg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09ICcvJykge1xuICAgICAgICAgIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uID0gaW5kZXg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyID09PSAnWycpIHtcbiAgICAgICAgYnJhY2tldERlcHRoKys7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09ICddJykge1xuICAgICAgICBicmFja2V0RGVwdGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmFzZUNsYXNzTmFtZVdpdGhJbXBvcnRhbnRNb2RpZmllciA9IG1vZGlmaWVycy5sZW5ndGggPT09IDAgPyBjbGFzc05hbWUgOiBjbGFzc05hbWUuc3Vic3RyaW5nKG1vZGlmaWVyU3RhcnQpO1xuICAgIGNvbnN0IGhhc0ltcG9ydGFudE1vZGlmaWVyID0gYmFzZUNsYXNzTmFtZVdpdGhJbXBvcnRhbnRNb2RpZmllci5zdGFydHNXaXRoKElNUE9SVEFOVF9NT0RJRklFUik7XG4gICAgY29uc3QgYmFzZUNsYXNzTmFtZSA9IGhhc0ltcG9ydGFudE1vZGlmaWVyID8gYmFzZUNsYXNzTmFtZVdpdGhJbXBvcnRhbnRNb2RpZmllci5zdWJzdHJpbmcoMSkgOiBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyO1xuICAgIGNvbnN0IG1heWJlUG9zdGZpeE1vZGlmaWVyUG9zaXRpb24gPSBwb3N0Zml4TW9kaWZpZXJQb3NpdGlvbiAmJiBwb3N0Zml4TW9kaWZpZXJQb3NpdGlvbiA+IG1vZGlmaWVyU3RhcnQgPyBwb3N0Zml4TW9kaWZpZXJQb3NpdGlvbiAtIG1vZGlmaWVyU3RhcnQgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVycyxcbiAgICAgIGhhc0ltcG9ydGFudE1vZGlmaWVyLFxuICAgICAgYmFzZUNsYXNzTmFtZSxcbiAgICAgIG1heWJlUG9zdGZpeE1vZGlmaWVyUG9zaXRpb25cbiAgICB9O1xuICB9O1xuICBpZiAoZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUpIHtcbiAgICByZXR1cm4gY2xhc3NOYW1lID0+IGV4cGVyaW1lbnRhbFBhcnNlQ2xhc3NOYW1lKHtcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHBhcnNlQ2xhc3NOYW1lXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQ2xhc3NOYW1lO1xufTtcbi8qKlxuICogU29ydHMgbW9kaWZpZXJzIGFjY29yZGluZyB0byBmb2xsb3dpbmcgc2NoZW1hOlxuICogLSBQcmVkZWZpbmVkIG1vZGlmaWVycyBhcmUgc29ydGVkIGFscGhhYmV0aWNhbGx5XG4gKiAtIFdoZW4gYW4gYXJiaXRyYXJ5IHZhcmlhbnQgYXBwZWFycywgaXQgbXVzdCBiZSBwcmVzZXJ2ZWQgd2hpY2ggbW9kaWZpZXJzIGFyZSBiZWZvcmUgYW5kIGFmdGVyIGl0XG4gKi9cbmNvbnN0IHNvcnRNb2RpZmllcnMgPSBtb2RpZmllcnMgPT4ge1xuICBpZiAobW9kaWZpZXJzLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVycztcbiAgfVxuICBjb25zdCBzb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgbGV0IHVuc29ydGVkTW9kaWZpZXJzID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKG1vZGlmaWVyID0+IHtcbiAgICBjb25zdCBpc0FyYml0cmFyeVZhcmlhbnQgPSBtb2RpZmllclswXSA9PT0gJ1snO1xuICAgIGlmIChpc0FyYml0cmFyeVZhcmlhbnQpIHtcbiAgICAgIHNvcnRlZE1vZGlmaWVycy5wdXNoKC4uLnVuc29ydGVkTW9kaWZpZXJzLnNvcnQoKSwgbW9kaWZpZXIpO1xuICAgICAgdW5zb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5zb3J0ZWRNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgc29ydGVkTW9kaWZpZXJzLnB1c2goLi4udW5zb3J0ZWRNb2RpZmllcnMuc29ydCgpKTtcbiAgcmV0dXJuIHNvcnRlZE1vZGlmaWVycztcbn07XG5jb25zdCBjcmVhdGVDb25maWdVdGlscyA9IGNvbmZpZyA9PiAoe1xuICBjYWNoZTogY3JlYXRlTHJ1Q2FjaGUoY29uZmlnLmNhY2hlU2l6ZSksXG4gIHBhcnNlQ2xhc3NOYW1lOiBjcmVhdGVQYXJzZUNsYXNzTmFtZShjb25maWcpLFxuICAuLi5jcmVhdGVDbGFzc0dyb3VwVXRpbHMoY29uZmlnKVxufSk7XG5jb25zdCBTUExJVF9DTEFTU0VTX1JFR0VYID0gL1xccysvO1xuY29uc3QgbWVyZ2VDbGFzc0xpc3QgPSAoY2xhc3NMaXN0LCBjb25maWdVdGlscykgPT4ge1xuICBjb25zdCB7XG4gICAgcGFyc2VDbGFzc05hbWUsXG4gICAgZ2V0Q2xhc3NHcm91cElkLFxuICAgIGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkc1xuICB9ID0gY29uZmlnVXRpbHM7XG4gIC8qKlxuICAgKiBTZXQgb2YgY2xhc3NHcm91cElkcyBpbiBmb2xsb3dpbmcgZm9ybWF0OlxuICAgKiBge2ltcG9ydGFudE1vZGlmaWVyfXt2YXJpYW50TW9kaWZpZXJzfXtjbGFzc0dyb3VwSWR9YFxuICAgKiBAZXhhbXBsZSAnZmxvYXQnXG4gICAqIEBleGFtcGxlICdob3Zlcjpmb2N1czpiZy1jb2xvcidcbiAgICogQGV4YW1wbGUgJ21kOiFwcidcbiAgICovXG4gIGNvbnN0IGNsYXNzR3JvdXBzSW5Db25mbGljdCA9IFtdO1xuICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NMaXN0LnRyaW0oKS5zcGxpdChTUExJVF9DTEFTU0VTX1JFR0VYKTtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBmb3IgKGxldCBpbmRleCA9IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXggLT0gMSkge1xuICAgIGNvbnN0IG9yaWdpbmFsQ2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpbmRleF07XG4gICAgY29uc3Qge1xuICAgICAgbW9kaWZpZXJzLFxuICAgICAgaGFzSW1wb3J0YW50TW9kaWZpZXIsXG4gICAgICBiYXNlQ2xhc3NOYW1lLFxuICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvblxuICAgIH0gPSBwYXJzZUNsYXNzTmFtZShvcmlnaW5hbENsYXNzTmFtZSk7XG4gICAgbGV0IGhhc1Bvc3RmaXhNb2RpZmllciA9IEJvb2xlYW4obWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbik7XG4gICAgbGV0IGNsYXNzR3JvdXBJZCA9IGdldENsYXNzR3JvdXBJZChoYXNQb3N0Zml4TW9kaWZpZXIgPyBiYXNlQ2xhc3NOYW1lLnN1YnN0cmluZygwLCBtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uKSA6IGJhc2VDbGFzc05hbWUpO1xuICAgIGlmICghY2xhc3NHcm91cElkKSB7XG4gICAgICBpZiAoIWhhc1Bvc3RmaXhNb2RpZmllcikge1xuICAgICAgICAvLyBOb3QgYSBUYWlsd2luZCBjbGFzc1xuICAgICAgICByZXN1bHQgPSBvcmlnaW5hbENsYXNzTmFtZSArIChyZXN1bHQubGVuZ3RoID4gMCA/ICcgJyArIHJlc3VsdCA6IHJlc3VsdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2xhc3NHcm91cElkID0gZ2V0Q2xhc3NHcm91cElkKGJhc2VDbGFzc05hbWUpO1xuICAgICAgaWYgKCFjbGFzc0dyb3VwSWQpIHtcbiAgICAgICAgLy8gTm90IGEgVGFpbHdpbmQgY2xhc3NcbiAgICAgICAgcmVzdWx0ID0gb3JpZ2luYWxDbGFzc05hbWUgKyAocmVzdWx0Lmxlbmd0aCA+IDAgPyAnICcgKyByZXN1bHQgOiByZXN1bHQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGhhc1Bvc3RmaXhNb2RpZmllciA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB2YXJpYW50TW9kaWZpZXIgPSBzb3J0TW9kaWZpZXJzKG1vZGlmaWVycykuam9pbignOicpO1xuICAgIGNvbnN0IG1vZGlmaWVySWQgPSBoYXNJbXBvcnRhbnRNb2RpZmllciA/IHZhcmlhbnRNb2RpZmllciArIElNUE9SVEFOVF9NT0RJRklFUiA6IHZhcmlhbnRNb2RpZmllcjtcbiAgICBjb25zdCBjbGFzc0lkID0gbW9kaWZpZXJJZCArIGNsYXNzR3JvdXBJZDtcbiAgICBpZiAoY2xhc3NHcm91cHNJbkNvbmZsaWN0LmluY2x1ZGVzKGNsYXNzSWQpKSB7XG4gICAgICAvLyBUYWlsd2luZCBjbGFzcyBvbWl0dGVkIGR1ZSB0byBjb25mbGljdFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNsYXNzR3JvdXBzSW5Db25mbGljdC5wdXNoKGNsYXNzSWQpO1xuICAgIGNvbnN0IGNvbmZsaWN0R3JvdXBzID0gZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzKGNsYXNzR3JvdXBJZCwgaGFzUG9zdGZpeE1vZGlmaWVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZsaWN0R3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBncm91cCA9IGNvbmZsaWN0R3JvdXBzW2ldO1xuICAgICAgY2xhc3NHcm91cHNJbkNvbmZsaWN0LnB1c2gobW9kaWZpZXJJZCArIGdyb3VwKTtcbiAgICB9XG4gICAgLy8gVGFpbHdpbmQgY2xhc3Mgbm90IGluIGNvbmZsaWN0XG4gICAgcmVzdWx0ID0gb3JpZ2luYWxDbGFzc05hbWUgKyAocmVzdWx0Lmxlbmd0aCA+IDAgPyAnICcgKyByZXN1bHQgOiByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRoZSBjb2RlIGluIHRoaXMgZmlsZSBpcyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbHVrZWVkL2Nsc3ggYW5kIG1vZGlmaWVkIHRvIHN1aXQgdGhlIG5lZWRzIG9mIHRhaWx3aW5kLW1lcmdlIGJldHRlci5cbiAqXG4gKiBTcGVjaWZpY2FsbHk6XG4gKiAtIFJ1bnRpbWUgY29kZSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sdWtlZWQvY2xzeC9ibG9iL3YxLjIuMS9zcmMvaW5kZXguanNcbiAqIC0gVHlwZVNjcmlwdCB0eXBlcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sdWtlZWQvY2xzeC9ibG9iL3YxLjIuMS9jbHN4LmQudHNcbiAqXG4gKiBPcmlnaW5hbCBjb2RlIGhhcyBNSVQgbGljZW5zZTogQ29weXJpZ2h0IChjKSBMdWtlIEVkd2FyZHMgPGx1a2UuZWR3YXJkczA1QGdtYWlsLmNvbT4gKGx1a2VlZC5jb20pXG4gKi9cbmZ1bmN0aW9uIHR3Sm9pbigpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGFyZ3VtZW50O1xuICBsZXQgcmVzb2x2ZWRWYWx1ZTtcbiAgbGV0IHN0cmluZyA9ICcnO1xuICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKGFyZ3VtZW50ID0gYXJndW1lbnRzW2luZGV4KytdKSB7XG4gICAgICBpZiAocmVzb2x2ZWRWYWx1ZSA9IHRvVmFsdWUoYXJndW1lbnQpKSB7XG4gICAgICAgIHN0cmluZyAmJiAoc3RyaW5nICs9ICcgJyk7XG4gICAgICAgIHN0cmluZyArPSByZXNvbHZlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufVxuY29uc3QgdG9WYWx1ZSA9IG1peCA9PiB7XG4gIGlmICh0eXBlb2YgbWl4ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtaXg7XG4gIH1cbiAgbGV0IHJlc29sdmVkVmFsdWU7XG4gIGxldCBzdHJpbmcgPSAnJztcbiAgZm9yIChsZXQgayA9IDA7IGsgPCBtaXgubGVuZ3RoOyBrKyspIHtcbiAgICBpZiAobWl4W2tdKSB7XG4gICAgICBpZiAocmVzb2x2ZWRWYWx1ZSA9IHRvVmFsdWUobWl4W2tdKSkge1xuICAgICAgICBzdHJpbmcgJiYgKHN0cmluZyArPSAnICcpO1xuICAgICAgICBzdHJpbmcgKz0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn07XG5mdW5jdGlvbiBjcmVhdGVUYWlsd2luZE1lcmdlKGNyZWF0ZUNvbmZpZ0ZpcnN0LCAuLi5jcmVhdGVDb25maWdSZXN0KSB7XG4gIGxldCBjb25maWdVdGlscztcbiAgbGV0IGNhY2hlR2V0O1xuICBsZXQgY2FjaGVTZXQ7XG4gIGxldCBmdW5jdGlvblRvQ2FsbCA9IGluaXRUYWlsd2luZE1lcmdlO1xuICBmdW5jdGlvbiBpbml0VGFpbHdpbmRNZXJnZShjbGFzc0xpc3QpIHtcbiAgICBjb25zdCBjb25maWcgPSBjcmVhdGVDb25maWdSZXN0LnJlZHVjZSgocHJldmlvdXNDb25maWcsIGNyZWF0ZUNvbmZpZ0N1cnJlbnQpID0+IGNyZWF0ZUNvbmZpZ0N1cnJlbnQocHJldmlvdXNDb25maWcpLCBjcmVhdGVDb25maWdGaXJzdCgpKTtcbiAgICBjb25maWdVdGlscyA9IGNyZWF0ZUNvbmZpZ1V0aWxzKGNvbmZpZyk7XG4gICAgY2FjaGVHZXQgPSBjb25maWdVdGlscy5jYWNoZS5nZXQ7XG4gICAgY2FjaGVTZXQgPSBjb25maWdVdGlscy5jYWNoZS5zZXQ7XG4gICAgZnVuY3Rpb25Ub0NhbGwgPSB0YWlsd2luZE1lcmdlO1xuICAgIHJldHVybiB0YWlsd2luZE1lcmdlKGNsYXNzTGlzdCk7XG4gIH1cbiAgZnVuY3Rpb24gdGFpbHdpbmRNZXJnZShjbGFzc0xpc3QpIHtcbiAgICBjb25zdCBjYWNoZWRSZXN1bHQgPSBjYWNoZUdldChjbGFzc0xpc3QpO1xuICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG1lcmdlQ2xhc3NMaXN0KGNsYXNzTGlzdCwgY29uZmlnVXRpbHMpO1xuICAgIGNhY2hlU2V0KGNsYXNzTGlzdCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBjYWxsVGFpbHdpbmRNZXJnZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub0NhbGwodHdKb2luLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuY29uc3QgZnJvbVRoZW1lID0ga2V5ID0+IHtcbiAgY29uc3QgdGhlbWVHZXR0ZXIgPSB0aGVtZSA9PiB0aGVtZVtrZXldIHx8IFtdO1xuICB0aGVtZUdldHRlci5pc1RoZW1lR2V0dGVyID0gdHJ1ZTtcbiAgcmV0dXJuIHRoZW1lR2V0dGVyO1xufTtcbmNvbnN0IGFyYml0cmFyeVZhbHVlUmVnZXggPSAvXlxcWyg/OihbYS16LV0rKTopPyguKylcXF0kL2k7XG5jb25zdCBmcmFjdGlvblJlZ2V4ID0gL15cXGQrXFwvXFxkKyQvO1xuY29uc3Qgc3RyaW5nTGVuZ3RocyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsncHgnLCAnZnVsbCcsICdzY3JlZW4nXSk7XG5jb25zdCB0c2hpcnRVbml0UmVnZXggPSAvXihcXGQrKFxcLlxcZCspPyk/KHhzfHNtfG1kfGxnfHhsKSQvO1xuY29uc3QgbGVuZ3RoVW5pdFJlZ2V4ID0gL1xcZCsoJXxweHxyP2VtfFtzZGxdP3YoW2h3aWJdfG1pbnxtYXgpfHB0fHBjfGlufGNtfG1tfGNhcHxjaHxleHxyP2xofGNxKHd8aHxpfGJ8bWlufG1heCkpfFxcYihjYWxjfG1pbnxtYXh8Y2xhbXApXFwoLitcXCl8XjAkLztcbmNvbnN0IGNvbG9yRnVuY3Rpb25SZWdleCA9IC9eKHJnYmE/fGhzbGE/fGh3Ynwob2spPyhsYWJ8bGNoKSlcXCguK1xcKSQvO1xuLy8gU2hhZG93IGFsd2F5cyBiZWdpbnMgd2l0aCB4IGFuZCB5IG9mZnNldCBzZXBhcmF0ZWQgYnkgdW5kZXJzY29yZSBvcHRpb25hbGx5IHByZXBlbmRlZCBieSBpbnNldFxuY29uc3Qgc2hhZG93UmVnZXggPSAvXihpbnNldF8pPy0/KChcXGQrKT9cXC4/KFxcZCspW2Etel0rfDApXy0/KChcXGQrKT9cXC4/KFxcZCspW2Etel0rfDApLztcbmNvbnN0IGltYWdlUmVnZXggPSAvXih1cmx8aW1hZ2V8aW1hZ2Utc2V0fGNyb3NzLWZhZGV8ZWxlbWVudHwocmVwZWF0aW5nLSk/KGxpbmVhcnxyYWRpYWx8Y29uaWMpLWdyYWRpZW50KVxcKC4rXFwpJC87XG5jb25zdCBpc0xlbmd0aCA9IHZhbHVlID0+IGlzTnVtYmVyKHZhbHVlKSB8fCBzdHJpbmdMZW5ndGhzLmhhcyh2YWx1ZSkgfHwgZnJhY3Rpb25SZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IGlzQXJiaXRyYXJ5TGVuZ3RoID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgJ2xlbmd0aCcsIGlzTGVuZ3RoT25seSk7XG5jb25zdCBpc051bWJlciA9IHZhbHVlID0+IEJvb2xlYW4odmFsdWUpICYmICFOdW1iZXIuaXNOYU4oTnVtYmVyKHZhbHVlKSk7XG5jb25zdCBpc0FyYml0cmFyeU51bWJlciA9IHZhbHVlID0+IGdldElzQXJiaXRyYXJ5VmFsdWUodmFsdWUsICdudW1iZXInLCBpc051bWJlcik7XG5jb25zdCBpc0ludGVnZXIgPSB2YWx1ZSA9PiBCb29sZWFuKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcih2YWx1ZSkpO1xuY29uc3QgaXNQZXJjZW50ID0gdmFsdWUgPT4gdmFsdWUuZW5kc1dpdGgoJyUnKSAmJiBpc051bWJlcih2YWx1ZS5zbGljZSgwLCAtMSkpO1xuY29uc3QgaXNBcmJpdHJhcnlWYWx1ZSA9IHZhbHVlID0+IGFyYml0cmFyeVZhbHVlUmVnZXgudGVzdCh2YWx1ZSk7XG5jb25zdCBpc1RzaGlydFNpemUgPSB2YWx1ZSA9PiB0c2hpcnRVbml0UmVnZXgudGVzdCh2YWx1ZSk7XG5jb25zdCBzaXplTGFiZWxzID0gLyojX19QVVJFX18qL25ldyBTZXQoWydsZW5ndGgnLCAnc2l6ZScsICdwZXJjZW50YWdlJ10pO1xuY29uc3QgaXNBcmJpdHJhcnlTaXplID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgc2l6ZUxhYmVscywgaXNOZXZlcik7XG5jb25zdCBpc0FyYml0cmFyeVBvc2l0aW9uID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgJ3Bvc2l0aW9uJywgaXNOZXZlcik7XG5jb25zdCBpbWFnZUxhYmVscyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsnaW1hZ2UnLCAndXJsJ10pO1xuY29uc3QgaXNBcmJpdHJhcnlJbWFnZSA9IHZhbHVlID0+IGdldElzQXJiaXRyYXJ5VmFsdWUodmFsdWUsIGltYWdlTGFiZWxzLCBpc0ltYWdlKTtcbmNvbnN0IGlzQXJiaXRyYXJ5U2hhZG93ID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgJycsIGlzU2hhZG93KTtcbmNvbnN0IGlzQW55ID0gKCkgPT4gdHJ1ZTtcbmNvbnN0IGdldElzQXJiaXRyYXJ5VmFsdWUgPSAodmFsdWUsIGxhYmVsLCB0ZXN0VmFsdWUpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gYXJiaXRyYXJ5VmFsdWVSZWdleC5leGVjKHZhbHVlKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHRbMV0pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnID8gcmVzdWx0WzFdID09PSBsYWJlbCA6IGxhYmVsLmhhcyhyZXN1bHRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGVzdFZhbHVlKHJlc3VsdFsyXSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGlzTGVuZ3RoT25seSA9IHZhbHVlID0+XG4vLyBgY29sb3JGdW5jdGlvblJlZ2V4YCBjaGVjayBpcyBuZWNlc3NhcnkgYmVjYXVzZSBjb2xvciBmdW5jdGlvbnMgY2FuIGhhdmUgcGVyY2VudGFnZXMgaW4gdGhlbSB3aGljaCB3aGljaCB3b3VsZCBiZSBpbmNvcnJlY3RseSBjbGFzc2lmaWVkIGFzIGxlbmd0aHMuXG4vLyBGb3IgZXhhbXBsZSwgYGhzbCgwIDAlIDAlKWAgd291bGQgYmUgY2xhc3NpZmllZCBhcyBhIGxlbmd0aCB3aXRob3V0IHRoaXMgY2hlY2suXG4vLyBJIGNvdWxkIGFsc28gdXNlIGxvb2tiZWhpbmQgYXNzZXJ0aW9uIGluIGBsZW5ndGhVbml0UmVnZXhgIGJ1dCB0aGF0IGlzbid0IHN1cHBvcnRlZCB3aWRlbHkgZW5vdWdoLlxubGVuZ3RoVW5pdFJlZ2V4LnRlc3QodmFsdWUpICYmICFjb2xvckZ1bmN0aW9uUmVnZXgudGVzdCh2YWx1ZSk7XG5jb25zdCBpc05ldmVyID0gKCkgPT4gZmFsc2U7XG5jb25zdCBpc1NoYWRvdyA9IHZhbHVlID0+IHNoYWRvd1JlZ2V4LnRlc3QodmFsdWUpO1xuY29uc3QgaXNJbWFnZSA9IHZhbHVlID0+IGltYWdlUmVnZXgudGVzdCh2YWx1ZSk7XG5jb25zdCB2YWxpZGF0b3JzID0gLyojX19QVVJFX18qL09iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgaXNBbnksXG4gIGlzQXJiaXRyYXJ5SW1hZ2UsXG4gIGlzQXJiaXRyYXJ5TGVuZ3RoLFxuICBpc0FyYml0cmFyeU51bWJlcixcbiAgaXNBcmJpdHJhcnlQb3NpdGlvbixcbiAgaXNBcmJpdHJhcnlTaGFkb3csXG4gIGlzQXJiaXRyYXJ5U2l6ZSxcbiAgaXNBcmJpdHJhcnlWYWx1ZSxcbiAgaXNJbnRlZ2VyLFxuICBpc0xlbmd0aCxcbiAgaXNOdW1iZXIsXG4gIGlzUGVyY2VudCxcbiAgaXNUc2hpcnRTaXplXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgdmFsdWU6ICdNb2R1bGUnXG59KTtcbmNvbnN0IGdldERlZmF1bHRDb25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbG9ycyA9IGZyb21UaGVtZSgnY29sb3JzJyk7XG4gIGNvbnN0IHNwYWNpbmcgPSBmcm9tVGhlbWUoJ3NwYWNpbmcnKTtcbiAgY29uc3QgYmx1ciA9IGZyb21UaGVtZSgnYmx1cicpO1xuICBjb25zdCBicmlnaHRuZXNzID0gZnJvbVRoZW1lKCdicmlnaHRuZXNzJyk7XG4gIGNvbnN0IGJvcmRlckNvbG9yID0gZnJvbVRoZW1lKCdib3JkZXJDb2xvcicpO1xuICBjb25zdCBib3JkZXJSYWRpdXMgPSBmcm9tVGhlbWUoJ2JvcmRlclJhZGl1cycpO1xuICBjb25zdCBib3JkZXJTcGFjaW5nID0gZnJvbVRoZW1lKCdib3JkZXJTcGFjaW5nJyk7XG4gIGNvbnN0IGJvcmRlcldpZHRoID0gZnJvbVRoZW1lKCdib3JkZXJXaWR0aCcpO1xuICBjb25zdCBjb250cmFzdCA9IGZyb21UaGVtZSgnY29udHJhc3QnKTtcbiAgY29uc3QgZ3JheXNjYWxlID0gZnJvbVRoZW1lKCdncmF5c2NhbGUnKTtcbiAgY29uc3QgaHVlUm90YXRlID0gZnJvbVRoZW1lKCdodWVSb3RhdGUnKTtcbiAgY29uc3QgaW52ZXJ0ID0gZnJvbVRoZW1lKCdpbnZlcnQnKTtcbiAgY29uc3QgZ2FwID0gZnJvbVRoZW1lKCdnYXAnKTtcbiAgY29uc3QgZ3JhZGllbnRDb2xvclN0b3BzID0gZnJvbVRoZW1lKCdncmFkaWVudENvbG9yU3RvcHMnKTtcbiAgY29uc3QgZ3JhZGllbnRDb2xvclN0b3BQb3NpdGlvbnMgPSBmcm9tVGhlbWUoJ2dyYWRpZW50Q29sb3JTdG9wUG9zaXRpb25zJyk7XG4gIGNvbnN0IGluc2V0ID0gZnJvbVRoZW1lKCdpbnNldCcpO1xuICBjb25zdCBtYXJnaW4gPSBmcm9tVGhlbWUoJ21hcmdpbicpO1xuICBjb25zdCBvcGFjaXR5ID0gZnJvbVRoZW1lKCdvcGFjaXR5Jyk7XG4gIGNvbnN0IHBhZGRpbmcgPSBmcm9tVGhlbWUoJ3BhZGRpbmcnKTtcbiAgY29uc3Qgc2F0dXJhdGUgPSBmcm9tVGhlbWUoJ3NhdHVyYXRlJyk7XG4gIGNvbnN0IHNjYWxlID0gZnJvbVRoZW1lKCdzY2FsZScpO1xuICBjb25zdCBzZXBpYSA9IGZyb21UaGVtZSgnc2VwaWEnKTtcbiAgY29uc3Qgc2tldyA9IGZyb21UaGVtZSgnc2tldycpO1xuICBjb25zdCBzcGFjZSA9IGZyb21UaGVtZSgnc3BhY2UnKTtcbiAgY29uc3QgdHJhbnNsYXRlID0gZnJvbVRoZW1lKCd0cmFuc2xhdGUnKTtcbiAgY29uc3QgZ2V0T3ZlcnNjcm9sbCA9ICgpID0+IFsnYXV0bycsICdjb250YWluJywgJ25vbmUnXTtcbiAgY29uc3QgZ2V0T3ZlcmZsb3cgPSAoKSA9PiBbJ2F1dG8nLCAnaGlkZGVuJywgJ2NsaXAnLCAndmlzaWJsZScsICdzY3JvbGwnXTtcbiAgY29uc3QgZ2V0U3BhY2luZ1dpdGhBdXRvQW5kQXJiaXRyYXJ5ID0gKCkgPT4gWydhdXRvJywgaXNBcmJpdHJhcnlWYWx1ZSwgc3BhY2luZ107XG4gIGNvbnN0IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5ID0gKCkgPT4gW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmddO1xuICBjb25zdCBnZXRMZW5ndGhXaXRoRW1wdHlBbmRBcmJpdHJhcnkgPSAoKSA9PiBbJycsIGlzTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF07XG4gIGNvbnN0IGdldE51bWJlcldpdGhBdXRvQW5kQXJiaXRyYXJ5ID0gKCkgPT4gWydhdXRvJywgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFsdWVdO1xuICBjb25zdCBnZXRQb3NpdGlvbnMgPSAoKSA9PiBbJ2JvdHRvbScsICdjZW50ZXInLCAnbGVmdCcsICdsZWZ0LWJvdHRvbScsICdsZWZ0LXRvcCcsICdyaWdodCcsICdyaWdodC1ib3R0b20nLCAncmlnaHQtdG9wJywgJ3RvcCddO1xuICBjb25zdCBnZXRMaW5lU3R5bGVzID0gKCkgPT4gWydzb2xpZCcsICdkYXNoZWQnLCAnZG90dGVkJywgJ2RvdWJsZScsICdub25lJ107XG4gIGNvbnN0IGdldEJsZW5kTW9kZXMgPSAoKSA9PiBbJ25vcm1hbCcsICdtdWx0aXBseScsICdzY3JlZW4nLCAnb3ZlcmxheScsICdkYXJrZW4nLCAnbGlnaHRlbicsICdjb2xvci1kb2RnZScsICdjb2xvci1idXJuJywgJ2hhcmQtbGlnaHQnLCAnc29mdC1saWdodCcsICdkaWZmZXJlbmNlJywgJ2V4Y2x1c2lvbicsICdodWUnLCAnc2F0dXJhdGlvbicsICdjb2xvcicsICdsdW1pbm9zaXR5J107XG4gIGNvbnN0IGdldEFsaWduID0gKCkgPT4gWydzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ2JldHdlZW4nLCAnYXJvdW5kJywgJ2V2ZW5seScsICdzdHJldGNoJ107XG4gIGNvbnN0IGdldFplcm9BbmRFbXB0eSA9ICgpID0+IFsnJywgJzAnLCBpc0FyYml0cmFyeVZhbHVlXTtcbiAgY29uc3QgZ2V0QnJlYWtzID0gKCkgPT4gWydhdXRvJywgJ2F2b2lkJywgJ2FsbCcsICdhdm9pZC1wYWdlJywgJ3BhZ2UnLCAnbGVmdCcsICdyaWdodCcsICdjb2x1bW4nXTtcbiAgY29uc3QgZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5ID0gKCkgPT4gW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhbHVlXTtcbiAgcmV0dXJuIHtcbiAgICBjYWNoZVNpemU6IDUwMCxcbiAgICBzZXBhcmF0b3I6ICc6JyxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzOiBbaXNBbnldLFxuICAgICAgc3BhY2luZzogW2lzTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF0sXG4gICAgICBibHVyOiBbJ25vbmUnLCAnJywgaXNUc2hpcnRTaXplLCBpc0FyYml0cmFyeVZhbHVlXSxcbiAgICAgIGJyaWdodG5lc3M6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgYm9yZGVyQ29sb3I6IFtjb2xvcnNdLFxuICAgICAgYm9yZGVyUmFkaXVzOiBbJ25vbmUnLCAnJywgJ2Z1bGwnLCBpc1RzaGlydFNpemUsIGlzQXJiaXRyYXJ5VmFsdWVdLFxuICAgICAgYm9yZGVyU3BhY2luZzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKSxcbiAgICAgIGJvcmRlcldpZHRoOiBnZXRMZW5ndGhXaXRoRW1wdHlBbmRBcmJpdHJhcnkoKSxcbiAgICAgIGNvbnRyYXN0OiBnZXROdW1iZXJBbmRBcmJpdHJhcnkoKSxcbiAgICAgIGdyYXlzY2FsZTogZ2V0WmVyb0FuZEVtcHR5KCksXG4gICAgICBodWVSb3RhdGU6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgaW52ZXJ0OiBnZXRaZXJvQW5kRW1wdHkoKSxcbiAgICAgIGdhcDogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKSxcbiAgICAgIGdyYWRpZW50Q29sb3JTdG9wczogW2NvbG9yc10sXG4gICAgICBncmFkaWVudENvbG9yU3RvcFBvc2l0aW9uczogW2lzUGVyY2VudCwgaXNBcmJpdHJhcnlMZW5ndGhdLFxuICAgICAgaW5zZXQ6IGdldFNwYWNpbmdXaXRoQXV0b0FuZEFyYml0cmFyeSgpLFxuICAgICAgbWFyZ2luOiBnZXRTcGFjaW5nV2l0aEF1dG9BbmRBcmJpdHJhcnkoKSxcbiAgICAgIG9wYWNpdHk6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgcGFkZGluZzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKSxcbiAgICAgIHNhdHVyYXRlOiBnZXROdW1iZXJBbmRBcmJpdHJhcnkoKSxcbiAgICAgIHNjYWxlOiBnZXROdW1iZXJBbmRBcmJpdHJhcnkoKSxcbiAgICAgIHNlcGlhOiBnZXRaZXJvQW5kRW1wdHkoKSxcbiAgICAgIHNrZXc6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgc3BhY2U6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KCksXG4gICAgICB0cmFuc2xhdGU6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICB9LFxuICAgIGNsYXNzR3JvdXBzOiB7XG4gICAgICAvLyBMYXlvdXRcbiAgICAgIC8qKlxuICAgICAgICogQXNwZWN0IFJhdGlvXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYXNwZWN0LXJhdGlvXG4gICAgICAgKi9cbiAgICAgIGFzcGVjdDogW3tcbiAgICAgICAgYXNwZWN0OiBbJ2F1dG8nLCAnc3F1YXJlJywgJ3ZpZGVvJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDb250YWluZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb250YWluZXJcbiAgICAgICAqL1xuICAgICAgY29udGFpbmVyOiBbJ2NvbnRhaW5lciddLFxuICAgICAgLyoqXG4gICAgICAgKiBDb2x1bW5zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29sdW1uc1xuICAgICAgICovXG4gICAgICBjb2x1bW5zOiBbe1xuICAgICAgICBjb2x1bW5zOiBbaXNUc2hpcnRTaXplXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEFmdGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstYWZ0ZXJcbiAgICAgICAqL1xuICAgICAgJ2JyZWFrLWFmdGVyJzogW3tcbiAgICAgICAgJ2JyZWFrLWFmdGVyJzogZ2V0QnJlYWtzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCcmVhayBCZWZvcmVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9icmVhay1iZWZvcmVcbiAgICAgICAqL1xuICAgICAgJ2JyZWFrLWJlZm9yZSc6IFt7XG4gICAgICAgICdicmVhay1iZWZvcmUnOiBnZXRCcmVha3MoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEluc2lkZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyZWFrLWluc2lkZVxuICAgICAgICovXG4gICAgICAnYnJlYWstaW5zaWRlJzogW3tcbiAgICAgICAgJ2JyZWFrLWluc2lkZSc6IFsnYXV0bycsICdhdm9pZCcsICdhdm9pZC1wYWdlJywgJ2F2b2lkLWNvbHVtbiddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm94IERlY29yYXRpb24gQnJlYWtcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtZGVjb3JhdGlvbi1icmVha1xuICAgICAgICovXG4gICAgICAnYm94LWRlY29yYXRpb24nOiBbe1xuICAgICAgICAnYm94LWRlY29yYXRpb24nOiBbJ3NsaWNlJywgJ2Nsb25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3ggU2l6aW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNpemluZ1xuICAgICAgICovXG4gICAgICBib3g6IFt7XG4gICAgICAgIGJveDogWydib3JkZXInLCAnY29udGVudCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGlzcGxheVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Rpc3BsYXlcbiAgICAgICAqL1xuICAgICAgZGlzcGxheTogWydibG9jaycsICdpbmxpbmUtYmxvY2snLCAnaW5saW5lJywgJ2ZsZXgnLCAnaW5saW5lLWZsZXgnLCAndGFibGUnLCAnaW5saW5lLXRhYmxlJywgJ3RhYmxlLWNhcHRpb24nLCAndGFibGUtY2VsbCcsICd0YWJsZS1jb2x1bW4nLCAndGFibGUtY29sdW1uLWdyb3VwJywgJ3RhYmxlLWZvb3Rlci1ncm91cCcsICd0YWJsZS1oZWFkZXItZ3JvdXAnLCAndGFibGUtcm93LWdyb3VwJywgJ3RhYmxlLXJvdycsICdmbG93LXJvb3QnLCAnZ3JpZCcsICdpbmxpbmUtZ3JpZCcsICdjb250ZW50cycsICdsaXN0LWl0ZW0nLCAnaGlkZGVuJ10sXG4gICAgICAvKipcbiAgICAgICAqIEZsb2F0c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Zsb2F0XG4gICAgICAgKi9cbiAgICAgIGZsb2F0OiBbe1xuICAgICAgICBmbG9hdDogWydyaWdodCcsICdsZWZ0JywgJ25vbmUnLCAnc3RhcnQnLCAnZW5kJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NsZWFyXG4gICAgICAgKi9cbiAgICAgIGNsZWFyOiBbe1xuICAgICAgICBjbGVhcjogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvdGgnLCAnbm9uZScsICdzdGFydCcsICdlbmQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIElzb2xhdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2lzb2xhdGlvblxuICAgICAgICovXG4gICAgICBpc29sYXRpb246IFsnaXNvbGF0ZScsICdpc29sYXRpb24tYXV0byddLFxuICAgICAgLyoqXG4gICAgICAgKiBPYmplY3QgRml0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb2JqZWN0LWZpdFxuICAgICAgICovXG4gICAgICAnb2JqZWN0LWZpdCc6IFt7XG4gICAgICAgIG9iamVjdDogWydjb250YWluJywgJ2NvdmVyJywgJ2ZpbGwnLCAnbm9uZScsICdzY2FsZS1kb3duJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPYmplY3QgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vYmplY3QtcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgJ29iamVjdC1wb3NpdGlvbic6IFt7XG4gICAgICAgIG9iamVjdDogWy4uLmdldFBvc2l0aW9ucygpLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJmbG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgb3ZlcmZsb3c6IFt7XG4gICAgICAgIG92ZXJmbG93OiBnZXRPdmVyZmxvdygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3cgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgICdvdmVyZmxvdy14JzogW3tcbiAgICAgICAgJ292ZXJmbG93LXgnOiBnZXRPdmVyZmxvdygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3cgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgICdvdmVyZmxvdy15JzogW3tcbiAgICAgICAgJ292ZXJmbG93LXknOiBnZXRPdmVyZmxvdygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJzY3JvbGwtYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgb3ZlcnNjcm9sbDogW3tcbiAgICAgICAgb3ZlcnNjcm9sbDogZ2V0T3ZlcnNjcm9sbCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvciBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICAnb3ZlcnNjcm9sbC14JzogW3tcbiAgICAgICAgJ292ZXJzY3JvbGwteCc6IGdldE92ZXJzY3JvbGwoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJzY3JvbGwgQmVoYXZpb3IgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJzY3JvbGwtYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgJ292ZXJzY3JvbGwteSc6IFt7XG4gICAgICAgICdvdmVyc2Nyb2xsLXknOiBnZXRPdmVyc2Nyb2xsKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Bvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgIHBvc2l0aW9uOiBbJ3N0YXRpYycsICdmaXhlZCcsICdhYnNvbHV0ZScsICdyZWxhdGl2ZScsICdzdGlja3knXSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wIC8gUmlnaHQgLyBCb3R0b20gLyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIGluc2V0OiBbe1xuICAgICAgICBpbnNldDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpZ2h0IC8gTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICAnaW5zZXQteCc6IFt7XG4gICAgICAgICdpbnNldC14JzogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvcCAvIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICAnaW5zZXQteSc6IFt7XG4gICAgICAgICdpbnNldC15JzogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIHN0YXJ0OiBbe1xuICAgICAgICBzdGFydDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBlbmQ6IFt7XG4gICAgICAgIGVuZDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICB0b3A6IFt7XG4gICAgICAgIHRvcDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIHJpZ2h0OiBbe1xuICAgICAgICByaWdodDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBib3R0b206IFt7XG4gICAgICAgIGJvdHRvbTogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgbGVmdDogW3tcbiAgICAgICAgbGVmdDogW2luc2V0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFZpc2liaWxpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy92aXNpYmlsaXR5XG4gICAgICAgKi9cbiAgICAgIHZpc2liaWxpdHk6IFsndmlzaWJsZScsICdpbnZpc2libGUnLCAnY29sbGFwc2UnXSxcbiAgICAgIC8qKlxuICAgICAgICogWi1JbmRleFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3otaW5kZXhcbiAgICAgICAqL1xuICAgICAgejogW3tcbiAgICAgICAgejogWydhdXRvJywgaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvLyBGbGV4Ym94IGFuZCBHcmlkXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggQmFzaXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LWJhc2lzXG4gICAgICAgKi9cbiAgICAgIGJhc2lzOiBbe1xuICAgICAgICBiYXNpczogZ2V0U3BhY2luZ1dpdGhBdXRvQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IERpcmVjdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtZGlyZWN0aW9uXG4gICAgICAgKi9cbiAgICAgICdmbGV4LWRpcmVjdGlvbic6IFt7XG4gICAgICAgIGZsZXg6IFsncm93JywgJ3Jvdy1yZXZlcnNlJywgJ2NvbCcsICdjb2wtcmV2ZXJzZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmxleCBXcmFwXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC13cmFwXG4gICAgICAgKi9cbiAgICAgICdmbGV4LXdyYXAnOiBbe1xuICAgICAgICBmbGV4OiBbJ3dyYXAnLCAnd3JhcC1yZXZlcnNlJywgJ25vd3JhcCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmxleFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXhcbiAgICAgICAqL1xuICAgICAgZmxleDogW3tcbiAgICAgICAgZmxleDogWycxJywgJ2F1dG8nLCAnaW5pdGlhbCcsICdub25lJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IEdyb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LWdyb3dcbiAgICAgICAqL1xuICAgICAgZ3JvdzogW3tcbiAgICAgICAgZ3JvdzogZ2V0WmVyb0FuZEVtcHR5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IFNocmlua1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtc2hyaW5rXG4gICAgICAgKi9cbiAgICAgIHNocmluazogW3tcbiAgICAgICAgc2hyaW5rOiBnZXRaZXJvQW5kRW1wdHkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE9yZGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3JkZXJcbiAgICAgICAqL1xuICAgICAgb3JkZXI6IFt7XG4gICAgICAgIG9yZGVyOiBbJ2ZpcnN0JywgJ2xhc3QnLCAnbm9uZScsIGlzSW50ZWdlciwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFRlbXBsYXRlIENvbHVtbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXRlbXBsYXRlLWNvbHVtbnNcbiAgICAgICAqL1xuICAgICAgJ2dyaWQtY29scyc6IFt7XG4gICAgICAgICdncmlkLWNvbHMnOiBbaXNBbnldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBDb2x1bW4gU3RhcnQgLyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWNvbHVtblxuICAgICAgICovXG4gICAgICAnY29sLXN0YXJ0LWVuZCc6IFt7XG4gICAgICAgIGNvbDogWydhdXRvJywge1xuICAgICAgICAgIHNwYW46IFsnZnVsbCcsIGlzSW50ZWdlciwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgICAgfSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIENvbHVtbiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgICdjb2wtc3RhcnQnOiBbe1xuICAgICAgICAnY29sLXN0YXJ0JzogZ2V0TnVtYmVyV2l0aEF1dG9BbmRBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQ29sdW1uIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgICdjb2wtZW5kJzogW3tcbiAgICAgICAgJ2NvbC1lbmQnOiBnZXROdW1iZXJXaXRoQXV0b0FuZEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBUZW1wbGF0ZSBSb3dzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC10ZW1wbGF0ZS1yb3dzXG4gICAgICAgKi9cbiAgICAgICdncmlkLXJvd3MnOiBbe1xuICAgICAgICAnZ3JpZC1yb3dzJzogW2lzQW55XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgUm93IFN0YXJ0IC8gRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgJ3Jvdy1zdGFydC1lbmQnOiBbe1xuICAgICAgICByb3c6IFsnYXV0bycsIHtcbiAgICAgICAgICBzcGFuOiBbaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgICB9LCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgUm93IFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgJ3Jvdy1zdGFydCc6IFt7XG4gICAgICAgICdyb3ctc3RhcnQnOiBnZXROdW1iZXJXaXRoQXV0b0FuZEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBSb3cgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgJ3Jvdy1lbmQnOiBbe1xuICAgICAgICAncm93LWVuZCc6IGdldE51bWJlcldpdGhBdXRvQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIEF1dG8gRmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtYXV0by1mbG93XG4gICAgICAgKi9cbiAgICAgICdncmlkLWZsb3cnOiBbe1xuICAgICAgICAnZ3JpZC1mbG93JzogWydyb3cnLCAnY29sJywgJ2RlbnNlJywgJ3Jvdy1kZW5zZScsICdjb2wtZGVuc2UnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQXV0byBDb2x1bW5zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1hdXRvLWNvbHVtbnNcbiAgICAgICAqL1xuICAgICAgJ2F1dG8tY29scyc6IFt7XG4gICAgICAgICdhdXRvLWNvbHMnOiBbJ2F1dG8nLCAnbWluJywgJ21heCcsICdmcicsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBBdXRvIFJvd3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWF1dG8tcm93c1xuICAgICAgICovXG4gICAgICAnYXV0by1yb3dzJzogW3tcbiAgICAgICAgJ2F1dG8tcm93cyc6IFsnYXV0bycsICdtaW4nLCAnbWF4JywgJ2ZyJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHYXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9nYXBcbiAgICAgICAqL1xuICAgICAgZ2FwOiBbe1xuICAgICAgICBnYXA6IFtnYXBdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR2FwIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9nYXBcbiAgICAgICAqL1xuICAgICAgJ2dhcC14JzogW3tcbiAgICAgICAgJ2dhcC14JzogW2dhcF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHYXAgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICAnZ2FwLXknOiBbe1xuICAgICAgICAnZ2FwLXknOiBbZ2FwXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEp1c3RpZnkgQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3RpZnktY29udGVudFxuICAgICAgICovXG4gICAgICAnanVzdGlmeS1jb250ZW50JzogW3tcbiAgICAgICAganVzdGlmeTogWydub3JtYWwnLCAuLi5nZXRBbGlnbigpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEp1c3RpZnkgSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0aWZ5LWl0ZW1zXG4gICAgICAgKi9cbiAgICAgICdqdXN0aWZ5LWl0ZW1zJzogW3tcbiAgICAgICAgJ2p1c3RpZnktaXRlbXMnOiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnc3RyZXRjaCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSnVzdGlmeSBTZWxmXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1zZWxmXG4gICAgICAgKi9cbiAgICAgICdqdXN0aWZ5LXNlbGYnOiBbe1xuICAgICAgICAnanVzdGlmeS1zZWxmJzogWydhdXRvJywgJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnc3RyZXRjaCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLWNvbnRlbnRcbiAgICAgICAqL1xuICAgICAgJ2FsaWduLWNvbnRlbnQnOiBbe1xuICAgICAgICBjb250ZW50OiBbJ25vcm1hbCcsIC4uLmdldEFsaWduKCksICdiYXNlbGluZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hbGlnbi1pdGVtc1xuICAgICAgICovXG4gICAgICAnYWxpZ24taXRlbXMnOiBbe1xuICAgICAgICBpdGVtczogWydzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ2Jhc2VsaW5lJywgJ3N0cmV0Y2gnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEFsaWduIFNlbGZcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hbGlnbi1zZWxmXG4gICAgICAgKi9cbiAgICAgICdhbGlnbi1zZWxmJzogW3tcbiAgICAgICAgc2VsZjogWydhdXRvJywgJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnc3RyZXRjaCcsICdiYXNlbGluZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlLWNvbnRlbnRcbiAgICAgICAqL1xuICAgICAgJ3BsYWNlLWNvbnRlbnQnOiBbe1xuICAgICAgICAncGxhY2UtY29udGVudCc6IFsuLi5nZXRBbGlnbigpLCAnYmFzZWxpbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIEl0ZW1zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2UtaXRlbXNcbiAgICAgICAqL1xuICAgICAgJ3BsYWNlLWl0ZW1zJzogW3tcbiAgICAgICAgJ3BsYWNlLWl0ZW1zJzogWydzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ2Jhc2VsaW5lJywgJ3N0cmV0Y2gnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIFNlbGZcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZS1zZWxmXG4gICAgICAgKi9cbiAgICAgICdwbGFjZS1zZWxmJzogW3tcbiAgICAgICAgJ3BsYWNlLXNlbGYnOiBbJ2F1dG8nLCAnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicsICdzdHJldGNoJ11cbiAgICAgIH1dLFxuICAgICAgLy8gU3BhY2luZ1xuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwOiBbe1xuICAgICAgICBwOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHB4OiBbe1xuICAgICAgICBweDogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBweTogW3tcbiAgICAgICAgcHk6IFtwYWRkaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBzOiBbe1xuICAgICAgICBwczogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBlOiBbe1xuICAgICAgICBwZTogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHB0OiBbe1xuICAgICAgICBwdDogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHI6IFt7XG4gICAgICAgIHByOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcGI6IFt7XG4gICAgICAgIHBiOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBsOiBbe1xuICAgICAgICBwbDogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG06IFt7XG4gICAgICAgIG06IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXg6IFt7XG4gICAgICAgIG14OiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG15OiBbe1xuICAgICAgICBteTogW21hcmdpbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXM6IFt7XG4gICAgICAgIG1zOiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbWU6IFt7XG4gICAgICAgIG1lOiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXQ6IFt7XG4gICAgICAgIG10OiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtcjogW3tcbiAgICAgICAgbXI6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtYjogW3tcbiAgICAgICAgbWI6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbWw6IFt7XG4gICAgICAgIG1sOiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNwYWNlIEJldHdlZW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NwYWNlXG4gICAgICAgKi9cbiAgICAgICdzcGFjZS14JzogW3tcbiAgICAgICAgJ3NwYWNlLXgnOiBbc3BhY2VdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3BhY2UgQmV0d2VlbiBYIFJldmVyc2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zcGFjZVxuICAgICAgICovXG4gICAgICAnc3BhY2UteC1yZXZlcnNlJzogWydzcGFjZS14LXJldmVyc2UnXSxcbiAgICAgIC8qKlxuICAgICAgICogU3BhY2UgQmV0d2VlbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3BhY2VcbiAgICAgICAqL1xuICAgICAgJ3NwYWNlLXknOiBbe1xuICAgICAgICAnc3BhY2UteSc6IFtzcGFjZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFkgUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NwYWNlXG4gICAgICAgKi9cbiAgICAgICdzcGFjZS15LXJldmVyc2UnOiBbJ3NwYWNlLXktcmV2ZXJzZSddLFxuICAgICAgLy8gU2l6aW5nXG4gICAgICAvKipcbiAgICAgICAqIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvd2lkdGhcbiAgICAgICAqL1xuICAgICAgdzogW3tcbiAgICAgICAgdzogWydhdXRvJywgJ21pbicsICdtYXgnLCAnZml0JywgJ3N2dycsICdsdncnLCAnZHZ3JywgaXNBcmJpdHJhcnlWYWx1ZSwgc3BhY2luZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNaW4tV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9taW4td2lkdGhcbiAgICAgICAqL1xuICAgICAgJ21pbi13JzogW3tcbiAgICAgICAgJ21pbi13JzogW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmcsICdtaW4nLCAnbWF4JywgJ2ZpdCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWF4LVdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWF4LXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdtYXgtdyc6IFt7XG4gICAgICAgICdtYXgtdyc6IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nLCAnbm9uZScsICdmdWxsJywgJ21pbicsICdtYXgnLCAnZml0JywgJ3Byb3NlJywge1xuICAgICAgICAgIHNjcmVlbjogW2lzVHNoaXJ0U2l6ZV1cbiAgICAgICAgfSwgaXNUc2hpcnRTaXplXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEhlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2hlaWdodFxuICAgICAgICovXG4gICAgICBoOiBbe1xuICAgICAgICBoOiBbaXNBcmJpdHJhcnlWYWx1ZSwgc3BhY2luZywgJ2F1dG8nLCAnbWluJywgJ21heCcsICdmaXQnLCAnc3ZoJywgJ2x2aCcsICdkdmgnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1pbi1IZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9taW4taGVpZ2h0XG4gICAgICAgKi9cbiAgICAgICdtaW4taCc6IFt7XG4gICAgICAgICdtaW4taCc6IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nLCAnbWluJywgJ21heCcsICdmaXQnLCAnc3ZoJywgJ2x2aCcsICdkdmgnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1heC1IZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXgtaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgICdtYXgtaCc6IFt7XG4gICAgICAgICdtYXgtaCc6IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nLCAnbWluJywgJ21heCcsICdmaXQnLCAnc3ZoJywgJ2x2aCcsICdkdmgnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zaXplXG4gICAgICAgKi9cbiAgICAgIHNpemU6IFt7XG4gICAgICAgIHNpemU6IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nLCAnYXV0bycsICdtaW4nLCAnbWF4JywgJ2ZpdCddXG4gICAgICB9XSxcbiAgICAgIC8vIFR5cG9ncmFwaHlcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBTaXplXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zaXplXG4gICAgICAgKi9cbiAgICAgICdmb250LXNpemUnOiBbe1xuICAgICAgICB0ZXh0OiBbJ2Jhc2UnLCBpc1RzaGlydFNpemUsIGlzQXJiaXRyYXJ5TGVuZ3RoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgU21vb3RoaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zbW9vdGhpbmdcbiAgICAgICAqL1xuICAgICAgJ2ZvbnQtc21vb3RoaW5nJzogWydhbnRpYWxpYXNlZCcsICdzdWJwaXhlbC1hbnRpYWxpYXNlZCddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zdHlsZVxuICAgICAgICovXG4gICAgICAnZm9udC1zdHlsZSc6IFsnaXRhbGljJywgJ25vdC1pdGFsaWMnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBXZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXdlaWdodFxuICAgICAgICovXG4gICAgICAnZm9udC13ZWlnaHQnOiBbe1xuICAgICAgICBmb250OiBbJ3RoaW4nLCAnZXh0cmFsaWdodCcsICdsaWdodCcsICdub3JtYWwnLCAnbWVkaXVtJywgJ3NlbWlib2xkJywgJ2JvbGQnLCAnZXh0cmFib2xkJywgJ2JsYWNrJywgaXNBcmJpdHJhcnlOdW1iZXJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBGYW1pbHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LWZhbWlseVxuICAgICAgICovXG4gICAgICAnZm9udC1mYW1pbHknOiBbe1xuICAgICAgICBmb250OiBbaXNBbnldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLW5vcm1hbCc6IFsnbm9ybWFsLW51bXMnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLW9yZGluYWwnOiBbJ29yZGluYWwnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLXNsYXNoZWQtemVybyc6IFsnc2xhc2hlZC16ZXJvJ10sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgJ2Z2bi1maWd1cmUnOiBbJ2xpbmluZy1udW1zJywgJ29sZHN0eWxlLW51bXMnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLXNwYWNpbmcnOiBbJ3Byb3BvcnRpb25hbC1udW1zJywgJ3RhYnVsYXItbnVtcyddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tZnJhY3Rpb24nOiBbJ2RpYWdvbmFsLWZyYWN0aW9ucycsICdzdGFja2VkLWZyYWN0b25zJ10sXG4gICAgICAvKipcbiAgICAgICAqIExldHRlciBTcGFjaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGV0dGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgdHJhY2tpbmc6IFt7XG4gICAgICAgIHRyYWNraW5nOiBbJ3RpZ2h0ZXInLCAndGlnaHQnLCAnbm9ybWFsJywgJ3dpZGUnLCAnd2lkZXInLCAnd2lkZXN0JywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaW5lIENsYW1wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGluZS1jbGFtcFxuICAgICAgICovXG4gICAgICAnbGluZS1jbGFtcCc6IFt7XG4gICAgICAgICdsaW5lLWNsYW1wJzogWydub25lJywgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5TnVtYmVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpbmUgSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGluZS1oZWlnaHRcbiAgICAgICAqL1xuICAgICAgbGVhZGluZzogW3tcbiAgICAgICAgbGVhZGluZzogWydub25lJywgJ3RpZ2h0JywgJ3NudWcnLCAnbm9ybWFsJywgJ3JlbGF4ZWQnLCAnbG9vc2UnLCBpc0xlbmd0aCwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIEltYWdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS1pbWFnZVxuICAgICAgICovXG4gICAgICAnbGlzdC1pbWFnZSc6IFt7XG4gICAgICAgICdsaXN0LWltYWdlJzogWydub25lJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIFR5cGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saXN0LXN0eWxlLXR5cGVcbiAgICAgICAqL1xuICAgICAgJ2xpc3Qtc3R5bGUtdHlwZSc6IFt7XG4gICAgICAgIGxpc3Q6IFsnbm9uZScsICdkaXNjJywgJ2RlY2ltYWwnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpc3QgU3R5bGUgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saXN0LXN0eWxlLXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgICdsaXN0LXN0eWxlLXBvc2l0aW9uJzogW3tcbiAgICAgICAgbGlzdDogWydpbnNpZGUnLCAnb3V0c2lkZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2Vob2xkZXIgQ29sb3JcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZWhvbGRlci1jb2xvclxuICAgICAgICovXG4gICAgICAncGxhY2Vob2xkZXItY29sb3InOiBbe1xuICAgICAgICBwbGFjZWhvbGRlcjogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZWhvbGRlciBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2Vob2xkZXItb3BhY2l0eVxuICAgICAgICovXG4gICAgICAncGxhY2Vob2xkZXItb3BhY2l0eSc6IFt7XG4gICAgICAgICdwbGFjZWhvbGRlci1vcGFjaXR5JzogW29wYWNpdHldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBBbGlnbm1lbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWFsaWduXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWFsaWdubWVudCc6IFt7XG4gICAgICAgIHRleHQ6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnanVzdGlmeScsICdzdGFydCcsICdlbmQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWNvbG9yXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWNvbG9yJzogW3tcbiAgICAgICAgdGV4dDogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ3RleHQtb3BhY2l0eSc6IFt7XG4gICAgICAgICd0ZXh0LW9wYWNpdHknOiBbb3BhY2l0eV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IERlY29yYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWRlY29yYXRpb25cbiAgICAgICAqL1xuICAgICAgJ3RleHQtZGVjb3JhdGlvbic6IFsndW5kZXJsaW5lJywgJ292ZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCcsICduby11bmRlcmxpbmUnXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLXN0eWxlXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWRlY29yYXRpb24tc3R5bGUnOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbLi4uZ2V0TGluZVN0eWxlcygpLCAnd2F2eSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIFRoaWNrbmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvbi10aGlja25lc3NcbiAgICAgICAqL1xuICAgICAgJ3RleHQtZGVjb3JhdGlvbi10aGlja25lc3MnOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbJ2F1dG8nLCAnZnJvbS1mb250JywgaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgVW5kZXJsaW5lIE9mZnNldFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtdW5kZXJsaW5lLW9mZnNldFxuICAgICAgICovXG4gICAgICAndW5kZXJsaW5lLW9mZnNldCc6IFt7XG4gICAgICAgICd1bmRlcmxpbmUtb2Zmc2V0JzogWydhdXRvJywgaXNMZW5ndGgsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWRlY29yYXRpb24tY29sb3InOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgVHJhbnNmb3JtXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC10cmFuc2Zvcm1cbiAgICAgICAqL1xuICAgICAgJ3RleHQtdHJhbnNmb3JtJzogWyd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJywgJ2NhcGl0YWxpemUnLCAnbm9ybWFsLWNhc2UnXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBPdmVyZmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgJ3RleHQtb3ZlcmZsb3cnOiBbJ3RydW5jYXRlJywgJ3RleHQtZWxsaXBzaXMnLCAndGV4dC1jbGlwJ10sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgV3JhcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtd3JhcFxuICAgICAgICovXG4gICAgICAndGV4dC13cmFwJzogW3tcbiAgICAgICAgdGV4dDogWyd3cmFwJywgJ25vd3JhcCcsICdiYWxhbmNlJywgJ3ByZXR0eSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBJbmRlbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWluZGVudFxuICAgICAgICovXG4gICAgICBpbmRlbnQ6IFt7XG4gICAgICAgIGluZGVudDogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFZlcnRpY2FsIEFsaWdubWVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3ZlcnRpY2FsLWFsaWduXG4gICAgICAgKi9cbiAgICAgICd2ZXJ0aWNhbC1hbGlnbic6IFt7XG4gICAgICAgIGFsaWduOiBbJ2Jhc2VsaW5lJywgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJywgJ3RleHQtdG9wJywgJ3RleHQtYm90dG9tJywgJ3N1YicsICdzdXBlcicsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV2hpdGVzcGFjZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3doaXRlc3BhY2VcbiAgICAgICAqL1xuICAgICAgd2hpdGVzcGFjZTogW3tcbiAgICAgICAgd2hpdGVzcGFjZTogWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZScsICdwcmUtbGluZScsICdwcmUtd3JhcCcsICdicmVhay1zcGFjZXMnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFdvcmQgQnJlYWtcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93b3JkLWJyZWFrXG4gICAgICAgKi9cbiAgICAgIGJyZWFrOiBbe1xuICAgICAgICBicmVhazogWydub3JtYWwnLCAnd29yZHMnLCAnYWxsJywgJ2tlZXAnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEh5cGhlbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9oeXBoZW5zXG4gICAgICAgKi9cbiAgICAgIGh5cGhlbnM6IFt7XG4gICAgICAgIGh5cGhlbnM6IFsnbm9uZScsICdtYW51YWwnLCAnYXV0byddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbnRlbnRcbiAgICAgICAqL1xuICAgICAgY29udGVudDogW3tcbiAgICAgICAgY29udGVudDogWydub25lJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gQmFja2dyb3VuZHNcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBBdHRhY2htZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1hdHRhY2htZW50XG4gICAgICAgKi9cbiAgICAgICdiZy1hdHRhY2htZW50JzogW3tcbiAgICAgICAgYmc6IFsnZml4ZWQnLCAnbG9jYWwnLCAnc2Nyb2xsJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIENsaXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWNsaXBcbiAgICAgICAqL1xuICAgICAgJ2JnLWNsaXAnOiBbe1xuICAgICAgICAnYmctY2xpcCc6IFsnYm9yZGVyJywgJ3BhZGRpbmcnLCAnY29udGVudCcsICd0ZXh0J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIE9wYWNpdHlcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ2JnLW9wYWNpdHknOiBbe1xuICAgICAgICAnYmctb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgT3JpZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1vcmlnaW5cbiAgICAgICAqL1xuICAgICAgJ2JnLW9yaWdpbic6IFt7XG4gICAgICAgICdiZy1vcmlnaW4nOiBbJ2JvcmRlcicsICdwYWRkaW5nJywgJ2NvbnRlbnQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgICdiZy1wb3NpdGlvbic6IFt7XG4gICAgICAgIGJnOiBbLi4uZ2V0UG9zaXRpb25zKCksIGlzQXJiaXRyYXJ5UG9zaXRpb25dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBSZXBlYXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXJlcGVhdFxuICAgICAgICovXG4gICAgICAnYmctcmVwZWF0JzogW3tcbiAgICAgICAgYmc6IFsnbm8tcmVwZWF0Jywge1xuICAgICAgICAgIHJlcGVhdDogWycnLCAneCcsICd5JywgJ3JvdW5kJywgJ3NwYWNlJ11cbiAgICAgICAgfV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXNpemVcbiAgICAgICAqL1xuICAgICAgJ2JnLXNpemUnOiBbe1xuICAgICAgICBiZzogWydhdXRvJywgJ2NvdmVyJywgJ2NvbnRhaW4nLCBpc0FyYml0cmFyeVNpemVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBJbWFnZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtaW1hZ2VcbiAgICAgICAqL1xuICAgICAgJ2JnLWltYWdlJzogW3tcbiAgICAgICAgYmc6IFsnbm9uZScsIHtcbiAgICAgICAgICAnZ3JhZGllbnQtdG8nOiBbJ3QnLCAndHInLCAncicsICdicicsICdiJywgJ2JsJywgJ2wnLCAndGwnXVxuICAgICAgICB9LCBpc0FyYml0cmFyeUltYWdlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdiZy1jb2xvcic6IFt7XG4gICAgICAgIGJnOiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIEZyb20gUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICAnZ3JhZGllbnQtZnJvbS1wb3MnOiBbe1xuICAgICAgICBmcm9tOiBbZ3JhZGllbnRDb2xvclN0b3BQb3NpdGlvbnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVmlhIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgJ2dyYWRpZW50LXZpYS1wb3MnOiBbe1xuICAgICAgICB2aWE6IFtncmFkaWVudENvbG9yU3RvcFBvc2l0aW9uc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBUbyBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC10by1wb3MnOiBbe1xuICAgICAgICB0bzogW2dyYWRpZW50Q29sb3JTdG9wUG9zaXRpb25zXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIEZyb21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICAnZ3JhZGllbnQtZnJvbSc6IFt7XG4gICAgICAgIGZyb206IFtncmFkaWVudENvbG9yU3RvcHNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVmlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgJ2dyYWRpZW50LXZpYSc6IFt7XG4gICAgICAgIHZpYTogW2dyYWRpZW50Q29sb3JTdG9wc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBUb1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC10byc6IFt7XG4gICAgICAgIHRvOiBbZ3JhZGllbnRDb2xvclN0b3BzXVxuICAgICAgfV0sXG4gICAgICAvLyBCb3JkZXJzXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIHJvdW5kZWQ6IFt7XG4gICAgICAgIHJvdW5kZWQ6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtcyc6IFt7XG4gICAgICAgICdyb3VuZGVkLXMnOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1lJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtZSc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLXQnOiBbe1xuICAgICAgICAncm91bmRlZC10JzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1yJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtcic6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWInOiBbe1xuICAgICAgICAncm91bmRlZC1iJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWwnOiBbe1xuICAgICAgICAncm91bmRlZC1sJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1zcyc6IFt7XG4gICAgICAgICdyb3VuZGVkLXNzJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtc2UnOiBbe1xuICAgICAgICAncm91bmRlZC1zZSc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBFbmQgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1lZSc6IFt7XG4gICAgICAgICdyb3VuZGVkLWVlJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZCBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtZXMnOiBbe1xuICAgICAgICAncm91bmRlZC1lcyc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3AgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtdGwnOiBbe1xuICAgICAgICAncm91bmRlZC10bCc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3AgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLXRyJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtdHInOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgQm90dG9tIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1icic6IFt7XG4gICAgICAgICdyb3VuZGVkLWJyJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEJvdHRvbSBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1ibCc6IFt7XG4gICAgICAgICdyb3VuZGVkLWJsJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13JzogW3tcbiAgICAgICAgYm9yZGVyOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXgnOiBbe1xuICAgICAgICAnYm9yZGVyLXgnOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXknOiBbe1xuICAgICAgICAnYm9yZGVyLXknOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItdy1zJzogW3tcbiAgICAgICAgJ2JvcmRlci1zJzogW2JvcmRlcldpZHRoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LWUnOiBbe1xuICAgICAgICAnYm9yZGVyLWUnOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctdCc6IFt7XG4gICAgICAgICdib3JkZXItdCc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXInOiBbe1xuICAgICAgICAnYm9yZGVyLXInOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctYic6IFt7XG4gICAgICAgICdib3JkZXItYic6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctbCc6IFt7XG4gICAgICAgICdib3JkZXItbCc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgICdib3JkZXItb3BhY2l0eSc6IFt7XG4gICAgICAgICdib3JkZXItb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zdHlsZVxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXN0eWxlJzogW3tcbiAgICAgICAgYm9yZGVyOiBbLi4uZ2V0TGluZVN0eWxlcygpLCAnaGlkZGVuJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXgnOiBbe1xuICAgICAgICAnZGl2aWRlLXgnOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFggUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXgtcmV2ZXJzZSc6IFsnZGl2aWRlLXgtcmV2ZXJzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXknOiBbe1xuICAgICAgICAnZGl2aWRlLXknOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFkgUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXktcmV2ZXJzZSc6IFsnZGl2aWRlLXktcmV2ZXJzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUtb3BhY2l0eSc6IFt7XG4gICAgICAgICdkaXZpZGUtb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1zdHlsZVxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXN0eWxlJzogW3tcbiAgICAgICAgZGl2aWRlOiBnZXRMaW5lU3R5bGVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvcic6IFt7XG4gICAgICAgIGJvcmRlcjogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3IteCc6IFt7XG4gICAgICAgICdib3JkZXIteCc6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLXknOiBbe1xuICAgICAgICAnYm9yZGVyLXknOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLXQnOiBbe1xuICAgICAgICAnYm9yZGVyLXQnOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3Itcic6IFt7XG4gICAgICAgICdib3JkZXItcic6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3ItYic6IFt7XG4gICAgICAgICdib3JkZXItYic6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLWwnOiBbe1xuICAgICAgICAnYm9yZGVyLWwnOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUtY29sb3InOiBbe1xuICAgICAgICBkaXZpZGU6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS1zdHlsZVxuICAgICAgICovXG4gICAgICAnb3V0bGluZS1zdHlsZSc6IFt7XG4gICAgICAgIG91dGxpbmU6IFsnJywgLi4uZ2V0TGluZVN0eWxlcygpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE91dGxpbmUgT2Zmc2V0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS1vZmZzZXRcbiAgICAgICAqL1xuICAgICAgJ291dGxpbmUtb2Zmc2V0JzogW3tcbiAgICAgICAgJ291dGxpbmUtb2Zmc2V0JzogW2lzTGVuZ3RoLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE91dGxpbmUgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdvdXRsaW5lLXcnOiBbe1xuICAgICAgICBvdXRsaW5lOiBbaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE91dGxpbmUgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdvdXRsaW5lLWNvbG9yJzogW3tcbiAgICAgICAgb3V0bGluZTogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy13aWR0aFxuICAgICAgICovXG4gICAgICAncmluZy13JzogW3tcbiAgICAgICAgcmluZzogZ2V0TGVuZ3RoV2l0aEVtcHR5QW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIFdpZHRoIEluc2V0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy13aWR0aFxuICAgICAgICovXG4gICAgICAncmluZy13LWluc2V0JzogWydyaW5nLWluc2V0J10sXG4gICAgICAvKipcbiAgICAgICAqIFJpbmcgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yaW5nLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdyaW5nLWNvbG9yJzogW3tcbiAgICAgICAgcmluZzogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yaW5nLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ3Jpbmctb3BhY2l0eSc6IFt7XG4gICAgICAgICdyaW5nLW9wYWNpdHknOiBbb3BhY2l0eV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIE9mZnNldCBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb2Zmc2V0LXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdyaW5nLW9mZnNldC13JzogW3tcbiAgICAgICAgJ3Jpbmctb2Zmc2V0JzogW2lzTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIE9mZnNldCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb2Zmc2V0LWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdyaW5nLW9mZnNldC1jb2xvcic6IFt7XG4gICAgICAgICdyaW5nLW9mZnNldCc6IFtjb2xvcnNdXG4gICAgICB9XSxcbiAgICAgIC8vIEVmZmVjdHNcbiAgICAgIC8qKlxuICAgICAgICogQm94IFNoYWRvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3dcbiAgICAgICAqL1xuICAgICAgc2hhZG93OiBbe1xuICAgICAgICBzaGFkb3c6IFsnJywgJ2lubmVyJywgJ25vbmUnLCBpc1RzaGlydFNpemUsIGlzQXJiaXRyYXJ5U2hhZG93XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJveCBTaGFkb3cgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2hhZG93LWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdzaGFkb3ctY29sb3InOiBbe1xuICAgICAgICBzaGFkb3c6IFtpc0FueV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3BhY2l0eVxuICAgICAgICovXG4gICAgICBvcGFjaXR5OiBbe1xuICAgICAgICBvcGFjaXR5OiBbb3BhY2l0eV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNaXggQmxlbmQgTW9kZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21peC1ibGVuZC1tb2RlXG4gICAgICAgKi9cbiAgICAgICdtaXgtYmxlbmQnOiBbe1xuICAgICAgICAnbWl4LWJsZW5kJzogWy4uLmdldEJsZW5kTW9kZXMoKSwgJ3BsdXMtbGlnaHRlcicsICdwbHVzLWRhcmtlciddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBCbGVuZCBNb2RlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1ibGVuZC1tb2RlXG4gICAgICAgKi9cbiAgICAgICdiZy1ibGVuZCc6IFt7XG4gICAgICAgICdiZy1ibGVuZCc6IGdldEJsZW5kTW9kZXMoKVxuICAgICAgfV0sXG4gICAgICAvLyBGaWx0ZXJzXG4gICAgICAvKipcbiAgICAgICAqIEZpbHRlclxuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZpbHRlclxuICAgICAgICovXG4gICAgICBmaWx0ZXI6IFt7XG4gICAgICAgIGZpbHRlcjogWycnLCAnbm9uZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmx1clxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JsdXJcbiAgICAgICAqL1xuICAgICAgYmx1cjogW3tcbiAgICAgICAgYmx1cjogW2JsdXJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJpZ2h0bmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyaWdodG5lc3NcbiAgICAgICAqL1xuICAgICAgYnJpZ2h0bmVzczogW3tcbiAgICAgICAgYnJpZ2h0bmVzczogW2JyaWdodG5lc3NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ29udHJhc3RcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb250cmFzdFxuICAgICAgICovXG4gICAgICBjb250cmFzdDogW3tcbiAgICAgICAgY29udHJhc3Q6IFtjb250cmFzdF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEcm9wIFNoYWRvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Ryb3Atc2hhZG93XG4gICAgICAgKi9cbiAgICAgICdkcm9wLXNoYWRvdyc6IFt7XG4gICAgICAgICdkcm9wLXNoYWRvdyc6IFsnJywgJ25vbmUnLCBpc1RzaGlydFNpemUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JheXNjYWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JheXNjYWxlXG4gICAgICAgKi9cbiAgICAgIGdyYXlzY2FsZTogW3tcbiAgICAgICAgZ3JheXNjYWxlOiBbZ3JheXNjYWxlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEh1ZSBSb3RhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9odWUtcm90YXRlXG4gICAgICAgKi9cbiAgICAgICdodWUtcm90YXRlJzogW3tcbiAgICAgICAgJ2h1ZS1yb3RhdGUnOiBbaHVlUm90YXRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEludmVydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ludmVydFxuICAgICAgICovXG4gICAgICBpbnZlcnQ6IFt7XG4gICAgICAgIGludmVydDogW2ludmVydF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTYXR1cmF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NhdHVyYXRlXG4gICAgICAgKi9cbiAgICAgIHNhdHVyYXRlOiBbe1xuICAgICAgICBzYXR1cmF0ZTogW3NhdHVyYXRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNlcGlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2VwaWFcbiAgICAgICAqL1xuICAgICAgc2VwaWE6IFt7XG4gICAgICAgIHNlcGlhOiBbc2VwaWFdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgRmlsdGVyXG4gICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjMuMC4wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtZmlsdGVyXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1maWx0ZXInOiBbe1xuICAgICAgICAnYmFja2Ryb3AtZmlsdGVyJzogWycnLCAnbm9uZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgQmx1clxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWJsdXJcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLWJsdXInOiBbe1xuICAgICAgICAnYmFja2Ryb3AtYmx1cic6IFtibHVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEJyaWdodG5lc3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1icmlnaHRuZXNzXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1icmlnaHRuZXNzJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWJyaWdodG5lc3MnOiBbYnJpZ2h0bmVzc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBDb250cmFzdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWNvbnRyYXN0XG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1jb250cmFzdCc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1jb250cmFzdCc6IFtjb250cmFzdF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBHcmF5c2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1ncmF5c2NhbGVcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLWdyYXlzY2FsZSc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1ncmF5c2NhbGUnOiBbZ3JheXNjYWxlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEh1ZSBSb3RhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1odWUtcm90YXRlXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1odWUtcm90YXRlJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWh1ZS1yb3RhdGUnOiBbaHVlUm90YXRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEludmVydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWludmVydFxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtaW52ZXJ0JzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWludmVydCc6IFtpbnZlcnRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLW9wYWNpdHknOiBbe1xuICAgICAgICAnYmFja2Ryb3Atb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIFNhdHVyYXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3Atc2F0dXJhdGVcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLXNhdHVyYXRlJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLXNhdHVyYXRlJzogW3NhdHVyYXRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIFNlcGlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3Atc2VwaWFcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLXNlcGlhJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLXNlcGlhJzogW3NlcGlhXVxuICAgICAgfV0sXG4gICAgICAvLyBUYWJsZXNcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbGxhcHNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbGxhcHNlXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sbGFwc2UnOiBbe1xuICAgICAgICBib3JkZXI6IFsnY29sbGFwc2UnLCAnc2VwYXJhdGUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1zcGFjaW5nJzogW3tcbiAgICAgICAgJ2JvcmRlci1zcGFjaW5nJzogW2JvcmRlclNwYWNpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFNwYWNpbmcgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zcGFjaW5nXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItc3BhY2luZy14JzogW3tcbiAgICAgICAgJ2JvcmRlci1zcGFjaW5nLXgnOiBbYm9yZGVyU3BhY2luZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgU3BhY2luZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1zcGFjaW5nLXknOiBbe1xuICAgICAgICAnYm9yZGVyLXNwYWNpbmcteSc6IFtib3JkZXJTcGFjaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRhYmxlIExheW91dFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RhYmxlLWxheW91dFxuICAgICAgICovXG4gICAgICAndGFibGUtbGF5b3V0JzogW3tcbiAgICAgICAgdGFibGU6IFsnYXV0bycsICdmaXhlZCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FwdGlvbiBTaWRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY2FwdGlvbi1zaWRlXG4gICAgICAgKi9cbiAgICAgIGNhcHRpb246IFt7XG4gICAgICAgIGNhcHRpb246IFsndG9wJywgJ2JvdHRvbSddXG4gICAgICB9XSxcbiAgICAgIC8vIFRyYW5zaXRpb25zIGFuZCBBbmltYXRpb25cbiAgICAgIC8qKlxuICAgICAgICogVHJhbmlzaXRpb24gUHJvcGVydHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLXByb3BlcnR5XG4gICAgICAgKi9cbiAgICAgIHRyYW5zaXRpb246IFt7XG4gICAgICAgIHRyYW5zaXRpb246IFsnbm9uZScsICdhbGwnLCAnJywgJ2NvbG9ycycsICdvcGFjaXR5JywgJ3NoYWRvdycsICd0cmFuc2Zvcm0nLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb24gRHVyYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLWR1cmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGR1cmF0aW9uOiBbe1xuICAgICAgICBkdXJhdGlvbjogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIFRpbWluZyBGdW5jdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIGVhc2U6IFt7XG4gICAgICAgIGVhc2U6IFsnbGluZWFyJywgJ2luJywgJ291dCcsICdpbi1vdXQnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb24gRGVsYXlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLWRlbGF5XG4gICAgICAgKi9cbiAgICAgIGRlbGF5OiBbe1xuICAgICAgICBkZWxheTogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbmltYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hbmltYXRpb25cbiAgICAgICAqL1xuICAgICAgYW5pbWF0ZTogW3tcbiAgICAgICAgYW5pbWF0ZTogWydub25lJywgJ3NwaW4nLCAncGluZycsICdwdWxzZScsICdib3VuY2UnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvLyBUcmFuc2Zvcm1zXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zZm9ybVxuICAgICAgICovXG4gICAgICB0cmFuc2Zvcm06IFt7XG4gICAgICAgIHRyYW5zZm9ybTogWycnLCAnZ3B1JywgJ25vbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAqL1xuICAgICAgc2NhbGU6IFt7XG4gICAgICAgIHNjYWxlOiBbc2NhbGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2NhbGUgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjYWxlXG4gICAgICAgKi9cbiAgICAgICdzY2FsZS14JzogW3tcbiAgICAgICAgJ3NjYWxlLXgnOiBbc2NhbGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2NhbGUgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjYWxlXG4gICAgICAgKi9cbiAgICAgICdzY2FsZS15JzogW3tcbiAgICAgICAgJ3NjYWxlLXknOiBbc2NhbGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvcm90YXRlXG4gICAgICAgKi9cbiAgICAgIHJvdGF0ZTogW3tcbiAgICAgICAgcm90YXRlOiBbaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zbGF0ZSBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNsYXRlXG4gICAgICAgKi9cbiAgICAgICd0cmFuc2xhdGUteCc6IFt7XG4gICAgICAgICd0cmFuc2xhdGUteCc6IFt0cmFuc2xhdGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNsYXRlIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAqL1xuICAgICAgJ3RyYW5zbGF0ZS15JzogW3tcbiAgICAgICAgJ3RyYW5zbGF0ZS15JzogW3RyYW5zbGF0ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTa2V3IFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9za2V3XG4gICAgICAgKi9cbiAgICAgICdza2V3LXgnOiBbe1xuICAgICAgICAnc2tldy14JzogW3NrZXddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2tldyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2tld1xuICAgICAgICovXG4gICAgICAnc2tldy15JzogW3tcbiAgICAgICAgJ3NrZXcteSc6IFtza2V3XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSBPcmlnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2Zvcm0tb3JpZ2luXG4gICAgICAgKi9cbiAgICAgICd0cmFuc2Zvcm0tb3JpZ2luJzogW3tcbiAgICAgICAgb3JpZ2luOiBbJ2NlbnRlcicsICd0b3AnLCAndG9wLXJpZ2h0JywgJ3JpZ2h0JywgJ2JvdHRvbS1yaWdodCcsICdib3R0b20nLCAnYm90dG9tLWxlZnQnLCAnbGVmdCcsICd0b3AtbGVmdCcsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8vIEludGVyYWN0aXZpdHlcbiAgICAgIC8qKlxuICAgICAgICogQWNjZW50IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWNjZW50LWNvbG9yXG4gICAgICAgKi9cbiAgICAgIGFjY2VudDogW3tcbiAgICAgICAgYWNjZW50OiBbJ2F1dG8nLCBjb2xvcnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQXBwZWFyYW5jZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FwcGVhcmFuY2VcbiAgICAgICAqL1xuICAgICAgYXBwZWFyYW5jZTogW3tcbiAgICAgICAgYXBwZWFyYW5jZTogWydub25lJywgJ2F1dG8nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEN1cnNvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2N1cnNvclxuICAgICAgICovXG4gICAgICBjdXJzb3I6IFt7XG4gICAgICAgIGN1cnNvcjogWydhdXRvJywgJ2RlZmF1bHQnLCAncG9pbnRlcicsICd3YWl0JywgJ3RleHQnLCAnbW92ZScsICdoZWxwJywgJ25vdC1hbGxvd2VkJywgJ25vbmUnLCAnY29udGV4dC1tZW51JywgJ3Byb2dyZXNzJywgJ2NlbGwnLCAnY3Jvc3NoYWlyJywgJ3ZlcnRpY2FsLXRleHQnLCAnYWxpYXMnLCAnY29weScsICduby1kcm9wJywgJ2dyYWInLCAnZ3JhYmJpbmcnLCAnYWxsLXNjcm9sbCcsICdjb2wtcmVzaXplJywgJ3Jvdy1yZXNpemUnLCAnbi1yZXNpemUnLCAnZS1yZXNpemUnLCAncy1yZXNpemUnLCAndy1yZXNpemUnLCAnbmUtcmVzaXplJywgJ253LXJlc2l6ZScsICdzZS1yZXNpemUnLCAnc3ctcmVzaXplJywgJ2V3LXJlc2l6ZScsICducy1yZXNpemUnLCAnbmVzdy1yZXNpemUnLCAnbndzZS1yZXNpemUnLCAnem9vbS1pbicsICd6b29tLW91dCcsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FyZXQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0LWluLXRpbWUtbW9kZSNjYXJldC1jb2xvci11dGlsaXRpZXNcbiAgICAgICAqL1xuICAgICAgJ2NhcmV0LWNvbG9yJzogW3tcbiAgICAgICAgY2FyZXQ6IFtjb2xvcnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUG9pbnRlciBFdmVudHNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wb2ludGVyLWV2ZW50c1xuICAgICAgICovXG4gICAgICAncG9pbnRlci1ldmVudHMnOiBbe1xuICAgICAgICAncG9pbnRlci1ldmVudHMnOiBbJ25vbmUnLCAnYXV0byddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmVzaXplXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmVzaXplXG4gICAgICAgKi9cbiAgICAgIHJlc2l6ZTogW3tcbiAgICAgICAgcmVzaXplOiBbJ25vbmUnLCAneScsICd4JywgJyddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIEJlaGF2aW9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtYmVoYXZpb3InOiBbe1xuICAgICAgICBzY3JvbGw6IFsnYXV0bycsICdzbW9vdGgnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbSc6IFt7XG4gICAgICAgICdzY3JvbGwtbSc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbXgnOiBbe1xuICAgICAgICAnc2Nyb2xsLW14JzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1teSc6IFt7XG4gICAgICAgICdzY3JvbGwtbXknOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tcyc6IFt7XG4gICAgICAgICdzY3JvbGwtbXMnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbWUnOiBbe1xuICAgICAgICAnc2Nyb2xsLW1lJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW10JzogW3tcbiAgICAgICAgJ3Njcm9sbC1tdCc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW1yJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tcic6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tYic6IFt7XG4gICAgICAgICdzY3JvbGwtbWInOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW1sJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tbCc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcCc6IFt7XG4gICAgICAgICdzY3JvbGwtcCc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1weCc6IFt7XG4gICAgICAgICdzY3JvbGwtcHgnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcHknOiBbe1xuICAgICAgICAnc2Nyb2xsLXB5JzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wcyc6IFt7XG4gICAgICAgICdzY3JvbGwtcHMnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wZSc6IFt7XG4gICAgICAgICdzY3JvbGwtcGUnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wdCc6IFt7XG4gICAgICAgICdzY3JvbGwtcHQnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXByJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wcic6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXBiJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wYic6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wbCc6IFt7XG4gICAgICAgICdzY3JvbGwtcGwnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgQWxpZ25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC1hbGlnblxuICAgICAgICovXG4gICAgICAnc25hcC1hbGlnbic6IFt7XG4gICAgICAgIHNuYXA6IFsnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicsICdhbGlnbi1ub25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBTdG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtc3RvcFxuICAgICAgICovXG4gICAgICAnc25hcC1zdG9wJzogW3tcbiAgICAgICAgc25hcDogWydub3JtYWwnLCAnYWx3YXlzJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBUeXBlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtdHlwZVxuICAgICAgICovXG4gICAgICAnc25hcC10eXBlJzogW3tcbiAgICAgICAgc25hcDogWydub25lJywgJ3gnLCAneScsICdib3RoJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBUeXBlIFN0cmljdG5lc3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC10eXBlXG4gICAgICAgKi9cbiAgICAgICdzbmFwLXN0cmljdG5lc3MnOiBbe1xuICAgICAgICBzbmFwOiBbJ21hbmRhdG9yeScsICdwcm94aW1pdHknXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvdWNoIEFjdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICovXG4gICAgICB0b3VjaDogW3tcbiAgICAgICAgdG91Y2g6IFsnYXV0bycsICdub25lJywgJ21hbmlwdWxhdGlvbiddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3VjaC1hY3Rpb25cbiAgICAgICAqL1xuICAgICAgJ3RvdWNoLXgnOiBbe1xuICAgICAgICAndG91Y2gtcGFuJzogWyd4JywgJ2xlZnQnLCAncmlnaHQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvdWNoIEFjdGlvbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgICd0b3VjaC15JzogW3tcbiAgICAgICAgJ3RvdWNoLXBhbic6IFsneScsICd1cCcsICdkb3duJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3VjaCBBY3Rpb24gUGluY2ggWm9vbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICovXG4gICAgICAndG91Y2gtcHonOiBbJ3RvdWNoLXBpbmNoLXpvb20nXSxcbiAgICAgIC8qKlxuICAgICAgICogVXNlciBTZWxlY3RcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy91c2VyLXNlbGVjdFxuICAgICAgICovXG4gICAgICBzZWxlY3Q6IFt7XG4gICAgICAgIHNlbGVjdDogWydub25lJywgJ3RleHQnLCAnYWxsJywgJ2F1dG8nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFdpbGwgQ2hhbmdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvd2lsbC1jaGFuZ2VcbiAgICAgICAqL1xuICAgICAgJ3dpbGwtY2hhbmdlJzogW3tcbiAgICAgICAgJ3dpbGwtY2hhbmdlJzogWydhdXRvJywgJ3Njcm9sbCcsICdjb250ZW50cycsICd0cmFuc2Zvcm0nLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvLyBTVkdcbiAgICAgIC8qKlxuICAgICAgICogRmlsbFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZpbGxcbiAgICAgICAqL1xuICAgICAgZmlsbDogW3tcbiAgICAgICAgZmlsbDogW2NvbG9ycywgJ25vbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFN0cm9rZSBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3N0cm9rZS13aWR0aFxuICAgICAgICovXG4gICAgICAnc3Ryb2tlLXcnOiBbe1xuICAgICAgICBzdHJva2U6IFtpc0xlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGgsIGlzQXJiaXRyYXJ5TnVtYmVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFN0cm9rZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3N0cm9rZVxuICAgICAgICovXG4gICAgICBzdHJva2U6IFt7XG4gICAgICAgIHN0cm9rZTogW2NvbG9ycywgJ25vbmUnXVxuICAgICAgfV0sXG4gICAgICAvLyBBY2Nlc3NpYmlsaXR5XG4gICAgICAvKipcbiAgICAgICAqIFNjcmVlbiBSZWFkZXJzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NyZWVuLXJlYWRlcnNcbiAgICAgICAqL1xuICAgICAgc3I6IFsnc3Itb25seScsICdub3Qtc3Itb25seSddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb3JjZWQgQ29sb3IgQWRqdXN0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9yY2VkLWNvbG9yLWFkanVzdFxuICAgICAgICovXG4gICAgICAnZm9yY2VkLWNvbG9yLWFkanVzdCc6IFt7XG4gICAgICAgICdmb3JjZWQtY29sb3ItYWRqdXN0JzogWydhdXRvJywgJ25vbmUnXVxuICAgICAgfV1cbiAgICB9LFxuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cHM6IHtcbiAgICAgIG92ZXJmbG93OiBbJ292ZXJmbG93LXgnLCAnb3ZlcmZsb3cteSddLFxuICAgICAgb3ZlcnNjcm9sbDogWydvdmVyc2Nyb2xsLXgnLCAnb3ZlcnNjcm9sbC15J10sXG4gICAgICBpbnNldDogWydpbnNldC14JywgJ2luc2V0LXknLCAnc3RhcnQnLCAnZW5kJywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLFxuICAgICAgJ2luc2V0LXgnOiBbJ3JpZ2h0JywgJ2xlZnQnXSxcbiAgICAgICdpbnNldC15JzogWyd0b3AnLCAnYm90dG9tJ10sXG4gICAgICBmbGV4OiBbJ2Jhc2lzJywgJ2dyb3cnLCAnc2hyaW5rJ10sXG4gICAgICBnYXA6IFsnZ2FwLXgnLCAnZ2FwLXknXSxcbiAgICAgIHA6IFsncHgnLCAncHknLCAncHMnLCAncGUnLCAncHQnLCAncHInLCAncGInLCAncGwnXSxcbiAgICAgIHB4OiBbJ3ByJywgJ3BsJ10sXG4gICAgICBweTogWydwdCcsICdwYiddLFxuICAgICAgbTogWydteCcsICdteScsICdtcycsICdtZScsICdtdCcsICdtcicsICdtYicsICdtbCddLFxuICAgICAgbXg6IFsnbXInLCAnbWwnXSxcbiAgICAgIG15OiBbJ210JywgJ21iJ10sXG4gICAgICBzaXplOiBbJ3cnLCAnaCddLFxuICAgICAgJ2ZvbnQtc2l6ZSc6IFsnbGVhZGluZyddLFxuICAgICAgJ2Z2bi1ub3JtYWwnOiBbJ2Z2bi1vcmRpbmFsJywgJ2Z2bi1zbGFzaGVkLXplcm8nLCAnZnZuLWZpZ3VyZScsICdmdm4tc3BhY2luZycsICdmdm4tZnJhY3Rpb24nXSxcbiAgICAgICdmdm4tb3JkaW5hbCc6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgJ2Z2bi1zbGFzaGVkLXplcm8nOiBbJ2Z2bi1ub3JtYWwnXSxcbiAgICAgICdmdm4tZmlndXJlJzogWydmdm4tbm9ybWFsJ10sXG4gICAgICAnZnZuLXNwYWNpbmcnOiBbJ2Z2bi1ub3JtYWwnXSxcbiAgICAgICdmdm4tZnJhY3Rpb24nOiBbJ2Z2bi1ub3JtYWwnXSxcbiAgICAgICdsaW5lLWNsYW1wJzogWydkaXNwbGF5JywgJ292ZXJmbG93J10sXG4gICAgICByb3VuZGVkOiBbJ3JvdW5kZWQtcycsICdyb3VuZGVkLWUnLCAncm91bmRlZC10JywgJ3JvdW5kZWQtcicsICdyb3VuZGVkLWInLCAncm91bmRlZC1sJywgJ3JvdW5kZWQtc3MnLCAncm91bmRlZC1zZScsICdyb3VuZGVkLWVlJywgJ3JvdW5kZWQtZXMnLCAncm91bmRlZC10bCcsICdyb3VuZGVkLXRyJywgJ3JvdW5kZWQtYnInLCAncm91bmRlZC1ibCddLFxuICAgICAgJ3JvdW5kZWQtcyc6IFsncm91bmRlZC1zcycsICdyb3VuZGVkLWVzJ10sXG4gICAgICAncm91bmRlZC1lJzogWydyb3VuZGVkLXNlJywgJ3JvdW5kZWQtZWUnXSxcbiAgICAgICdyb3VuZGVkLXQnOiBbJ3JvdW5kZWQtdGwnLCAncm91bmRlZC10ciddLFxuICAgICAgJ3JvdW5kZWQtcic6IFsncm91bmRlZC10cicsICdyb3VuZGVkLWJyJ10sXG4gICAgICAncm91bmRlZC1iJzogWydyb3VuZGVkLWJyJywgJ3JvdW5kZWQtYmwnXSxcbiAgICAgICdyb3VuZGVkLWwnOiBbJ3JvdW5kZWQtdGwnLCAncm91bmRlZC1ibCddLFxuICAgICAgJ2JvcmRlci1zcGFjaW5nJzogWydib3JkZXItc3BhY2luZy14JywgJ2JvcmRlci1zcGFjaW5nLXknXSxcbiAgICAgICdib3JkZXItdyc6IFsnYm9yZGVyLXctcycsICdib3JkZXItdy1lJywgJ2JvcmRlci13LXQnLCAnYm9yZGVyLXctcicsICdib3JkZXItdy1iJywgJ2JvcmRlci13LWwnXSxcbiAgICAgICdib3JkZXItdy14JzogWydib3JkZXItdy1yJywgJ2JvcmRlci13LWwnXSxcbiAgICAgICdib3JkZXItdy15JzogWydib3JkZXItdy10JywgJ2JvcmRlci13LWInXSxcbiAgICAgICdib3JkZXItY29sb3InOiBbJ2JvcmRlci1jb2xvci10JywgJ2JvcmRlci1jb2xvci1yJywgJ2JvcmRlci1jb2xvci1iJywgJ2JvcmRlci1jb2xvci1sJ10sXG4gICAgICAnYm9yZGVyLWNvbG9yLXgnOiBbJ2JvcmRlci1jb2xvci1yJywgJ2JvcmRlci1jb2xvci1sJ10sXG4gICAgICAnYm9yZGVyLWNvbG9yLXknOiBbJ2JvcmRlci1jb2xvci10JywgJ2JvcmRlci1jb2xvci1iJ10sXG4gICAgICAnc2Nyb2xsLW0nOiBbJ3Njcm9sbC1teCcsICdzY3JvbGwtbXknLCAnc2Nyb2xsLW1zJywgJ3Njcm9sbC1tZScsICdzY3JvbGwtbXQnLCAnc2Nyb2xsLW1yJywgJ3Njcm9sbC1tYicsICdzY3JvbGwtbWwnXSxcbiAgICAgICdzY3JvbGwtbXgnOiBbJ3Njcm9sbC1tcicsICdzY3JvbGwtbWwnXSxcbiAgICAgICdzY3JvbGwtbXknOiBbJ3Njcm9sbC1tdCcsICdzY3JvbGwtbWInXSxcbiAgICAgICdzY3JvbGwtcCc6IFsnc2Nyb2xsLXB4JywgJ3Njcm9sbC1weScsICdzY3JvbGwtcHMnLCAnc2Nyb2xsLXBlJywgJ3Njcm9sbC1wdCcsICdzY3JvbGwtcHInLCAnc2Nyb2xsLXBiJywgJ3Njcm9sbC1wbCddLFxuICAgICAgJ3Njcm9sbC1weCc6IFsnc2Nyb2xsLXByJywgJ3Njcm9sbC1wbCddLFxuICAgICAgJ3Njcm9sbC1weSc6IFsnc2Nyb2xsLXB0JywgJ3Njcm9sbC1wYiddLFxuICAgICAgdG91Y2g6IFsndG91Y2gteCcsICd0b3VjaC15JywgJ3RvdWNoLXB6J10sXG4gICAgICAndG91Y2gteCc6IFsndG91Y2gnXSxcbiAgICAgICd0b3VjaC15JzogWyd0b3VjaCddLFxuICAgICAgJ3RvdWNoLXB6JzogWyd0b3VjaCddXG4gICAgfSxcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnM6IHtcbiAgICAgICdmb250LXNpemUnOiBbJ2xlYWRpbmcnXVxuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGJhc2VDb25maWcgQ29uZmlnIHdoZXJlIG90aGVyIGNvbmZpZyB3aWxsIGJlIG1lcmdlZCBpbnRvLiBUaGlzIG9iamVjdCB3aWxsIGJlIG11dGF0ZWQuXG4gKiBAcGFyYW0gY29uZmlnRXh0ZW5zaW9uIFBhcnRpYWwgY29uZmlnIHRvIG1lcmdlIGludG8gdGhlIGBiYXNlQ29uZmlnYC5cbiAqL1xuY29uc3QgbWVyZ2VDb25maWdzID0gKGJhc2VDb25maWcsIHtcbiAgY2FjaGVTaXplLFxuICBwcmVmaXgsXG4gIHNlcGFyYXRvcixcbiAgZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUsXG4gIGV4dGVuZCA9IHt9LFxuICBvdmVycmlkZSA9IHt9XG59KSA9PiB7XG4gIG92ZXJyaWRlUHJvcGVydHkoYmFzZUNvbmZpZywgJ2NhY2hlU2l6ZScsIGNhY2hlU2l6ZSk7XG4gIG92ZXJyaWRlUHJvcGVydHkoYmFzZUNvbmZpZywgJ3ByZWZpeCcsIHByZWZpeCk7XG4gIG92ZXJyaWRlUHJvcGVydHkoYmFzZUNvbmZpZywgJ3NlcGFyYXRvcicsIHNlcGFyYXRvcik7XG4gIG92ZXJyaWRlUHJvcGVydHkoYmFzZUNvbmZpZywgJ2V4cGVyaW1lbnRhbFBhcnNlQ2xhc3NOYW1lJywgZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUpO1xuICBmb3IgKGNvbnN0IGNvbmZpZ0tleSBpbiBvdmVycmlkZSkge1xuICAgIG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnW2NvbmZpZ0tleV0sIG92ZXJyaWRlW2NvbmZpZ0tleV0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGV4dGVuZCkge1xuICAgIG1lcmdlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnW2tleV0sIGV4dGVuZFtrZXldKTtcbiAgfVxuICByZXR1cm4gYmFzZUNvbmZpZztcbn07XG5jb25zdCBvdmVycmlkZVByb3BlcnR5ID0gKGJhc2VPYmplY3QsIG92ZXJyaWRlS2V5LCBvdmVycmlkZVZhbHVlKSA9PiB7XG4gIGlmIChvdmVycmlkZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBiYXNlT2JqZWN0W292ZXJyaWRlS2V5XSA9IG92ZXJyaWRlVmFsdWU7XG4gIH1cbn07XG5jb25zdCBvdmVycmlkZUNvbmZpZ1Byb3BlcnRpZXMgPSAoYmFzZU9iamVjdCwgb3ZlcnJpZGVPYmplY3QpID0+IHtcbiAgaWYgKG92ZXJyaWRlT2JqZWN0KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3ZlcnJpZGVPYmplY3QpIHtcbiAgICAgIG92ZXJyaWRlUHJvcGVydHkoYmFzZU9iamVjdCwga2V5LCBvdmVycmlkZU9iamVjdFtrZXldKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBtZXJnZUNvbmZpZ1Byb3BlcnRpZXMgPSAoYmFzZU9iamVjdCwgbWVyZ2VPYmplY3QpID0+IHtcbiAgaWYgKG1lcmdlT2JqZWN0KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWVyZ2VPYmplY3QpIHtcbiAgICAgIGNvbnN0IG1lcmdlVmFsdWUgPSBtZXJnZU9iamVjdFtrZXldO1xuICAgICAgaWYgKG1lcmdlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiYXNlT2JqZWN0W2tleV0gPSAoYmFzZU9iamVjdFtrZXldIHx8IFtdKS5jb25jYXQobWVyZ2VWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuY29uc3QgZXh0ZW5kVGFpbHdpbmRNZXJnZSA9IChjb25maWdFeHRlbnNpb24sIC4uLmNyZWF0ZUNvbmZpZykgPT4gdHlwZW9mIGNvbmZpZ0V4dGVuc2lvbiA9PT0gJ2Z1bmN0aW9uJyA/IGNyZWF0ZVRhaWx3aW5kTWVyZ2UoZ2V0RGVmYXVsdENvbmZpZywgY29uZmlnRXh0ZW5zaW9uLCAuLi5jcmVhdGVDb25maWcpIDogY3JlYXRlVGFpbHdpbmRNZXJnZSgoKSA9PiBtZXJnZUNvbmZpZ3MoZ2V0RGVmYXVsdENvbmZpZygpLCBjb25maWdFeHRlbnNpb24pLCAuLi5jcmVhdGVDb25maWcpO1xuY29uc3QgdHdNZXJnZSA9IC8qI19fUFVSRV9fKi9jcmVhdGVUYWlsd2luZE1lcmdlKGdldERlZmF1bHRDb25maWcpO1xuZXhwb3J0IHsgY3JlYXRlVGFpbHdpbmRNZXJnZSwgZXh0ZW5kVGFpbHdpbmRNZXJnZSwgZnJvbVRoZW1lLCBnZXREZWZhdWx0Q29uZmlnLCBtZXJnZUNvbmZpZ3MsIHR3Sm9pbiwgdHdNZXJnZSwgdmFsaWRhdG9ycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLW1qcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Csebik%5CDesktop%5CH1B%5CH1BMatch_FrontEnd%5Csrc%5Capp%5Cprofile%5Cpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);